<!DOCTYPE html><html lang="ko" data-mode="dark" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="컴퓨터 구조에 대한 네번 째 이야기" /><meta property="og:locale" content="ko" /><meta name="description" content="메모리 범위와 종류" /><meta property="og:description" content="메모리 범위와 종류" /><link rel="canonical" href="https://yjh9317.github.io/posts/%EC%BB%B4%ED%93%A8%ED%84%B0-%EA%B5%AC%EC%A1%B0%EC%97%90-%EB%8C%80%ED%95%9C-%EB%84%A4%EB%B2%88-%EC%A7%B8-%EC%9D%B4%EC%95%BC%EA%B8%B0/" /><meta property="og:url" content="https://yjh9317.github.io/posts/%EC%BB%B4%ED%93%A8%ED%84%B0-%EA%B5%AC%EC%A1%B0%EC%97%90-%EB%8C%80%ED%95%9C-%EB%84%A4%EB%B2%88-%EC%A7%B8-%EC%9D%B4%EC%95%BC%EA%B8%B0/" /><meta property="og:site_name" content="yjh9317" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-03-30T00:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="컴퓨터 구조에 대한 네번 째 이야기" /><meta name="twitter:site" content="@twitter_username" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-03-30T00:00:00+09:00","datePublished":"2023-03-30T00:00:00+09:00","description":"메모리 범위와 종류","headline":"컴퓨터 구조에 대한 네번 째 이야기","mainEntityOfPage":{"@type":"WebPage","@id":"https://yjh9317.github.io/posts/%EC%BB%B4%ED%93%A8%ED%84%B0-%EA%B5%AC%EC%A1%B0%EC%97%90-%EB%8C%80%ED%95%9C-%EB%84%A4%EB%B2%88-%EC%A7%B8-%EC%9D%B4%EC%95%BC%EA%B8%B0/"},"url":"https://yjh9317.github.io/posts/%EC%BB%B4%ED%93%A8%ED%84%B0-%EA%B5%AC%EC%A1%B0%EC%97%90-%EB%8C%80%ED%95%9C-%EB%84%A4%EB%B2%88-%EC%A7%B8-%EC%9D%B4%EC%95%BC%EA%B8%B0/"}</script><title>컴퓨터 구조에 대한 네번 째 이야기 | yjh9317</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="yjh9317"><meta name="application-name" content="yjh9317"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> </a></div><div class="site-title mt-3"> <a href="/">yjh9317</a></div><div class="site-subtitle font-italic">코딩열심히하려는사람</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/yjh9317" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['example','doamin.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>컴퓨터 구조에 대한 네번 째 이야기</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>컴퓨터 구조에 대한 네번 째 이야기</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1680102000" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Mar 30, 2023 </em> </span><div class="d-flex justify-content-between"> <span> By <em> <a href="https://twitter.com/username">Yang jeong hyeon</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="4968 words"> <em>27 min</em> read</span></div></div></div><div class="post-content"><h1 id="메모리-범위와-종류">메모리 범위와 종류</h1><ul><li><p>보통 메모리라고 하면 메인 메모리에 해당하는 램을 생각하지만 메모리는 <code class="language-plaintext highlighter-rouge">컴퓨터를 구성하는 요소 중에서 임시적이든, 영구적이든 저장 기능을 조금이라도 가지고 있으면 무조건 메모리의 범위로 포함</code>한다.</p><li><p>보통 메인메모리와 하드디스크를 비교하면 메인 메모리는 실행, 하드디스크는 저장의 기능으로 비교하지만 하드디스크는 실행이라는 기능도 가지고 있다.</p></ul><p><br /><br /></p><h2 id="메인-메모리"><span class="mr-2">메인 메모리</span><a href="#메인-메모리" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><ul><li><p>정확히는 D램(D-RAM)계열의 메모리</p><li><p>메인 메모리는 반드시 램이어야할 이유는 없다.</p><ul><li><p>따라서 메인 메모리와 램에는 등호관계가 성립하지 않는다.</p><li><p>그러나 대부분 메인메모리를 램으로 사용한다.</p></ul></ul><p><br /></p><h2 id="레지스터"><span class="mr-2">레지스터</span><a href="#레지스터" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><ul><li><p>레지스터들도 당연히 메모리.</p><li><p>CPU안에 내장되어 있어서 연산을 위한 저장소를 제공한다.</p></ul><p><br /></p><h2 id="캐쉬"><span class="mr-2">캐쉬</span><a href="#캐쉬" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><ul><li><p>캐쉬는 D램보다 빠른 S램(S-RAM)으로 구성하는데, 램이라는 단어는 메인 메모리를 의미하는 용도로 사용되므로, 캐쉬 메모리는 캐쉬라고 부른다.</p><li><p>캐쉬는 CPU와 램 사이에서 중간 저장소 역할을 하는 메모리이다.</p><li><p>캐쉬가 CPU에 내장되어 있다고 표현하기도 하는데, <code class="language-plaintext highlighter-rouge">캐쉬 메모리는 원래 CPU의 일부로 존재하는 메모리 개념이 아니다. CPU에 근접해 있는 메모리 개념이다.</code></p><li><p>CPU의 일부로 존재하는 메모리는 레지스터이다.</p></ul><p><br /></p><h2 id="하드디스크와-이외의-저장-장치들"><span class="mr-2">하드디스크와 이외의 저장 장치들</span><a href="#하드디스크와-이외의-저장-장치들" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><ul><li><p>하드디스크는 크고 작은 파일들을 저장하기 위한 용도로 사용되지만, 프로그램 실행에 있어서도 중요한 의미를 지닌다.</p><li><p>그밖에 SD카드,CD_ROM과 같은 I/O 장치들도 메모리에 해당한다.</p><li><p>프로그래머는 레지스터,캐쉬, 메인 메모리,하드디스크뿐만 아니라 그 밖의 I/O 장치들과의 입/출력 타이밍 및 대기 시간 등을 가장 중요한 요소로 생각하고 항상 고민해야 한다.</p></ul><p><br /><br /></p><h1 id="메모리-계층-구조">메모리 계층 구조</h1><ul><li><p>프로그램이 실행되는 동안 메모리가 하는 역할은 데이터의 입출력이다.</p><ul><li>따라서 기본적인 역할은 모든 메모리가 동일하다.</ul><li><p>하지만 차이점이 존재하는데 가장 큰 차이점은 <code class="language-plaintext highlighter-rouge">CPU를 기준으로 얼마나 떨어져 있느냐</code>이다.</p><li><p>레지스터 &gt; 캐쉬 메모리 &gt; 메인 메모리 &gt; 하드 디스크 순으로 CPU에 가깝다.</p><li><p>CPU와 가까이 있을수록 빠르고, 멀리 있을수록 느리다.</p><li><p>그렇다면 가장 가까운 레지스터만 사용하면 가장 빠르겠지만 문제는 기술과 비용이 든다.</p><ul><li>CPU 근처로 대용량의 메모리를 가져 갈수록 기술적인 문제들과 비용이 훨씬 많이 든다</ul></ul><p><br /><br /></p><h3 id="계층-구조"><span class="mr-2">계층 구조</span><a href="#계층-구조" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><hr /><p><br /><br /></p><p align="center"><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 500 400'%3E%3C/svg%3E" data-src="./../../assets/img/윈도우즈%20시스템%20프로그래밍/컴퓨터%20구조에%20대한%20네번%20째%20이야기/메모리%20계층%20구조.png" width="500" height="400" data-proofer-ignore></p><p><br /></p><ul><li><p>가장 위쪽에 있는 것은 레지스터</p><ul><li>크기가 가장 작지만 가장 빠르다</ul><li><p>그 다음 L1 캐쉬와 L2 캐쉬가 존재하다.</p><ul><li>L1캐쉬가 L2캐쉬보다 CPU에 근접해 있다.</ul><li><p>그 다음은 메인 메모리.</p><ul><li>캐쉬보다는 크지만 상대적으로 느리다.</ul><li><p>그 다음은 하드 디스크.</p><ul><li>가장 크지만 가장 느리다.</ul></ul><p><br /></p><h3 id="원리"><span class="mr-2">원리</span><a href="#원리" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><hr /><ul><li><p>CPU는 메인 메모리에게 데이터를 요청한다.</p><li><p>메인 메모리가 갖고 있으면,바로 CPU에게 주지만 없으면 하드 디스크에 요청한다.</p><li><p>하드 디스크는 그 데이터 블럭을 메인 메모리에게 올려준다.</p><li><p>그래서 메인 메모리는 CPU에게 데이터를 넘겨준다.</p><li><p>ALU가 L1 캐시에 데이터를 요청한다. (레지스터가 아님.)</p><li><p>L1 캐시가 갖고 있지 않으면 L1 캐시는 L2 캐시에게 요청한다.</p><li><p>L2 캐시가 갖고 있지 않으면 메인 메모리에게 요청한다.</p><li><p>메인 메모리에게 없으면 하드 디스크에게 요청한다.</p><li><p>하드 디스크에 있었으면 메인 메모리에 데이터를 올려주는 등, 역으로 아래에서 위로 데이터를 올려주고를 반복해서 CPU까지 전달한다.</p><li><p>근데, CPU에서 바로 하드디스크로 접근해서 데이터를 요청하는게 빠르지 않을까 생각할 수 있다.</p><ul><li><p>만약 프로그램의 실행 흐름이 산발적이라면(여기저기 랜덤으로 실행) 하드디스크의 요청이 더 빠를 수도 있다.</p><li><p>하지만 지역적인 특성을 지니기 때문에, 메모리가 계층적인 것이 더 성능이 향상된다.</p><ul><li>지역적인 특성은 실행 흐름이 여기저기서 실행하는 것이 아닌 어느 지역에 국한되어서 실행됨을 의미</ul></ul></ul><p><br /><br /></p><h1 id="캐쉬와-캐쉬-알고리즘">캐쉬와 캐쉬 알고리즘</h1><ul><li><p>캐쉬 메모리가 존재했을 떄 성능이 향상되는 이유는 프로그램의 일반적인 특성 Locality가 존재하기 때문이다.</p><li><p>캐쉬메모리는 Temporal Locality와 Spatial Locality 두가지 특성을 지니고 있다.</p></ul><p><br /></p><h2 id="temporal-locality-반복-접근"><span class="mr-2">Temporal Locality (반복 접근)</span><a href="#temporal-locality-반복-접근" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><ul><li><code class="language-plaintext highlighter-rouge">프로그램 실행시 한 번 접근이 이뤄진 주소의 메모리 영역은 자주 접근하게 된다는 프로그램 특성</code></ul><p><br /></p><h2 id="spatial-locality-주변-접근"><span class="mr-2">Spatial Locality (주변 접근)</span><a href="#spatial-locality-주변-접근" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><ul><li><p><code class="language-plaintext highlighter-rouge">프로그램 실행시 접근하는 메모리 영역은 이미 접근이 이루어진 영역의 근처일 확률이 높다는 프로그램 성격을 표현할 떄 사용하는 말</code></p><li><p>cpu가 필요한 데이터를 캐쉬 메모리에 요구할 때 있을 확률이 90%가 넘는데 그 이유가 바로 Spatial Locality 때문이다.</p><ul><li>밑에서 이야기하는 데이터 블록 단위 이동이 곧 Spatial Locality의 특징이다.</ul></ul><p><br /></p><h2 id="캐쉬-알고리즘"><span class="mr-2">캐쉬 알고리즘</span><a href="#캐쉬-알고리즘" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><ul><li>Temporal Locality와 Spatial Locality의 특성이 캐쉬에 어떻게 반영하는지에 대한 과정</ul><p><br /></p><p align="center"><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 600 400'%3E%3C/svg%3E" data-src="./../../assets/img/윈도우즈%20시스템%20프로그래밍/컴퓨터%20구조에%20대한%20네번%20째%20이야기/캐쉬%20알고리즘.png" width="600" height="400" data-proofer-ignore></p><p><br /></p><ul><li><p>Cpu가 L1에 캐쉬를 요구한다고 가정했을 때</p><li><p>L1 <code class="language-plaintext highlighter-rouge">캐쉬에 해당 데이터가 존재할 경우를 캐쉬 힛이 발생</code>했다고 하며, 이 데이터를 레지스터로 이동시킨다.</p><li><p>반대로 L1 <code class="language-plaintext highlighter-rouge">캐쉬에 해당 데이터가 존재하지 않을 경우 캐쉬 미스가 발생</code>했다고 하고, 캐쉬 미스가 발생하면 L2 캐쉬에서 해당 데이터를 가져오게 된다.</p><ul><li>L 2캐쉬에도 없다면 그 밑의 계층인 메인메모리에서 데이터를 가져온다.</ul></ul><p><br /></p><ul><li><p>메모리 사이에서 데이터의 이동은 블록 단위로 진행이 된다.</p><ul><li><p>메모리의 피라미드 구조 아래로 갈수록 블록 크기는 커진다.</p><li><p>이는 피라미드 구조 아래에 존재하는 메모리일 수록 접근 횟수를 줄이는 효과를 가져다 준다.</p></ul></ul><p><br /></p><ul><li><p>Cpu가 캐쉬에게 데이터를 요청했을 때, 그 데이터만 요구하는게 아닌 그 데이터를 포함한 데이터 블록을 전달하기 때문에 다음번에 데이터를 요청했을 때 확률이 높아지는 것이다.</p><ul><li>블록단위 전송이 이뤄지기 때문에 캐쉬 메모리에 데이터가 있을 확률이 90퍼가 넘는 이유.</ul></ul><p><br /></p><h3 id="캐쉬-미스가-발생할-떄-고려하게-되는-부분"><span class="mr-2">캐쉬 미스가 발생할 떄 고려하게 되는 부분</span><a href="#캐쉬-미스가-발생할-떄-고려하게-되는-부분" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><hr /><ul><li><p>운영체제가 동작하고, 프로그램이 실행되는 동안 하드 디스크를 제외한 모든 메모리가 항상 채워져 있다.</p><li><p>L2캐쉬의 경우 캐쉬 메모리를 채워놔야만 L1 캐쉬에서 요구하는 데이터를 소유하고 있을 확률이 높아지기 때문에 조금이라도 비워둘 필요가 없다.</p><li><p>그런데 L1 캐쉬에서 캐쉬미스가 발생해서 L2캐쉬로부터 데이터 블록을 읽어 들일 때 해당 데이터 블록을 L1 캐쉬에 저장을 해야하는데 저장하려면 기존 L1 캐쉬 데이터를 밀어야 한다.</p><li><p>이 때 보편적으로 거론되는 알고리즘이 LRU 알고리즘이다.</p><ul><li>LRU 알고리즘 : 가장 오래전에 참조된 블록을 밀어내는 알고리즘</ul></ul><p><br /></p><h2 id="캐쉬-프렌드리-코드"><span class="mr-2">캐쉬 프렌드리 코드</span><a href="#캐쉬-프렌드리-코드" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><ul><li>캐쉬의 도움을 많이 받을수 있도록 구현하는 코드</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">j</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">total</span><span class="o">+=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// arr[0][0] -&gt; arr[1][0] 보다 arr[0][0] -&gt; arr[0][1] 같이 해당 데이터의 근처에 있을수록 좋음</span>

</pre></table></code></div></div><ul><li>산발적인 접근이 아닌 순차적으로 접근했을 때가 캐쉬의 도움을 받을 수 있다.</ul><p><br /><br /></p><h1 id="가상-메모리">가상 메모리</h1><ul><li><p>CPU가 요구하는 메모리 공간이 2GB라고 했을 때 메인 메모리가 가지고 있는 공간이 256MB라고 한다면 부족한 메모리 공간을 채워주기 위해 더 큰 메모리 공간을 지닌 하드디스크까지 확장해서 사용한다.</p><li><p><code class="language-plaintext highlighter-rouge">하드디스크까지 확장해서 메모리 공간을 넓히는 것을 가상 메모리 기법</code>이라고 한다.</p><li><p>가상 메모리에는 가상 주소와 물리 주소가 있다.</p></ul><p><br /></p><h2 id="물리주소"><span class="mr-2">물리주소</span><a href="#물리주소" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><ul><li><code class="language-plaintext highlighter-rouge">데이터는 컴파일이 완료된 운영체제와 그 운영체제를 바탕으로 동작하는 프로그램을 총칭하는 것</code>이다.</ul><p><br /></p><p align="center"><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 600 300'%3E%3C/svg%3E" data-src="./../../assets/img/윈도우즈%20시스템%20프로그래밍/컴퓨터%20구조에%20대한%20네번%20째%20이야기/임베디드%20시스템의%20동작%20원리.png" width="600" height="300" data-proofer-ignore></p><p><br /></p><ul><li><p>위 그림에서는 운영체제 코드와 프로그램을 하나의 바이너리 코드로 생성해서 시스템에 로딩한다.</p><li><p>위 그림의 램 용량을 16MB라고 가정한다면 임베디드 시스템에서 접근 가능한 메모리 영역은 0번지부터 “(16 x 1024 x 1024) -1”번지까지 사이가 된다.</p><ul><li><p>이 접근 가능한 메모리 영역이 바로 실제 물리적인 메인 메모리의 주소 범위에 해당한다.</p><li><p>이렇게 <code class="language-plaintext highlighter-rouge">주소를 할당하는 것을 가리켜 물리적 주소 지정</code>이라고 한다.</p><ul><li>물리적 주소 지정의 특징은 메인 메모리 크기에 따라 지정 가능한 주소의 범위가 결정된다는 것이다.</ul></ul></ul><p><br /></p><ul><li>물리적 주소 지정을 하게 되면 CPU 입장에서는 접근 가능한 주소의 범위가 제한된다.<ul><li>이것은 프로그래머가 할당할 수 있는 주소 범위도 제한적이라는 뜻도 된다.</ul><li><p>이렇게 주소 범위가 제한되면 프로그래머는 주소 범위를 넘지 않게 개발해야하기 때문에 상당한 제약사항으로 작용한다.</p><li>이러한 제약 사항을 겪지 않게 하기 위해 가상 주소 시스템을 사용한다.</ul><p><br /><br /></p><h2 id="가상-주소-시스템-1"><span class="mr-2">가상 주소 시스템 1</span><a href="#가상-주소-시스템-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><ul><li><p>32비트 시스템에서 프로세스 생성시 4GB의 메모리를 할당받을 수 있다.</p><li><p>하지만 메인 메모리의 크기는 턱없이 부족하다.</p><li><p>따라서 4GB는 실제 존재하지 않는 가상의 주소라는 것을 알 수 있다.</p><ul><li><p>이렇게 <code class="language-plaintext highlighter-rouge">가상의 주소를 지정하는 것을 가상 주소 지정</code>이라 한다.</p><li><p><code class="language-plaintext highlighter-rouge">가상 주소 지정을 통해 할당받는 4GB를 가리켜 가상 메모리 공간</code>이라 한다.</p></ul></ul><p><br /></p><ul><li><p>하드 디스크까지 확장하여 사용하는 가상 메모리 기법을 사용할 때 고려해야할 점이 있다.</p><li><p>가상 메모리 시스템의 원리를 배우고 나면 이 두 문제를 해결하기 위한 방법은 해결할 수 있다.</p></ul><p><br /></p><h3 id="1선-할당으로-인한-부담"><span class="mr-2">1.선 할당으로 인한 부담</span><a href="#1선-할당으로-인한-부담" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><hr /><ul><li><p>프로세스를 생성할 시 4GB씩 할당해줄 것인지</p><li><p>아주 작은 프로그램(ex) “Hello World”)를 실행시킬 때에도 4GB씩 할당할지</p></ul><p><br /></p><h3 id="2느린-속도의-개선-필요성"><span class="mr-2">2.느린 속도의 개선 필요성</span><a href="#2느린-속도의-개선-필요성" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><hr /><ul><li>메인 메모리와 하드 디스크는 속도에 차이가 있어 생기는 문제</ul><p><br /><br /></p><h1 id="가상-메모리-시스템의-원리-1">가상 메모리 시스템의 원리 1</h1><ul><li><p>가상 메모리 시스템을 구현하는 방법은 표준으로 정해져 있지는 않다.</p><li><p>그러나 대부분의 시스템에서는 페이징(Paging)이라는 기법을 사용하므로 이를 바탕으로 설명한다.</p><ul><li>페이징 알고리즘의 구현방법은 다양하여 구현이 아닌 이해의 관점으로 본다.</ul></ul><p><br /><br /></p><h3 id="가상-메모리-시스템을-설명하기-위한-약간의-설정"><span class="mr-2">가상 메모리 시스템을 설명하기 위한 약간의 설정</span><a href="#가상-메모리-시스템을-설명하기-위한-약간의-설정" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><hr /><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>밑에서 설명할 시스템의 사양
-------------------------
가정 1. 16비트 시스템. 따라서 0부터 64K-1까지 주소 지정 가능
가정 2. 프로세스별로 64K바이트 메모리 할당, 물론 가상 메모리 할당
가정 3. 메인 메모리 16K바이트, 즉 램 용량이 16K바이트
</pre></table></code></div></div><p><br /></p><p align="center"><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 500 400'%3E%3C/svg%3E" data-src="./../../assets/img/윈도우즈%20시스템%20프로그래밍/컴퓨터%20구조에%20대한%20네번%20째%20이야기/풀어야할%20문제의%20도입.png" width="500" height="400" data-proofer-ignore></p><p><br /></p><ul><li><p>실제 메모리는 16K 바이트이지만, 프로세스를 생성할 때마다 64K바이트를 할당하고자 하니 문제가 생긴다.</p><ul><li><p>특히 16K번지 이상의 메모리는 접근조차 불가능</p><li><p>최대 할당 가능한 메모리는 16K-1번지까지</p></ul></ul><p><br /></p><ul><li>이 문제를 해결하기 위해 다음과 같은 구조를 생각한다.</ul><p><br /></p><p align="center"><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 500 500'%3E%3C/svg%3E" data-src="./../../assets/img/윈도우즈%20시스템%20프로그래밍/컴퓨터%20구조에%20대한%20네번%20째%20이야기/가상 메모리와 MMU.png" width="500" height="500" data-proofer-ignore></p><p><br /></p><ul><li><p>첫번째 요청에서 16KB가 있다고 가정할 때 CPU는 실제보다 더 큰 메모리가 있다고 생각하고 MMU에게 요구하는데 1K번지부터 20바이트 할당을 요청한다.</p><li><p>여기서 20바이트를 할당할 때 메인 메모리를 블럭 단위로 할당하기 때문에 1K번지에 해당하는 0 - 4K를 할당한다.</p><ul><li>메모리 블럭 단위를 4K라고 가정</ul><li><p>두번째 요청에서 36K번지에서 20바이트를 요청하면 순차적으로가 아니라 그 다음 블록을 순간순간적으로 바로 결정짓기 때문에 36K - 40K를 할당한다.</p><li><p>여기서 실제 물리적인 주소를 생각하면 36K - 40K는 4K에 해당한다.</p><li><p>CPU가 만약 36K에 있는 데이터를 요청한다면 MMU는 물리 메모리 4K에 있는 데이터를 가져다 CPU에게 전달한다.</p><ul><li>CPU가 가상 메모리로 접근한다면 MMU는 물리 메모리로 접근하고 그 메모리를 CPU에게 전달한다.</ul></ul><p><br /></p><ul><li>즉, <code class="language-plaintext highlighter-rouge">MMU(Memory management unit)는 존재하지 않는 메모리를 존재하는 것 처럼 CPU가 느끼도록 컨트롤 하는 역할</code>이다.<ul><li>CPU가 실제보다 더 큰 메모리가 있다고 가정하여 존재하지 않는(기존 보다 큰) 메모리를 요청하기 때문에 MMU가 해결하는 구조.</ul></ul><p><br /><br /></p><h1 id="가상-메모리-시스템의-원리-2">가상 메모리 시스템의 원리 2</h1><ul><li>가상 메모리 시스템의 원리 1에서는 물리메모리와 가상 메모리에 대한 설명이고 2는 페이지와 페이지 프레임에 대한 설명이다.</ul><p><br /></p><h2 id="페이지--페이지-프레임"><span class="mr-2">페이지 &amp; 페이지 프레임</span><a href="#페이지--페이지-프레임" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><ul><li><p><code class="language-plaintext highlighter-rouge">소프트웨어 입장에서의 메모리 블록을 페이지</code> 라고 부른다.</p><li><p><code class="language-plaintext highlighter-rouge">하드웨어 입장에서의 메모리 블록을 페이지 프레임</code>이라고 부른다</p><li><p>페이지 단위로 데이터를 할당하고 페이지 프레임 단위로 데이터를 해제하기 때문에 페이지와 페이지 프레임의 크기는 같다.</p></ul><p><br /></p><p align="center"><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 600 500'%3E%3C/svg%3E" data-src="./../../assets/img/윈도우즈%20시스템%20프로그래밍/컴퓨터%20구조에%20대한%20네번%20째%20이야기/페이지%20테이블의%20구성.png" width="600" height="500" data-proofer-ignore></p><p><br /></p><ul><li>위 그림은 <strong>가상 메모리(페이지)</strong>와 그에 해당하는 <strong>실제 메모리(페이지 프레임)</strong>가 어떻게 매핑되는지 보여준다.</ul><p><br /><br /></p><p align="center"><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 600 300'%3E%3C/svg%3E" data-src="./../../assets/img/윈도우즈%20시스템%20프로그래밍/컴퓨터%20구조에%20대한%20네번%20째%20이야기/스왑%20파일과%20메인%20메모리.png" width="600" height="300" data-proofer-ignore></p><p><br /></p><ul><li><p>느린속도를 개선하기 위해 하드디스크의 일부까지 메인메모리를 확대하는 것이 가상메모리, 실질적인 메모리는 RAM에 국한된다고 이야기 했었다.</p><li><p>RAM에 접근할 때는 빨라지고 하드디스크에 접근해질 때는 느려지기 때문에 하드디스크와 RAM의 관계를 Cash관계로 구성한다.</p><ul><li><p>RAM부터 하드디스크까지 2GB라고 한다면 2GB의 메모리 공간 전부를 하드디스크에 넣어버린다.</p><li><p>Temporal Locality와 Spatial Locality에 의해 메모리를 블록단위로 하드디스크에 놓고 RAM은 그 블록을 가져다가 사용하는 형태.</p></ul></ul><p><br /><br /></p><ul><li><p>속도가 빠른 램과 메모리가 큰 하드디스크의 역할을 완전시 동일시 해서 등장하기 때문에 이러한 문제점이 나타난 것이다.</p><li><p>하드디스크는 스왑파일을 통해서 메인 메모리를 보조하고 램과 동일한 성격의 메인 메모리 역할을 하는것이 아니기 때문에 발생한 것.</p></ul><p><br /><br /></p><h3 id="하드디스크의-역할"><span class="mr-2">하드디스크의 역할</span><a href="#하드디스크의-역할" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><hr /><p align="center"><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 600 500'%3E%3C/svg%3E" data-src="./../../assets/img/윈도우즈%20시스템%20프로그래밍/컴퓨터%20구조에%20대한%20네번%20째%20이야기/하드디스크의%20역할%20-%201.png" width="600" height="500" data-proofer-ignore></p><p><br /></p><ul><li><p>램이 꽉찬 상태에서 CPU로부터 4-8K를 할당하겠다는 명령이 들어오면 램은 자리를 내어주기 위해 한 메모리 블럭을 빼야한다.</p><li><p>가장 오래 사용되지 않은 메모리 블럭인 8-12K를 하드디스크에 옮기고 그 자리에 4-8K의 메모리 블럭을 할당한다.</p><li><p>만약 하드디스크로 옮겨진 8-12K를 다시 할당한다면 들어온 4-8K가 아닌, 똑같이 가장 오래 사용되지 않은 메모리 블럭을 빼내고 다시 할당하는 형태로 구성된다.</p><li><p><code class="language-plaintext highlighter-rouge">하드디스크는 저장할 때 파일시스템기반으로 저장하는데 이러한 프로세스의 가상 메모리 확장을 위해 메모리 공간에 파일을 저장하는 것을 스왑파일</code>이라고 한다.</p></ul><p><br /><br /></p><h1 id="둘-이상의-프로세스와-가상-메모리">둘 이상의 프로세스와 가상 메모리</h1><ul><li>가상 메모리에서 하드디스크의 역할에 대해 살펴보았는데, 이를 바탕으로 둘 이상의 메모리가 큰 프로세스에게 어떻게 할당이 가능한지 설명할 수 있다.</ul><p><br /></p><p align="center"><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 500 400'%3E%3C/svg%3E" data-src="./../../assets/img/윈도우즈%20시스템%20프로그래밍/컴퓨터%20구조에%20대한%20네번%20째%20이야기/둘%20이상의%20프로세스%20지원.png" width="500" height="400" data-proofer-ignore></p><p><br /></p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>- 프로세스 A가 실행을 멈추고 프로세스 B를 실행시킨다고 가정한다.

1. 현재 메인 메모리중 RAM은 프로세스 A를 실행시키기 위한 데이터가 존재한다.

2. 프로세스 B를 실행하기 전에 RAM에 존재하는 프로세스 A의 실행을 위한 데이터 모두를 프로세스 A 스왑파일에 저장한다.

3. 프로세스 B의 실행을 위한 데이터를 프로세스 B 스왑파일로부터 램에 가져다 놓는다.
</pre></table></code></div></div><ul><li><p>이러한 과정을 반복하여 둘 이상의 프로세스가 각각 할당받아 실행을 이어가는 것ㄷ이다.</p><li><p>이러한 메모리를 채우고 비우고하는 것도 콘텍스트 스위칭에 해당하기 때문에 부담이 크다.</p></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%EC%9C%88%EB%8F%84%EC%9A%B0%EC%A6%88%EC%8B%9C%EC%8A%A4%ED%85%9C%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/'>윈도우즈시스템프로그래밍</a>, <a href='/categories/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/'>운영체제</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/windows/" class="post-tag no-text-decoration" >windows</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=%EC%BB%B4%ED%93%A8%ED%84%B0+%EA%B5%AC%EC%A1%B0%EC%97%90+%EB%8C%80%ED%95%9C+%EB%84%A4%EB%B2%88+%EC%A7%B8+%EC%9D%B4%EC%95%BC%EA%B8%B0+-+yjh9317&url=https%3A%2F%2Fyjh9317.github.io%2Fposts%2F%25EC%25BB%25B4%25ED%2593%25A8%25ED%2584%25B0-%25EA%25B5%25AC%25EC%25A1%25B0%25EC%2597%2590-%25EB%258C%2580%25ED%2595%259C-%25EB%2584%25A4%25EB%25B2%2588-%25EC%25A7%25B8-%25EC%259D%25B4%25EC%2595%25BC%25EA%25B8%25B0%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=%EC%BB%B4%ED%93%A8%ED%84%B0+%EA%B5%AC%EC%A1%B0%EC%97%90+%EB%8C%80%ED%95%9C+%EB%84%A4%EB%B2%88+%EC%A7%B8+%EC%9D%B4%EC%95%BC%EA%B8%B0+-+yjh9317&u=https%3A%2F%2Fyjh9317.github.io%2Fposts%2F%25EC%25BB%25B4%25ED%2593%25A8%25ED%2584%25B0-%25EA%25B5%25AC%25EC%25A1%25B0%25EC%2597%2590-%25EB%258C%2580%25ED%2595%259C-%25EB%2584%25A4%25EB%25B2%2588-%25EC%25A7%25B8-%25EC%259D%25B4%25EC%2595%25BC%25EA%25B8%25B0%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fyjh9317.github.io%2Fposts%2F%25EC%25BB%25B4%25ED%2593%25A8%25ED%2584%25B0-%25EA%25B5%25AC%25EC%25A1%25B0%25EC%2597%2590-%25EB%258C%2580%25ED%2595%259C-%25EB%2584%25A4%25EB%25B2%2588-%25EC%25A7%25B8-%25EC%259D%25B4%25EC%2595%25BC%25EA%25B8%25B0%2F&text=%EC%BB%B4%ED%93%A8%ED%84%B0+%EA%B5%AC%EC%A1%B0%EC%97%90+%EB%8C%80%ED%95%9C+%EB%84%A4%EB%B2%88+%EC%A7%B8+%EC%9D%B4%EC%95%BC%EA%B8%B0+-+yjh9317" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/Gameplay-Param/">GameplayTag Param</a><li><a href="/posts/Device/">Device</a><li><a href="/posts/SwapChain/">SwapChain</a><li><a href="/posts/VertexBuffer/">VertexBuffer</a><li><a href="/posts/IndexBuffer/">IndexBuffer</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/unreal/">unreal</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/design-pattern/">design pattern</a> <a class="post-tag" href="/tags/coding-test/">coding test</a> <a class="post-tag" href="/tags/directx/">directx</a> <a class="post-tag" href="/tags/windows/">windows</a> <a class="post-tag" href="/tags/data-structure/">data_structure</a> <a class="post-tag" href="/tags/modern-effective-c/">modern effective c++</a> <a class="post-tag" href="/tags/directx3d/">directx3d</a> <a class="post-tag" href="/tags/python/">python</a></div></div></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/%EC%BB%B4%ED%93%A8%ED%84%B0-%EA%B5%AC%EC%A1%B0%EC%97%90-%EB%8C%80%ED%95%9C-%EC%B2%AB%EB%B2%88-%EC%A7%B8-%EC%9D%B4%EC%95%BC%EA%B8%B0/"><div class="card-body"> <em class="small" data-ts="1653404400" data-df="ll" > May 25, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>컴퓨터 구조에 대한 첫번 째 이야기</h3><div class="text-muted small"><p> 컴퓨터 시스템의 주요 구성요소 컴퓨터 시스템을 구성하는 요소는 아래와 같다. 컴퓨터 하드웨어의 구성 CPU 중앙처리장치로써, 기본적으로 연산을 담당한다. CPU의 내부에는 위 그림과 같이 ALU , 컨트롤유닛 , 버스인터페이스 , 레지스터가 있다. 메인메모리 ...</p></div></div></a></div><div class="card"> <a href="/posts/%EC%9C%A0%EB%8B%88%EC%BD%94%EB%93%9C/"><div class="card-body"> <em class="small" data-ts="1653750000" data-df="ll" > May 29, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>유니코드</h3><div class="text-muted small"><p> 아스키코드와 유니코드 아스키코드 미국에서 정의하고 있는 알파벳과 기호를 이용한 표준 아스키코드는 1Byte로 표현 유니코드 영어가 아닌 다른 국가에서 사용하는 문자를 표현하기 위한 표준 유니코드는 2Byte로 표현 문자셋(Character Set...</p></div></div></a></div><div class="card"> <a href="/posts/64%EB%B9%84%ED%8A%B8%EA%B8%B0%EB%B0%98%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"><div class="card-body"> <em class="small" data-ts="1654354800" data-df="ll" > Jun 5, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>64비트기반프로그래밍</h3><div class="text-muted small"><p> 64비트와 32비트 비트를 나누는 기준 한 번에 전송 및 수신할 수 있는 데이터의 크기 데이터 처리 능력(외부로부터 들어오는 데이터를 처리하는 크기) 프로그래머 입장에서의 비트 프로그래밍 할 때는 주소값의 범위가 넓으면 넓은 만큼 넓은 메모리 공간을 활용할수 있다. 32비트 컴퓨터...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/%EC%93%B0%EB%A0%88%EB%93%9C-%ED%92%80%EB%A7%81/" class="btn btn-outline-primary" prompt="Older"><p>쓰레드 풀링</p></a> <a href="/posts/%EA%B5%AC%EC%A1%B0%EC%A0%81-%EC%98%88%EC%99%B8-%EC%B2%98%EB%A6%AC/" class="btn btn-outline-primary" prompt="Newer"><p>구조적 예외 처리</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/username">Yang jeong hyeon</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div></p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/unreal/">unreal</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/design-pattern/">design pattern</a> <a class="post-tag" href="/tags/coding-test/">coding test</a> <a class="post-tag" href="/tags/directx/">directx</a> <a class="post-tag" href="/tags/windows/">windows</a> <a class="post-tag" href="/tags/data-structure/">data_structure</a> <a class="post-tag" href="/tags/modern-effective-c/">modern effective c++</a> <a class="post-tag" href="/tags/directx3d/">directx3d</a> <a class="post-tag" href="/tags/python/">python</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/ko.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
