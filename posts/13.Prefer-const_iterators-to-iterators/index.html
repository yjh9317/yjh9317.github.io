<!DOCTYPE html><html lang="ko" data-mode="dark" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="iterators보다 const_iterators를 선호하라" /><meta property="og:locale" content="ko" /><meta name="description" content="const_iterators는 const를 가리키는 포인터의 STL 버전이다." /><meta property="og:description" content="const_iterators는 const를 가리키는 포인터의 STL 버전이다." /><link rel="canonical" href="https://yjh9317.github.io/posts/13.Prefer-const_iterators-to-iterators/" /><meta property="og:url" content="https://yjh9317.github.io/posts/13.Prefer-const_iterators-to-iterators/" /><meta property="og:site_name" content="yjh9317" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2024-03-18T00:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="iterators보다 const_iterators를 선호하라" /><meta name="twitter:site" content="@twitter_username" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-03-18T00:00:00+09:00","datePublished":"2024-03-18T00:00:00+09:00","description":"const_iterators는 const를 가리키는 포인터의 STL 버전이다.","headline":"iterators보다 const_iterators를 선호하라","mainEntityOfPage":{"@type":"WebPage","@id":"https://yjh9317.github.io/posts/13.Prefer-const_iterators-to-iterators/"},"url":"https://yjh9317.github.io/posts/13.Prefer-const_iterators-to-iterators/"}</script><title>iterators보다 const_iterators를 선호하라 | yjh9317</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="yjh9317"><meta name="application-name" content="yjh9317"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> </a></div><div class="site-title mt-3"> <a href="/">yjh9317</a></div><div class="site-subtitle font-italic">코딩열심히하려는사람</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/yjh9317" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['example','doamin.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>iterators보다 const_iterators를 선호하라</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>iterators보다 const_iterators를 선호하라</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1710687600" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Mar 18, 2024 </em> </span><div class="d-flex justify-content-between"> <span> By <em> <a href="https://twitter.com/username">Yang jeong hyeon</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1538 words"> <em>8 min</em> read</span></div></div></div><div class="post-content"><ul><li><p>const_iterators는 const를 가리키는 포인터의 STL 버전이다.</p><li><p>const_iterators는 수정하면 안되는 값을 가리키기 때문에, 수정할 필요가 없을 때는 항상 const_iterators를 사용하는 것이 바람직하다.</p><li><p>C++11는 물론 C++98에서도 그러는게 좋았지만, C++98에서 const_iterators로 관행을 지키는 것이 그리 달갑지는 않았다.</p><li><p>그런 반복자를 생성하기도 어렵고, 활용에도 제약이 있기 때문이다.</p></ul><p><br /></p><h1 id="c98-버전-const_iterator">C++98 버전 const_iterator</h1><ul><li><p>vector&lt;int&gt;에서 1983을 찾고 1998을 넣는다고 가정을 한다.</p><ul><li>만약 1983을이 없다면 vector의 맨 끝에 삽입한다.</ul></ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="c1">// C++98버전</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">values</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">values</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">valeus</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="mi">1983</span><span class="p">);</span>
<span class="n">values</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">it</span><span class="p">,</span><span class="mi">1998</span><span class="p">);</span>
</pre></table></code></div></div><ul><li><p>그러나 이 코드는 iterator가 가리키는 것을 전혀 수정하지 않으므로, iterator가 최선의 선택은 아니다.</p><li><p>iterator 대신 const_iterator를 사용하도록 코드를 고치는 것이 쉬워야 하지만, C++98에서는 그렇지 않았다.</p><li><p>다음은 개념적으로 건전하지만 실제로 정확하지 않은 접근 방식이다.</p></ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="c1">// C++98버전</span>
<span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">IterT</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">ConstIterT</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">values1</span><span class="p">;</span>

<span class="p">...</span>

<span class="n">ConstIterT</span> <span class="n">ci</span> <span class="o">=</span> 
    <span class="n">std</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">ConstIterT</span><span class="o">&gt;</span><span class="p">(</span><span class="n">values</span><span class="p">.</span><span class="n">begin</span><span class="p">()),</span>
    <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">ConstIterT</span><span class="o">&gt;</span><span class="p">(</span><span class="n">values</span><span class="p">.</span><span class="n">end</span><span class="p">()),</span>
    <span class="mi">1983</span><span class="p">);</span>

<span class="n">values</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">IterT</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ci</span><span class="p">),</span> <span class="mi">1998</span><span class="p">);</span>  <span class="c1">//컴파일이 안될 수 있음</span>
</pre></table></code></div></div><ul><li><p>std::find 호출에서 static_cast를 사용한 것은, value가 non-const 컨테이너이며 C++98에서 const_iterator를 얻는 간단한 방법이 없었기 때문이다.</p><li><p>static_cast를 사용하지 않더라도 가능은 하지만, 결국 작위적인 왜곡이 관여하게 필요하다</p><li><p>const_iterator를 얻는다 하더라도 C++98에서는 삽입과 삭제의 위치를 iterator로만 지정할 수 있기 때문에 const_iterator는 허용되지 않았다.</p><li><p>앞의 코드에서 const_iterator를 다시 iterator로 캐스팅한 이유가 const_iterator를 insert에 그대로 넘겨주면 컴파일이 되지 않기 때문이다.</p><li><p>하지만 넘겨주더라도 const_iterator에서 iterator로의 이식성 있는 변환은 존재하지 않아 컴파일이 되지 않을 수도 있다.</p></ul><p><br /></p><h1 id="c11-버전의-const_iterator">C++11 버전의 const_iterator</h1><ul><li><p>하지만 C++11에서는 const_iterator를 얻기 쉽고 사용하기도 쉽다.</p><li><p>컨테이너 멤버 함수 cbegin과 cend는 const_iterator를 돌려주고 non-const 컨테이너도 그렇다.</p><li><p>그리고 삽입,삭제 위치를 지정하는 목적으로 반복자를 사용하는 STL 멤버 함수들은 실제로 const_iterator를 사용한다.</p><li><p>iterator를 사용하는 기존 C++98 코드를 C++11에서 const_iterator를 사용하도록 개정하는 것은 아주 간단하다.</p></ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">values</span><span class="p">;</span>

<span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">values</span><span class="p">.</span><span class="n">cbegin</span><span class="p">(),</span> <span class="n">values</span><span class="p">.</span><span class="n">cend</span><span class="p">(),</span> <span class="mi">1983</span><span class="p">);</span> <span class="c1">// cbegin과 cend를 사용</span>

<span class="n">valeus</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="mi">1998</span><span class="p">);</span>
</pre></table></code></div></div><p><br /></p><ul><li><p>const_iterator에 대한 C++11의 지원에서 뭔가 부족한 점이 발견되는 상황은 최대한 일반적인 라이브러리 코드를 작성할 때 분이다.</p><li><p>그런 코드는 begin,end 함수를 멤버 함수가 아니라 비멤버 함수로 제공해야 하는 컨테이너들과 컨테이너 비슷한 자료구조들이 존재한다는 점을 고려한다.</p><li><p>내장 배열이 그러한 경우에 해당하며, 인터페이스가 오직 자유 함수들로만 이루어진 서드파티 라이브러리들도 그러한 경우이다.</p><li><p>그래서 일반성을 극대화한 코드는 특정 멤버 함수의 존재를 요구하는 대신 그 멤버 함수에 상응하는 비멤버 함수를 사용한다.</p></ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="c1">// targetVal의 첫 출현을 찾고 그 위치에 insertVal를 삽입</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">C</span><span class="p">,</span> <span class="n">tpyename</span> <span class="n">V</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">findAndInsert</span><span class="p">(</span><span class="n">C</span><span class="o">&amp;</span> <span class="n">container</span><span class="p">,</span>             
                    <span class="k">const</span> <span class="n">V</span><span class="o">&amp;</span> <span class="n">targetVal</span><span class="p">,</span>     
                    <span class="k">const</span> <span class="n">V</span><span class="o">&amp;</span> <span class="n">insertVal</span><span class="p">)</span>     
<span class="p">{</span>
    <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">cbegin</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">cend</span><span class="p">;</span>

    <span class="c1">// 비멤버 cbegin,cend 사용</span>
    <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">cbegin</span><span class="p">(</span><span class="n">container</span><span class="p">),</span><span class="n">cend</span><span class="p">(</span><span class="n">container</span><span class="p">),</span><span class="n">targetVal</span><span class="p">);</span>

    <span class="n">container</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">insertVal</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li><p>이 템플릿은 C++14에서는 잘 작동하고 C++11에서는 begin과 end가 있지만, cbegin과 cend, rbegin, rend, crbegin, crend가 없어 작동하지 않는다.</p><li><p>C++11에서 최대한 일반적인 코드를 작성하고, 사용하는 라이브러리들이 모두 누락된 비멤버 cbegin과 friend에 대한 템플릿을 제공하지 않는다면, 직접 구현하는 것도 어렵지 않다.</p></ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">C</span><span class="p">&gt;</span>
<span class="k">auto</span> <span class="nf">cbegin</span><span class="p">(</span><span class="k">const</span> <span class="n">C</span><span class="o">&amp;</span> <span class="n">container</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">container</span><span class="p">))</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">container</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li><p>컨테이너 같은 자료구조를 대표하는 임의의 인수 형식 C를 받고, 해당 const 참조 매개변수 container를 통해서 그 자료구조에 접근한다.</p><li><p>C가 통상적인 컨테이너라면 container는 const버전에 대한 참조가 된다</p><li><p>그러한 const 컨테이너에 대해 비멤버 begin 함수를 호출하면 const_iterator 형식의 반복자가 반환된다.</p><li><p>이 템플릿이 돌려주는 것이 바로 그 반복자이다.</p><li><p>이런 구현 방식의 장점은, begin 멤버함수를 제공하지만 cbegin 멤버함수는 제공하지 않는 컨테이너에 대해서도 작동한다는 것이다.</p><li><p>즉,begin만 직접적으로 제공하는 컨테이너에 대해서도 이 비멤버 cbegin을 사용할 수 있다.</p></ul><p><br /></p><h1 id="결론"><strong>결론</strong></h1><ul><li><p>다시 기본으로 돌아가서, 이번 항목의 요점은 가능한 const_iterator를 사용하라는 것이다.</p><li><p>이 조언의 근본적인 동기는 const를 사용하는 것이 의미가 있는 경우에는 항상 const를 사용하는 것이 바람직하다는 것인데, 이 조언은 C++11이전에도 참이였다.</p><li><p>C++98에서 반복자를 다룰 때 이 조언이 전혀실용적이지 않지만, C++11에서는 두드러지게 실용적이고, C++14는 C++11에서 마무리하지 못한 몇가지 단점까지 해결한다.</p></ul><blockquote><p>이것만은 잊지 말자!</p><ul class="prompt-tip"><li><p>iterator보다 const_iterator를 선호하자</p><li><p>최대한 일반적인 코드에서는 begin, end, rbegin 등의 비멤버 버전들을 해당 멤버 함수들보다 선호하라</p></ul></blockquote></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/modern-effective-c/'>Modern Effective C++</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/modern-effective-c/" class="post-tag no-text-decoration" >modern effective c++</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=iterators%EB%B3%B4%EB%8B%A4+const_iterators%EB%A5%BC+%EC%84%A0%ED%98%B8%ED%95%98%EB%9D%BC+-+yjh9317&url=https%3A%2F%2Fyjh9317.github.io%2Fposts%2F13.Prefer-const_iterators-to-iterators%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=iterators%EB%B3%B4%EB%8B%A4+const_iterators%EB%A5%BC+%EC%84%A0%ED%98%B8%ED%95%98%EB%9D%BC+-+yjh9317&u=https%3A%2F%2Fyjh9317.github.io%2Fposts%2F13.Prefer-const_iterators-to-iterators%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fyjh9317.github.io%2Fposts%2F13.Prefer-const_iterators-to-iterators%2F&text=iterators%EB%B3%B4%EB%8B%A4+const_iterators%EB%A5%BC+%EC%84%A0%ED%98%B8%ED%95%98%EB%9D%BC+-+yjh9317" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/Gameplay-Param/">GameplayTag Param</a><li><a href="/posts/Device/">Device</a><li><a href="/posts/SwapChain/">SwapChain</a><li><a href="/posts/VertexBuffer/">VertexBuffer</a><li><a href="/posts/IndexBuffer/">IndexBuffer</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/unreal/">unreal</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/design-pattern/">design pattern</a> <a class="post-tag" href="/tags/coding-test/">coding test</a> <a class="post-tag" href="/tags/directx/">directx</a> <a class="post-tag" href="/tags/windows/">windows</a> <a class="post-tag" href="/tags/data-structure/">data_structure</a> <a class="post-tag" href="/tags/modern-effective-c/">modern effective c++</a> <a class="post-tag" href="/tags/directx3d/">directx3d</a> <a class="post-tag" href="/tags/python/">python</a></div></div></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/2.Understand-auto-type-deduction/"><div class="card-body"> <em class="small" data-ts="1705503600" data-df="ll" > Jan 18, 2024 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>auto의 형식 연역 규칙을 숙지하라</h3><div class="text-muted small"><p> auto와 템플릿 auto 형식은 한가지 예외만 빼면 템플릿과 똑같이 작동한다. auto 형식 연역과 템플릿 형식 연역 사이에는 직접적인 대응 관계가 존재한다. // 템플릿 template&amp;lt;typename T&amp;gt; void f(ParamType param); f(expr); auto를 이용한...</p></div></div></a></div><div class="card"> <a href="/posts/3.Understand-decltype/"><div class="card-body"> <em class="small" data-ts="1705762800" data-df="ll" > Jan 21, 2024 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>decltype의 작동 방식을 숙지하라</h3><div class="text-muted small"><p> decltype은 주어진 이름이나 표현식의 형식을 알려주는 키워드 하지만 가끔 예상밖의 결과를 제공 대부분의 경우 템플릿과 auto와 달리 decltype은 그대로의 결과를 도출한다. const int i = 0; // decltype(i)는 const int bool f(c...</p></div></div></a></div><div class="card"> <a href="/posts/4.Know-how-to-view-deduced-types/"><div class="card-body"> <em class="small" data-ts="1706022000" data-df="ll" > Jan 24, 2024 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>연역된 형식을 파악하는 방법을 알아두라.</h3><div class="text-muted small"><p> 형식 연역 결과를 직접 확인하는 수단은 필요한 시점에 따라 다르다. 이번 항목에선 3가지 시점으로 살펴본다. IDE 편집기 IDE 코드 편집기는 프로그램 개체(변수,매개변수,함수 등)을 마우스 커서에 올리면 개채 형식을 표현해준다. 이런 일이 가능하려면 코드가 어느정도 컴파일 ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/Property-None-%EC%97%90%EB%9F%AC/" class="btn btn-outline-primary" prompt="Older"><p>Property None 에러</p></a> <a href="/posts/14.Declare-functions-noexcept-if-they-won-t-emit-exceptions/" class="btn btn-outline-primary" prompt="Newer"><p>예외를 방출하지 않을 함수는 noexcept로 선언하라</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/username">Yang jeong hyeon</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div></p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/unreal/">unreal</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/design-pattern/">design pattern</a> <a class="post-tag" href="/tags/coding-test/">coding test</a> <a class="post-tag" href="/tags/directx/">directx</a> <a class="post-tag" href="/tags/windows/">windows</a> <a class="post-tag" href="/tags/data-structure/">data_structure</a> <a class="post-tag" href="/tags/modern-effective-c/">modern effective c++</a> <a class="post-tag" href="/tags/directx3d/">directx3d</a> <a class="post-tag" href="/tags/python/">python</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/ko.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
