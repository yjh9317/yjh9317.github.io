<!DOCTYPE html><html lang="ko" data-mode="dark" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="decltype의 작동 방식을 숙지하라" /><meta property="og:locale" content="ko" /><meta name="description" content="decltype은 주어진 이름이나 표현식의 형식을 알려주는 키워드" /><meta property="og:description" content="decltype은 주어진 이름이나 표현식의 형식을 알려주는 키워드" /><link rel="canonical" href="https://yjh9317.github.io/posts/3.Understand-decltype/" /><meta property="og:url" content="https://yjh9317.github.io/posts/3.Understand-decltype/" /><meta property="og:site_name" content="yjh9317" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2024-01-21T00:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="decltype의 작동 방식을 숙지하라" /><meta name="twitter:site" content="@twitter_username" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-01-21T00:00:00+09:00","datePublished":"2024-01-21T00:00:00+09:00","description":"decltype은 주어진 이름이나 표현식의 형식을 알려주는 키워드","headline":"decltype의 작동 방식을 숙지하라","mainEntityOfPage":{"@type":"WebPage","@id":"https://yjh9317.github.io/posts/3.Understand-decltype/"},"url":"https://yjh9317.github.io/posts/3.Understand-decltype/"}</script><title>decltype의 작동 방식을 숙지하라 | yjh9317</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="yjh9317"><meta name="application-name" content="yjh9317"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> </a></div><div class="site-title mt-3"> <a href="/">yjh9317</a></div><div class="site-subtitle font-italic">코딩열심히하려는사람</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/yjh9317" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['example','doamin.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>decltype의 작동 방식을 숙지하라</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>decltype의 작동 방식을 숙지하라</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1705762800" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Jan 21, 2024 </em> </span><div class="d-flex justify-content-between"> <span> By <em> <a href="https://twitter.com/username">Yang jeong hyeon</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1537 words"> <em>8 min</em> read</span></div></div></div><div class="post-content"><ul><li><p>decltype은 <code class="language-plaintext highlighter-rouge">주어진 이름이나 표현식의 형식을 알려주는 키워드</code></p><li><p>하지만 가끔 예상밖의 결과를 제공</p></ul><p><br /></p><h1 id="대부분의-경우"><strong>대부분의 경우</strong></h1><ul><li>템플릿과 auto와 달리 decltype은 그대로의 결과를 도출한다.</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="k">const</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>            <span class="c1">// decltype(i)는 const int</span>

<span class="kt">bool</span> <span class="nf">f</span><span class="p">(</span><span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="n">w</span><span class="p">);</span>    <span class="c1">// decltype(w)는 const Widget&amp;</span>
                            <span class="c1">// decltype(f)는 bool(const Widget&amp;)</span>

<span class="k">if</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">w</span><span class="p">))</span>                    <span class="c1">// decltype(f(w))는 bool</span>

<span class="k">struct</span> <span class="nc">Point</span><span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">;</span>                <span class="c1">// decltype(Point::x)는 int</span>
<span class="p">};</span>                          <span class="c1">// decltype(Point::y)는 int</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">vector</span> <span class="p">{</span>
    <span class="nl">public:</span>
        <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="n">std</span><span class="o">::</span><span class="n">sizee_t</span> <span class="n">index</span><span class="p">);</span>
<span class="p">};</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>              <span class="c1">// decltype(v)는 vector&lt;int&gt;</span>

<span class="k">if</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>               <span class="c1">// decltype(v[0])는 int&amp;</span>
</pre></table></code></div></div><p><br /></p><h1 id="템플릿의-operator"><strong>템플릿의 operator[]</strong></h1><h3 id="c11"><span class="mr-2">C++11</span><a href="#c11" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><p>C++11에서 decltype은 함수의 반환 형식이 그 매개변수 형식들에 의존하는 함수 템플릿을 선언할 때 주로 사용된다</p><li><p>T의 객체를 담은 container의 operator[] 연산은 T&amp;를 돌려주는데,<br /> 중요한 점은 container의 operator[]의 반환 형식이 container에 따라 다르다.</p><li><p>decltype을 이용하면 그런 함수의 반환 형식을 손쉽게 표현할 수 있다.</p></ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Container</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Index</span><span class="p">&gt;</span>
<span class="k">auto</span> <span class="nf">authAndAccess</span> <span class="p">(</span><span class="n">Container</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Index</span> <span class="n">i</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
<span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="k">return</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>여기서 auto는 형식 영역이 아닌, <code class="language-plaintext highlighter-rouge">후행 반환 형식(trailing return type)</code>으로 사용된다.<ul><li>후행 반환 형식은 <code class="language-plaintext highlighter-rouge">return type을 매개변수 목록 다음에 선언하겠다는 것</code><li>후행 반환 형식은 매개변수의 타입을 선언한 후에 return type을 정할 수 있음</ul></ul><p><br /></p><h3 id="c14"><span class="mr-2">C++14</span><a href="#c14" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><p>C++11에서는 람다 함수로 반환 형식의 연역을 허용하며,<br /> C++14에서는 확장해서 모든 람다와 모든 함수의 return type의 연역을 허용한다.</p><li><p>C++ 14에서는 위 코드에서 후행 반환 형식을 사용하지 않고 auto만 사용해도 작동한다.</p></ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Container</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Index</span><span class="p">&gt;</span>
<span class="k">auto</span> <span class="nf">authAndAccess</span> <span class="p">(</span><span class="n">Container</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Index</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="k">return</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li><p>항목2에서 설명했듯이, 함수 반환 형식이 auto라면 컴파일러는 템플릿 형식 연역을 적용한다.</p><li><p>항목1에서는 템플릿 형식 연역 과정에서 초기화 표현식의 참조성이 무시된다고 설명했었다.</p><li><p>컨테이너에 대한 operator[] 연산이 대부분 T&amp;를 돌려주는데, 위 두 규칙때문에 다음과 같은 코드가 에러가 발생한다.</p></ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">deque</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">d</span><span class="p">;</span>

<span class="n">authAndAccess</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>  <span class="c1">// d[5]를 돌려주고 10을 d[5]에 배정하는 코드</span>
                          <span class="c1">// 오른값에 다시 오른값을 배정해버려 에러 발생</span>
</pre></table></code></div></div><ul><li><p>d[5]는 int&amp;를 돌려주지만, 위 함수의 auto때문에 참조가 제거되어 반환 형식은 int가 되어버린다.</p><li><p>반환값인 int는 오른값이고 이 int에 10을 배정하려는 코드가 되어버려서 컴파일되지 않는다.</p></ul><p><br /></p><h1 id="decltypeauto">decltype(auto)</h1><h3 id="함수-반환-형식"><span class="mr-2">함수 반환 형식</span><a href="#함수-반환-형식" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><p>C++14부터 추가된 <code class="language-plaintext highlighter-rouge">decltype(auto)</code>를 통해 decltype 형식 연역을 적용할 수 있다.</p><ul><li><code class="language-plaintext highlighter-rouge">auto는 해당 형식이 연역되어야 함</code>을 뜻하고, <code class="language-plaintext highlighter-rouge">decltype은 연역 과정에서 decltype 형식 연역 규칙들이 적용되어야 함</code>을 의미한다.</ul></ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Container</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Index</span><span class="p">&gt;</span>
<span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">authAndAccess</span> <span class="p">(</span><span class="n">Container</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Index</span> <span class="n">i</span><span class="p">)</span>  <span class="c1">// decltype을 추가</span>
<span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="k">return</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li><p>이제 authAndAccess의 반환 형식은 실제로 c[i]의 반환 형식과 일치한다.</p><li><p>c[i]가 T&amp;를 돌려주는 경우 T&amp;를 돌려주고, c[i]가 하나의 객체를 돌려주는 흔치않은 경우여도 역시 같은 형식의 객체를 돌려준다.</p></ul><p><br /></p><h3 id="변수-및-초기화-표현식"><span class="mr-2">변수 및 초기화 표현식</span><a href="#변수-및-초기화-표현식" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="n">Widget</span> <span class="n">w</span><span class="p">;</span>

<span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="n">cw</span> <span class="o">=</span> <span class="n">w</span><span class="p">;</span>

<span class="k">auto</span> <span class="n">myWidget1</span> <span class="o">=</span> <span class="n">cw</span><span class="p">;</span>           <span class="c1">// auto 형식 연역</span>
                               <span class="c1">// 형식은 Widget</span>

<span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">myWidget2</span> <span class="o">=</span> <span class="n">c2</span><span class="p">;</span> <span class="c1">// decltype 형식 연역</span>
                               <span class="c1">// 형식은 const Widget&amp;</span>
</pre></table></code></div></div><ul><li>하지만 고칠 사항이 두 부분이 있다.</ul><h3 id="첫-번째"><span class="mr-2">첫 번째</span><a href="#첫-번째" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Container</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Index</span><span class="p">&gt;</span>
<span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">authAndAccess</span><span class="p">(</span><span class="n">Container</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Index</span> <span class="n">i</span><span class="p">);</span> <span class="c1">// Container&amp;</span>
</pre></table></code></div></div><ul><li><p>컨테이너 c는 non-const 객체에 대한 왼값 참조로 사용되는데, 문제점은 이 때문에 함수에 오른값 컨테이너는 전달할 수 없다.</p><li><p>오른값도 받기 위해선 오버로딩 방법도 있지만, 보편 참조를 사용하는 것이 관리하기도 편하다.</p></ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Container</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Index</span><span class="p">&gt;</span>
<span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">authAndAccess</span><span class="p">(</span><span class="n">Container</span><span class="o">&amp;&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Index</span> <span class="n">i</span><span class="p">);</span> <span class="c1">// Container&amp;&amp;</span>
</pre></table></code></div></div><ul><li><p>지금 시점에선 이 템플릿의 형식과 인덱스 객체의 형식은 알 수 없다.</p><li><p>항목25에 따라, 보편 참조에 std::forward를 사용하면 된다.</p></ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Container</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Index</span><span class="p">&gt;</span>
<span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">authAndAccess</span><span class="p">(</span><span class="n">Container</span><span class="o">&amp;&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Index</span> <span class="n">i</span><span class="p">);</span>
<span class="p">{</span>
  <span class="c1">// ...</span>
  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Container</span><span class="o">&gt;</span><span class="p">(</span><span class="n">c</span><span class="p">)[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="두-번째"><span class="mr-2">두 번째</span><a href="#두-번째" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><p>decltype은 아주 가끔 예상 밖의 결과를 제공한다.</p><li><p>그래서 완전히 이해하려면 몇 특별한 경우에 익숙해져야 하는데 여기서는 한 가지만 소개한다.</p><li><p>decltype을 이름에 적용하면 이름에 대해 선언한 형식이 나오는데 <br /> 대체로 이름은 왼값 표현식이지만 decltype 행동에 영향을 주진 않는다.</p><li><p>하지만 <code class="language-plaintext highlighter-rouge">이름보다 복잡한 왼값 표현식에 대해서는 decltype은 항상 왼값 참조를 반환한다.</code></p><ul><li>형식이 T인 어떤 왼값 표현식에 대해 decltype은 T&amp;를 반환</ul><li><p>그래서 아래와 같은 경우가 생긴다.</p></ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">f1</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">x</span><span class="p">;</span>     <span class="c1">// x는 int</span>
<span class="p">}</span>

<span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">f2</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">);</span>   <span class="c1">// (x)는 int&amp;</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>f1과 달리 f2는 더욱 위험한 것이 참조로 반환하기 때문에 미정의 행동을 발생시킬 수 있다.</ul><p><br /></p><h1 id="결론"><strong>결론</strong></h1><blockquote><p>이것만은 잊지 말자!</p><ul class="prompt-tip"><li><p>decltype은 항상 변수나 표현식의 형식을 아무 수정 없이 보고한다.</p><li><p>decltype은 형식이 T이고 이름이 아닌 왼값 표현식에 대해서는 항상 T&amp;를 보고한다.</p><li><p>C++14는 decltype(auto)를 지원한다. decltype(auto)는 auto처럼 초기치로부터 형식을 연역하지만, 형식 연역 과정에서 decltype 규칙을 적용한다.</p></ul></blockquote></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/modern-effective-c/'>Modern Effective C++</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/modern-effective-c/" class="post-tag no-text-decoration" >modern effective c++</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=decltype%EC%9D%98+%EC%9E%91%EB%8F%99+%EB%B0%A9%EC%8B%9D%EC%9D%84+%EC%88%99%EC%A7%80%ED%95%98%EB%9D%BC+-+yjh9317&url=https%3A%2F%2Fyjh9317.github.io%2Fposts%2F3.Understand-decltype%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=decltype%EC%9D%98+%EC%9E%91%EB%8F%99+%EB%B0%A9%EC%8B%9D%EC%9D%84+%EC%88%99%EC%A7%80%ED%95%98%EB%9D%BC+-+yjh9317&u=https%3A%2F%2Fyjh9317.github.io%2Fposts%2F3.Understand-decltype%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fyjh9317.github.io%2Fposts%2F3.Understand-decltype%2F&text=decltype%EC%9D%98+%EC%9E%91%EB%8F%99+%EB%B0%A9%EC%8B%9D%EC%9D%84+%EC%88%99%EC%A7%80%ED%95%98%EB%9D%BC+-+yjh9317" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/Gameplay-Param/">GameplayTag Param</a><li><a href="/posts/Device/">Device</a><li><a href="/posts/SwapChain/">SwapChain</a><li><a href="/posts/VertexBuffer/">VertexBuffer</a><li><a href="/posts/IndexBuffer/">IndexBuffer</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/unreal/">unreal</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/design-pattern/">design pattern</a> <a class="post-tag" href="/tags/coding-test/">coding test</a> <a class="post-tag" href="/tags/directx/">directx</a> <a class="post-tag" href="/tags/windows/">windows</a> <a class="post-tag" href="/tags/data-structure/">data_structure</a> <a class="post-tag" href="/tags/modern-effective-c/">modern effective c++</a> <a class="post-tag" href="/tags/directx3d/">directx3d</a> <a class="post-tag" href="/tags/python/">python</a></div></div></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/2.Understand-auto-type-deduction/"><div class="card-body"> <em class="small" data-ts="1705503600" data-df="ll" > Jan 18, 2024 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>auto의 형식 연역 규칙을 숙지하라</h3><div class="text-muted small"><p> auto와 템플릿 auto 형식은 한가지 예외만 빼면 템플릿과 똑같이 작동한다. auto 형식 연역과 템플릿 형식 연역 사이에는 직접적인 대응 관계가 존재한다. // 템플릿 template&amp;lt;typename T&amp;gt; void f(ParamType param); f(expr); auto를 이용한...</p></div></div></a></div><div class="card"> <a href="/posts/4.Know-how-to-view-deduced-types/"><div class="card-body"> <em class="small" data-ts="1706022000" data-df="ll" > Jan 24, 2024 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>연역된 형식을 파악하는 방법을 알아두라.</h3><div class="text-muted small"><p> 형식 연역 결과를 직접 확인하는 수단은 필요한 시점에 따라 다르다. 이번 항목에선 3가지 시점으로 살펴본다. IDE 편집기 IDE 코드 편집기는 프로그램 개체(변수,매개변수,함수 등)을 마우스 커서에 올리면 개채 형식을 표현해준다. 이런 일이 가능하려면 코드가 어느정도 컴파일 ...</p></div></div></a></div><div class="card"> <a href="/posts/5.Prefer-auto-to-explicit-type-declarations/"><div class="card-body"> <em class="small" data-ts="1706281200" data-df="ll" > Jan 27, 2024 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>명시적 형식 선언보다는 auto를 선호하라.</h3><div class="text-muted small"><p> auto 덕분에 다음과 같은 문제점을 피할 수 있다. 초기화 문제 auto를 1 2 3 4 5 int x1; // 문맥에 따라 초기화되지 않을 수 있음 auto x2; // 오류! 초기화 필수 auto x3 = 0; // 작동 간단한 표현 1 2 3 4 5 6 7 8 9 10 11 template&amp;lt;ty...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/%EB%B3%80%EC%88%98/" class="btn btn-outline-primary" prompt="Older"><p>변수</p></a> <a href="/posts/4.Know-how-to-view-deduced-types/" class="btn btn-outline-primary" prompt="Newer"><p>연역된 형식을 파악하는 방법을 알아두라.</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/username">Yang jeong hyeon</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div></p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/unreal/">unreal</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/design-pattern/">design pattern</a> <a class="post-tag" href="/tags/coding-test/">coding test</a> <a class="post-tag" href="/tags/directx/">directx</a> <a class="post-tag" href="/tags/windows/">windows</a> <a class="post-tag" href="/tags/data-structure/">data_structure</a> <a class="post-tag" href="/tags/modern-effective-c/">modern effective c++</a> <a class="post-tag" href="/tags/directx3d/">directx3d</a> <a class="post-tag" href="/tags/python/">python</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/ko.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
