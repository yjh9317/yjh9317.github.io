<!DOCTYPE html><html lang="ko" data-mode="dark" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="3장 스레드 간 데이터 공유" /><meta property="og:locale" content="ko" /><meta name="description" content="3.1 스레드 간 데이터 공유 시 문제점 (Problems with sharing data between threads)" /><meta property="og:description" content="3.1 스레드 간 데이터 공유 시 문제점 (Problems with sharing data between threads)" /><link rel="canonical" href="https://yjh9317.github.io/posts/3%EC%9E%A5-%EC%8A%A4%EB%A0%88%EB%93%9C-%EA%B0%84-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B3%B5%EC%9C%A0/" /><meta property="og:url" content="https://yjh9317.github.io/posts/3%EC%9E%A5-%EC%8A%A4%EB%A0%88%EB%93%9C-%EA%B0%84-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B3%B5%EC%9C%A0/" /><meta property="og:site_name" content="yjh9317" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2024-09-15T00:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="3장 스레드 간 데이터 공유" /><meta name="twitter:site" content="@twitter_username" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-09-15T00:00:00+09:00","datePublished":"2024-09-15T00:00:00+09:00","description":"3.1 스레드 간 데이터 공유 시 문제점 (Problems with sharing data between threads)","headline":"3장 스레드 간 데이터 공유","mainEntityOfPage":{"@type":"WebPage","@id":"https://yjh9317.github.io/posts/3%EC%9E%A5-%EC%8A%A4%EB%A0%88%EB%93%9C-%EA%B0%84-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B3%B5%EC%9C%A0/"},"url":"https://yjh9317.github.io/posts/3%EC%9E%A5-%EC%8A%A4%EB%A0%88%EB%93%9C-%EA%B0%84-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B3%B5%EC%9C%A0/"}</script><title>3장 스레드 간 데이터 공유 | yjh9317</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="yjh9317"><meta name="application-name" content="yjh9317"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> </a></div><div class="site-title mt-3"> <a href="/">yjh9317</a></div><div class="site-subtitle font-italic">코딩열심히하려는사람</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/yjh9317" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['example','doamin.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>3장 스레드 간 데이터 공유</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>3장 스레드 간 데이터 공유</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1726326000" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Sep 15, 2024 </em> </span><div class="d-flex justify-content-between"> <span> By <em> <a href="https://twitter.com/username">Yang jeong hyeon</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="6899 words"> <em>38 min</em> read</span></div></div></div><div class="post-content"><h1 id="31-스레드-간-데이터-공유-시-문제점-problems-with-sharing-data-between-threads"><strong>3.1 스레드 간 데이터 공유 시 문제점 (Problems with sharing data between threads)</strong></h1><ul><li>여러 스레드가 데이터를 공유할 때, 특히 하나 이상의 스레드가 데이터를 수정하는 경우 문제가 발생할 수 있음.<li><p>읽기 전용 데이터는 문제가 없지만, 수정이 가해지면 데이터의 일관성을 유지하기 위한 세심한 주의가 필요함</p><li>데이터 구조에는 항상 참이어야 하는 <strong>불변성(invariants)</strong>이라는 개념이 있음.<ul><li>예를 들어, 이중 연결 리스트에서 한 노드의 ‘다음’ 포인터가 가리키는 노드의 ‘이전’ 포인터는 원래 노드를 가리켜야 함.<li>데이터 업데이트 중에는 이러한 불변성이 일시적으로 깨질 수 있으며, 이 상태를 다른 스레드가 보게 되면 문제가 발생</ul></ul><h2 id="경쟁-조건-race-conditions"><span class="mr-2"><strong>경쟁 조건 (Race conditions)</strong></span><a href="#경쟁-조건-race-conditions" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li><p><code class="language-plaintext highlighter-rouge">둘 이상의 스레드에서 수행되는 연산의 상대적인 순서에 따라 결과가 달라지는 모든 상황을 의미</code>.</p><li><p>대부분의 경우 모든 가능한 결과가 수용 가능하면 양성이지만, 불변성이 깨지는 경쟁 조건은 문제가 됨.</p><li><p>C++ 표준에서는 <strong>데이터 경쟁(data race)</strong>을 단일 객체에 대한 동시 수정으로 인해 발생하는 특정 유형의 경쟁 조건으로 정의하며, 이는 정의되지 않은 동작(undefined behavior)을 유발.</p><li>문제가 되는 경쟁 조건은 일반적으로 둘 이상의 개별 데이터 조각을 수정해야 하는 작업에서 발생함.<ul><li>이러한 작업은 별도의 명령으로 수행되므로, 한 명령만 완료된 중간 상태를 다른 스레드가 접근할 수 있음.</ul><li>경쟁 조건은 일반적으로 타이밍에 민감하여 찾기 어렵고 재현하기 어려움.<ul><li>디버거를 사용하면 타이밍이 변경되어 문제가 사라지는 경우도 있음</ul></ul><h2 id="문제가-되는-경쟁-조건을-피하는-방법"><span class="mr-2"><strong>문제가 되는 경쟁 조건을 피하는 방법</strong></span><a href="#문제가-되는-경쟁-조건을-피하는-방법" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>데이터를 보호하는 가장 기본적인 도구는 <code class="language-plaintext highlighter-rouge">뮤텍스(mutex)</code></ul><h3 id="보호-메커니즘-사용"><span class="mr-2"><strong>보호 메커니즘 사용</strong></span><a href="#보호-메커니즘-사용" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>데이터를 고치는 스레드만 중간 과정을 볼 수 있도록 데이터 주변을 보호<li>다른 스레드는 작업이 시작되기 전이나 완전히 끝난 후의 모습만 볼 수 있음<li>C++에는 이런 보호 장치가 있음</ul><h3 id="데이터-구조-설계-변경"><span class="mr-2">데이터 구조 설계 변경</span><a href="#데이터-구조-설계-변경" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>데이터를 고치는 작업 자체가 마치 한 번에 일어나는 것처럼, 그리고 그 과정 중에도 데이터 규칙이 항상 지켜지도록 데이터 구조를 처음부터 다시 설계하는 것</ul><h3 id="트랜잭션-처리"><span class="mr-2">트랜잭션 처리</span><a href="#트랜잭션-처리" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>은행에서 돈을 보내는 것처럼, 데이터 변경 작업을 하나의 묶음(트랜잭션)으로 만들어서 한 번에 처리</ul><p><br /></p><h1 id="32-뮤텍스로-공유-데이터-보호하기-protecting-shared-data-with-mutexes"><strong>3.2 뮤텍스로 공유 데이터 보호하기 (Protecting shared data with mutexes)</strong></h1><ul><li><code class="language-plaintext highlighter-rouge">뮤텍스(상호 배제, mutual exclusion)</code>는 공유 데이터에 접근하기 전에 잠그고, 접근이 끝나면 잠금 해제하는 동기화 기본 요소<li>한 스레드가 특정 뮤텍스를 잠그면, 동일한 뮤텍스를 잠그려는 다른 모든 스레드는 첫 번째 스레드가 뮤텍스를 해제할 때까지 기다려야 함.<ul><li>이를 통해 모든 스레드가 공유 데이터의 일관된 뷰를 볼 수 있도록 보장</ul></ul><h2 id="321-c에서-뮤텍스-사용하기-using-mutexes-in-c"><span class="mr-2"><strong>3.2.1 C++에서 뮤텍스 사용하기 (Using mutexes in C++)</strong></span><a href="#321-c에서-뮤텍스-사용하기-using-mutexes-in-c" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>C++에서는 <code class="language-plaintext highlighter-rouge">std::mutex</code>의 인스턴스를 생성하여 뮤텍스를 만들고, <code class="language-plaintext highlighter-rouge">lock()</code> 멤버 함수로 잠그고, <code class="language-plaintext highlighter-rouge">unlock()</code> 멤버 함수로 잠금 해제함.<li>그러나 멤버 함수를 직접 호출하는 것은 권장되지 않음.<ul><li>모든 코드 경로에서 <code class="language-plaintext highlighter-rouge">unlock()</code>을 호출해야 하는 것을 기억해야 하기 때문임 (예외 포함).</ul><li>대신 C++ 표준 라이브러리는 <code class="language-plaintext highlighter-rouge">RAII(Resource Acquisition Is Initialization)</code> 관용구를 구현하는 <code class="language-plaintext highlighter-rouge">std::lock_guard</code> 클래스 템플릿을 제공함. <code class="language-plaintext highlighter-rouge">std::lock_guard</code>는 생성 시 제공된 뮤텍스를 잠그고 소멸 시 잠금 해제하여, 잠긴 뮤텍스가 항상 올바르게 해제되도록 보장</ul><h3 id="코드-예제-뮤텍스로-리스트-보호하기"><span class="mr-2">코드 예제: 뮤텍스로 리스트 보호하기</span><a href="#코드-예제-뮤텍스로-리스트-보호하기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;list&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;mutex&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">some_list</span><span class="p">;</span>       <span class="c1">// [cite: 1] 보호할 공유 데이터</span>
<span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">some_mutex</span><span class="p">;</span>          <span class="c1">// [cite: 1] 해당 데이터를 보호하는 뮤텍스</span>

<span class="kt">void</span> <span class="nf">add_to_list</span><span class="p">(</span><span class="kt">int</span> <span class="n">new_value</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">guard</span><span class="p">(</span><span class="n">some_mutex</span><span class="p">);</span> <span class="c1">// [cite: 1] 뮤텍스를 잠금 (범위를 벗어나면 자동 해제)</span>
    <span class="n">some_list</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">new_value</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">new_value</span> <span class="o">&lt;&lt;</span> <span class="s">" added to list."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">list_contains</span><span class="p">(</span><span class="kt">int</span> <span class="n">value_to_find</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">guard</span><span class="p">(</span><span class="n">some_mutex</span><span class="p">);</span> <span class="c1">// [cite: 1] 뮤텍스를 잠금</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">some_list</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">some_list</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">value_to_find</span><span class="p">)</span> <span class="o">!=</span> <span class="n">some_list</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// int main() {</span>
<span class="c1">//     std::thread t1(add_to_list, 42);</span>
<span class="c1">//     std::thread t2(add_to_list, 100);</span>
<span class="c1">//     std::thread t3([]{</span>
<span class="c1">//         if (list_contains(42)) {</span>
<span class="c1">//             std::cout &lt;&lt; "List contains 42." &lt;&lt; std::endl;</span>
<span class="c1">//         } else {</span>
<span class="c1">//             std::cout &lt;&lt; "List does not contain 42." &lt;&lt; std::endl;</span>
<span class="c1">//         }</span>
<span class="c1">//     });</span>

<span class="c1">//     t1.join();</span>
<span class="c1">//     t2.join();</span>
<span class="c1">//     t3.join();</span>
<span class="c1">//     return 0;</span>
<span class="c1">// }</span>
</pre></table></code></div></div><ul><li>일반적으로 전역 변수 대신 클래스 내에 뮤텍스와 보호 데이터를 그룹화하는 것이 좋음.<li>이는 객체 지향 설계 원칙에 부합하며, 캡슐화를 통해 기능을 명확히 하고 보호를 강제할 수 있음.<li>그러나 멤버 함수가 보호된 데이터에 대한 포인터나 참조를 반환하면, 해당 포인터나 참조를 통해 뮤텍스 잠금 없이 데이터에 접근할 수 있게 되어 보호가 무력화될 수 있음</ul><h2 id="322-공유-데이터-보호를-위한-코드-구조화-structuring-code-for-protecting-shared-data"><span class="mr-2"><strong>3.2.2 공유 데이터 보호를 위한 코드 구조화 (Structuring code for protecting shared data)</strong></span><a href="#322-공유-데이터-보호를-위한-코드-구조화-structuring-code-for-protecting-shared-data" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>뮤텍스로 데이터를 보호하는 것은 단순히 모든 멤버 함수에 <code class="language-plaintext highlighter-rouge">std::lock_guard</code>를 추가하는 것만으로는 충분하지 않음.<li>보호된 데이터에 대한 포인터나 참조가 외부로 유출되지 않도록 주의해야 함.<li>멤버 함수가 호출자에게 포인터나 참조를 반환하거나, 제어할 수 없는 외부 함수에 인수로 전달하지 않도록 해야 함.</ul><h3 id="코드-예제-보호된-데이터에-대한-참조를-실수로-유출하는-경우"><span class="mr-2">코드 예제: 보호된 데이터에 대한 참조를 실수로 유출하는 경우</span><a href="#코드-예제-보호된-데이터에-대한-참조를-실수로-유출하는-경우" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>process_data 멤버 함수가 사용자 제공 함수 func를 호출하면서 보호된 데이터 data에 대한 참조를 전달함<li>악의적인 함수(malicious_function)가 이 참조를 외부로 유출하여 뮤텍스 보호 없이 데이터에 접근할 수 있게 되는 상황을 보여줌</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">some_data</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">};</span>
<span class="k">class</span> <span class="nc">data_wrapper</span> <span class="p">{</span>
<span class="nl">private:</span>
    <span class="n">some_data</span> <span class="n">data</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">m</span><span class="p">;</span>
<span class="nl">public:</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Function</span><span class="p">&gt;</span>
    <span class="kt">void</span> <span class="n">process_data</span><span class="p">(</span><span class="n">Function</span> <span class="n">func</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">l</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
        <span class="n">func</span><span class="p">(</span><span class="n">data</span><span class="p">);</span> <span class="c1">// [cite: 1] 보호된 data를 사용자 제공 함수 func에 전달</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="n">some_data</span><span class="o">*</span> <span class="n">unprotected_ptr</span><span class="p">;</span> <span class="c1">// 유출된 포인터를 저장할 전역 변수 </span>
<span class="kt">void</span> <span class="n">malicious_function</span><span class="p">(</span><span class="n">some_data</span><span class="o">&amp;</span> <span class="n">protected_data</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">unprotected_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">protected_data</span><span class="p">;</span> <span class="c1">// [cite: 1] 보호된 데이터의 주소를 외부로 유출</span>
<span class="p">}</span>

<span class="n">data_wrapper</span> <span class="n">x</span><span class="p">;</span>
<span class="kt">void</span> <span class="n">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">x</span><span class="p">.</span><span class="n">process_data</span><span class="p">(</span><span class="n">malicious_function</span><span class="p">);</span> <span class="c1">// [cite: 1] 악의적인 함수 전달</span>
    <span class="c1">// 이제 unprotected_ptr를 통해 뮤텍스 잠금 없이 data에 접근 가능</span>
    <span class="c1">// unprotected_ptr-&gt;do_something(); // [cite: 1] 보호되지 않은 접근</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>잠금 범위 밖으로 보호된 데이터에 대한 포인터나 참조를 전달하지 말 것</ul><p><br /></p><h2 id="323-인터페이스에-내재된-경쟁-조건-발견하기-spotting-race-conditions-inherent-in-interfaces"><span class="mr-2"><strong>3.2.3 인터페이스에 내재된 경쟁 조건 발견하기 (Spotting race conditions inherent in interfaces)</strong></span><a href="#323-인터페이스에-내재된-경쟁-조건-발견하기-spotting-race-conditions-inherent-in-interfaces" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>뮤텍스를 사용하더라도 적절한 데이터를 보호하지 않으면 경쟁 조건이 발생할 수 있음.<ul><li>예를 들어 이중 연결 리스트에서 노드를 삭제할 때, 삭제되는 노드와 양옆 노드 세 개 모두에 대한 동시 접근을 막아야 함.<li>개별 노드의 포인터만 개별적으로 보호하면 경쟁 조건은 여전히 발생할 수 있음.<li>전체 리스트를 보호하는 단일 뮤텍스가 가장 간단한 해결책</ul><li><code class="language-plaintext highlighter-rouge">std::stack</code>과 같이 단순한 인터페이스에서도 경쟁 조건이 발생할 수 있음.<ul><li><code class="language-plaintext highlighter-rouge">empty()</code>와 <code class="language-plaintext highlighter-rouge">size()</code>의 결과는 호출 시점에는 정확할 수 있지만, 반환 후 다른 스레드가 스택을 수정할 수 있어 신뢰할 수 없음.<li>특히, <code class="language-plaintext highlighter-rouge">empty()</code> 호출과 <code class="language-plaintext highlighter-rouge">top()</code> 호출 사이에 다른 스레드가 마지막 요소를 <code class="language-plaintext highlighter-rouge">pop()</code>하면, <code class="language-plaintext highlighter-rouge">top()</code> 호출은 정의되지 않은 동작을 유발하는 경쟁 조건이 발생함 (빈 스택에서 top() 호출)</ul></ul><h2 id="코드-예제-스택에서의-경쟁-조건"><span class="mr-2"><strong>코드 예제: 스택에서의 경쟁 조건</strong></span><a href="#코드-예제-스택에서의-경쟁-조건" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="c1">// (단일 스레드에서는 안전한 코드)</span>
<span class="n">std</span><span class="o">::</span><span class="n">stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">s</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>            <span class="c1">// [cite: 1] 1. empty() 호출</span>
    <span class="kt">int</span> <span class="k">const</span> <span class="n">value</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">top</span><span class="p">();</span> <span class="c1">// [cite: 1] 2. top() 호출 - 이 사이에 다른 스레드가 pop() 할 수 있음</span>
    <span class="n">s</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>                   <span class="c1">// [cite: 1] 3. pop() 호출 - 이 사이에 다른 스레드가 top()을 다시 호출할 수 있음</span>
    <span class="c1">// do_something(value);</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="문제점"><span class="mr-2">문제점</span><a href="#문제점" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>공유 스택 객체에서 위 코드는 안전하지 않음.<li>한 스레드가 empty() 호출 후 true를 반환받았더라도, top() 호출 직전에 다른 스레드가 마지막 요소를 pop()할 수 있음.<ul><li>이는 top() 호출 시 빈 스택에 접근하게 되어 정의되지 않은 동작을 유발함.</ul></ul><h3 id="또-다른-경쟁-조건"><span class="mr-2">또 다른 경쟁 조건</span><a href="#또-다른-경쟁-조건" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>top() 호출과 pop() 호출 사이에도 경쟁 조건이 존재함.<li>두 스레드가 동시에 이 코드를 실행하면, 한 스택의 값이 두 번 처리되거나, 한 값은 처리되지 않고 버려질 수 있음.</ul><h3 id="해결책--인터페이스-변경이-필요"><span class="mr-2">해결책 : 인터페이스 변경이 필요</span><a href="#해결책--인터페이스-변경이-필요" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>top()이 예외를 던지도록 함<ul><li>빈 스택에서 호출될 경우. 하지만 이는 프로그래밍을 번거롭게 만듦.</ul><li>top()과 pop() 결합: 하나의 연산으로 만들어 뮤텍스 보호 하에 실행되도록 함.<ul><li>주의점 (Cargill의 문제점): pop()이 값을 반환하도록 정의되면, 값을 복사하는 과정에서 예외(예: std::bad_alloc)가 발생할 경우 스택에서 이미 제거된 값은 손실될 수 있음.<li>std::stack은 이를 피하기 위해 top()과 pop()을 분리함.</ul></ul><h3 id="결합된-pop-연산의-예외-안전성-문제-해결-옵션"><span class="mr-2">결합된 pop() 연산의 예외 안전성 문제 해결 옵션</span><a href="#결합된-pop-연산의-예외-안전성-문제-해결-옵션" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="1-참조-전달"><span class="mr-2">1. 참조 전달</span><a href="#1-참조-전달" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>pop() 함수에 값을 받을 변수에 대한 참조를 인수로 전달함.<ul><li>예: some_stack.pop(result);</ul><li>단점: 호출 코드가 미리 해당 타입의 인스턴스를 생성해야 하고, 할당 불가능한 타입을 저장할 수 없음.</ul><h4 id="2예외를-던지지-않는-복사이동-생성자-요구"><span class="mr-2">2.예외를 던지지 않는 복사/이동 생성자 요구</span><a href="#2예외를-던지지-않는-복사이동-생성자-요구" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>예외를 던지지 않고 안전하게 값을 반환할 수 있는 타입으로 사용을 제한함.<li>std::is_nothrow_copy_constructible 등으로 컴파일 타임에 확인 가능.<li>단점: 매우 제한적임.</ul><h4 id="3pop된-항목에-대한-포인터-반환"><span class="mr-2">3.pop된 항목에 대한 포인터 반환</span><a href="#3pop된-항목에-대한-포인터-반환" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>std::shared_ptr 등을 사용하여 메모리 관리를 하면서 포인터를 반환함.<li>장점: 포인터 복사는 예외를 던지지 않음.<li>단점: 단순 타입의 경우 메모리 관리 오버헤드가 클 수 있음.</ul><h4 id="4-옵션-1과-옵션-2-또는-3을-모두-제공"><span class="mr-2">4. 옵션 1과 옵션 2 또는 3을 모두 제공</span><a href="#4-옵션-1과-옵션-2-또는-3을-모두-제공" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>사용자에게 선택권을 제공</ul><h3 id="코드-예제-경쟁-조건-없는-스레드-안전-스택-인터페이스-옵션-1과-3-구현"><span class="mr-2">코드 예제: 경쟁 조건 없는 스레드 안전 스택 인터페이스 (옵션 1과 3 구현)</span><a href="#코드-예제-경쟁-조건-없는-스레드-안전-스택-인터페이스-옵션-1과-3-구현" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="c1">// 스레드 안전한 스택(thread-safe stack)을 구현한 C++ 코드</span>
<span class="cp">#include</span> <span class="cpf">&lt;exception&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span>
<span class="c1">// 스택이 비었을 때 발생하는 예외 정의</span>
<span class="k">struct</span> <span class="nc">empty_stack</span><span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">what</span><span class="p">()</span> <span class="k">const</span> <span class="k">throw</span><span class="p">();</span> <span class="c1">// 예외 메시지 반환 (구현은 별도)</span>
<span class="p">};</span>

<span class="c1">// 템플릿 기반 스레드 안전 스택 클래스</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">threadsafe_stack</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">threadsafe_stack</span><span class="p">();</span> <span class="c1">// 기본 생성자</span>
    <span class="n">threadsafe_stack</span><span class="p">(</span><span class="k">const</span> <span class="n">threadsafe_stack</span><span class="o">&amp;</span><span class="p">);</span> <span class="c1">// 복사 생성자</span>
    <span class="n">threadsafe_stack</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">threadsafe_stack</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span> <span class="c1">// 대입 연산자 (삭제)</span>

    <span class="kt">void</span> <span class="n">push</span><span class="p">(</span><span class="n">T</span> <span class="n">new_value</span><span class="p">);</span> <span class="c1">// 스택에 원소 추가</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">pop</span><span class="p">();</span> <span class="c1">// 스택에서 원소 제거 및 반환 (shared_ptr 사용)</span>
    <span class="kt">void</span> <span class="n">pop</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">);</span> <span class="c1">// 스택에서 원소 제거 및 참조로 값 전달</span>
    <span class="kt">bool</span> <span class="n">empty</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> <span class="c1">// 스택이 비었는지 확인</span>
<span class="p">};</span>
</pre></table></code></div></div><h3 id="코드-예제-스레드-안전-스택의-구체적인-구현"><span class="mr-2">코드 예제: 스레드 안전 스택의 구체적인 구현</span><a href="#코드-예제-스레드-안전-스택의-구체적인-구현" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
</pre><td class="rouge-code"><pre><span class="c1">// 스레드 안전한 스택(thread-safe stack)의 전체 구현 C++ 코드</span>
<span class="cp">#include</span> <span class="cpf">&lt;exception&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;mutex&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stack&gt;</span><span class="cp">
</span>
<span class="c1">// 스택이 비어있을 때 발생하는 사용자 정의 예외 구조체</span>
<span class="k">struct</span> <span class="nc">empty_stack</span><span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span>
<span class="p">{</span>
 <span class="err"> </span> <span class="err"> </span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">what</span><span class="p">()</span> <span class="k">const</span> <span class="k">throw</span><span class="p">();</span>
<span class="p">};</span>

<span class="c1">// 템플릿을 사용하여 모든 데이터 타입을 지원하는 스레드 안전 스택 클래스</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">threadsafe_stack</span>
<span class="p">{</span>
<span class="nl">private:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">stack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">;</span> <span class="c1">// 실제 데이터를 저장하는 내부 스택 객체</span>
 <span class="err"> </span> <span class="err"> </span><span class="k">mutable</span> <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">m</span><span class="p">;</span> <span class="c1">// 데이터 접근을 동기화하기 위한 뮤텍스 객체. (const 멤버 함수에서도 lock 가능하도록 mutable 키워드 사용)</span>

<span class="nl">public:</span>
 <span class="err"> </span> <span class="err"> </span><span class="n">threadsafe_stack</span><span class="p">(){}</span> <span class="c1">// 기본 생성자</span>

    <span class="c1">// 복사 생성자. 다른 스택의 뮤텍스를 잠그고 데이터를 복사</span>
 <span class="err"> </span> <span class="err"> </span><span class="n">threadsafe_stack</span><span class="p">(</span><span class="k">const</span> <span class="n">threadsafe_stack</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span>
 <span class="err"> </span> <span class="err"> </span><span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">m</span><span class="p">);</span> <span class="c1">// 다른 객체의 뮤텍스를 잠금 (RAII 방식으로 자동 해제)</span>
 <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span><span class="n">data</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">data</span><span class="p">;</span>
 <span class="err"> </span> <span class="err"> </span><span class="p">}</span>

    <span class="c1">// 대입 연산자는 삭제되어 복사를 방지. (스레드 안전성을 위해)</span>
 <span class="err"> </span> <span class="err"> </span><span class="n">threadsafe_stack</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">threadsafe_stack</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>

 <span class="err"> </span> <span class="err"> </span><span class="kt">void</span> <span class="n">push</span><span class="p">(</span><span class="n">T</span> <span class="n">new_value</span><span class="p">)</span>
 <span class="err"> </span> <span class="err"> </span><span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">m</span><span class="p">);</span> <span class="c1">// 현재 객체의 뮤텍스를 잠금</span>
        <span class="n">data</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">new_value</span><span class="p">);</span>
 <span class="err"> </span> <span class="err"> </span><span class="p">}</span>


 <span class="err"> </span> <span class="err"> </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">pop</span><span class="p">()</span>
 <span class="err"> </span> <span class="err"> </span><span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">m</span><span class="p">);</span> <span class="c1">// 현재 객체의 뮤텍스를 잠금</span>
 <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span><span class="k">if</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="k">throw</span> <span class="n">empty_stack</span><span class="p">();</span> <span class="c1">// 스택이 비어있으면 empty_stack 예외를 던짐</span>
        <span class="c1">// 스택의 최상단 원소로 std::shared_ptr을 생성하여 복사(예외 안전성)</span>
        <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">const</span> <span class="n">res</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">top</span><span class="p">()));</span>
 <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span><span class="n">data</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
 <span class="err"> </span> <span class="err"> </span><span class="p">}</span>

 <span class="err"> </span> <span class="err"> </span><span class="kt">void</span> <span class="n">pop</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span>
 <span class="err"> </span> <span class="err"> </span><span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">m</span><span class="p">);</span> <span class="c1">// 현재 객체의 뮤텍스를 잠금</span>
 <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span><span class="k">if</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="k">throw</span> <span class="n">empty_stack</span><span class="p">();</span> <span class="c1">// 스택이 비어있으면 empty_stack 예외를 던짐</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="n">top</span><span class="p">();</span> <span class="c1">// 스택의 최상단 원소를 참조 변수에 복사</span>
        <span class="n">data</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
 <span class="err"> </span> <span class="err"> </span><span class="p">}</span>

 <span class="err"> </span> <span class="err"> </span><span class="kt">bool</span> <span class="n">empty</span><span class="p">()</span> <span class="k">const</span>
 <span class="err"> </span> <span class="err"> </span><span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">m</span><span class="p">);</span> <span class="c1">// 현재 객체의 뮤텍스를 잠금</span>
        <span class="k">return</span> <span class="n">data</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span>
 <span class="err"> </span> <span class="err"> </span><span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><p><br /></p><h2 id="324-교착-상태-문제점과-해결책-deadlock-the-problem-and-a-solution"><span class="mr-2"><strong>3.2.4 교착 상태: 문제점과 해결책 (Deadlock: the problem and a solution)</strong></span><a href="#324-교착-상태-문제점과-해결책-deadlock-the-problem-and-a-solution" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li><p>교착 상태(Deadlock)는 두 개 이상의 스레드가 서로가 점유하고 있는 자원(예: 뮤텍스)을 기다리며 더 이상 진행하지 못하는 상황.</p><li>교착 상태를 피하는 일반적인 방법: 항상 동일한 순서로 뮤텍스를 잠금.<li>그러나 두 개의 동일 클래스 인스턴스 간에 데이터를 교환하는 경우처럼 순서 정의가 어려운 경우가 있음.<ul><li>한 스레드는 lock(mutex_A); lock(mutex_B); 순서로, 다른 스레드는 lock(mutex_B); lock(mutex_A); 순서로 잠그려 하면 교착 상태 발생 가능.</ul><li>C++ 표준 라이브러리는 <code class="language-plaintext highlighter-rouge">std::lock()</code> 함수를 제공하여 둘 이상의 뮤텍스를 교착 상태 위험 없이 한 번에 잠글 수 있게 함.</ul><h3 id="코드-예제-stdlock과-stdlock_guard를-사용한-교환-연산"><span class="mr-2"><strong>코드 예제: std::lock()과 std::lock_guard를 사용한 교환 연산</strong></span><a href="#코드-예제-stdlock과-stdlock_guard를-사용한-교환-연산" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre><td class="rouge-code"><pre><span class="c1">// 두 개의 X 객체를 스레드 안전하게 교환(swap)하는 기능을 포함한 클래스 X의 C++ 코드</span>
<span class="k">class</span> <span class="nc">some_big_object</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">some_big_object</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">some_big_object</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">);</span> <span class="c1">// some_big_object를 위한 swap 함수</span>

<span class="k">class</span> <span class="nc">X</span>
<span class="p">{</span>
<span class="nl">private:</span>
    <span class="n">some_big_object</span> <span class="n">some_detail</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">m</span><span class="p">;</span>                <span class="c1">// some_detail 멤버에 대한 접근을 동기화하기 위한 뮤텍스</span>

<span class="nl">public:</span>
    <span class="n">X</span><span class="p">(</span><span class="n">some_big_object</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">sd</span><span class="p">)</span> <span class="o">:</span> <span class="n">some_detail</span><span class="p">(</span><span class="n">sd</span><span class="p">)</span> <span class="p">{}</span>

    <span class="c1">// friend 함수로 선언된 swap 함수: 두 X 객체의 내용을 스레드 안전하게 교환</span>
    <span class="k">friend</span> <span class="kt">void</span> <span class="n">swap</span><span class="p">(</span><span class="n">X</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">X</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// 자기 자신과의 교환 시도는 아무 작업도 하지 않고 반환</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">lhs</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>

        <span class="c1">// std::lock 함수를 사용하여 두 뮤텍스를 데드락 발생 없이 동시에 잠금</span>
        <span class="n">std</span><span class="o">::</span><span class="n">lock</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">m</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">m</span><span class="p">);</span>

        <span class="c1">// std::lock_guard를 사용하여 뮤텍스가 자동으로 해제되도록 함</span>
        <span class="c1">// std::adopt_lock은 이미 잠긴 뮤텍스의 소유권을 이전받아 관리하도록 함</span>
        <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock_a</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">m</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">adopt_lock</span><span class="p">);</span>
        <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock_b</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">m</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">adopt_lock</span><span class="p">);</span>

        <span class="c1">// 실제 데이터 멤버인 some_detail 객체들을 사용자 정의 swap 함수를 이용해 교환</span>
        <span class="n">swap</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">some_detail</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">some_detail</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h2 id="325-교착-상태를-피하기-위한-추가-지침-further-guidelines-for-avoiding-deadlock"><span class="mr-2"><strong>3.2.5 교착 상태를 피하기 위한 추가 지침 (Further guidelines for avoiding deadlock)</strong></span><a href="#325-교착-상태를-피하기-위한-추가-지침-further-guidelines-for-avoiding-deadlock" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>교착 상태는 잠금뿐만 아니라 스레드가 서로를 기다리는 모든 동기화 구조에서 발생할 수 있음.<li>근본적인 아이디어는 <code class="language-plaintext highlighter-rouge">다른 스레드가 당신을 기다리고 있을 가능성이 있다면 그 스레드를 기다리지 않는 것</code></ul><h4 id="중첩된-잠금-피하기-avoid-nested-locks"><span class="mr-2"><strong>중첩된 잠금 피하기 (Avoid nested locks)</strong></span><a href="#중첩된-잠금-피하기-avoid-nested-locks" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>이미 잠금을 보유하고 있다면 다른 잠금을 획득하지 말 것.<li>여러 잠금이 필요하면 std::lock을 사용하여 한 번에 획득함.</ul><h4 id="잠금을-보유한-상태에서-사용자-제공-코드-호출-피하기-avoid-calling-user-supplied-code-while-holding-a-lock"><span class="mr-2"><strong>잠금을 보유한 상태에서 사용자 제공 코드 호출 피하기 (Avoid calling user-supplied code while holding a lock)</strong></span><a href="#잠금을-보유한-상태에서-사용자-제공-코드-호출-피하기-avoid-calling-user-supplied-code-while-holding-a-lock" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>사용자 코드가 어떤 작업을 할지 알 수 없으므로 (다른 잠금을 획득할 수도 있음), 중첩된 잠금 지침을 위반하여 교착 상태를 유발할 수 있음.</ul><h4 id="고정된-순서로-잠금-획득하기-acquire-locks-in-a-fixed-order"><span class="mr-2"><strong>고정된 순서로 잠금 획득하기 (Acquire locks in a fixed order)</strong></span><a href="#고정된-순서로-잠금-획득하기-acquire-locks-in-a-fixed-order" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>둘 이상의 잠금을 획득해야 하고 std::lock으로 한 번에 획득할 수 없다면, 모든 스레드에서 동일한 순서로 잠금을 획득함.<li>예: 연결 리스트에서 노드를 순회할 때 항상 다음 노드의 잠금을 먼저 획득하고 이전 노드의 잠금을 해제하는 핸드오버핸드(hand-over-hand) 잠금 스타일. 역순 순회는 교착 상태 유발 가능.</ul><h4 id="잠금-계층-사용하기-use-a-lock-hierarchy"><span class="mr-2"><strong>잠금 계층 사용하기 (Use a lock hierarchy)</strong></span><a href="#잠금-계층-사용하기-use-a-lock-hierarchy" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>애플리케이션을 계층으로 나누고 각 계층에서 잠길 수 있는 모든 뮤텍스를 식별함.<li>스레드가 뮤텍스를 잠그려 할 때, 이미 더 낮은 계층의 잠금을 보유하고 있다면 해당 뮤텍스를 잠글 수 없도록 함.<li>런타임에 각 뮤텍스에 계층 번호를 할당하고 각 스레드가 잠근 뮤텍스를 기록하여 이를 확인할 수 있음.<ul><li>hierarchical_mutex는 thread_local 변수를 사용하여 현재 스레드의 잠금 계층 값을 추적.</ul></ul><h4 id="이-지침들을-잠금-이상으로-확장하기"><span class="mr-2"><strong>이 지침들을 잠금 이상으로 확장하기</strong></span><a href="#이-지침들을-잠금-이상으로-확장하기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>스레드를 기다리면서 잠금을 보유하는 것은 좋지 않음.<ul><li>해당 스레드가 진행하기 위해 그 잠금을 필요로 할 수 있기 때문</ul></ul><h2 id="326-stdunique_lock을-사용한-유연한-잠금-flexible-locking-with-stdunique_lock"><span class="mr-2"><strong>3.2.6 std::unique_lock을 사용한 유연한 잠금 (Flexible locking with std::unique_lock)</strong></span><a href="#326-stdunique_lock을-사용한-유연한-잠금-flexible-locking-with-stdunique_lock" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li><p><code class="language-plaintext highlighter-rouge">std::unique_lock</code>은 <code class="language-plaintext highlighter-rouge">std::lock_guard</code>보다 더 많은 유연성을 제공함. <code class="language-plaintext highlighter-rouge">std::unique_lock</code> 인스턴스가 항상 연관된 뮤텍스를 소유하지 않아도 됨.</p><li><p>생성자에 <code class="language-plaintext highlighter-rouge">std::defer_lock</code>을 전달하면 뮤텍스가 잠기지 않은 상태로 생성되며, 나중에 lock() 멤버 함수를 호출하거나 std::unique_lock 객체를 std::lock()에 전달하여 잠글 수 있음.</p><li><p><code class="language-plaintext highlighter-rouge">std::unique_lock</code>은 뮤텍스 소유 여부를 나타내는 플래그를 저장해야 하므로 <code class="language-plaintext highlighter-rouge">std::lock_guard</code>보다 공간을 더 차지하고 약간의 성능 저하가 있을 수 있음.</p><li><p><code class="language-plaintext highlighter-rouge">owns_lock()</code> 멤버 함수로 현재 잠금을 소유하고 있는지 질의할 수 있음</p></ul><h2 id="327-범위-간-뮤텍스-소유권-이전-transferring-mutex-ownership-between-scopes"><span class="mr-2"><strong>3.2.7 범위 간 뮤텍스 소유권 이전 (Transferring mutex ownership between scopes)</strong></span><a href="#327-범위-간-뮤텍스-소유권-이전-transferring-mutex-ownership-between-scopes" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li><code class="language-plaintext highlighter-rouge">std::unique_lock</code> 인스턴스는 연관된 뮤텍스를 반드시 소유하지 않아도 되므로, 인스턴스를 이동(move)시켜 뮤텍스의 소유권을 이전할 수 있음<li>함수에서 std::unique_lock 인스턴스를 반환하면 소유권이 호출자에게 이전되어 동일한 잠금 하에 추가 작업을 수행할 수 있음</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">get_lock</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">extern</span> <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">some_mutex</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">some_mutex</span><span class="p">);</span> <span class="c1">// 뮤텍스 잠금</span>
    <span class="c1">// prepare_data();</span>
    <span class="k">return</span> <span class="n">lk</span><span class="p">;</span> <span class="c1">// lk의 소유권이 이동됨 (컴파일러가 std::move 처리)</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">process_data</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">get_lock</span><span class="p">());</span> <span class="c1">// 반환된 unique_lock으로 소유권 이전</span>
    <span class="c1">// do_something();</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>std::unique_lock은 소멸되기 전에 unlock() 멤버 함수를 호출하여 잠금을 해제할 수도 있음.<ul><li>이는 잠금이 더 이상 필요하지 않은 특정 코드 분기에서 잠금을 해제하여 성능을 향상시키는 데 중요할 수 있음</ul></ul><h2 id="328-적절한-세분성으로-잠그기-locking-at-an-appropriate-granularity"><span class="mr-2"><strong>3.2.8 적절한 세분성으로 잠그기 (Locking at an appropriate granularity)</strong></span><a href="#328-적절한-세분성으로-잠그기-locking-at-an-appropriate-granularity" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li><code class="language-plaintext highlighter-rouge">잠금 세분성(lock granularity)</code>은 단일 잠금으로 보호되는 데이터의 양을 설명하는 용어.<li>너무 작은 단위로 잠그면(fine-grained lock) 경쟁이 줄지만 관리 오버헤드가 커지고, 너무 큰 단위로 잠그면(coarse-grained lock) 경쟁이 심해져 병렬성이 저하됨<ul><li>잠금은 필요한 최소 시간 동안만 보유해야 함<li>잠금을 보유한 상태에서 파일 I/O와 같은 시간이 많이 걸리는 작업은 피해야 함<li>std::unique_lock을 사용하면 필요 없는 구간에서 unlock()하고 나중에 다시 lock()할 수 있음.</ul></ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">get_and_process_data</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">my_lock</span><span class="p">(</span><span class="n">the_mutex</span><span class="p">);</span>
    <span class="n">some_class</span> <span class="n">data_to_process</span> <span class="o">=</span> <span class="n">get_next_data_chunk</span><span class="p">();</span>
    <span class="n">my_lock</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span> <span class="c1">// process() 호출 전에 잠금 해제</span>

    <span class="n">result_type</span> <span class="n">result</span> <span class="o">=</span> <span class="n">process</span><span class="p">(</span><span class="n">data_to_process</span><span class="p">);</span> <span class="c1">// 이 작업은 잠금 없이 수행</span>
    <span class="n">my_lock</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>   <span class="c1">// 결과를 쓰기 위해 다시 잠금</span>

    <span class="n">write_result</span><span class="p">(</span><span class="n">data_to_process</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p><br /></p><h1 id="33-공유-데이터-보호를-위한-대안적인-기능-alternative-facilities-for-protecting-shared-data"><strong>3.3 공유 데이터 보호를 위한 대안적인 기능 (Alternative facilities for protecting shared data)</strong></h1><ul><li>뮤텍스가 가장 일반적인 메커니즘이지만, 특정 시나리오에 더 적합한 보호를 제공하는 대안들이 있음.</ul><h2 id="331-초기화-중-공유-데이터-보호-protecting-shared-data-during-initialization"><span class="mr-2"><strong>3.3.1 초기화 중 공유 데이터 보호 (Protecting shared data during initialization)</strong></span><a href="#331-초기화-중-공유-데이터-보호-protecting-shared-data-during-initialization" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>공유 데이터가 초기화 중에만 동시 접근으로부터 보호되어야 하고, 그 이후에는 명시적인 동기화가 필요 없는 경우가 흔함 (예: 초기화 후 읽기 전용 데이터).<li>이 경우 초기화가 완료된 후에도 뮤텍스를 잠그는 것은 불필요한 성능 저하를 유발함</ul><h3 id="게으른-초기화lazy-initialization와-문제점"><span class="mr-2"><strong>게으른 초기화(Lazy initialization)와 문제점</strong></span><a href="#게으른-초기화lazy-initialization와-문제점" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>필요할 때만 리소스를 초기화하는 방식</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">some_resource</span><span class="o">&gt;</span> <span class="n">resource_ptr</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">resource_ptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">resource_ptr</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="k">new</span> <span class="n">some_resource</span><span class="p">);</span> <span class="c1">// 1. 초기화</span>
    <span class="p">}</span>
    <span class="n">resource_ptr</span><span class="o">-&gt;</span><span class="n">do_something</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>단순히 뮤텍스로 보호하면 모든 스레드가 리소스 사용 전에 뮤텍스를 기다려야 하므로 불필요한 직렬화 발생</ul><h3 id="이중-검사-잠금-패턴double-checked-locking-pattern과-위험성"><span class="mr-2"><strong>이중 검사 잠금 패턴(Double-Checked Locking Pattern)과 위험성</strong></span><a href="#이중-검사-잠금-패턴double-checked-locking-pattern과-위험성" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>잠금을 획득하기 전에 포인터를 먼저 읽고, NULL인 경우에만 잠금을 획득한 후 다시 포인터를 검사하는 방식</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="c1">// (이중 검사 잠금 - 정의되지 않은 동작 유발 가능성 있음)</span>
<span class="kt">void</span> <span class="nf">undefined_behaviour_with_double_checked_locking</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">resource_ptr</span><span class="p">)</span> <span class="p">{</span>                               <span class="c1">// 1. 잠금 외부에서 첫 번째 읽기</span>
        <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">resource_mutex</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">resource_ptr</span><span class="p">)</span> <span class="p">{</span>                           <span class="c1">// 2. 잠금 내부에서 두 번째 읽기</span>
            <span class="n">resource_ptr</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="k">new</span> <span class="n">some_resource</span><span class="p">);</span>     <span class="c1">// 3. 실제 초기화</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">resource_ptr</span><span class="o">-&gt;</span><span class="n">do_something</span><span class="p">();</span>                      <span class="c1">// 4. 사용</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>문제점: 잠금 외부에서의 읽기(1)와 다른 스레드가 잠금 내부에서 수행한 쓰기(3)가 동기화되지 않아 데이터 경쟁 발생 가능성이 있음. 이는 정의되지 않은 동작을 유발함</ul><h3 id="c-표준-라이브러리-해결책-stdcall_once"><span class="mr-2"><strong>C++ 표준 라이브러리 해결책: std::call_once</strong></span><a href="#c-표준-라이브러리-해결책-stdcall_once" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><code class="language-plaintext highlighter-rouge">std::once_flag</code>와 <code class="language-plaintext highlighter-rouge">std::call_once</code>를 사용하여 이러한 상황을 안전하고 효율적으로 처리함.<li><code class="language-plaintext highlighter-rouge">std::call_once</code>는 지정된 함수가 정확히 한 번만 호출되도록 보장하며, 일반적으로 뮤텍스를 명시적으로 사용하는 것보다 오버헤드가 적음</ul><h3 id="코드-예제-stdcall_once를-사용한-스레드-안전한-게으른-초기화"><span class="mr-2">코드 예제: std::call_once를 사용한 스레드 안전한 게으른 초기화</span><a href="#코드-예제-stdcall_once를-사용한-스레드-안전한-게으른-초기화" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">some_resource</span><span class="o">&gt;</span> <span class="n">resource_ptr_call_once</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">once_flag</span> <span class="n">resource_flag</span><span class="p">;</span> <span class="c1">// 한 번만 실행되도록 보장하기 위한 플래그</span>
<span class="kt">void</span> <span class="nf">init_resource</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">resource_ptr_call_once</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="k">new</span> <span class="n">some_resource</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Resource initialized by call_once."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">foo_call_once</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">call_once</span><span class="p">(</span><span class="n">resource_flag</span><span class="p">,</span> <span class="n">init_resource</span><span class="p">);</span> <span class="c1">// init_resource 함수를 스레드-세이프하게 한 번만 호출</span>
    <span class="n">resource_ptr_call_once</span><span class="o">-&gt;</span><span class="n">do_something</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Resource used by foo_call_once."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>std::call_once는 클래스 멤버의 게으른 초기화에도 사용될 수 있음<li>static으로 선언된 지역 변수의 초기화는 C++11에서 스레드 안전하게 정확히 한 번만 발생하도록 정의되어, std::call_once의 대안으로 사용될 수 있음</ul><h2 id="332-드물게-업데이트되는-데이터-구조-보호-protecting-rarely-updated-data-structures"><span class="mr-2"><strong>3.3.2 드물게 업데이트되는 데이터 구조 보호 (Protecting rarely updated data structures)</strong></span><a href="#332-드물게-업데이트되는-데이터-구조-보호-protecting-rarely-updated-data-structures" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>대부분 읽기 전용이고 가끔만 업데이트되는 데이터 구조(예: DNS 캐시)의 경우, std::mutex를 사용하면 읽기 작업 시 불필요한 직렬화가 발생.<li>이때는 <strong>읽기-쓰기 뮤텍스(reader-writer mutex)</strong>가 더 적합함.<li><p>이는 단일 “쓰기자(writer)” 스레드에 의한 배타적 접근 또는 여러 “읽기자(reader)” 스레드에 의한 공유 동시 접근을 허용함.</p><li><p>C++11 표준 라이브러리는 이를 직접 제공하지 않지만, Boost 라이브러리의 <code class="language-plaintext highlighter-rouge">boost::shared_mutex</code>를 사용할 수 있음.</p><li>업데이트 연산: <code class="language-plaintext highlighter-rouge">std::lock_guard&lt;boost::shared_mutex&gt;</code> 또는 <code class="language-plaintext highlighter-rouge">std::unique_lock&lt;boost::shared_mutex&gt;</code> 사용 (배타적 접근).<li>읽기 전용 연산: <code class="language-plaintext highlighter-rouge">boost::shared_lock&lt;boost::shared_mutex&gt;</code> 사용 (공유 접근).<ul><li>어떤 스레드가 공유 잠금을 가지고 있으면, 배타적 잠금을 획득하려는 스레드는 모든 다른 스레드가 잠금을 해제할 때까지 차단됨.<li>어떤 스레드가 배타적 잠금을 가지고 있으면, 다른 어떤 스레드도 첫 번째 스레드가 잠금을 해제할 때까지 공유 또는 배타적 잠금을 획득할 수 없음.</ul></ul><h2 id="333-재귀적-잠금-recursive-locking"><span class="mr-2"><strong>3.3.3 재귀적 잠금 (Recursive locking)</strong></span><a href="#333-재귀적-잠금-recursive-locking" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>std::mutex의 경우 이미 잠금을 보유한 스레드가 해당 뮤텍스를 다시 잠그려고 하면 정의되지 않은 동작이 발생함.<li>스레드가 동일한 뮤텍스를 먼저 해제하지 않고 여러 번 다시 획득해야 하는 경우, C++ 표준 라이브러리는 <code class="language-plaintext highlighter-rouge">std::recursive_mutex</code>를 제공함.<li><p>lock()을 세 번 호출했다면 unlock()도 세 번 호출해야 다른 스레드가 잠글 수 있음.</p><li>일반적으로 재귀적 뮤텍스가 필요하다고 생각되면 설계를 변경하는 것이 더 좋음.<li>흔한 사용 사례는 클래스 멤버 함수가 다른 공개 멤버 함수를 호출하는 경우지만, 이는 클래스 불변성이 깨진 상태에서 두 번째 멤버 함수가 작동해야 함을 의미할 수 있어 좋지 않은 설계로 이어질 수 있음.<li>더 나은 방법은 잠금을 이미 보유하고 있다고 가정하는 새로운 private 멤버 함수를 추출하여 사용하는 것임</ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/concurrency/'>Concurrency</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/concurrency/" class="post-tag no-text-decoration" >concurrency</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=3%EC%9E%A5+%EC%8A%A4%EB%A0%88%EB%93%9C+%EA%B0%84+%EB%8D%B0%EC%9D%B4%ED%84%B0+%EA%B3%B5%EC%9C%A0+-+yjh9317&url=https%3A%2F%2Fyjh9317.github.io%2Fposts%2F3%25EC%259E%25A5-%25EC%258A%25A4%25EB%25A0%2588%25EB%2593%259C-%25EA%25B0%2584-%25EB%258D%25B0%25EC%259D%25B4%25ED%2584%25B0-%25EA%25B3%25B5%25EC%259C%25A0%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=3%EC%9E%A5+%EC%8A%A4%EB%A0%88%EB%93%9C+%EA%B0%84+%EB%8D%B0%EC%9D%B4%ED%84%B0+%EA%B3%B5%EC%9C%A0+-+yjh9317&u=https%3A%2F%2Fyjh9317.github.io%2Fposts%2F3%25EC%259E%25A5-%25EC%258A%25A4%25EB%25A0%2588%25EB%2593%259C-%25EA%25B0%2584-%25EB%258D%25B0%25EC%259D%25B4%25ED%2584%25B0-%25EA%25B3%25B5%25EC%259C%25A0%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fyjh9317.github.io%2Fposts%2F3%25EC%259E%25A5-%25EC%258A%25A4%25EB%25A0%2588%25EB%2593%259C-%25EA%25B0%2584-%25EB%258D%25B0%25EC%259D%25B4%25ED%2584%25B0-%25EA%25B3%25B5%25EC%259C%25A0%2F&text=3%EC%9E%A5+%EC%8A%A4%EB%A0%88%EB%93%9C+%EA%B0%84+%EB%8D%B0%EC%9D%B4%ED%84%B0+%EA%B3%B5%EC%9C%A0+-+yjh9317" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/Gameplay-Param/">GameplayTag Param</a><li><a href="/posts/Device/">Device</a><li><a href="/posts/SwapChain/">SwapChain</a><li><a href="/posts/VertexBuffer/">VertexBuffer</a><li><a href="/posts/IndexBuffer/">IndexBuffer</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/unreal/">unreal</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/design-pattern/">design pattern</a> <a class="post-tag" href="/tags/coding-test/">coding test</a> <a class="post-tag" href="/tags/directx/">directx</a> <a class="post-tag" href="/tags/windows/">windows</a> <a class="post-tag" href="/tags/data-structure/">data_structure</a> <a class="post-tag" href="/tags/modern-effective-c/">modern effective c++</a> <a class="post-tag" href="/tags/directx3d/">directx3d</a> <a class="post-tag" href="/tags/python/">python</a></div></div></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/1%EC%9E%A5-C++%EC%9D%98-%EB%8F%99%EC%8B%9C%EC%84%B1/"><div class="card-body"> <em class="small" data-ts="1725116400" data-df="ll" > Sep 1, 2024 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>1장 C++의 동시성</h3><div class="text-muted small"><p> 1.1 동시성이란 무엇인가? 가장 기본적인 수준에서 동시성은 둘 이상의 개별적인 활동이 동시에 발생하는 것을 의미 컴퓨터 시스템에서의 동시성은 단일 시스템이 여러 독립적인 활동을 순차적이 아닌 병렬적으로 수행하는 것을 말함 컴퓨터 시스템에서의 동시성 과거 대부분의 컴퓨터는 단일 프로세서(싱글 코어)를 가지고 있었고, 작업...</p></div></div></a></div><div class="card"> <a href="/posts/2%EC%9E%A5-%EC%8A%A4%EB%A0%88%EB%93%9C-%EA%B4%80%EB%A6%AC/"><div class="card-body"> <em class="small" data-ts="1725634800" data-df="ll" > Sep 7, 2024 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>2장 스레드 관리</h3><div class="text-muted small"><p> 2.1 기본 스레드 관리 (Basic thread management) 모든 C++ 프로그램은 main() 함수를 실행하는 최소 하나의 스레드를 가짐. 추가 스레드를 시작하여 다른 함수를 진입점으로 실행할 수 있으며, 이 스레드들은 초기 스레드 및 서로와 동시에 실행됨. 지정된 진입점 함수가 반환되면 해당 스레드는 종료됨 2.1.1 스레...</p></div></div></a></div><div class="card"> <a href="/posts/01.Confirm-Screen/"><div class="card-body"> <em class="small" data-ts="1748962800" data-df="ll" > Jun 4, 2025 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Confirm Screen</h3><div class="text-muted small"><p> Confirm Screen</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/2%EC%9E%A5-%EC%8A%A4%EB%A0%88%EB%93%9C-%EA%B4%80%EB%A6%AC/" class="btn btn-outline-primary" prompt="Older"><p>2장 스레드 관리</p></a> <a href="/posts/Dedicated-Server-%EC%84%B8%ED%8C%85/" class="btn btn-outline-primary" prompt="Newer"><p>Dedicated Server 세팅</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/username">Yang jeong hyeon</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div></p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/unreal/">unreal</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/design-pattern/">design pattern</a> <a class="post-tag" href="/tags/coding-test/">coding test</a> <a class="post-tag" href="/tags/directx/">directx</a> <a class="post-tag" href="/tags/windows/">windows</a> <a class="post-tag" href="/tags/data-structure/">data_structure</a> <a class="post-tag" href="/tags/modern-effective-c/">modern effective c++</a> <a class="post-tag" href="/tags/directx3d/">directx3d</a> <a class="post-tag" href="/tags/python/">python</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/ko.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
