<!DOCTYPE html><html lang="ko" data-mode="dark" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="반복자 패턴" /><meta property="og:locale" content="ko" /><meta name="description" content="반복자 패턴" /><meta property="og:description" content="반복자 패턴" /><link rel="canonical" href="https://yjh9317.github.io/posts/%EB%B0%98%EB%B3%B5%EC%9E%90-%ED%8C%A8%ED%84%B4/" /><meta property="og:url" content="https://yjh9317.github.io/posts/%EB%B0%98%EB%B3%B5%EC%9E%90-%ED%8C%A8%ED%84%B4/" /><meta property="og:site_name" content="yjh9317" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-06-13T00:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="반복자 패턴" /><meta name="twitter:site" content="@twitter_username" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-06-17T15:34:32+09:00","datePublished":"2023-06-13T00:00:00+09:00","description":"반복자 패턴","headline":"반복자 패턴","mainEntityOfPage":{"@type":"WebPage","@id":"https://yjh9317.github.io/posts/%EB%B0%98%EB%B3%B5%EC%9E%90-%ED%8C%A8%ED%84%B4/"},"url":"https://yjh9317.github.io/posts/%EB%B0%98%EB%B3%B5%EC%9E%90-%ED%8C%A8%ED%84%B4/"}</script><title>반복자 패턴 | yjh9317</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="yjh9317"><meta name="application-name" content="yjh9317"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> </a></div><div class="site-title mt-3"> <a href="/">yjh9317</a></div><div class="site-subtitle font-italic">코딩열심히하려는사람</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/yjh9317" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['example','doamin.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>반복자 패턴</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>반복자 패턴</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1686582000" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Jun 13, 2023 </em> </span> <span> Updated <em class="" data-ts="1750142072" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Jun 17, 2025 </em> </span><div class="d-flex justify-content-between"> <span> By <em> <a href="https://twitter.com/username">Yang jeong hyeon</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1917 words"> <em>10 min</em> read</span></div></div></div><div class="post-content"><h1 id="반복자-패턴">반복자 패턴</h1><ul><li><p>컬렉션(배열, 리스트, 트리 등)의 내부 구조를 외부에 노출하지 않으면서, 그 요소들을 순차적으로 접근할 수 있는 방법을 제공하는 행위 디자인 패턴</p><li>for 루프를 사용해 std::vector의 모든 요소를 출력하는 것이 바로 이 패턴의 가장 흔한 예다.<li>반복자 패턴의 핵심은, 데이터 구조가 어떻게 생겼는지(배열인지, 연결 리스트인지 등)와 상관없이 클라이언트가 <strong>동일한 방식(begin, end, ++, *)</strong>으로 컬렉션의 요소를 순회할 수 있도록 하는 것이다.</ul><h2 id="c-표준-라이브러리의-반복자"><span class="mr-2">C++ 표준 라이브러리의 반복자</span><a href="#c-표준-라이브러리의-반복자" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>C++ 개발자들은 이미 반복자 패턴을 매일 사용하고 있다.<li>게임 캐릭터의 인벤토리를 예로 들어보자.</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">struct</span> <span class="nc">Item</span> <span class="p">{</span> <span class="n">string</span> <span class="n">name</span><span class="p">;</span> <span class="p">};</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span> <span class="n">inventory</span> <span class="o">=</span> <span class="p">{</span> <span class="p">{</span><span class="s">"Sword"</span><span class="p">},</span> <span class="p">{</span><span class="s">"Shield"</span><span class="p">},</span> <span class="p">{</span><span class="s">"Health Potion"</span><span class="p">}</span> <span class="p">};</span>

    <span class="c1">// 1. begin()으로 첫 번째 요소를 가리키는 반복자를 얻는다.</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">inventory</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>

    <span class="c1">// 2. operator* (역참조)로 반복자가 가리키는 요소의 값에 접근한다.</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"첫 번째 아이템: "</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">).</span><span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// 출력: Sword</span>

    <span class="c1">// 3. operator++ 로 다음 요소로 이동한다.</span>
    <span class="o">++</span><span class="n">it</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"두 번째 아이템: "</span> <span class="o">&lt;&lt;</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// 포인터처럼 -&gt; 연산자도 사용 가능. 출력: Shield</span>

    <span class="c1">// 4. end()는 마지막 요소 '다음'을 가리키며, 순회의 종료 조건으로 사용된다.</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">--- 전체 인벤토리 순회 ---"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">inventory</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">iter</span> <span class="o">!=</span> <span class="n">inventory</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">iter</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>std::vector가 내부적으로 데이터를 어떻게 저장하는지 전혀 몰라도, 우리는 begin(), end(), ++, * 라는 표준화된 인터페이스를 통해 모든 요소에 접근할 수 있다.<li>이것이 반복자 패턴의 본질이다.<li>C++의 범위 기반 for 루프는 이 과정을 더욱 단순화한 문법적 설탕(syntactic sugar)이다</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="c1">// 범위 기반 for 루프는 내부적으로 반복자를 사용한다.</span>
<span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">item</span> <span class="o">:</span> <span class="n">inventory</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">item</span><span class="p">.</span><span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="커스텀-반복자-게임-씬-그래프-순회하기"><span class="mr-2">커스텀 반복자: 게임 씬 그래프 순회하기</span><a href="#커스텀-반복자-게임-씬-그래프-순회하기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>반복자 패턴의 진정한 힘은 vector와 같은 선형 구조뿐만 아니라, 트리와 같은 복잡한 비선형 자료구조를 순회할 때 드러난다.<li>게임 엔진의 <strong>씬 그래프(Scene Graph)</strong>는 모든 게임 오브젝트를 부모-자식 관계의 트리 구조로 관리한다.<li>이 씬 그래프의 모든 오브젝트를 특정 순서(예: 깊이 우선 탐색, DFS)로 순회하고 싶다면 어떻게 해야 할까?</ul><h3 id="1-데이터-구조component-정의"><span class="mr-2">1. 데이터 구조(Component) 정의</span><a href="#1-데이터-구조component-정의" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>먼저 GameObject 클래스를 정의한다. 각 GameObject는 자식들을 가질 수 있다.</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">GameObject</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">string</span> <span class="n">name</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">GameObject</span><span class="o">&gt;&gt;</span> <span class="n">children</span><span class="p">;</span>

    <span class="n">GameObject</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">)</span> <span class="o">:</span> <span class="n">name</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="p">{}</span>
    <span class="kt">void</span> <span class="n">AddChild</span><span class="p">(</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">GameObject</span><span class="o">&gt;</span> <span class="n">child</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">children</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">move</span><span class="p">(</span><span class="n">child</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h3 id="2-커스텀-반복자custom-iterator-구현"><span class="mr-2">2. 커스텀 반복자(Custom Iterator) 구현</span><a href="#2-커스텀-반복자custom-iterator-구현" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>깊이 우선 탐색(DFS)을 수행하는 DFSIterator를 직접 구현해 보자.<li>재귀적인 DFS 알고리즘을 비재귀적인 operator++로 구현하려면, 방문할 노드들을 저장할 스택이 필요하다.</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre><td class="rouge-code"><pre><span class="c1">// 깊이 우선 탐색을 위한 커스텀 반복자</span>
<span class="k">class</span> <span class="nc">DFSIterator</span> <span class="p">{</span>
<span class="nl">private:</span>
    <span class="n">GameObject</span><span class="o">*</span> <span class="n">current</span><span class="p">;</span>
    <span class="n">stack</span><span class="o">&lt;</span><span class="n">GameObject</span><span class="o">*&gt;</span> <span class="n">nodes_to_visit</span><span class="p">;</span>

<span class="nl">public:</span>
    <span class="k">explicit</span> <span class="n">DFSIterator</span><span class="p">(</span><span class="n">GameObject</span><span class="o">*</span> <span class="n">start_node</span><span class="p">)</span> <span class="o">:</span> <span class="n">current</span><span class="p">(</span><span class="n">start_node</span><span class="p">)</span> <span class="p">{}</span>

    <span class="c1">// 역참조 연산자</span>
    <span class="n">GameObject</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">current</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">GameObject</span><span class="o">*</span> <span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">current</span><span class="p">;</span> <span class="p">}</span>

    <span class="c1">// 다음 노드로 이동 (핵심 로직)</span>
    <span class="n">DFSIterator</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">++</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// 현재 노드의 자식들을 역순으로 스택에 넣는다 (그래야 첫째 자식부터 방문).</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">.</span><span class="n">rbegin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">.</span><span class="n">rend</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">nodes_to_visit</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">());</span>
        <span class="p">}</span>

        <span class="c1">// 스택에서 다음 방문할 노드를 꺼낸다.</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nodes_to_visit</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">nodes_to_visit</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
            <span class="n">nodes_to_visit</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">current</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span> <span class="c1">// 순회 종료</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 비교 연산자</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">DFSIterator</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">current</span> <span class="o">!=</span> <span class="n">other</span><span class="p">.</span><span class="n">current</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><ul><li>이 operator++ 구현은 복잡하고, 원래의 재귀적인 DFS 알고리즘과는 모습이 사뭇 다르다. 가독성이 떨어지고 버그가 발생하기 쉽다.</ul><h3 id="3-begin--end-메서드-제공"><span class="mr-2">3. begin() / end() 메서드 제공</span><a href="#3-begin--end-메서드-제공" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>GameObject 클래스에 이 반복자를 사용할 수 있는 진입점을 제공한다.</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">GameObject</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="nl">public:</span>
    <span class="n">DFSIterator</span> <span class="n">begin</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// 생성 시점의 this가 첫 번째 current가 됨</span>
        <span class="c1">// ++ 호출 시 자식들이 스택에 쌓이고 첫 번째 자식이 다음 current가 됨</span>
        <span class="k">return</span> <span class="n">DFSIterator</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">DFSIterator</span> <span class="n">end</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// 순회가 끝나면 current는 nullptr가 되므로, end()는 nullptr를 가리키는 반복자와 비교한다.</span>
        <span class="k">return</span> <span class="n">DFSIterator</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><ul><li>이제 클라이언트는 씬 그래프의 내부 구조를 몰라도, for 루프 하나로 모든 GameObject를 깊이 우선으로 순회할 수 있다.</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="c1">// 사용 예시</span>
<span class="n">GameObject</span> <span class="nf">scene_root</span><span class="p">(</span><span class="s">"SceneRoot"</span><span class="p">);</span>
<span class="c1">// ... 씬 그래프 구성 ...</span>

<span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">object</span> <span class="o">:</span> <span class="n">scene_root</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Updating: "</span> <span class="o">&lt;&lt;</span> <span class="n">object</span><span class="p">.</span><span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="더-나은-방법-코루틴coroutine을-이용한-순회"><span class="mr-2">더 나은 방법: 코루틴(Coroutine)을 이용한 순회</span><a href="#더-나은-방법-코루틴coroutine을-이용한-순회" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>앞서 구현한 스택 기반의 operator++는 복잡하고 비직관적이다.<li>C++20에 도입된 <strong>코루틴(Coroutine)</strong>을 사용하면 이 문제를 매우 우아하게 해결할 수 있다.<li>코루틴은 함수의 실행을 중간에 멈추고 값을 반환한 뒤, 나중에 그 지점부터 실행을 재개하는 기능을 제공한다.</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;coroutine&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;experimental/generator&gt;</span><span class="c1"> // 컴파일러에 따라 구현이 다를 수 있음</span><span class="cp">
</span>
<span class="c1">// 코루틴을 이용한 재귀적 DFS 생성기(Generator)</span>
<span class="n">experimental</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">GameObject</span><span class="o">*&gt;</span> <span class="n">GetNodesDFS</span><span class="p">(</span><span class="n">GameObject</span><span class="o">*</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="p">)</span> <span class="k">co_return</span><span class="p">;</span>

    <span class="k">co_yield</span> <span class="n">node</span><span class="p">;</span> <span class="c1">// 1. 현재 노드를 반환하고 여기서 잠시 멈춘다.</span>

    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">child</span> <span class="o">:</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 2. 자식 노드에 대한 재귀 호출 결과를 다시 그대로 반환한다.</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">*</span> <span class="n">child_node</span> <span class="o">:</span> <span class="n">GetNodesDFS</span><span class="p">(</span><span class="n">child</span><span class="p">.</span><span class="n">get</span><span class="p">()))</span> <span class="p">{</span>
            <span class="k">co_yield</span> <span class="n">child_node</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>이 GetNodesDFS 함수는 재귀적인 DFS 알고리즘의 모습과 거의 동일하여 매우 직관적이고 가독성이 높다. 스택을 수동으로 관리할 필요도 없다.</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="c1">// 코루틴 사용 예시</span>
<span class="n">GameObject</span> <span class="nf">scene_root</span><span class="p">(</span><span class="s">"SceneRoot"</span><span class="p">);</span>
<span class="c1">// ... 씬 그래프 구성 ...</span>

<span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">*</span> <span class="n">object_ptr</span> <span class="o">:</span> <span class="n">GetNodesDFS</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scene_root</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Updating with coroutine: "</span> <span class="o">&lt;&lt;</span> <span class="n">object_ptr</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h1 id="요약">요약</h1><ul><li><p>반복자 패턴은 컬렉션의 내부 구현을 숨긴 채, 요소에 순차적으로 접근하는 표준화된 방법을 제공한다.</p><li><p>for (auto&amp; element : collection) 형태의 범위 기반 for 루프는 C++에서 반복자 패턴을 가장 편리하게 사용하는 방법이다.</p><li><p>vector 같은 선형 구조뿐만 아니라, 트리와 같은 복잡한 자료구조에 대한 커스텀 반복자를 직접 구현할 수 있다.</p><li><p>전통적인 커스텀 반복자 구현은 복잡할 수 있지만, C++20 코루틴과 같은 현대적인 기능을 활용하면 훨씬 간결하고 가독성 높은 순회 로직을 작성할 수 있다.</p></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/'>디자인 패턴</a>, <a href='/categories/%ED%96%89%ED%83%9C-%ED%8C%A8%ED%84%B4/'>행태 패턴</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/design-pattern/" class="post-tag no-text-decoration" >design pattern</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=%EB%B0%98%EB%B3%B5%EC%9E%90+%ED%8C%A8%ED%84%B4+-+yjh9317&url=https%3A%2F%2Fyjh9317.github.io%2Fposts%2F%25EB%25B0%2598%25EB%25B3%25B5%25EC%259E%2590-%25ED%258C%25A8%25ED%2584%25B4%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=%EB%B0%98%EB%B3%B5%EC%9E%90+%ED%8C%A8%ED%84%B4+-+yjh9317&u=https%3A%2F%2Fyjh9317.github.io%2Fposts%2F%25EB%25B0%2598%25EB%25B3%25B5%25EC%259E%2590-%25ED%258C%25A8%25ED%2584%25B4%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fyjh9317.github.io%2Fposts%2F%25EB%25B0%2598%25EB%25B3%25B5%25EC%259E%2590-%25ED%258C%25A8%25ED%2584%25B4%2F&text=%EB%B0%98%EB%B3%B5%EC%9E%90+%ED%8C%A8%ED%84%B4+-+yjh9317" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/Gameplay-Param/">GameplayTag Param</a><li><a href="/posts/Device/">Device</a><li><a href="/posts/SwapChain/">SwapChain</a><li><a href="/posts/VertexBuffer/">VertexBuffer</a><li><a href="/posts/IndexBuffer/">IndexBuffer</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/unreal/">unreal</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/design-pattern/">design pattern</a> <a class="post-tag" href="/tags/coding-test/">coding test</a> <a class="post-tag" href="/tags/directx/">directx</a> <a class="post-tag" href="/tags/windows/">windows</a> <a class="post-tag" href="/tags/data-structure/">data_structure</a> <a class="post-tag" href="/tags/modern-effective-c/">modern effective c++</a> <a class="post-tag" href="/tags/directx3d/">directx3d</a> <a class="post-tag" href="/tags/python/">python</a></div></div></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/%EC%B1%85%EC%9E%84-%EC%82%AC%EC%8A%AC-%ED%8C%A8%ED%84%B4/"><div class="card-body"> <em class="small" data-ts="1685631600" data-df="ll" > Jun 2, 2023 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>책임 사슬 패턴</h3><div class="text-muted small"><p> 책임 사슬 패턴 요청을 처리할 수 있는 객체들의 사슬(chain)을 만들어, 요청이 처리될 때까지 이 사슬을 따라 객체들이 차례대로 요청을 확인하게 만드는 행위 디자인 패턴이다. 요청을 보낸 객체(Sender)는 어떤 객체가 그 요청을 처리할지 알 필요가 없다. 요청은 사슬의 첫 번째 객체에게 전달되고, 해당 객체는 요청을 처...</p></div></div></a></div><div class="card"> <a href="/posts/%EC%BB%A4%EB%A7%A8%EB%93%9C-%ED%8C%A8%ED%84%B4/"><div class="card-body"> <em class="small" data-ts="1685890800" data-df="ll" > Jun 5, 2023 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>커맨드 패턴</h3><div class="text-muted small"><p> 커맨드 패턴 player.Jump()처럼 객체의 메서드를 직접 호출하는 대신, ‘점프하라’는 요청(request) 또는 명령(command) 자체를 하나의 객체로 캡슐화하는 것이 커맨드 패턴(Command Pattern)의 핵심이다. 이렇게 요청을 객체로 만들면 어떤 장점이 있을까? 명령을 변수처럼 저장하거나, 큐에 ...</p></div></div></a></div><div class="card"> <a href="/posts/%EC%9D%B8%ED%84%B0%ED%94%84%EB%A6%AC%ED%84%B0-%ED%8C%A8%ED%84%B4/"><div class="card-body"> <em class="small" data-ts="1686150000" data-df="ll" > Jun 8, 2023 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>인터프리터 패턴</h3><div class="text-muted small"><p> 인터프리터 패턴 특정 ‘언어’에 대한 문법을 정의하고, 그 언어로 작성된 문장을 해석(interpret)하는 해석기를 제공하는 행위 디자인 패턴 쉽게 말해, 우리가 직접 정의한 간단한 규칙이나 언어를 이해하고 실행하는 엔진을 만드는 방법이다. 게임 개발에서는 NPC의 행동을 정의하는 간단한 스크립트, 퀘스트의 완료...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/%EC%9D%B8%ED%84%B0%ED%94%84%EB%A6%AC%ED%84%B0-%ED%8C%A8%ED%84%B4/" class="btn btn-outline-primary" prompt="Older"><p>인터프리터 패턴</p></a> <a href="/posts/%EB%A7%A4%EA%B0%9C%EC%9E%90-%ED%8C%A8%ED%84%B4/" class="btn btn-outline-primary" prompt="Newer"><p>매개자 패턴</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/username">Yang jeong hyeon</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div></p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/unreal/">unreal</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/design-pattern/">design pattern</a> <a class="post-tag" href="/tags/coding-test/">coding test</a> <a class="post-tag" href="/tags/directx/">directx</a> <a class="post-tag" href="/tags/windows/">windows</a> <a class="post-tag" href="/tags/data-structure/">data_structure</a> <a class="post-tag" href="/tags/modern-effective-c/">modern effective c++</a> <a class="post-tag" href="/tags/directx3d/">directx3d</a> <a class="post-tag" href="/tags/python/">python</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/ko.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
