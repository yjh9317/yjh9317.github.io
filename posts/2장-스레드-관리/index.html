<!DOCTYPE html><html lang="ko" data-mode="dark" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="2장 스레드 관리" /><meta property="og:locale" content="ko" /><meta name="description" content="2.1 기본 스레드 관리 (Basic thread management)" /><meta property="og:description" content="2.1 기본 스레드 관리 (Basic thread management)" /><link rel="canonical" href="https://yjh9317.github.io/posts/2%EC%9E%A5-%EC%8A%A4%EB%A0%88%EB%93%9C-%EA%B4%80%EB%A6%AC/" /><meta property="og:url" content="https://yjh9317.github.io/posts/2%EC%9E%A5-%EC%8A%A4%EB%A0%88%EB%93%9C-%EA%B4%80%EB%A6%AC/" /><meta property="og:site_name" content="yjh9317" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2024-09-07T00:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="2장 스레드 관리" /><meta name="twitter:site" content="@twitter_username" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-09-07T00:00:00+09:00","datePublished":"2024-09-07T00:00:00+09:00","description":"2.1 기본 스레드 관리 (Basic thread management)","headline":"2장 스레드 관리","mainEntityOfPage":{"@type":"WebPage","@id":"https://yjh9317.github.io/posts/2%EC%9E%A5-%EC%8A%A4%EB%A0%88%EB%93%9C-%EA%B4%80%EB%A6%AC/"},"url":"https://yjh9317.github.io/posts/2%EC%9E%A5-%EC%8A%A4%EB%A0%88%EB%93%9C-%EA%B4%80%EB%A6%AC/"}</script><title>2장 스레드 관리 | yjh9317</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="yjh9317"><meta name="application-name" content="yjh9317"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> </a></div><div class="site-title mt-3"> <a href="/">yjh9317</a></div><div class="site-subtitle font-italic">코딩열심히하려는사람</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/yjh9317" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['example','doamin.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>2장 스레드 관리</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>2장 스레드 관리</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1725634800" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Sep 7, 2024 </em> </span><div class="d-flex justify-content-between"> <span> By <em> <a href="https://twitter.com/username">Yang jeong hyeon</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="4689 words"> <em>26 min</em> read</span></div></div></div><div class="post-content"><h1 id="21-기본-스레드-관리-basic-thread-management"><strong>2.1 기본 스레드 관리 (Basic thread management)</strong></h1><ul><li>모든 C++ 프로그램은 <code class="language-plaintext highlighter-rouge">main()</code> 함수를 실행하는 최소 하나의 스레드를 가짐. 추가 스레드를 시작하여 다른 함수를 진입점으로 실행할 수 있으며, 이 스레드들은 초기 스레드 및 서로와 동시에 실행됨.<li>지정된 진입점 함수가 반환되면 해당 스레드는 종료됨</ul><h2 id="211-스레드-시작하기-launching-a-thread"><span class="mr-2"><strong>2.1.1 스레드 시작하기 (Launching a thread)</strong></span><a href="#211-스레드-시작하기-launching-a-thread" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>C++에서 스레드는 해당 스레드에서 실행할 작업을 지정하는 <code class="language-plaintext highlighter-rouge">std::thread</code> 객체를 생성하여 시작.<li>가장 간단한 경우는 매개변수 없이 void를 반환하는 일반 함수를 작업으로 지정하는 것</ul><h3 id="코드-예제-단순-스레드-시작"><span class="mr-2"><strong>코드 예제 (단순 스레드 시작)</strong></span><a href="#코드-예제-단순-스레드-시작" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="c1"> // std::thread 사용을 위해 필요</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">do_some_work</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Worker thread executing"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="c1">// 실제 작업 수행</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">my_thread</span><span class="p">(</span><span class="n">do_some_work</span><span class="p">);</span> <span class="c1">// 새 스레드 시작</span>
    <span class="c1">// my_thread.join(); // 스레드가 완료될 때까지 기다림 (2.1.2절에서 설명)</span>
    <span class="c1">// my_thread.detach(); // 스레드를 백그라운드에서 실행 (2.1.4절에서 설명)</span>

    <span class="c1">// 중요: my_thread 객체가 소멸되기 전에 join() 또는 detach()를 호출해야 함</span>
    <span class="c1">// 그렇지 않으면 프로그램이 std::terminate()를 호출하며 종료됨</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">my_thread</span><span class="p">.</span><span class="n">joinable</span><span class="p">())</span> <span class="p">{</span> <span class="c1">// join() 또는 detach()가 호출되지 않았는지 확인</span>
        <span class="n">my_thread</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li><code class="language-plaintext highlighter-rouge">#include &lt;thread&gt;</code>: std::thread 클래스 사용을 위한 헤더 포함.<li><code class="language-plaintext highlighter-rouge">void do_some_work()</code>: 새 스레드에서 실행될 함수 정의.<li><code class="language-plaintext highlighter-rouge">std::thread my_thread(do_some_work);</code>: do_some_work 함수를 실행하는 새 스레드 생성 및 시작.<ul><li>my_thread 객체가 이 새 스레드를 나타냄.</ul><li>중요: <code class="language-plaintext highlighter-rouge">std::thread</code> 객체 소멸 전, 해당 스레드에 대해 <code class="language-plaintext highlighter-rouge">join()</code> (스레드 완료 대기) 또는 <code class="language-plaintext highlighter-rouge">detach()</code> (스레드를 분리하여 백그라운드에서 실행) 명시적 호출 필요.<ul><li>그렇지 않으면 <code class="language-plaintext highlighter-rouge">std::thread</code>의 소멸자가 <code class="language-plaintext highlighter-rouge">std::terminate()</code>를 호출하여 프로그램 비정상 종료.</ul><li><code class="language-plaintext highlighter-rouge">std::thread</code>는 함수 포인터뿐만 아니라 함수 호출 연산자(<code class="language-plaintext highlighter-rouge">operator()</code>)를 가진 클래스의 인스턴스(함수 객체)와 같은 모든 호출 가능 타입(<code class="language-plaintext highlighter-rouge">callable type</code>)과 함께 작동함.</ul><h3 id="코드-예제-함수-객체로-스레드-시작"><span class="mr-2"><strong>코드 예제 (함수 객체로 스레드 시작)</strong></span><a href="#코드-예제-함수-객체로-스레드-시작" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">background_task</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="k">operator</span><span class="p">()()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="c1">// do_something();</span>
        <span class="c1">// do_something_else();</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Background task executing"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// ... main 함수 내 ...</span>
<span class="n">background_task</span> <span class="n">f</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">my_thread_func_obj</span><span class="p">(</span><span class="n">f</span><span class="p">);</span> <span class="c1">// 함수 객체의 복사본이 새 스레드로 전달됨</span>
<span class="k">if</span> <span class="p">(</span><span class="n">my_thread_func_obj</span><span class="p">.</span><span class="n">joinable</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">my_thread_func_obj</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li><code class="language-plaintext highlighter-rouge">background_task 클래스</code>: 함수 호출 연산자 정의로 함수 객체로 사용 가능.<li><code class="language-plaintext highlighter-rouge">std::thread my_thread_func_obj(f);</code>: background_task 객체 f의 복사본이 새 스레드의 저장 공간으로 복사되어 실행됨.<ul><li>따라서 복사본이 원본과 동일하게 동작하는 것이 중요.</ul><li>C++의 <code class="language-plaintext highlighter-rouge">"most vexing parse"</code>를 피하기 위해 임시 객체를 스레드 생성자에 전달할 때 주의해야 함.<ul><li>이는 함수 선언과 유사한 구문으로 해석될 수 있기 때문임.</ul></ul><h3 id="코드-예제-most-vexing-parse-피하기"><span class="mr-2"><strong>코드 예제 (Most Vexing Parse 피하기)</strong></span><a href="#코드-예제-most-vexing-parse-피하기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="c1">// std::thread my_thread(background_task()); // 오류: 함수 선언으로 해석될 수 있음</span>

<span class="c1">// 해결 방법 1: 추가 괄호 사용</span>
<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="nf">my_thread_extra_parens</span><span class="p">((</span><span class="n">background_task</span><span class="p">()));</span> <span class="c1">// 변수 정의로 해석됨</span>
<span class="k">if</span> <span class="p">(</span><span class="n">my_thread_extra_parens</span><span class="p">.</span><span class="n">joinable</span><span class="p">())</span> <span class="n">my_thread_extra_parens</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>

<span class="c1">// 해결 방법 2: 중괄호를 사용한 새로운 초기화 구문 (C++11)</span>
<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">my_thread_braces</span><span class="p">{</span><span class="n">background_task</span><span class="p">()};</span> <span class="c1">// 변수 정의로 해석됨</span>
<span class="k">if</span> <span class="p">(</span><span class="n">my_thread_braces</span><span class="p">.</span><span class="n">joinable</span><span class="p">())</span> <span class="n">my_thread_braces</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</pre></table></code></div></div><ul><li>람다 표현식(C++11의 새로운 기능)을 사용하면 이러한 <code class="language-plaintext highlighter-rouge">"most vexing parse"</code> 문제를 피할 수 있음.<li>람다 표현식은 로컬 함수를 작성하고 로컬 변수를 캡처할 수 있게 해줌</ul><h3 id="코드-예제-람다-표현식으로-스레드-시작"><span class="mr-2"><strong>코드 예제 (람다 표현식으로 스레드 시작)</strong></span><a href="#코드-예제-람다-표현식으로-스레드-시작" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="nf">my_thread_lambda</span><span class="p">([]</span> <span class="p">{</span>
    <span class="c1">// do_something()</span><span class="p">;</span>
    <span class="c1">// do_something_else();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Lambda thread executing"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">});</span>
<span class="k">if</span> <span class="p">(</span><span class="n">my_thread_lambda</span><span class="p">.</span><span class="n">joinable</span><span class="p">())</span> <span class="n">my_thread_lambda</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</pre></table></code></div></div><ul><li>스레드가 시작된 후에는 해당 스레드가 완료될 때까지 기다릴지(<code class="language-plaintext highlighter-rouge">join()</code>) 또는 독립적으로 실행되도록 분리할지(<code class="language-plaintext highlighter-rouge">detach()</code>) 명시적으로 결정해야 함</ul><h2 id="212-스레드가-완료될-때까지-기다리기-waiting-for-a-thread-to-complete"><span class="mr-2"><strong>2.1.2 스레드가 완료될 때까지 기다리기 (Waiting for a thread to complete)</strong></span><a href="#212-스레드가-완료될-때까지-기다리기-waiting-for-a-thread-to-complete" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>스레드가 완료될 때까지 기다리려면 관련된 <code class="language-plaintext highlighter-rouge">std::thread</code> 인스턴스에서 <code class="language-plaintext highlighter-rouge">join()</code>을 호출함.<li><code class="language-plaintext highlighter-rouge">join()</code>을 호출하면 호출 스레드는 대상 스레드가 종료될 때까지 차단됨. <code class="language-plaintext highlighter-rouge">join()</code>은 스레드와 관련된 저장 공간을 정리하므로, <code class="language-plaintext highlighter-rouge">std::thread</code> 객체는 더 이상 해당 스레드와 연결되지 않음.<li>따라서 특정 스레드에 대해 <code class="language-plaintext highlighter-rouge">join()</code>은 한 번만 호출할 수 있음. <code class="language-plaintext highlighter-rouge">join()</code> 호출 후 <code class="language-plaintext highlighter-rouge">joinable()</code>은 false를 반환함</ul><h3 id="코드-예제-스레드-완료-대기"><span class="mr-2"><strong>코드 예제 (스레드 완료 대기)</strong></span><a href="#코드-예제-스레드-완료-대기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">func</span>
 <span class="p">{</span>
    <span class="kt">int</span><span class="o">&amp;</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">func</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">i_</span><span class="p">)</span><span class="o">:</span><span class="n">i</span><span class="p">(</span><span class="n">i_</span><span class="p">){}</span>
    <span class="kt">void</span> <span class="k">operator</span><span class="p">()()</span>
    <span class="p">{</span>
 <span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="mi">1000000</span><span class="p">;</span><span class="o">++</span><span class="n">j</span><span class="p">)</span>
 <span class="p">{</span>
    <span class="n">do_something</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>               
<span class="p">}</span>
    <span class="p">}</span>
 <span class="p">};</span>
 <span class="kt">void</span> <span class="n">oops</span><span class="p">()</span>
 <span class="p">{</span>
    <span class="kt">int</span> <span class="n">some_local_state</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
    <span class="n">func</span> <span class="n">my_func</span><span class="p">(</span><span class="n">some_local_state</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">my_thread</span><span class="p">(</span><span class="n">my_func</span><span class="p">);</span>
    <span class="n">my_thread</span><span class="p">.</span><span class="n">detach</span><span class="p">();</span>               
<span class="p">}</span>   
</pre></table></code></div></div><ul><li><code class="language-plaintext highlighter-rouge">my_thread.detach()</code>를 <code class="language-plaintext highlighter-rouge">my_thread.join()</code>으로 바꾸면 oops 함수가 종료되기 전에 스레드가 완료되어 로컬 변수 파괴 문제를 피할 수 있음</ul><h2 id="213-예외적인-상황에서-기다리기-waiting-in-exceptional-circumstances"><span class="mr-2"><strong>2.1.3 예외적인 상황에서 기다리기 (Waiting in exceptional circumstances)</strong></span><a href="#213-예외적인-상황에서-기다리기-waiting-in-exceptional-circumstances" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li><code class="language-plaintext highlighter-rouge">std::thread</code> 객체가 소멸되기 전에 <code class="language-plaintext highlighter-rouge">join()</code> 또는 <code class="language-plaintext highlighter-rouge">detach()</code>를 호출해야 함. 스레드를 기다리려는 경우 예외가 발생하여 <code class="language-plaintext highlighter-rouge">join()</code> 호출이 건너뛰어지는 상황을 방지해야 함.<li>이를 위해 <code class="language-plaintext highlighter-rouge">try/catch</code> 블록을 사용하거나 <code class="language-plaintext highlighter-rouge">RAII(Resource Acquisition Is Initialization) 관용구</code>를 활용할 수 있음</ul><h3 id="코드-예제-raii를-사용한-스레드-완료-대기---thread_guard"><span class="mr-2"><strong>코드 예제 (RAII를 사용한 스레드 완료 대기 - thread_guard)</strong></span><a href="#코드-예제-raii를-사용한-스레드-완료-대기---thread_guard" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="c1">// (요약 및 핵심 부분)</span>
<span class="k">class</span> <span class="nc">thread_guard</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">;</span>
<span class="nl">public:</span>
    <span class="k">explicit</span> <span class="n">thread_guard</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&amp;</span> <span class="n">t_</span><span class="p">)</span> <span class="o">:</span> <span class="n">t</span><span class="p">(</span><span class="n">t_</span><span class="p">)</span> <span class="p">{}</span>
    <span class="o">~</span><span class="n">thread_guard</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">joinable</span><span class="p">())</span> <span class="p">{</span> <span class="c1">// 스레드가 여전히 join 가능한지 확인</span>
            <span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>       <span class="c1">// 소멸자에서 join 호출</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">thread_guard</span><span class="p">(</span><span class="n">thread_guard</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span> <span class="c1">// 복사 생성자 삭제</span>
    <span class="n">thread_guard</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">thread_guard</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span> <span class="c1">// 복사 할당 연산자 삭제</span>
<span class="p">};</span>

<span class="c1">// ... f() 함수 내 ...</span>
<span class="c1">// int some_local_state = 0;</span>
<span class="c1">// func my_func(some_local_state); // func는 스레드에서 실행될 함수 객체</span>
<span class="c1">// std::thread t(my_func);</span>
<span class="c1">// thread_guard g(t); // thread_guard 객체 생성, t의 생명주기 관리</span>
<span class="c1">// do_something_in_current_thread(); // 이 작업 중 예외 발생 가능</span>
<span class="c1">// f() 함수가 종료되면 g가 먼저 소멸되고, g의 소멸자에서 t.join()이 호출됨</span>
</pre></table></code></div></div><ul><li><code class="language-plaintext highlighter-rouge">thread_guard</code> 클래스: std::thread 객체의 참조를 가짐.<li>소멸자: <code class="language-plaintext highlighter-rouge">t.joinable()</code>을 확인하여 스레드가 아직 join되지 않았으면 <code class="language-plaintext highlighter-rouge">t.join()</code> 호출. 이는 스레드가 이미 join되었거나 detach된 경우 <code class="language-plaintext highlighter-rouge">join()</code>을 다시 호출하는 것을 방지.<li>복사 생성자와 복사 할당 연산자: <code class="language-plaintext highlighter-rouge">= delete</code>로 선언되어 컴파일러에 의해 자동으로 생성되는 것을 막음.<ul><li>이는 <code class="language-plaintext highlighter-rouge">thread_guard</code> 객체가 참조하는 스레드의 유효 범위를 벗어나 복사되거나 할당되는 위험한 상황을 방지.</ul><li>함수 f 내에서 <code class="language-plaintext highlighter-rouge">thread_guard g(t);</code> 선언 시, f 함수의 범위를 벗어날 때 (정상 종료든 예외 발생이든) g의 소멸자가 호출되어 t.join()이 실행되므로 스레드 t가 안전하게 완료됨</ul><h3 id="214-백그라운드에서-스레드-실행하기-running-threads-in-the-background"><span class="mr-2"><strong>2.1.4 백그라운드에서 스레드 실행하기 (Running threads in the background)</strong></span><a href="#214-백그라운드에서-스레드-실행하기-running-threads-in-the-background" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>스레드가 완료될 때까지 기다릴 필요가 없는 경우, <code class="language-plaintext highlighter-rouge">detach()</code>를 호출하여 스레드를 백그라운드에서 실행하도록 둘 수 있음.<li><code class="language-plaintext highlighter-rouge">detach()</code>는 std::thread 객체와 스레드 간의 연결을 끊어, std::thread 객체가 소멸될 때 <code class="language-plaintext highlighter-rouge">std::terminate()</code>가 호출되는 것을 방지함.<li><p>분리된 스레드는 <code class="language-plaintext highlighter-rouge">데몬 스레드(daemon threads)</code>라고도 불리며, 일반적으로 애플리케이션 수명 동안 백그라운드 작업을 수행</p><li><code class="language-plaintext highlighter-rouge">detach()</code>는 std::thread 객체의 멤버 함수를 호출하여 수행함.<li><code class="language-plaintext highlighter-rouge">detach()</code> 호출 후 std::thread 객체는 더 이상 실제 실행 스레드와 연결되지 않으므로 <code class="language-plaintext highlighter-rouge">joinable()</code>은 false를 반환함.<li><code class="language-plaintext highlighter-rouge">join()</code>과 마찬가지로, <code class="language-plaintext highlighter-rouge">detach()</code>는 연결된 실행 스레드가 있는 std::thread 객체에 대해서만 호출할 수 있음 (joinable()이 true를 반환하는 경우).</ul><h3 id="코드-예제-다른-문서를-처리하기-위해-스레드-분리"><span class="mr-2"><strong>코드 예제 (다른 문서를 처리하기 위해 스레드 분리)</strong></span><a href="#코드-예제-다른-문서를-처리하기-위해-스레드-분리" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">edit_document</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">open_document_and_display_gui</span><span class="p">(</span><span class="n">filename</span><span class="p">);</span>
    <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">done_editing</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">user_command</span> <span class="n">cmd</span><span class="o">=</span><span class="n">get_user_input</span><span class="p">();</span>
        <span class="c1">// ... 사용자 입력 처리 부분 ...</span>
        <span class="k">if</span><span class="p">(</span><span class="n">cmd</span><span class="p">.</span><span class="n">type</span><span class="o">==</span><span class="n">open_new_document</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span> <span class="n">new_name</span><span class="o">=</span><span class="n">get_filename_from_user</span><span class="p">();</span>
            <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">(</span><span class="n">edit_document</span><span class="p">,</span><span class="n">new_name</span><span class="p">);</span> <span class="c1">// 새 스레드 시작하며 파일 이름 전달                 </span>
            <span class="n">t</span><span class="p">.</span><span class="n">detach</span><span class="p">();</span> <span class="c1">// 스레드 분리                              </span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">process_user_input</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>워드 프로세서가 새 문서를 열 때, 각 문서 편집 창을 자체 스레드에서 실행하는 예를 보여줌.<li>새 문서를 여는 요청을 처리하는 스레드는 다른 스레드가 완료되기를 기다릴 필요가 없으므로, 새 스레드를 detach()하는 것이 적합.<li>이 예제는 스레드 시작 함수에 인수를 전달하는 경우도 보여줌</ul><p><br /></p><h1 id="22-스레드-함수에-인수-전달하기-passing-arguments-to-a-thread-function"><strong>2.2 스레드 함수에 인수 전달하기 (Passing arguments to a thread function)</strong></h1><ul><li>std::thread 생성자에 추가 인수를 전달하여 호출 가능 객체나 함수에 인수를 전달할 수 있음.<li>기본적으로 인수는 내부 저장 공간으로 복사되어 새 실행 스레드에서 접근할 수 있게 됨.<ul><li>이는 함수 매개변수가 참조를 예상하더라도 마찬가지</ul></ul><h3 id="코드-예제-인수-전달"><span class="mr-2"><strong>코드 예제 (인수 전달)</strong></span><a href="#코드-예제-인수-전달" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="c1">// </span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="nf">t</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s">"hello"</span><span class="p">);</span> <span class="c1">// f(3, "hello") 호출, "hello"는 char const*로 전달 후 새 스레드에서 std::string으로 변환됨</span>
<span class="c1">// t.join(); // 실제 사용 시 필요</span>
</pre></table></code></div></div><ul><li>자동 변수에 대한 포인터를 전달할 때는 주의해야 함.<li>포인터 자체가 복사되므로, 원래 함수가 종료되기 전에 새 스레드에서 해당 포인터가 역참조되지 않으면 정의되지 않은 동작이 발생할 수 있음</ul><h3 id="코드-예제-잘못된-포인터-인수-전달-및-해결"><span class="mr-2"><strong>코드 예제 (잘못된 포인터 인수 전달 및 해결)</strong></span><a href="#코드-예제-잘못된-포인터-인수-전달-및-해결" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="c1">// (잘못된 경우)</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">oops</span><span class="p">(</span><span class="kt">int</span> <span class="n">some_param</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
    <span class="n">sprintf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="s">"%i"</span><span class="p">,</span> <span class="n">some_param</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span> <span class="c1">// buffer의 포인터가 전달됨</span>
    <span class="n">t</span><span class="p">.</span><span class="n">detach</span><span class="p">();</span>                 <span class="c1">// oops 함수가 종료되면 buffer는 파괴될 수 있음</span>
<span class="p">}</span>

<span class="c1">// (올바른 경우)</span>
<span class="kt">void</span> <span class="n">not_oops</span><span class="p">(</span><span class="kt">int</span> <span class="n">some_param</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
    <span class="n">sprintf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="s">"%i"</span><span class="p">,</span> <span class="n">some_param</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span> <span class="c1">// std::string으로 변환하여 복사본 전달</span>
    <span class="n">t</span><span class="p">.</span><span class="n">detach</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>반대로 객체가 복사되지만 실제로는 참조를 원했던 경우도 있음.<li>std::thread 생성자는 함수의 매개변수 타입을 알지 못하고 제공된 값을 그대로 복사하기 때문<ul><li>이 경우 <code class="language-plaintext highlighter-rouge">std::ref</code>를 사용하여 인수를 래핑해야 함.</ul></ul><h3 id="코드-예제-참조-전달"><span class="mr-2"><strong>코드 예제 (참조 전달)</strong></span><a href="#코드-예제-참조-전달" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">update_data_for_widget</span><span class="p">(</span><span class="n">widget_id</span> <span class="n">w</span><span class="p">,</span> <span class="n">widget_data</span><span class="o">&amp;</span> <span class="n">data</span><span class="p">);</span> <span class="c1">// data는 참조로 전달되어야 함</span>

<span class="n">widget_data</span> <span class="n">data_val</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="nf">t</span><span class="p">(</span><span class="n">update_data_for_widget</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">data_val</span><span class="p">));</span> <span class="c1">// std::ref를 사용하여 data_val의 참조를 전달</span>
<span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</pre></table></code></div></div><ul><li>멤버 함수 포인터를 스레드 함수로 전달할 수도 있으며, 이 경우 첫 번째 인수로 적절한 객체 포인터를 제공해야 함</ul><h3 id="코드-예제-멤버-함수-포인터-전달"><span class="mr-2"><strong>코드 예제 (멤버 함수 포인터 전달)</strong></span><a href="#코드-예제-멤버-함수-포인터-전달" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">X</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">do_lengthy_work</span><span class="p">();</span>
<span class="p">};</span>

<span class="n">X</span> <span class="n">my_x</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">(</span><span class="o">&amp;</span><span class="n">X</span><span class="o">::</span><span class="n">do_lengthy_work</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">my_x</span><span class="p">);</span> <span class="c1">// my_x.do_lengthy_work()를 새 스레드에서 호출</span>
<span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</pre></table></code></div></div><ul><li>인수는 복사될 수 없지만 이동(move)될 수만 있는 경우도 있음. <code class="language-plaintext highlighter-rouge">std::unique_ptr</code>와 같은 타입이 그 예임.<li>소스 객체가 임시 객체이면 이동은 자동으로 수행되지만, 이름 있는 값인 경우 <code class="language-plaintext highlighter-rouge">std::move()</code>를 명시적으로 호출해야 함</ul><h3 id="코드-예제-이동-시맨틱스를-사용한-인수-전달"><span class="mr-2"><strong>코드 예제 (이동 시맨틱스를 사용한 인수 전달)</strong></span><a href="#코드-예제-이동-시맨틱스를-사용한-인수-전달" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">process_big_object</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">big_object</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">);</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">big_object</span><span class="o">&gt;</span> <span class="n">p_val</span><span class="p">(</span><span class="k">new</span> <span class="n">big_object</span><span class="p">);</span>
<span class="n">p_val</span><span class="o">-&gt;</span><span class="n">prepare_data</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>

<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="nf">t</span><span class="p">(</span><span class="n">process_big_object</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">p_val</span><span class="p">));</span> <span class="c1">// p_val의 소유권을 새 스레드로 이전</span>
<span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</pre></table></code></div></div><p><br /></p><h1 id="23-스레드-소유권-이전하기-transferring-ownership-of-a-thread"><strong>2.3 스레드 소유권 이전하기 (Transferring ownership of a thread)</strong></h1><ul><li><code class="language-plaintext highlighter-rouge">std::thread 인스턴스는 이동 가능(movable)하지만 복사 불가능(noncopyable)</code>함.<li>이는 <code class="language-plaintext highlighter-rouge">특정 실행 스레드의 소유권이 std::thread 인스턴스 간에 이전될 수 있음을 의미</code>함.<li>이는 한 번에 하나의 객체만 특정 실행 스레드와 연결되도록 보장하면서 프로그래머에게 소유권 이전 옵션을 제공함</ul><h3 id="코드-예제-스레드-소유권-이전"><span class="mr-2"><strong>코드 예제 (스레드 소유권 이전)</strong></span><a href="#코드-예제-스레드-소유권-이전" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">some_function</span><span class="p">();</span>
<span class="kt">void</span> <span class="nf">some_other_function</span><span class="p">();</span>

<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="nf">t1</span><span class="p">(</span><span class="n">some_function</span><span class="p">);</span>         <span class="c1">// t1이 새 스레드 소유</span>
<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">t1</span><span class="p">);</span>        <span class="c1">// t2가 t1으로부터 소유권 이전받음, t1은 더 이상 스레드와 연결되지 않음</span>
<span class="n">t1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="n">some_other_function</span><span class="p">);</span> <span class="c1">// t1이 새 스레드 소유 (임시 객체로부터의 이동은 암시적)</span>
<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t3</span><span class="p">;</span>
<span class="n">t3</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">t2</span><span class="p">);</span>                    <span class="c1">// t3가 t2로부터 소유권 이전받음</span>
<span class="n">t1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">t3</span><span class="p">);</span>                    <span class="c1">// 오류! t1은 이미 스레드를 관리하고 있으므로 std::terminate() 호출됨</span>
</pre></table></code></div></div><ul><li><code class="language-plaintext highlighter-rouge">std::move(t1)</code>: t1의 소유권 명시적 이전.<li><code class="language-plaintext highlighter-rouge">임시 std::thread 객체로부터의 소유권 이전</code>: <code class="language-plaintext highlighter-rouge">std::move()</code> 호출 없이 자동 수행.<li>이미 스레드를 관리하는 std::thread 객체에 다른 스레드의 소유권 할당 시도: <code class="language-plaintext highlighter-rouge">std::terminate()</code> 호출로 프로그램 종료. 이는 소멸 시점에서와 마찬가지로 스레드를 “버리는” 것을 방지하기 위함<li>std::thread의 이동 지원 덕분에 함수에서 스레드 소유권을 반환하거나 함수로 전달할 수 있음</ul><h3 id="코드-예제-scoped_thread---raii를-활용한-스레드-소유권-관리"><span class="mr-2"><strong>코드 예제 (scoped_thread - RAII를 활용한 스레드 소유권 관리)</strong></span><a href="#코드-예제-scoped_thread---raii를-활용한-스레드-소유권-관리" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">scoped_thread</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">;</span>
<span class="nl">public:</span>
    <span class="k">explicit</span> <span class="n">scoped_thread</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t_</span><span class="p">)</span> <span class="o">:</span> <span class="n">t</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">t_</span><span class="p">))</span> <span class="c1">// 생성자에서 소유권 이전</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">t</span><span class="p">.</span><span class="n">joinable</span><span class="p">())</span> <span class="c1">// join 가능 여부 확인                          </span>
            <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">logic_error</span><span class="p">(</span><span class="err">“</span><span class="n">No</span> <span class="kr">thread</span><span class="err">”</span><span class="p">);</span> 
    <span class="p">}</span>
    <span class="o">~</span><span class="n">scoped_thread</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span> <span class="c1">// 소멸자에서 join</span>
    <span class="p">}</span>
    <span class="n">scoped_thread</span><span class="p">(</span><span class="n">scoped_thread</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span><span class="o">=</span><span class="k">delete</span><span class="p">;</span>
    <span class="n">scoped_thread</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">scoped_thread</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span><span class="o">=</span><span class="k">delete</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">func</span><span class="p">;</span>                  

<span class="kt">void</span> <span class="n">f</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">some_local_state</span><span class="p">;</span>
    <span class="n">scoped_thread</span> <span class="n">t</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="n">some_local_state</span><span class="p">)));</span> <span class="c1">// 직접 소유권 전달</span>
    <span class="n">do_something_in_current_thread</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>이 클래스는 생성 시 std::thread 객체의 소유권을 가져오고, 소멸 시 해당 스레드를 join()함.<li>이는 스레드가 범위를 벗어나기 전에 완료되도록 보장<li>std::thread 객체는 std::vector와 같은 이동을 지원하는 컨테이너에 저장될 수 있음. 이를 통해 여러 스레드를 그룹으로 관리할 수 있음</ul><h3 id="코드-예제-여러-스레드를-시작하고-완료-대기"><span class="mr-2"><strong>코드 예제 (여러 스레드를 시작하고 완료 대기)</strong></span><a href="#코드-예제-여러-스레드를-시작하고-완료-대기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">do_work</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">id</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="n">threads</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">20</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">threads</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="n">do_work</span><span class="p">,</span><span class="n">i</span><span class="p">));</span>   
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">threads</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">threads</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="n">std</span><span class="o">::</span><span class="n">mem_fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">::</span><span class="n">join</span><span class="p">));</span>   
<span class="p">}</span>
</pre></table></code></div></div><ul><li><code class="language-plaintext highlighter-rouge">std::vector&lt;std::thread&gt;</code>를 사용하여 여러 스레드를 시작하고, <code class="language-plaintext highlighter-rouge">std::for_each</code>와 <code class="language-plaintext highlighter-rouge">std::mem_fn</code>을 사용하여 각 스레드를 join()하는 예제</ul><p><br /></p><h1 id="24-런타임에-스레드-수-선택하기-choosing-the-number-of-threads-at-runtime"><strong>2.4 런타임에 스레드 수 선택하기 (Choosing the number of threads at runtime)</strong></h1><ul><li>C++ 표준 라이브러리는 <code class="language-plaintext highlighter-rouge">std::thread::hardware_concurrency()</code> 함수를 제공하여, 프로그램 실행 시 진정으로 동시에 실행될 수 있는 스레드 수에 대한 힌트를 반환<li>멀티코어 시스템에서는 CPU 코어 수가 될 수 있음. 이 정보가 없으면 0을 반환할 수 있지만, 작업을 스레드 간에 분할하는 데 유용한 가이드가 될 수 있음</ul><h3 id="코드-예제-parallel_accumulate---작업-분할"><span class="mr-2"><strong>코드 예제 (parallel_accumulate - 작업 분할</strong></span><a href="#코드-예제-parallel_accumulate---작업-분할" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre><td class="rouge-code"><pre><span class="c1">// (핵심 로직 요약)</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Iterator</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">T</span> <span class="nf">parallel_accumulate</span><span class="p">(</span><span class="n">Iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">Iterator</span> <span class="n">last</span><span class="p">,</span> <span class="n">T</span> <span class="n">init</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="k">const</span> <span class="n">length</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">distance</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">length</span><span class="p">)</span> <span class="k">return</span> <span class="n">init</span><span class="p">;</span> <span class="c1">// 빈 범위 처리</span>

    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="k">const</span> <span class="n">min_per_thread</span> <span class="o">=</span> <span class="mi">25</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="k">const</span> <span class="n">max_threads</span> <span class="o">=</span> <span class="p">(</span><span class="n">length</span> <span class="o">+</span> <span class="n">min_per_thread</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">min_per_thread</span><span class="p">;</span> <span class="c1">// 최대 스레드 수 계산</span>

    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="k">const</span> <span class="n">hardware_threads</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">::</span><span class="n">hardware_concurrency</span><span class="p">();</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="k">const</span> <span class="n">num_threads</span> <span class="o">=</span>
        <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">hardware_threads</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">hardware_threads</span> <span class="o">:</span> <span class="mi">2</span><span class="p">,</span> <span class="n">max_threads</span><span class="p">);</span> <span class="c1">// 실제 사용할 스레드 수 결정</span>

    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="k">const</span> <span class="n">block_size</span> <span class="o">=</span> <span class="n">length</span> <span class="o">/</span> <span class="n">num_threads</span><span class="p">;</span> <span class="c1">// 각 스레드가 처리할 블록 크기</span>

    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">results</span><span class="p">(</span><span class="n">num_threads</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="n">threads</span><span class="p">(</span><span class="n">num_threads</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// 주 스레드를 제외한 스레드 수</span>

    <span class="n">Iterator</span> <span class="n">block_start</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">num_threads</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Iterator</span> <span class="n">block_end</span> <span class="o">=</span> <span class="n">block_start</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">advance</span><span class="p">(</span><span class="n">block_end</span><span class="p">,</span> <span class="n">block_size</span><span class="p">);</span> <span class="c1">// 현재 블록의 끝</span>
        <span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span>
            <span class="n">accumulate_block</span><span class="o">&lt;</span><span class="n">Iterator</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">(),</span> <span class="c1">// accumulate_block은 각 블록의 합계를 계산하는 함수 객체</span>
            <span class="n">block_start</span><span class="p">,</span> <span class="n">block_end</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span> <span class="c1">// 새 스레드 시작</span>
        <span class="n">block_start</span> <span class="o">=</span> <span class="n">block_end</span><span class="p">;</span> <span class="c1">// 다음 블록의 시작</span>
    <span class="p">}</span>
    <span class="n">accumulate_block</span><span class="o">&lt;</span><span class="n">Iterator</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">()(</span><span class="n">block_start</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">results</span><span class="p">[</span><span class="n">num_threads</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span> <span class="c1">// 주 스레드가 나머지 블록 처리</span>

    <span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">threads</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">threads</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
                  <span class="n">std</span><span class="o">::</span><span class="n">mem_fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">::</span><span class="n">join</span><span class="p">));</span> <span class="c1">// 모든 작업 스레드 완료 대기</span>

    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">results</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">results</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">init</span><span class="p">);</span> <span class="c1">// 최종 결과 합산</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li><p>std::accumulate의 병렬 버전을 간단하게 구현함.</p><li><p>이 함수는 스레드당 최소 요소 수를 고려하여 작업을 스레드 간에 분할</p><li><p>주의: 이 parallel_accumulate 예제는 단순하며, 예외 처리, 비결합 연산자(non-associative operator)로 인한 결과 변동 가능성 등은 고려되지 않았음. 또한, 반복자 요구 사항이 더 엄격하고, T 타입은 기본 생성 가능해야 함</p></ul><p><br /></p><h1 id="25-스레드-식별하기-identifying-threads"><strong>2.5 스레드 식별하기 (Identifying threads)</strong></h1><ul><li>각 스레드는 <code class="language-plaintext highlighter-rouge">std::thread::id</code> 타입의 고유 식별자를 가짐.<li>스레드 식별자는 두 가지 방법으로 얻을 수 있음</ul><h2 id="식별자-얻는-방법"><span class="mr-2">식별자 얻는 방법</span><a href="#식별자-얻는-방법" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="1번-방법"><span class="mr-2"><strong>1번 방법</strong></span><a href="#1번-방법" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><code class="language-plaintext highlighter-rouge">std::thread 객체의 get_id() 멤버 함수 호출</code><li>std::thread 객체가 실행 스레드와 연결되어 있지 않으면, “어떤 스레드도 아님(not any thread)”을 나타내는 기본 생성된 <code class="language-plaintext highlighter-rouge">std::thread::id</code> 객체를 반환</ul><h3 id="2번-방법"><span class="mr-2"><strong>2번 방법</strong></span><a href="#2번-방법" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>&lt;thread&gt; 헤더에 정의된 <code class="language-plaintext highlighter-rouge">std::this_thread::get_id()</code>를 호출하여 현재 스레드의 식별자를 얻음.</ul><h2 id="stdthreadid"><span class="mr-2"><strong>std::thread::id</strong></span><a href="#stdthreadid" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li><code class="language-plaintext highlighter-rouge">std::thread::id</code> 객체는 자유롭게 복사하고 비교할 수 있음.<li>두 <code class="language-plaintext highlighter-rouge">std::thread::id</code> 객체가 같으면 동일한 스레드를 나타내거나 둘 다 “어떤 스레드도 아님” 값을 가짐.<ul><li>같지 않으면 다른 스레드를 나타냄.</ul><li><code class="language-plaintext highlighter-rouge">std::thread::id</code>는 전체 순서(total ordering)를 제공하므로 연관 컨테이너의 키로 사용하거나 정렬할 수 있음.<li><code class="language-plaintext highlighter-rouge">std::hash&lt;std::thread::id&gt;</code>도 제공되어 해시 기반 컨테이너의 키로 사용할 수 있음</ul><h3 id="활용"><span class="mr-2"><strong>활용</strong></span><a href="#활용" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>스레드 ID는 특정 스레드가 특정 작업을 수행해야 하는지 확인하는 데 사용될 수 있음.<li>또는 스레드별 데이터를 저장하는 데이터 구조의 키로 사용될 수 있음.<li><code class="language-plaintext highlighter-rouge">std::thread::id</code>는 std::cout과 같은 출력 스트림으로 출력할 수 있으며, 주로 디버깅 및 로깅에 유용</ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/concurrency/'>Concurrency</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/concurrency/" class="post-tag no-text-decoration" >concurrency</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=2%EC%9E%A5+%EC%8A%A4%EB%A0%88%EB%93%9C+%EA%B4%80%EB%A6%AC+-+yjh9317&url=https%3A%2F%2Fyjh9317.github.io%2Fposts%2F2%25EC%259E%25A5-%25EC%258A%25A4%25EB%25A0%2588%25EB%2593%259C-%25EA%25B4%2580%25EB%25A6%25AC%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=2%EC%9E%A5+%EC%8A%A4%EB%A0%88%EB%93%9C+%EA%B4%80%EB%A6%AC+-+yjh9317&u=https%3A%2F%2Fyjh9317.github.io%2Fposts%2F2%25EC%259E%25A5-%25EC%258A%25A4%25EB%25A0%2588%25EB%2593%259C-%25EA%25B4%2580%25EB%25A6%25AC%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fyjh9317.github.io%2Fposts%2F2%25EC%259E%25A5-%25EC%258A%25A4%25EB%25A0%2588%25EB%2593%259C-%25EA%25B4%2580%25EB%25A6%25AC%2F&text=2%EC%9E%A5+%EC%8A%A4%EB%A0%88%EB%93%9C+%EA%B4%80%EB%A6%AC+-+yjh9317" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/Gameplay-Param/">GameplayTag Param</a><li><a href="/posts/Device/">Device</a><li><a href="/posts/SwapChain/">SwapChain</a><li><a href="/posts/VertexBuffer/">VertexBuffer</a><li><a href="/posts/IndexBuffer/">IndexBuffer</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/unreal/">unreal</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/design-pattern/">design pattern</a> <a class="post-tag" href="/tags/coding-test/">coding test</a> <a class="post-tag" href="/tags/directx/">directx</a> <a class="post-tag" href="/tags/windows/">windows</a> <a class="post-tag" href="/tags/data-structure/">data_structure</a> <a class="post-tag" href="/tags/modern-effective-c/">modern effective c++</a> <a class="post-tag" href="/tags/directx3d/">directx3d</a> <a class="post-tag" href="/tags/python/">python</a></div></div></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/1%EC%9E%A5-C++%EC%9D%98-%EB%8F%99%EC%8B%9C%EC%84%B1/"><div class="card-body"> <em class="small" data-ts="1725116400" data-df="ll" > Sep 1, 2024 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>1장 C++의 동시성</h3><div class="text-muted small"><p> 1.1 동시성이란 무엇인가? 가장 기본적인 수준에서 동시성은 둘 이상의 개별적인 활동이 동시에 발생하는 것을 의미 컴퓨터 시스템에서의 동시성은 단일 시스템이 여러 독립적인 활동을 순차적이 아닌 병렬적으로 수행하는 것을 말함 컴퓨터 시스템에서의 동시성 과거 대부분의 컴퓨터는 단일 프로세서(싱글 코어)를 가지고 있었고, 작업...</p></div></div></a></div><div class="card"> <a href="/posts/3%EC%9E%A5-%EC%8A%A4%EB%A0%88%EB%93%9C-%EA%B0%84-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B3%B5%EC%9C%A0/"><div class="card-body"> <em class="small" data-ts="1726326000" data-df="ll" > Sep 15, 2024 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>3장 스레드 간 데이터 공유</h3><div class="text-muted small"><p> 3.1 스레드 간 데이터 공유 시 문제점 (Problems with sharing data between threads) 여러 스레드가 데이터를 공유할 때, 특히 하나 이상의 스레드가 데이터를 수정하는 경우 문제가 발생할 수 있음. 읽기 전용 데이터는 문제가 없지만, 수정이 가해지면 데이터의 일관성을 유지하기 위한 세심한 주의가 필...</p></div></div></a></div><div class="card"> <a href="/posts/01.Confirm-Screen/"><div class="card-body"> <em class="small" data-ts="1748962800" data-df="ll" > Jun 4, 2025 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Confirm Screen</h3><div class="text-muted small"><p> Confirm Screen</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/1%EC%9E%A5-C++%EC%9D%98-%EB%8F%99%EC%8B%9C%EC%84%B1/" class="btn btn-outline-primary" prompt="Older"><p>1장 C++의 동시성</p></a> <a href="/posts/3%EC%9E%A5-%EC%8A%A4%EB%A0%88%EB%93%9C-%EA%B0%84-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B3%B5%EC%9C%A0/" class="btn btn-outline-primary" prompt="Newer"><p>3장 스레드 간 데이터 공유</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/username">Yang jeong hyeon</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div></p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/unreal/">unreal</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/design-pattern/">design pattern</a> <a class="post-tag" href="/tags/coding-test/">coding test</a> <a class="post-tag" href="/tags/directx/">directx</a> <a class="post-tag" href="/tags/windows/">windows</a> <a class="post-tag" href="/tags/data-structure/">data_structure</a> <a class="post-tag" href="/tags/modern-effective-c/">modern effective c++</a> <a class="post-tag" href="/tags/directx3d/">directx3d</a> <a class="post-tag" href="/tags/python/">python</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/ko.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
