[ { "title": "Confirm Screen", "url": "/posts/01.Confirm-Screen/", "categories": "unreal, CommonUI", "tags": "unreal", "date": "2025-06-04 00:00:00 +0900", "snippet": "Confirm Screen " }, { "title": "Common Input Data", "url": "/posts/05.CommonInputData/", "categories": "unreal, CommonUI", "tags": "unreal", "date": "2025-06-03 00:00:00 +0900", "snippet": "UCommonInputSettings (공용 입력 세팅) 프로젝트 세팅에 있는 클래스 위치는 프로젝트 세팅 (Project Settings) -&gt; 게임 (Game) -&gt; Common Input Settings 주된 역할은 Common UI가 입력을 어떻게 처리할지, 특히 어떤 입력 장치에 대해 어떤 아이콘 세트를 사용할지를 전역적으로 설정 중요한 설정 중 하나가 Input Data (입력 데이터) 항목 여기서 키보드/마우스, Xbox 게임패드, PS5 게임패드 같은 각 입력 타입별로 어떤 UCommonUIInputData 에셋을 쓸지 지정 시스템에게 이 입력 장치에는 이 아이콘 모음을 쓰라고 알려주는 핵심 부분 결국, UCommonInputSettings는 각종 입력 방식에 대해 어떤 아이콘 데이터(UCommonUIInputData)를 사용할지 연결해주는 중앙 설정 지점세팅 기존의 입력데이터는 None으로, 입력데이터칸에 사용할 UCommonUIInputData를 지정 그 밑에는 플랫폼 입력칸으로, 여러 플랫폼이 있고 그 중에 사용할 플랫폼에서 사용할 컨트롤러 데이터(UCommonInputBaseControllerData)를 설정해줌 UCommonInputBaseControllerData (공용 입력 기본 컨트롤러 데이터) UDataAsset에서 파생된 데이터 에셋 주 목적은 특정 게임 컨트롤러 타입 또는 제품군(예: Xbox 컨트롤러, PlayStation DualSense 컨트롤러, 일반적인 XInput 호환 컨트롤러 등)에 대한 구체적인 입력 관련 데이터와 시각적 표현(주로 아이콘 세트 및 컨트롤러 이미지)을 정의 UCommonUIInputData가 좀 더 일반적인 입력 장치 타입(예: ‘게임패드 전체’, ‘키보드/마우스’)에 대한 개별 키와 아이콘 매핑을 주로 다룬다면, UCommonInputBaseControllerData는 한 단계 더 나아가 특정 제조사나 모델군의 컨트롤러에 좀 더 특화된 정보 묶음을 제공하는 데 사용 세팅 입력 타입은 사용할 컨트롤러 타입을 사용 입력 브러시 데이터 맵에서 사용할 이미지와 Key를 설정 이 값으로 이전 장의 CommonBoundAction의 CommonText와 InputActionWidget으로 사용 FCommonInputActionDataBase (공용 입력 액션 데이터베이스 구조체) C++ 구조체(Struct)이면서, 데이터 테이블의 행(Row) 구조를 만들기 위한 기본 틀(Base) 실제로 사용할 때는 보통 이 FCommonInputActionDataBase에서 파생된 다른 구조체(예: FCommonInputActionUIData)를 데이터 테이블 에셋의 행 구조로 선택 이 데이터 테이블의 각 행은 하나의 ‘입력 액션(Input Action)’ (프로젝트 세팅 -&gt; 입력(Input)에서 정의한 “점프”, “확인” 같은 추상적 동작)을 의미함. 그리고 그 액션에 대한 UI 관련 정보(예: 화면에 표시될 이름)를 담고 있음. 주요 속성으로는 보통 해당 액션의 DisplayName (표시 이름) (예: “점프하기”, “메뉴 열기”) 같은 것이 있음. 예전엔 아이콘 정보도 있었지만, 요즘은 UCommonUIInputData에서 키별로 아이콘을 더 자세히 관리 UCommonBoundActionButton 같은 위젯이 자신이 어떤 입력 액션을 대표하는지, 그리고 어떤 이름으로 표시되어야 하는지를 이 데이터 테이블의 특정 행을 참조해서 알 수 있음세팅 Key Mapping 에 사용할 InputAction을 데이터 테이블로 관리 CommonUIInputData는 이 DataTable을 이용해서 사용할 InputAction을 설정 UCommonUIInputData (공용 UI 입력 데이터) 데이터 에셋의 종류로, 지원하려는 각 입력 장치 타입(키보드/마우스, Xbox 컨트롤러 등)마다 별도의 인스턴스를 생성함 역할은 특정 입력 장치 타입에서 각각의 물리적 입력 키(Key)가 UI에 어떻게 보여야 하는지(주로 어떤 아이콘을 쓸지)를 정의 세팅 InputType (입력 타입): 이 데이터 에셋이 어떤 종류의 입력 장치를 위한 것인지(예: Gamepad, KeyboardAndMouse)를 명시 KeyBrushes (키 브러시 맵): TMap&lt;FKey, FSlateBrush&gt; 형태의 맵 키(Key): FKey 값으로, 특정 물리적 키를 나타냄 값(Value): FSlateBrush 값으로, 해당 물리적 키에 대해 UI에 표시할 아이콘 이미지를 지정함 DefaultClickAction UCommonUIInputData 에셋이 정의하는 입력 장치 타입에서, 사용자가 일반적으로 ‘확인’, ‘선택’, ‘실행’, 또는 ‘주요 상호작용’의 의미로 받아들이는 기본 입력 액션DefaultBackAction DefaultClickAction과 비슷하게, 해당 입력 장치 타입에서 사용자가 일반적으로 ‘취소’, ‘뒤로 가기’, ‘이전 화면’, 또는 ‘메뉴 닫기’의 의미로 받아들이는 기본 입력 액션을 지정결과" }, { "title": "Common Bound Action", "url": "/posts/04.CommonBoundAction/", "categories": "unreal, CommonUI", "tags": "unreal", "date": "2025-06-03 00:00:00 +0900", "snippet": "UCommonBoundActionBar 여러 개의 UCommonBoundActionButton (또는 유사한 액션 표시 위젯)들을 담는 컨테이너 또는 \"바(bar)\" 형태의 위젯기능 다중 액션 표시 화면의 특정 영역(주로 하단이나 측면)에 현재 사용 가능한 여러 입력 액션들의 목록을 아이콘과 함께 표시 동적 구성 표시할 입력 액션 목록을 동적으로 변경할 수 있다. 예를 들어, 현재 UI 컨텍스트나 게임 상황에 따라 사용 가능한 액션들만 표시하도록 업데이트할 수 있다 자동 레이아웃 내부에 포함된 액션 버튼들을 가로나 세로로 정렬 설정 각 액션을 표시할 때 사용할 템플릿 위젯을 지정 디테일 패널에서 Action Button Class를 채우지 않으면 컴파일 오류 발생 이 템플릿 위젯은 주로 UCommonBoundActionButton이거나 이를 커스터마이징한 위젯 블루프린트. UCommonBoundActionBar는 목록에 있는 각 액션에 대해 이 템플릿 위젯의 인스턴스를 생성하여 내용을 채움 사용 예시 게임 메뉴 화면의 하단 네비게이션 바 선택 뒤로 옵션 대화창의 선택지 버튼 모음. 컨텍스트에 따라 사용 가능한 액션이 변하는 UI.UCommonBoundActionButton 단일 입력 액션에 바인딩(연결)된 버튼기능 자동 아이콘 표시 특정 입력 액션과 연결되면, 현재 활성화된 입력 장치(게임패드, 키보드/마우스)에 맞는 아이콘을 데이터 테이블에서 가져와 자동으로 표시 예를 들어 “확인” 액션에 연결된 경우, 게임패드 사용 시에는 “A” 버튼 아이콘을, 키보드 사용 시에는 “Enter” 키 아이콘을 보여줄 수 있다. 입력 액션 실행 사용자가 이 버튼을 클릭하거나 연결된 입력 액션에 해당하는 키를 누르면, 해당 입력 액션이 실행되도록 설정할 수 있다. 스타일링 UCommonButtonBase를 기반으로 하거나 유사한 기능을 가지므로, UCommonButtonStyle을 통해 시각적 스타일을 일관되게 관리할 수 있다. 설정 보통 입력 액션 데이터 테이블의 행(Row) 핸들을 지정하여 어떤 입력 액션을 나타낼지 결정한다. 이 데이터 테이블 행에는 해당 액션의 이름, 아이콘 정보 등이 포함된다. 이 클래스를 생성하면 Widget Bind를 필수적으로 해야 한다.사용 예시 “A 확인”, “B 취소” 와 같이 특정 키와 함께 액션 설명을 표시하는 버튼 게임 내 상호작용 오브젝트에 대한 프롬프트 (예: “X 아이템 줍기”) " }, { "title": "Press Any Key 구현하기", "url": "/posts/03.PressAnyKey/", "categories": "unreal, CommonUI", "tags": "unreal", "date": "2025-06-03 00:00:00 +0900", "snippet": "Press Any key 게임에서 아무 Key를 눌러 다음 화면을 넘어갈 때 사용하는 Widget 보통 마우스나 키보드 둘 다 지원하는데 각각 함수를 이용하여 마우스나 키보드의 입력을 감지해서 함수를 호출하는 방식 UserWidget 함수(마우스, 키보드 감지)OnMouseButtonDown 마우스의 입력을 받아 Main Menu를 여는 함수 호출OnKeyDown 키보드의 입력을 받아 Main Menu를 여는 함수 호출Common Activatable Widget 함수(설정)GetDesiredInputConfig 설명 UCommonActivatableWidget이 활성화될 때 어떤 입력 환경 설정(Input Configuration)을 원하는지 시스템에 알려주는 함수 ECommonInputMode::Menu: UI 요소에만 입력이 집중. 게임플레이 입력은 무시 ECommonInputMode::Game: 게임플레이에만 입력이 집중. UI는 입력을 받지 않음 ECommonInputMode::All: UI와 게임플레이 모두 입력을 받을 수 있음. (예: 게임 화면 위에 떠 있는 간단한 알림창, 미니맵 상호작용 등) ECommonInputMode::GameAndMenu: All과 유사하지만, UI 입력이 게임 입력보다 우선권을 가질 수 있음을 명시적으로 나타냄 MouseCaptureMode : 마우스 커서의 캡처 방식을 설정 bHideCursorDuringViewportCapture : 뷰포트 캡처 중 마우스 커서를 숨길지 여부를 결정 bExecuteInputHandlers :이 위젯의 입력 핸들러를 실행할지 여부호출GetDesiredFocusTarget 설명 UCommonActivatableWidget이 활성화될 때 어떤 내부 위젯(UMG 위젯)에 초기 키보드/게임패드 포커스를 설정할지 시스템에 알려주는 함수반환 타입 TWeakObjectPtr&lt;UWidget&gt; (포커스를 받을 UMG 위젯에 대한 약한 포인터)호출 시점 해당 Activatable Widget이 활성화되고, 시스템이 초기 포커스를 설정해야 할 때 호출 GetDesiredInputConfig() 호출 이후에 적절한 시점에 호출됨 호출화면PressAnyKey PressAnyKey에서 활성화된 Visibility를 Visible로 바꾸고 포커스 가능 여부도 true로 바꿔줌Main Menu" }, { "title": "Common Button Style", "url": "/posts/02.CommonButtonStyle/", "categories": "unreal, CommonUI", "tags": "unreal", "date": "2025-06-03 00:00:00 +0900", "snippet": "Common Button Style UButton과 달리 CommonButton에 사용할 수 있는 에셋 여러 버튼에 동일한 스타일을 적용해야 할 때, 각 버튼마다 개별적으로 스타일 속성을 설정하는 대신, 하나의 UCommonButtonStyle 에셋을 만들고 이를 공유하여 사용 목록 기존 UUserWidget에 적용하는 Style과 거의 흡사함" }, { "title": "Common Button Base", "url": "/posts/01.CommonButton/", "categories": "unreal, CommonUI", "tags": "unreal", "date": "2025-06-03 00:00:00 +0900", "snippet": "UCommonButtonBase 기존의 UMG UButton 위젯보다 훨씬 더 많은 기능과 유연성을 제공하며, 특히 다양한 입력 장치(마우스, 키보드, 게임패드)를 지원하고 일관된 UI 스타일을 유지해야 하는 복잡한 UI 시스템을 구축하는 데 적합장점 중앙 집중식 스타일링 에셋 지원 버튼 및 텍스트 스타일을 에셋으로 관리하여 프로젝트 전체 버튼의 일관성을 유지하기 쉬움 커스텀 입력으로 쉬운 트리거 데이터 테이블을 통해 키보드 입력(예: Esc 키) 등으로 버튼을 쉽게 발동시킬 수 있음 입력 방식 변경 자동 감지 마우스/키보드 ↔ 게임패드 전환 시, 연결된 플랫폼별 아이콘을 자동으로 업데이트(InputActionWidget 변수 사용). 네이티브 게임패드 네비게이션 지원 별도 구현 없이 바로 게임패드 이동이 가능 UButton과의 차이점스타일링 UButton은 개별 인스턴스마다 스타일을 설정해야 하지만, UCommonButtonBase는 UCommonButtonStyle을 통해 중앙 집중적이고 상태 기반의 고급 스타일링을 지원입력 UButton은 주로 마우스 클릭에 의존하지만, UCommonButtonBase는 다양한 입력 액션, 입력 장치별 시각적 프롬프트 표시 등 고급 입력 처리를 지원기능 UCommonButtonBase는 선택 상태, 토글 기능, 향상된 네비게이션 등 더 많은 내장 기능을 제공목적 UButton은 간단한 UI에 적합하고, UCommonButtonBase는 복잡하고 일관성이 중요하며 다양한 입력을 지원해야 하는 모던 UI 시스템에 적합" }, { "title": "Developer Settings", "url": "/posts/03.Developer-Settings/", "categories": "unreal, CommonUI", "tags": "unreal", "date": "2025-06-02 00:00:00 +0900", "snippet": "문제점 Push할 때 ‘Press Any Key’ 화면과 같은 UI 위젯을 하드코딩된 클래스 이름으로 푸시하고 있음. 이는 나중에 위젯을 변경하거나 관리할 때 여러 파일을 수정해야 하는 번거로움과 오류 발생 가능성을 높힘 그래서 해결책으로 Developer Settings 클래스를 사용 Developer Settings UDeveloperSettings 클래스는 C++ 클래스로,언리얼 엔진에서 프로젝트별 설정을 저장하고 관리하기 위한 기반 클래스 이 클래스를 상속받아 커스텀 설정을 만들면, 에디터의 프로젝트 세팅 (Project Settings) 창에 새로운 항목으로 나타남 목적 게임이나 플러그인의 다양한 설정 값들을 중앙에서 관리하고, .ini 설정 파일에 저장하여 영구적으로 유지할 수 있게 함장점 하드코딩된 값을 줄여 유연성을 높힘 여러 개발자가 동일한 설정 값을 공유하기 용이 에디터 UI를 통해 쉽게 값을 변경하고 테스트 가능 빌드된 게임에서도 이 설정 값을 읽어와 사용할 수 있음코드#include \"CoreMinimal.h\"#include \"Engine/DeveloperSettings.h\"#include \"GameplayTagContainer.h\"#include \"FrontendDeveloperSettings.generated.h\"class UWidget_ActivatableBase;UCLASS(Config = Game, defaultconfig, meta = (DisplayName = \"Frontend UI Settings\"))class FRONTENDUI_API UFrontendDeveloperSettings : public UDeveloperSettings{\tGENERATED_BODY()public:\tUPROPERTY(Config, EditAnywhere, Category = \"Widget Reference\", meta = (ForceInlineRow, Categories = \"Frontend.Widget\"))\tTMap&lt; FGameplayTag,TSoftClassPtr&lt;UWidget_ActivatableBase&gt; &gt; FrontendWidgetMap;};\tUCLASS Config = Game 이 클래스의 Config 지정자가 붙은 UPROPERTY들이 Game 카테고리의 설정 파일에 저장됨을 의미 일반적으로 DefaultGame.ini 파일에 저장 defaultconfig Config 지정자와 함께 사용되며, 이 클래스의 설정이 기본 설정 파일에 저장됨을 나타냅 만약 해당 .ini 파일이나 섹션이 존재하지 않으면, 클래스에 정의된 기본값으로 새로 생성 에디터에서 변경된 값은 이 기본 설정 파일에 다시 저장 UPROPERTY Config 이 프로퍼티의 값이 UCLASS에 지정된 Config 파일(여기서는 DefaultGame.ini)에 저장되고 로드됨을 의미 ForceInlineRow 이 메타 지정자는 주로 TMap이나 구조체(Struct)와 같은 복합적인 데이터 타입을 디테일 패널에 표시할 때 사용 TMap의 경우, 기본적으로 키(Key)와 값(Value)이 각각 다른 줄에 표시될 수 있음 ForceInlineRow를 true로 설정하면, 키와 값(또는 구조체의 여러 멤버)이 에디터의 디테일 패널에서 가로로 한 줄에 함께 표시되도록 강제 결과 프로젝트 세팅에 Frontend UI Settings가 추가됨 meta = (DisplayName = “Frontend UI Settings”)) DefaultGame.ini UPROPERTY의 Config 으로 인해 DefaultGame.ini에 자동으로 추가" }, { "title": "Common UI 비동기 로드", "url": "/posts/02.Common-UI-%EB%B9%84%EB%8F%99%EA%B8%B0-%EB%A1%9C%EB%93%9C/", "categories": "unreal, CommonUI", "tags": "unreal", "date": "2025-06-02 00:00:00 +0900", "snippet": "비동기 로드 UI가 복잡해지거나 로드할 에셋이 많을 때 발생할 수 있는 프레임 드랍 및 랙 현상을 줄이기 위해 비동기 로드 사용함수 : PushSoftWidgetToStackAsync GameSubsystem에서 호출하는 함수로, RequestAsyncLoad함수로 비동기 함수로 실행 비동기 로드할 클래스는 TSoftClassPtr로 사용 Lambda로 Parameter에 들어갈 함수를 만들고, EAsyncPushWidgetState를 이용해서 TFunction으로 전달된 AsyncPushStateCallback 함수가 만들기 전에 실행 or Push 후에 실행을 결정 enum class EAsyncPushWidgetState : uint8{\tOnCreatedBeforePush,\tAfterPush};void UFrontendUISubsystem::PushSoftWidgetToStackAsync(const FGameplayTag&amp; InWidgetStackTag, TSoftClassPtr&lt;UWidget_ActivatableBase&gt; InSoftWidgetClass,TFunction&lt;void(EAsyncPushWidgetState,UWidget_ActivatableBase*)&gt; AsyncPushStateCallback){\tcheck(!InSoftWidgetClass.IsNull());\tUAssetManager::Get().GetStreamableManager().RequestAsyncLoad(\t\tInSoftWidgetClass.ToSoftObjectPath(),\t\tFStreamableDelegate::CreateLambda(\t\t\t[InSoftWidgetClass,this,InWidgetStackTag,AsyncPushStateCallback]()\t\t\t{\t\t\t\tUClass* LoadedWidgetClass = InSoftWidgetClass.Get();\t\t\t\t\t\t\t\tcheck(LoadedWidgetClass &amp;&amp; CreatedPrimaryLayout); // GameplayTag로 Widget 찾기\t\t\t\tUCommonActivatableWidgetContainerBase* FoundWidgetStack = CreatedPrimaryLayout-&gt;FindWidgetStackByTag(InWidgetStackTag);\t\t\t\tUWidget_ActivatableBase* CreatedWidget = FoundWidgetStack-&gt;AddWidget&lt;UWidget_ActivatableBase&gt;(\t\t\t\t\tLoadedWidgetClass,\t\t\t\t\t[AsyncPushStateCallback](UWidget_ActivatableBase&amp; CreatedWidgetInstance)\t\t\t\t\t{\t\t\t\t\t\tAsyncPushStateCallback(EAsyncPushWidgetState::OnCreatedBeforePush,&amp;CreatedWidgetInstance);\t\t\t\t\t}\t\t\t\t);\t\t\t\tAsyncPushStateCallback(EAsyncPushWidgetState::AfterPush,CreatedWidget);\t\t\t}\t\t)\t);}사용 : PushSoftWidget Cached 변수는 저장되어 있는 함수와 매개변수 PushSoftWidgetToStackAsync 함수를 호출할 때 EAsyncPushWidgetState 변수를 switch에 넣어 언제 사용되는지를 결정 그 안에는 Delegate를 호출하여 함수 실행 // UAsyncAction_PushSoftWidget : public UBlueprintAsyncActionBasevoid UAsyncAction_PushSoftWidget::Activate(){\tUFrontendUISubsystem* FrontendUISubsystem = UFrontendUISubsystem::Get(CachedOwningWorld.Get());\tFrontendUISubsystem-&gt;PushSoftWidgetToStackAsync(CachedWidgetStackTag,CachedSoftWidgetClass,\t\t[this](EAsyncPushWidgetState InPushState, UWidget_ActivatableBase* PushedWidget)\t\t{\t\t\tswitch (InPushState)\t\t\t{\t\t\tcase EAsyncPushWidgetState::OnCreatedBeforePush:\t\t\t\t\t\t\t\tPushedWidget-&gt;SetOwningPlayer(CachedOwningPC.Get()); // Member Delegate\t\t\t\tOnWidgetCreatedBeforePush.Broadcast(PushedWidget);\t\t\t\tbreak;\t\t\tcase EAsyncPushWidgetState::AfterPush: // Member Delegate\t\t\t\tAfterPush.Broadcast(PushedWidget);\t\t\t\tif (bCachedFocusOnNewlyPushedWidget)\t\t\t\t{\t\t\t\t\tif (UWidget* WidgetToFocus = PushedWidget-&gt;GetDesiredFocusTarget())\t\t\t\t\t{\t\t\t\t\t\tWidgetToFocus-&gt;SetFocus();\t\t\t\t\t}\t\t\t\t}\t\t\t\tSetReadyToDestroy();\t\t\t\tbreak;\t\t\tdefault:\t\t\t\tbreak;\t\t\t}\t\t}\t);}실행1. 테스트용 WBP 생성2. 블루프린트에서 연결 후 SoftPush 실행3. 결과" }, { "title": "CommonUserWidget", "url": "/posts/01.CommonUserWidget/", "categories": "unreal, CommonUI", "tags": "unreal", "date": "2025-06-02 00:00:00 +0900", "snippet": "CommonUserWidget Common UI 위젯들의 가장 기본적인 부모 클래스 입력 처리를 위한 약간의 헬퍼 함수를 가지고 있고, 이 클래스를 상속받은 위젯은 위젯 스택에 직접 push될 수 없음 Widget Stack의 Container 역할인 Primary Layout Widget로 사용 CommonActivatableWidget CommonUserWidget의 자식 클래스 이 클래스를 상속받은 위젯은 위젯 스택에 push될 수 있으며, 활성화/비활성화(켜고 끄기)가 가능 MainMenu, OptionsMenu, PopUpWindow등에 사용 " }, { "title": "GameplayTag Param", "url": "/posts/Gameplay-Param/", "categories": "unreal, Unreal Etc", "tags": "unreal", "date": "2025-06-01 00:00:00 +0900", "snippet": " GameplayTag 매개변수에 UPARAM(meta = (Categories = \"\")) 를 이용하면 블루프린트에서 Categoriees에 해당하는 Tag의 하위 Tag만 뜨도록 설정 가능UFUNCTION(BlueprintCallable)void TestFunc(UPARAM(meta = (Categories = \"Shared.Attack\")) FGameplayTag FirstTag, UPARAM(meta = (Categories = \"Shared.Movement\")) FGameplayTag SecondTag); FirstTag는 Shared.Attack 에서 파생되는 하위 Tag만 접근이 가능하고 SecondTag는 Shared.Movement에서 파생되는 하위 Tag만 접근이 가능" }, { "title": "Widget Stack", "url": "/posts/Widget-Stack/", "categories": "unreal, CommonUI", "tags": "unreal", "date": "2025-06-01 00:00:00 +0900", "snippet": "Widget Stack Common UI에서는 UI 요소(위젯)들을 직접 생성하기보다 “스택”에 밀어 넣어(push) 관리 게임에서 일반적으로 4가지 형식의 스택을 사용 1. Modal Stack 각종 팝업창(예: 알림, 확인 창)을 위한 최상위 스택2. Game Menu Stack 인벤토리나 게임 내 메뉴(설정, 퀘스트 창 등)를 위한 스택3. Game HUD Stack 체력 바처럼 플레이어가 직접 상호작용하지 않는 화면 정보 표시용 스택4. Front end Stack Press Any Key 같은 초기 화면 UI를 위한 최하위 스택Widget Stack 순서의 중요성 상위 스택의 위젯은 하위 스택의 위젯을 비활성화하거나 덮을 수 있다. 우선순위 및 비활성화 기능은 UI 시스템을 효과적으로 만드는 데 핵심적인 역할 예시 1. 같은 스택 내 Modal Stack에서 팝업창2가 팝업창1보다 나중에 표시되면, 팝업창2가 팝업창1의 상호작용을 막을 수 있음예시 2. 다른 스택 간 Modal Stack에 있는 위젯은 Game Menu Stack이나 Front end Stack에 있는 위젯보다 우선권을 가짐스택 찾는 방법 : GameplayTag 여러 개의 스택 중 원하는 스택에 정확히 위젯을 추가하려면 각 스택을 식별할 방법이 필요하기 때문에 GameplayTag를 사용 각 위젯 스택에 고유한 게임플레이 태그를 ID처럼 할당 스택의 Gameplay Tag 예시 Modal Stack → Frontend.WidgetStack.Modal Game Menu Stack → Frontend.WidgetStack.GameMenu Game HUD Stack → Frontend.WidgetStack.HUD Front end Stack → Frontend.WidgetStack.Frontend" }, { "title": "Common UI", "url": "/posts/Common-UI/", "categories": "unreal, CommonUI", "tags": "unreal", "date": "2025-05-31 00:00:00 +0900", "snippet": "Common UI 게임의 메뉴, 버튼, 창 같은 사용자 인터페이스(UI)를 다양한 플랫폼(PC, 콘솔, 모바일 등)과 여러 입력 방식(키보드, 마우스, 게임패드, 터치)에서 일관되고 편리하게 만들 수 있도록 언리얼 엔진이 제공하는 고급 UI 개발 도구 세트Frontend 구조1단계 : 커스텀 플레이어 컨트롤러 모든 UI 표시는 직접 만든 플레이어 컨트롤러 클래스에서 시작 카메라 고정 : 플레이어 컨트롤러는 게임 레벨에 미리 배치된 특정 카메라를 찾아 화면을 그 카메라의 시점으로 고정 핵심 UI 레이아웃 생성 : 그 다음, “Primary Layout Widget” (주요 레이아웃 위젯)이라는 특별한 UI 요소를 생성 2단계 : 주요 레이아웃 위젯 (Primary Layout Widget) 이 위젯은 Common UI의 핵심 기능인 위젯 스택(Widget Stacks)을 등록하고 관리하는 중앙 허브 역할 Common UI에서는 UI 위젯(버튼, 창 등)을 직접 화면에 바로 생성하는 대신, 이 스택에 쌓아 올리거나(push) 제거하는(pop) 방식으로 관리 이 주요 레이아웃 위젯이 바로 그 스택들을 담는 컨테이너 3단계 : 프론트엔드 UI 서브시스템 (Frontend UI Subsystem) 블루프린트와 C++ 양쪽에서 쉽게 접근할 수 있는 전역 시스템 역할 레이아웃 위젯 저장: 앞에서 만든 “Primary Layout Widget”을 이 서브시스템에 저장 이렇게 하면 게임 내 어디서든 이 핵심 레이아웃 위젯에 쉽게 접근하고 사용 가능 헬퍼 함수(Helper Functions) 제공: 위젯 스택에 새로운 UI를 쉽게 추가(push)할 수 있도록 도와주는 여러 편의 기능(함수)들을 이 서브시스템 안에 생성4단계 : 첫 UI 화면 표시 UI 서브시스템 준비가 끝나면, 다시 플레이어 컨트롤러로 돌아와서 서브시스템의 헬퍼 함수를 사용해 첫 번째 UI 화면(예: \"Press Any Key\" 화면)을 위젯 스택에 추가(push) 이로써 사용자에게 첫 UI를 보여줌 사전 작업 먼저, Unreal Plugin에서 Common UI Plugin을 추가 그 다음에는 프로젝트 세팅에 들어가서 게임 뷰포트 클라이언트 클래스에서 CommonGameViewportClient로 변경 그리고 Custom GameMode에 Custom PlayerController를 설정하고 그 게임모드 사용" }, { "title": "AWS Lambda", "url": "/posts/AWS-Lambda/", "categories": "unreal, DedicatedServer", "tags": "unreal", "date": "2025-02-15 00:00:00 +0900", "snippet": "AWS Lambda Lambda는 사용자가 서버를 직접 관리할 필요 없이 코드를 실행할 수 있게 해주는 기능 AWS의 Console home에 Lambda에 들어가서 생성할 수 있다 특징 코드는 AWS가 관리하는 서버에서 필요할 때만 실행된다 특정 이벤트(자동 트리거 또는 수동 실행)에 반응하여 코드를 실행하도록 설계됨 게임 클라이언트는 직접 AWS API를 호출할 수 없지만, 보안 설정된 엔드포인트를 통해 Lambda 함수를 트리거하여 백엔드 작업을 수행하게 할 수 있음 코드가 실행되는 시간만큼만 비용이 청구되며, 유휴 상태일 때는 비용이 발생하지 않음. 또한, 동시에 많은 요청이 들어와도 자동으로 확장되어 모든 요청을 처리 여러 프로그래밍 언어를 지원(.Net,Java,Node.js,Python,Ruby) 문법 몇 개=&gt; 기존의 function 키워드를 사용하는 함수 표현식보다 훨씬 간결하게 함수를 정의할 수 있게 해줌// 기존 함수 표현식const add_old = function(a, b) { return a + b;};// 화살표 함수const add_new = (a, b) =&gt; { return a + b;};// 함수 본문이 한 줄이면 중괄호와 return 생략 가능const add_shorter = (a, b) =&gt; a + b;// 매개변수가 하나면 괄호도 생략 가능const square = x =&gt; x * x;비동기 관련 자바스크립트는 싱글 스레드 기반 언어지만, Node.js 환경에서는 시간이 걸리는 작업을 비동기로 처리해서 프로그램 전체가 멈추는 것을 방지 async와 await는 Promise를 기반으로, 비동기 코드를 마치 동기 코드처럼 작동하게 만듦 async 함수 선언/표현식 앞에 async를 붙이면, 해당 함수는 항상 Promise를 반환 함수 내에서 await 키워드를 사용할 수 있게 됨async function myAsyncFunction() { // 이 함수는 항상 Promise를 반환 return \"작업 완료!\";}myAsyncFunction().then(result =&gt; console.log(result)); // 작업 완료await async 함수 내에서만 사용할 수 있음 await 뒤에는 Promise가 와야 함 await은 해당 Promise가 완료될 때까지 함수의 실행을 일시 중지시키고 기다림 Promise가 성공적으로 이행(resolve)되면, 그 결과값을 반환 // 가짜로 1초 걸리는 작업 함수 (Promise 반환)function waitOneSecond(message) { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { console.log(message); resolve(); // 완료됨을 알림 }, 1000); // 1000ms });}// async/await 사용async function runTasks() { try { console.log(\"작업 시작\"); await waitOneSecond(\"첫 번째 작업 완료 (1초)\"); // 1초 기다림 await waitOneSecond(\"두 번째 작업 완료 (또 1초)\"); // 또 1초 기다림 console.log(\"모든 작업 끝\"); } catch (error) { // Promise가 reject되면 여기서 에러 처리 console.error(\"오류 발생:\", error); }}runTasks();/*출력 결과:작업 시작!(1초 후)첫 번째 작업 완료 (1초)(1초 후)두 번째 작업 완료 (또 1초)모든 작업 끝!*/var 자바 스크립트에서는 var를 주로 썼지만, var은 스코프 문제가 있음// var의 함수 스코프 문제 예시function checkVarScope() { if (true) { var message = \"Hello\"; // 블록 안에서 선언했지만... } console.log(message); // ...블록 밖에서도 접근 가능 \"Hello\" 출력}checkVarScope();// for 루프에서의 문제for (var i = 0; i &lt; 3; i++) { setTimeout(function() { console.log(\"var:\", i); // 루프가 끝난 후의 i 값(3)이 3번 출력됨 }, 100);} var은 함수 스코프(Function Scope) 를 가져서 함수 내부에서 선언되면 함수 전체에서 유효하고, 함수 외부에서 선언되면 전역 스코프를 가짐 그래서 let을 도입let let은 블록 스코프 변수(선언된 블록 내부에서만 유효) const와 달리 값 재할당 가능 재선언 금지(var은 가능)function checkLetScope() { if (true) { let message = \"Hello\"; // 이 블록 안에서만 유효 console.log(message); // \"Hello\" 출력 } // console.log(message); // ReferenceError: message is not defined (블록 밖 접근 불가)}checkLetScope();// for 루프에서의 개선for (let i = 0; i &lt; 3; i++) { // 각 반복마다 새로운 i 변수 스코프가 생성되는 것처럼 동작 setTimeout(function() { console.log(\"let:\", i); // 각 시점의 i 값(0, 1, 2)이 정상적으로 출력됨 }, 100);}" }, { "title": "Game Session && Player Session", "url": "/posts/Game-Session-&&-Player-Session/", "categories": "unreal, DedicatedServer", "tags": "unreal", "date": "2025-02-12 00:00:00 +0900", "snippet": "GameSession 특정 게임 서버 프로세스에서 실행되는 하나의 게임 플레이 인스턴스 새로운 게임 플레이(매치, 라운드 등)를 위한 환경을 제공 해당 게임 세션의 설정(맵 이름, 게임 모드, 최대 플레이어 수 등)과 상태(현재 플레이어 수, 세션 ID, 서버 IP/포트 등) 정보를 가짐 AWS CLIaws gamelift create-game-session ^ --fleet-id (플릿 ID) ^ --name (이름) ^ --maximum-player-session-count (최대 플레이어 수) ^ --location (지역) 링크에 있는 주소를 통해 추가하고 싶은 목록은 추가 가능 생성하고 나면 fleet의 GameSessions창을 통해 Active 상태가 된걸 확인할 수 있다 Player Session 특정 Game Session 내에서 **개별 플레이어를 위한 예약된 '슬롯' 또는 '연결 상태'를 나타냄 플레이어가 게임 서버에 성공적으로 연결되었는지 추적하고 관리하는 데 사용 플레이어별 데이터(예: 플레이어 ID, 팀 정보 등)를 가질 수 있음 AWS CLIaws gamelift create-player-session ^ --game-session-id (Game Session 아이디) ^ --player-id (사용할 플레이어 아이디) 링크에 있는 주소를 통해 추가하고 싶은 목록은 추가 가능 생성하고 나면 fleet의 GameSessions창을 통해 맨 뒤에 Player Session이 추가된 것을 확인할 수 있다 링크 Game Session https://docs.aws.amazon.com/cli/latest/reference/gamelift/create-game-session.html Player Session https://docs.aws.amazon.com/cli/latest/reference/gamelift/create-player-session.html " }, { "title": "Register && Get AuthToken && Run .exe", "url": "/posts/Register-&&-GetAuthToken-&&-Run/", "categories": "unreal, DedicatedServer", "tags": "unreal", "date": "2025-02-11 00:00:00 +0900", "snippet": "Register Fleet을 사용하기 위해선 이 컴퓨터를 등록해야 한다. compute name은 사용하고 싶은 이름을 넣으면 된다. fleet-id는 fleet에 들어가서 arn을 복사해서 붙여넣으면 된다. ip는 cmd의 ipconfig를 통해서 IPㅍ4 주소를 통해 알아낼 수 있다. location은 사용할 location 입력 AWS CLIaws gamelift register-compute \\ --compute-name (사용자 정의 이름) \\ --fleet-id (플릿 arn) \\ --ip-address (ip주소) \\ --location (지역)결과{ \"Compute\": { \"FleetId\": \"fleet-2222bbbb-33cc-44dd-55ee-6666ffff77aa\", \"FleetArn\": \"arn:aws:gamelift:us-west-2:111122223333:fleet/fleet-2222bbbb-33cc-44dd-55ee-6666ffff77aa\", \"ComputeName\": \"HardwareAnywhere\", \"ComputeArn\": \"arn:aws:gamelift:us-west-2:111122223333:compute/HardwareAnywhere\", \"IpAddress\": \"10.1.2.3\", \"ComputeStatus\": \"Active\", \"Location\": \"custom-location-1\", \"CreationTime\": \"2023-02-23T18:09:26.727000+00:00\", \"GameLiftServiceSdkEndpoint\": \"wss://us-west-2.api.amazongamelift.com\" }} GameLiftServiceSdkEndpoint는 어느 AWS region의 GameLift 서비스와 통신해야 하는지를 알려주는 구체적인 네트워크 주소(URL)GetAuthToken AuthToken(인증 토큰)은 안전하게 통신하기 위해 사용하는 만료 시간이 있는 임시 인증 키로, 특정 컴퓨팅 리소스가 특정 플릿에 속해있으며 GameLift 서비스와 통신할 권한이 있음을 증명한다 간단하게 인증번호라고 생각하면 될 것 같다. AWS CLIaws gamelift get-compute-auth-token \\ --fleet-id (플릿 arn) \\ --compute-name (이름)결과{ \"FleetId\": \"fleet-2222bbbb-33cc-44dd-55ee-6666ffff77aa\", \"FleetArn\": \"arn:aws:gamelift:us-east-1:111122223333:fleet/fleet-2222bbbb-33cc-44dd-55ee-6666ffff77aa\", \"ComputeName\": \"HardwareAnywhere\", \"ComputeArn\": \"arn:aws:gamelift:us-east-1:111122223333:compute/HardwareAnywhere\", \"AuthToken\": \"0c728041-3e84-4aaa-b927-a0fb202684c0\", \"ExpirationTimestamp\": \"2023-02-23T18:47:54+00:00\"} \"AuthToken\" 뒤에 있는 식별자를 통해서 이제 접속이 가능하다.Run .exeAWS CLI\"Path\\YourGameProject.exe\" ^ -log ^ -authtoken= (위에서 얻은 Authtoken) ^ -hostid=(이름) -fleetid=(플릿 아이디) ^ -websocketurl= (GameLiftServiceSdkEndpoint)^ -port= (사용하고 싶은 포트 번호) Path은 언리얼 프로젝트를 (Server 버전)package하고 나온 폴더 경로를 넣고 뒤에 실행파일 이름을 넣어주면 된다 authtoken은 GetAuthToken하고 나온 AuthToken을 넣어주면 된다 hostid는 register할 때 넣은 compute name를 적고 fleetid는 생성한 Fleet의 id를 넣어주면 된다 websocketurl은 register에서 나온 GameLiftServiceSdkEndpoint를 넣어주면 된다 port는 사용하고 싶은 포트번호 사용(1024 ~ 49151) 링크 Register Compute https://docs.aws.amazon.com/ko_kr/gamelift/latest/developerguide/fleets-creating-anywhere.html#fleet-anywhere-compute https://docs.aws.amazon.com/cli/latest/reference/gamelift/register-compute.html " }, { "title": "Anywhere Fleet", "url": "/posts/Anywhere-Fleet/", "categories": "unreal, DedicatedServer", "tags": "unreal", "date": "2025-02-10 00:00:00 +0900", "snippet": "Anywhere fleet AWS의 Amazon GameLift Servers 에 들어가서 Anywhere 하위 목록에 Fleet에 들어가서 Fleet을 생성할 수 있다. 들어가면 여러 가지가 있는데 Name,Custom Location 설정만 해주면 (나머지는 패스) Fleet을 생성할 수 있다. 링크 https://docs.aws.amazon.com/ko_kr/gamelift/latest/developerguide/fleets-creating-anywhere.html#fleet-anywhere-create" }, { "title": "Custom Location", "url": "/posts/Custom-Location/", "categories": "unreal, DedicatedServer", "tags": "unreal", "date": "2025-02-08 00:00:00 +0900", "snippet": "Custom Location Anywhere Fleet을 생성하기 전에 Custom Location(사용자 지정 위치)를 지정해줘야 Anywhere Fleet을 생성이 가능하다 먼저, AWS의 Console Home에 가서 Amazon GameLift Server를 검색해서 들어간다. 그다음 왼쪽의 목록에서 Anywhere Fleet을 만드는 과정이니 Anywhere 하위 목록의 위치에 들어간다. 그러고 나면 기본적으로 우상단에 있는 위치가 시스템 정의로 정의되어 있는데 그 밑에 있는 위치 생성(Create Location) 버튼으로 생성이 가능하다. 삭제도 생성 버튼옆에 있어 지울 Location을 선택하고 삭제가 가능 AWS CLI생성 밑에 링크에 들어가면 AWS CLI 버전으로 다음과 같이 Command line으로도 Custom Location을 생성할 수 있다AWS CLIaws gamelift create-location \\ --location-name custom-location-1 --profile UserName 그러면 다음과 같이 출력된다 LocationArn은 리소스의 고유 식별자로 생각하면 된다 { \"Location\": { \"LocationName\": \"custom-location-1\", \"LocationArn\": \"arn:aws:gamelift:us-east-1:111122223333:location/custom-location-1\" }}삭제 삭제 명령어는 아래와 같이 LocationArn을 이용해서 삭제한다. Amazon GameLift Server의 Anywhere Fleet 하위 목록인 위치에 들어가서 LocationArn을 확인할 수도 있다. AWS CLIaws gamelift delete-location --location-arn &lt;value&gt;링크 https://docs.aws.amazon.com/ko_kr/gamelift/latest/developerguide/fleets-creating-anywhere.html#fleet-anywhere-location" }, { "title": "Fleet", "url": "/posts/Fleet/", "categories": "unreal, DedicatedServer", "tags": "unreal", "date": "2025-02-06 00:00:00 +0900", "snippet": "Fleet Fleet은 게임 서버 호스팅에 사용되는 컴퓨팅 리소스 그룹을 의미한다 종류로는 EC2와 Anywhere이 있다 EC2 EC2란 Amazon Elastic Compute Cloud의 약자로, AWS 클라우드에서 제공하는 가상 서버라고 생각하면 된다 그러면 EC2 Fleet은 AWS가 관리하는 EC2 인스턴스 상에 게임 서버를 배포하고 호스팅하는 방식을 의미한다. Anywhere 고객이 직접 관리하는 온프레미스 서버 또는 다른 클라우드 환경의 컴퓨팅 리소스를 GameLift 시스템에 통합하여 게임 서버로 활용하는 방식 온프레미스란, 회사 건물 안에 회사가 산 컴퓨터(서버)를 두고 직접 관리하며 사용하는 것을 의미한다. 차이 Anywhere fleet”와 “EC2 fleet”의 가장 핵심적인 차이는 관리 대상 리소스가 위치하는 곳과 관리 주체에 있다." }, { "title": "AWS Configure", "url": "/posts/AWS-Configure/", "categories": "unreal, DedicatedServer", "tags": "unreal", "date": "2025-02-05 00:00:00 +0900", "snippet": "AWS CLI AWS를 사용하기 위해선 구성(Configure)을 해야하는데 그전에 AWS CLI(Command Line)을 설치 해야한다 맨 아래 링크 AWS CLI를 보고 다운 AWS Configure1번 AWS CLI를 설치 했으면 프로그램 실행창에서 cmd를 열고 이 부분을 실행해야 한다. AWS access portal에 간 후, AWS accounts에서 Access Keys를 누르고 사용할 플랫폼을 누르면 SSO start URL과 SSO region이 나온다. AWS CLI$ aws configure ssoSSO session name (Recommended): 이름SSO start URL [None]: https://my-sso-portal.awsapps.com/startSSO region [None]: us-east-1SSO registration scopes [None]: sso:account:access2번 위 과정을 마치면 특정 코드를 알려주는 사이트가 나오는데 그 코드를 cmd에 넣어주면 다음과 같이 입력하는 칸이 나온다. CLI client default region 사용할 지역 넣기 (ex: us-east-2) CLI client output format json CLI profile name 이름 3번 위 과정을 마치면 C드라이브에서 .aws/sso/cache에 들어가면 프로필이 저장되어 있는 메모장이 있다.aws sso login –profile 이제 cmd를 열고 aws sso login --profile [입력한 profile name] AWS에 로그인이 가능해진다.링크 AWS CLI https://docs.aws.amazon.com/ko_kr/cli/latest/userguide/getting-started-install.html AWS Configure https://docs.aws.amazon.com/ko_kr/cli/latest/userguide/cli-configure-sso.html#sso-configure-profile-token-auto-sso " }, { "title": "Intergrating GameLift", "url": "/posts/Intergrating-GameLift/", "categories": "unreal, DedicatedServer", "tags": "unreal", "date": "2025-02-04 00:00:00 +0900", "snippet": "GameLift GameLift는 AWS(Amazon Web Services)에서 제공하는 게임 서버 호스팅 서비스이다.Intergration https://docs.aws.amazon.com/gamelift/latest/developerguide/integration-engines-setup-unreal.html 위는 공식 문서로, Intergrate하는 방법이 담겨져 있는데 밑에 순서대로 하자면 다음과 같다. 1. 선행 조건 먼저 통합되기 위해서는 다음과 같은 조건을 만족해야 한다. Target.Type == TargetRules.TargetType.Server 게임 프로젝트는 서버 SDK for Amazon GameLift Servers binary를 인식 2. FProcessParameters 선언 AWS에서 게임 서버 프로세스를 초기화할 때 사용하는 구조체 게임 서버의 라이프사이클(예: 게임 세션 시작, 업데이트, 종료 등) 동안 발생하는 이벤트에 대해 개발자가 정의한 콜백 함수들을 지정하는 역할 3. GameLift 초기화 FServerParameters 구조체로 서버에 필요한 정보를 설정void AShooterGameMode::SetServerParameters(FServerParameters&amp; OutServerParameters){ \tUE_LOG(LogShooterGameMode, Log, TEXT(\"Initializing the GameLift Server\")); \t // SDK 모듈 불러오기 \tFGameLiftServerSDKModule* GameLiftSdkModule = &amp;FModuleManager::LoadModuleChecked&lt;FGameLiftServerSDKModule&gt;(FName(\"GameLiftServerSDK\")); \tFServerParameters ServerParameters; // AuthToken(인증 토큰) 을 멤버 값에 설정 \tif (FParse::Value(FCommandLine::Get(), TEXT(\"-authtoken=\"), ServerParameters.m_authToken)) \t{ \t\tUE_LOG(LogShooterGameMode, Log, TEXT(\"AUTH_TOKEN: %s\"), *ServerParameters.m_authToken) \t} // 인스턴스의 호스트 ID를 설정 \tif (FParse::Value(FCommandLine::Get(), TEXT(\"-hostid=\"), ServerParameters.m_hostId)) \t{ \t\tUE_LOG(LogShooterGameMode, Log, TEXT(\"HOST_ID: %s\"), *ServerParameters.m_hostId) \t} // 플리 ID를 설정 // 플릿 ID는 해당 게임 서버가 속하는 GameLift Anywhere Fleet의 고유 식별자 \tif (FParse::Value(FCommandLine::Get(), TEXT(\"-fleetid=\"), ServerParameters.m_fleetId)) \t{ \t\tUE_LOG(LogShooterGameMode, Log, TEXT(\"FLEET_ID: %s\"), *ServerParameters.m_fleetId) \t} // GameLift 서비스와의 통신에 사용되는 WebSocket 엔드포인트 설정 \tif (FParse::Value(FCommandLine::Get(), TEXT(\"-websocketurl=\"), ServerParameters.m_webSocketUrl)) \t{ \t\tUE_LOG(LogShooterGameMode, Log, TEXT(\"WEBSOCKET_URL: %s\"), *ServerParameters.m_webSocketUrl) \t}}4. GameLift 서버를 초기화 및 콜백 함수 설정void AShooterGameMode::InitGameLift(){ UE_LOG(LogShooterGameMode, Log, TEXT(\"Initializing the GameLift Server\")); FGameLiftServerSDKModule* GameLiftSdkModule = &amp;FModuleManager::LoadModuleChecked&lt;FGameLiftServerSDKModule&gt;(FName(\"GameLiftServerSDK\")); // GameLift Anywhere Fleet을 위한 서버 파라미터들을 정의 FServerParameters ServerParameters; SetServerParameters(ServerParameters); // GameLift SDK 초기화를 수행 GameLiftSdkModule-&gt;InitSDK(ServerParameters); // GameLift가 새 게임 세션을 시작할 때 호출 auto onGameSession = [=](Aws::GameLift::Server::Model::GameSession gameSession) { FString gameSessionId = FString(gameSession.GetGameSessionId()); UE_LOG(LogShooterGameMode, Log, TEXT(\"GameSession Initializing: %s\"), *gameSessionId); // 게임 세션을 활성화 GameLiftSdkModule-&gt;ActivateGameSession(); }; ProcessParameters.OnStartGameSession.BindLambda(onGameSession); // GameLift가 서버 종료를 요청할 때 호출 auto onProcessTerminate = [=]() { UE_LOG(LogShooterGameMode, Log, TEXT(\"Game Server Process is terminating\")); // SDK에 프로세스 종료를 알림 GameLiftSdkModule-&gt;ProcessEnding(); }; // ProcessParameters의 OnTerminate 콜백에 위 람다 함수를 바인딩합니다. ProcessParameters.OnTerminate.BindLambda(onProcessTerminate); // 주기적으로 호출되어 서버가 정상 상태인지 확인 auto onHealthCheck = []() { UE_LOG(LogShooterGameMode, Log, TEXT(\"Performing Health Check\")); return true; }; // ProcessParameters의 OnHealthCheck 콜백에 위 람다 함수를 바인딩합니다. ProcessParameters.OnHealthCheck.BindLambda(onHealthCheck); int32 Port = FURL::UrlConfig.DefaultPort; ParseCommandLinePort(Port); ProcessParameters.port = Port; TArray&lt;FString&gt; LogFiles; LogFiles.Add(TEXT(\"FPSTemplate/Saved/Logs/FPSTemplate.log\")); ProcessParameters.logParameters = LogFiles; UE_LOG(LogShooterGameMode, Log, TEXT(\"Calling Process Ready\")); // ProcessParameters에 설정된 콜백 함수 및 파라미터들이 SDK에 전달 GameLiftSdkModule-&gt;ProcessReady(ProcessParameters);}" }, { "title": "Identity Center vs IAM", "url": "/posts/Identity-Center-vs-IAM/", "categories": "unreal, DedicatedServer", "tags": "unreal", "date": "2025-02-03 00:00:00 +0900", "snippet": "IAM(Identity and Access Management) 개념 AWS 계정(루트 계정 아래)의 사용자, 그룹, 역할을 생성하고 관리하며, 각 엔티티(사용자, 역할 등)에게 AWS 서비스나 리소스에 대한 접근 권한을 부여하기 위한 서비스 EC2, S3, RDS 등의 자원에 접근하기 위한 사용자/권한을 생성하고 관리 IAM 특징 Own credentials IAM 사용자는 각 AWS 계정 내에서 생성되며, 각 사용자마다 고유한 사용자 이름, 암호, 액세스 키 등이 발급된다 사용자가 AWS 콘솔에 로그인하거나 API를 호출할 때, 해당 사용자에게 발급된 자격 증명을 사용합니다. 즉, 각 사용자가 자신만의 로그인 정보(자격 증명)를 가지고 있어 개별적으로 관리된다. Assigned unique permissions (개별 권한 할당) 각 IAM 사용자마다 구체적인 IAM 정책(policy)을 통해 필요한 권한을 개별적으로 설정할 수 있다. Identity Center AWS Organizations와 연계하여 여러 AWS 계정(서브 계정)들을 단일한 인증 창구를 통해 통합적으로 로그인 및 권한 관리할 수 있음 여러 계정을 사용하는 대기업, 조직에서 효율적 Identity Center 특징 Centrally managed Identity Center 사용자는 조직 전체(여러 AWS 계정 포함)에서 중앙에서 관리 조직 내 모든 AWS 계정에 대해 한 곳에서 사용자 계정을 생성, 업데이트, 삭제하거나 권한을 관리할 수 있다. Single set of credentials (단일 자격 증명) 사용자는 하나의 자격 증명을 통해 여러 AWS 계정에 로그인할 수 있다 한 번 로그인하면 여러 계정 및 역할에 대한 접근이 가능하므로, 사용자 입장에서 여러 계정마다 별도의 자격 증명을 기억하거나 관리할 필요가 없다. Access multiple AWS accounts (여러 AWS 계정 접근) Identity Center는 AWS Organizations와 연동되어, 사용자에게 조직 내 여러 AWS 계정에서의 접근을 손쉽게 설정할 수 있게 한다 대규모 조직이나 멀티 계정 환경에서, 각 계정에 대해 개별 사용자 생성 없이 중앙에서 관리된 인증 정보와 역할 할당을 통해 여러 계정을 한꺼번에 접근할 수 있다. 둘의 차이점 Management Scope (관리 범위) IAM은 특정 AWS 계정 내에서 사용자, 그룹, 역할을 생성 및 관리하지만, Identity Center는 AWS Organizations와 연계하여, 여러 AWS 계정을 포괄하는 중앙 집중식 사용자 및 권한 관리 시스템을 제공 Federation (연합/페더레이션) IAM 사용자들은 AWS 계정 내에서 직접 생성되며, 자체 자격 증명을 사용하지만, Identity Center는 사용자가 외부 IdP의 자격 증명을 사용하여 AWS 리소스에 접근할 수 있도록 구성할 수 있다. Single Sign-On (SSO, 단일 로그인) IAM 사용자는 자신의 별도 자격 증명으로 AWS 계정에 로그인하지만, Identity Center 사용자는 한 번의 로그인으로 조직 내 연결된 모든 AWS 계정과 애플리케이션에 접근할 수 있다. " }, { "title": "Dedicated Server 세팅", "url": "/posts/Dedicated-Server-%EC%84%B8%ED%8C%85/", "categories": "unreal, DedicatedServer", "tags": "unreal", "date": "2025-02-01 00:00:00 +0900", "snippet": "1. 언리얼 소스 코드 다운로드 먼저 언리얼 깃허브 사이트에 들어가서 원하는 빌드 버전의 소스 코드를 다운 받은 다음에 Setup.bat, GenerateProjectFiles.bat을 순서대로 실행해야 Visual studio 파일이 생긴다2. Server build Target 언리얼에서 클라이언트가 아닌 서버에서 사용할 코드만을 컴파일하기 위해선 Server Build Target을 사용해야 한다. 여기서 build 파일은 언리얼 엔진 프로젝트에서 프로젝트의 컴파일, 빌드, 패키징, 배포와 관련된 설정을 관리하는 파일이다. 언리얼 C++ 파일을 생성하고 나면 기본적으로 아래와 같이 클라이언트용 build 파일이 생긴다. // FPSTemplate은 프로젝트 이름(예시)using UnrealBuildTool;using System.Collections.Generic;public class FPSTemplateTarget : TargetRules{\tpublic FPSTemplateTarget(TargetInfo Target) : base(Target)\t{\t\tType = TargetType.Game;\t\tDefaultBuildSettings = BuildSettingsVersion.V5;\t\tIncludeOrderVersion = EngineIncludeOrderVersion.Unreal5_4;\t\tExtraModuleNames.Add(\"FPSTemplate\"); }} 그런데 서버 버전을 사용하기 위해선 다음과 같이 기본 빌드 파일의 프로젝트이름 뒤에 Server를 붙이고 Type도 Server로 바꿔줘야 한다.using UnrealBuildTool;using System.Collections.Generic;public class FPSTemplateServerTarget : TargetRules{ public FPSTemplateServerTarget(TargetInfo Target) : base(Target) { Type = TargetType.Server; DefaultBuildSettings = BuildSettingsVersion.V5; IncludeOrderVersion = EngineIncludeOrderVersion.Unreal5_4; }} 그리고 visual stuido 기준으론 왼쪽 위에, Rider 기준으론 오른쪽 위에 solution configuration을 Development Server로 변환해준 다음에 프로젝트를 build 해주면 된다. build 하기전에 Binaries 파일과 Intermediate 파일을 지운 다음 .uproject파일에서 Generate Visual stuido project files를 해줘야 visual studio가 새로운 설정을 인식할 수 있다. " }, { "title": "3장 스레드 간 데이터 공유", "url": "/posts/3%EC%9E%A5-%EC%8A%A4%EB%A0%88%EB%93%9C-%EA%B0%84-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B3%B5%EC%9C%A0/", "categories": "Concurrency", "tags": "concurrency", "date": "2024-09-15 00:00:00 +0900", "snippet": "3.1 스레드 간 데이터 공유 시 문제점 (Problems with sharing data between threads) 여러 스레드가 데이터를 공유할 때, 특히 하나 이상의 스레드가 데이터를 수정하는 경우 문제가 발생할 수 있음. 읽기 전용 데이터는 문제가 없지만, 수정이 가해지면 데이터의 일관성을 유지하기 위한 세심한 주의가 필요함 데이터 구조에는 항상 참이어야 하는 불변성(invariants)이라는 개념이 있음. 예를 들어, 이중 연결 리스트에서 한 노드의 ‘다음’ 포인터가 가리키는 노드의 ‘이전’ 포인터는 원래 노드를 가리켜야 함. 데이터 업데이트 중에는 이러한 불변성이 일시적으로 깨질 수 있으며, 이 상태를 다른 스레드가 보게 되면 문제가 발생 경쟁 조건 (Race conditions) 둘 이상의 스레드에서 수행되는 연산의 상대적인 순서에 따라 결과가 달라지는 모든 상황을 의미. 대부분의 경우 모든 가능한 결과가 수용 가능하면 양성이지만, 불변성이 깨지는 경쟁 조건은 문제가 됨. C++ 표준에서는 데이터 경쟁(data race)을 단일 객체에 대한 동시 수정으로 인해 발생하는 특정 유형의 경쟁 조건으로 정의하며, 이는 정의되지 않은 동작(undefined behavior)을 유발. 문제가 되는 경쟁 조건은 일반적으로 둘 이상의 개별 데이터 조각을 수정해야 하는 작업에서 발생함. 이러한 작업은 별도의 명령으로 수행되므로, 한 명령만 완료된 중간 상태를 다른 스레드가 접근할 수 있음. 경쟁 조건은 일반적으로 타이밍에 민감하여 찾기 어렵고 재현하기 어려움. 디버거를 사용하면 타이밍이 변경되어 문제가 사라지는 경우도 있음 문제가 되는 경쟁 조건을 피하는 방법 데이터를 보호하는 가장 기본적인 도구는 뮤텍스(mutex)보호 메커니즘 사용 데이터를 고치는 스레드만 중간 과정을 볼 수 있도록 데이터 주변을 보호 다른 스레드는 작업이 시작되기 전이나 완전히 끝난 후의 모습만 볼 수 있음 C++에는 이런 보호 장치가 있음데이터 구조 설계 변경 데이터를 고치는 작업 자체가 마치 한 번에 일어나는 것처럼, 그리고 그 과정 중에도 데이터 규칙이 항상 지켜지도록 데이터 구조를 처음부터 다시 설계하는 것트랜잭션 처리 은행에서 돈을 보내는 것처럼, 데이터 변경 작업을 하나의 묶음(트랜잭션)으로 만들어서 한 번에 처리3.2 뮤텍스로 공유 데이터 보호하기 (Protecting shared data with mutexes) 뮤텍스(상호 배제, mutual exclusion)는 공유 데이터에 접근하기 전에 잠그고, 접근이 끝나면 잠금 해제하는 동기화 기본 요소 한 스레드가 특정 뮤텍스를 잠그면, 동일한 뮤텍스를 잠그려는 다른 모든 스레드는 첫 번째 스레드가 뮤텍스를 해제할 때까지 기다려야 함. 이를 통해 모든 스레드가 공유 데이터의 일관된 뷰를 볼 수 있도록 보장 3.2.1 C++에서 뮤텍스 사용하기 (Using mutexes in C++) C++에서는 std::mutex의 인스턴스를 생성하여 뮤텍스를 만들고, lock() 멤버 함수로 잠그고, unlock() 멤버 함수로 잠금 해제함. 그러나 멤버 함수를 직접 호출하는 것은 권장되지 않음. 모든 코드 경로에서 unlock()을 호출해야 하는 것을 기억해야 하기 때문임 (예외 포함). 대신 C++ 표준 라이브러리는 RAII(Resource Acquisition Is Initialization) 관용구를 구현하는 std::lock_guard 클래스 템플릿을 제공함. std::lock_guard는 생성 시 제공된 뮤텍스를 잠그고 소멸 시 잠금 해제하여, 잠긴 뮤텍스가 항상 올바르게 해제되도록 보장코드 예제: 뮤텍스로 리스트 보호하기#include &lt;list&gt;#include &lt;mutex&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;std::list&lt;int&gt; some_list; // [cite: 1] 보호할 공유 데이터std::mutex some_mutex; // [cite: 1] 해당 데이터를 보호하는 뮤텍스void add_to_list(int new_value) { std::lock_guard&lt;std::mutex&gt; guard(some_mutex); // [cite: 1] 뮤텍스를 잠금 (범위를 벗어나면 자동 해제) some_list.push_back(new_value); std::cout &lt;&lt; new_value &lt;&lt; \" added to list.\" &lt;&lt; std::endl;}bool list_contains(int value_to_find) { std::lock_guard&lt;std::mutex&gt; guard(some_mutex); // [cite: 1] 뮤텍스를 잠금 return std::find(some_list.begin(), some_list.end(), value_to_find) != some_list.end();}// int main() {// std::thread t1(add_to_list, 42);// std::thread t2(add_to_list, 100);// std::thread t3([]{// if (list_contains(42)) {// std::cout &lt;&lt; \"List contains 42.\" &lt;&lt; std::endl;// } else {// std::cout &lt;&lt; \"List does not contain 42.\" &lt;&lt; std::endl;// }// });// t1.join();// t2.join();// t3.join();// return 0;// } 일반적으로 전역 변수 대신 클래스 내에 뮤텍스와 보호 데이터를 그룹화하는 것이 좋음. 이는 객체 지향 설계 원칙에 부합하며, 캡슐화를 통해 기능을 명확히 하고 보호를 강제할 수 있음. 그러나 멤버 함수가 보호된 데이터에 대한 포인터나 참조를 반환하면, 해당 포인터나 참조를 통해 뮤텍스 잠금 없이 데이터에 접근할 수 있게 되어 보호가 무력화될 수 있음3.2.2 공유 데이터 보호를 위한 코드 구조화 (Structuring code for protecting shared data) 뮤텍스로 데이터를 보호하는 것은 단순히 모든 멤버 함수에 std::lock_guard를 추가하는 것만으로는 충분하지 않음. 보호된 데이터에 대한 포인터나 참조가 외부로 유출되지 않도록 주의해야 함. 멤버 함수가 호출자에게 포인터나 참조를 반환하거나, 제어할 수 없는 외부 함수에 인수로 전달하지 않도록 해야 함.코드 예제: 보호된 데이터에 대한 참조를 실수로 유출하는 경우 process_data 멤버 함수가 사용자 제공 함수 func를 호출하면서 보호된 데이터 data에 대한 참조를 전달함 악의적인 함수(malicious_function)가 이 참조를 외부로 유출하여 뮤텍스 보호 없이 데이터에 접근할 수 있게 되는 상황을 보여줌class some_data { /* ... */ };class data_wrapper {private: some_data data; std::mutex m;public: template&lt;typename Function&gt; void process_data(Function func) { std::lock_guard&lt;std::mutex&gt; l(m); func(data); // [cite: 1] 보호된 data를 사용자 제공 함수 func에 전달 }};some_data* unprotected_ptr; // 유출된 포인터를 저장할 전역 변수 void malicious_function(some_data&amp; protected_data) { unprotected_ptr = &amp;protected_data; // [cite: 1] 보호된 데이터의 주소를 외부로 유출}data_wrapper x;void foo() { x.process_data(malicious_function); // [cite: 1] 악의적인 함수 전달 // 이제 unprotected_ptr를 통해 뮤텍스 잠금 없이 data에 접근 가능 // unprotected_ptr-&gt;do_something(); // [cite: 1] 보호되지 않은 접근} 잠금 범위 밖으로 보호된 데이터에 대한 포인터나 참조를 전달하지 말 것3.2.3 인터페이스에 내재된 경쟁 조건 발견하기 (Spotting race conditions inherent in interfaces) 뮤텍스를 사용하더라도 적절한 데이터를 보호하지 않으면 경쟁 조건이 발생할 수 있음. 예를 들어 이중 연결 리스트에서 노드를 삭제할 때, 삭제되는 노드와 양옆 노드 세 개 모두에 대한 동시 접근을 막아야 함. 개별 노드의 포인터만 개별적으로 보호하면 경쟁 조건은 여전히 발생할 수 있음. 전체 리스트를 보호하는 단일 뮤텍스가 가장 간단한 해결책 std::stack과 같이 단순한 인터페이스에서도 경쟁 조건이 발생할 수 있음. empty()와 size()의 결과는 호출 시점에는 정확할 수 있지만, 반환 후 다른 스레드가 스택을 수정할 수 있어 신뢰할 수 없음. 특히, empty() 호출과 top() 호출 사이에 다른 스레드가 마지막 요소를 pop()하면, top() 호출은 정의되지 않은 동작을 유발하는 경쟁 조건이 발생함 (빈 스택에서 top() 호출) 코드 예제: 스택에서의 경쟁 조건// (단일 스레드에서는 안전한 코드)std::stack&lt;int&gt; s;if (!s.empty()) { // [cite: 1] 1. empty() 호출 int const value = s.top(); // [cite: 1] 2. top() 호출 - 이 사이에 다른 스레드가 pop() 할 수 있음 s.pop(); // [cite: 1] 3. pop() 호출 - 이 사이에 다른 스레드가 top()을 다시 호출할 수 있음 // do_something(value);}문제점 공유 스택 객체에서 위 코드는 안전하지 않음. 한 스레드가 empty() 호출 후 true를 반환받았더라도, top() 호출 직전에 다른 스레드가 마지막 요소를 pop()할 수 있음. 이는 top() 호출 시 빈 스택에 접근하게 되어 정의되지 않은 동작을 유발함. 또 다른 경쟁 조건 top() 호출과 pop() 호출 사이에도 경쟁 조건이 존재함. 두 스레드가 동시에 이 코드를 실행하면, 한 스택의 값이 두 번 처리되거나, 한 값은 처리되지 않고 버려질 수 있음.해결책 : 인터페이스 변경이 필요 top()이 예외를 던지도록 함 빈 스택에서 호출될 경우. 하지만 이는 프로그래밍을 번거롭게 만듦. top()과 pop() 결합: 하나의 연산으로 만들어 뮤텍스 보호 하에 실행되도록 함. 주의점 (Cargill의 문제점): pop()이 값을 반환하도록 정의되면, 값을 복사하는 과정에서 예외(예: std::bad_alloc)가 발생할 경우 스택에서 이미 제거된 값은 손실될 수 있음. std::stack은 이를 피하기 위해 top()과 pop()을 분리함. 결합된 pop() 연산의 예외 안전성 문제 해결 옵션1. 참조 전달 pop() 함수에 값을 받을 변수에 대한 참조를 인수로 전달함. 예: some_stack.pop(result); 단점: 호출 코드가 미리 해당 타입의 인스턴스를 생성해야 하고, 할당 불가능한 타입을 저장할 수 없음.2.예외를 던지지 않는 복사/이동 생성자 요구 예외를 던지지 않고 안전하게 값을 반환할 수 있는 타입으로 사용을 제한함. std::is_nothrow_copy_constructible 등으로 컴파일 타임에 확인 가능. 단점: 매우 제한적임.3.pop된 항목에 대한 포인터 반환 std::shared_ptr 등을 사용하여 메모리 관리를 하면서 포인터를 반환함. 장점: 포인터 복사는 예외를 던지지 않음. 단점: 단순 타입의 경우 메모리 관리 오버헤드가 클 수 있음.4. 옵션 1과 옵션 2 또는 3을 모두 제공 사용자에게 선택권을 제공코드 예제: 경쟁 조건 없는 스레드 안전 스택 인터페이스 (옵션 1과 3 구현)// 스레드 안전한 스택(thread-safe stack)을 구현한 C++ 코드#include &lt;exception&gt;#include &lt;memory&gt;// 스택이 비었을 때 발생하는 예외 정의struct empty_stack: std::exception{ const char* what() const throw(); // 예외 메시지 반환 (구현은 별도)};// 템플릿 기반 스레드 안전 스택 클래스template&lt;typename T&gt;class threadsafe_stack{public: threadsafe_stack(); // 기본 생성자 threadsafe_stack(const threadsafe_stack&amp;); // 복사 생성자 threadsafe_stack&amp; operator=(const threadsafe_stack&amp;) = delete; // 대입 연산자 (삭제) void push(T new_value); // 스택에 원소 추가 std::shared_ptr&lt;T&gt; pop(); // 스택에서 원소 제거 및 반환 (shared_ptr 사용) void pop(T&amp; value); // 스택에서 원소 제거 및 참조로 값 전달 bool empty() const; // 스택이 비었는지 확인};코드 예제: 스레드 안전 스택의 구체적인 구현// 스레드 안전한 스택(thread-safe stack)의 전체 구현 C++ 코드#include &lt;exception&gt;#include &lt;memory&gt;#include &lt;mutex&gt;#include &lt;stack&gt;// 스택이 비어있을 때 발생하는 사용자 정의 예외 구조체struct empty_stack: std::exception{    const char* what() const throw();};// 템플릿을 사용하여 모든 데이터 타입을 지원하는 스레드 안전 스택 클래스template&lt;typename T&gt;class threadsafe_stack{private: std::stack&lt;T&gt; data; // 실제 데이터를 저장하는 내부 스택 객체    mutable std::mutex m; // 데이터 접근을 동기화하기 위한 뮤텍스 객체. (const 멤버 함수에서도 lock 가능하도록 mutable 키워드 사용)public:    threadsafe_stack(){} // 기본 생성자 // 복사 생성자. 다른 스택의 뮤텍스를 잠그고 데이터를 복사    threadsafe_stack(const threadsafe_stack&amp; other)    { std::lock_guard&lt;std::mutex&gt; lock(other.m); // 다른 객체의 뮤텍스를 잠금 (RAII 방식으로 자동 해제)        data = other.data;    } // 대입 연산자는 삭제되어 복사를 방지. (스레드 안전성을 위해)    threadsafe_stack&amp; operator=(const threadsafe_stack&amp;) = delete;    void push(T new_value)    { std::lock_guard&lt;std::mutex&gt; lock(m); // 현재 객체의 뮤텍스를 잠금 data.push(new_value);    }    std::shared_ptr&lt;T&gt; pop()    { std::lock_guard&lt;std::mutex&gt; lock(m); // 현재 객체의 뮤텍스를 잠금        if(data.empty()) throw empty_stack(); // 스택이 비어있으면 empty_stack 예외를 던짐 // 스택의 최상단 원소로 std::shared_ptr을 생성하여 복사(예외 안전성) std::shared_ptr&lt;T&gt; const res(std::make_shared&lt;T&gt;(data.top()));        data.pop(); return res;    }    void pop(T&amp; value)    { std::lock_guard&lt;std::mutex&gt; lock(m); // 현재 객체의 뮤텍스를 잠금        if(data.empty()) throw empty_stack(); // 스택이 비어있으면 empty_stack 예외를 던짐 value = data.top(); // 스택의 최상단 원소를 참조 변수에 복사 data.pop();    }    bool empty() const    { std::lock_guard&lt;std::mutex&gt; lock(m); // 현재 객체의 뮤텍스를 잠금 return data.empty();    }};3.2.4 교착 상태: 문제점과 해결책 (Deadlock: the problem and a solution) 교착 상태(Deadlock)는 두 개 이상의 스레드가 서로가 점유하고 있는 자원(예: 뮤텍스)을 기다리며 더 이상 진행하지 못하는 상황. 교착 상태를 피하는 일반적인 방법: 항상 동일한 순서로 뮤텍스를 잠금. 그러나 두 개의 동일 클래스 인스턴스 간에 데이터를 교환하는 경우처럼 순서 정의가 어려운 경우가 있음. 한 스레드는 lock(mutex_A); lock(mutex_B); 순서로, 다른 스레드는 lock(mutex_B); lock(mutex_A); 순서로 잠그려 하면 교착 상태 발생 가능. C++ 표준 라이브러리는 std::lock() 함수를 제공하여 둘 이상의 뮤텍스를 교착 상태 위험 없이 한 번에 잠글 수 있게 함.코드 예제: std::lock()과 std::lock_guard를 사용한 교환 연산// 두 개의 X 객체를 스레드 안전하게 교환(swap)하는 기능을 포함한 클래스 X의 C++ 코드class some_big_object;void swap(some_big_object&amp; lhs, some_big_object&amp; rhs); // some_big_object를 위한 swap 함수class X{private: some_big_object some_detail; std::mutex m; // some_detail 멤버에 대한 접근을 동기화하기 위한 뮤텍스public: X(some_big_object const&amp; sd) : some_detail(sd) {} // friend 함수로 선언된 swap 함수: 두 X 객체의 내용을 스레드 안전하게 교환 friend void swap(X&amp; lhs, X&amp; rhs) { // 자기 자신과의 교환 시도는 아무 작업도 하지 않고 반환 if (&amp;lhs == &amp;rhs) return; // std::lock 함수를 사용하여 두 뮤텍스를 데드락 발생 없이 동시에 잠금 std::lock(lhs.m, rhs.m); // std::lock_guard를 사용하여 뮤텍스가 자동으로 해제되도록 함 // std::adopt_lock은 이미 잠긴 뮤텍스의 소유권을 이전받아 관리하도록 함 std::lock_guard&lt;std::mutex&gt; lock_a(lhs.m, std::adopt_lock); std::lock_guard&lt;std::mutex&gt; lock_b(rhs.m, std::adopt_lock); // 실제 데이터 멤버인 some_detail 객체들을 사용자 정의 swap 함수를 이용해 교환 swap(lhs.some_detail, rhs.some_detail); }};3.2.5 교착 상태를 피하기 위한 추가 지침 (Further guidelines for avoiding deadlock) 교착 상태는 잠금뿐만 아니라 스레드가 서로를 기다리는 모든 동기화 구조에서 발생할 수 있음. 근본적인 아이디어는 다른 스레드가 당신을 기다리고 있을 가능성이 있다면 그 스레드를 기다리지 않는 것중첩된 잠금 피하기 (Avoid nested locks) 이미 잠금을 보유하고 있다면 다른 잠금을 획득하지 말 것. 여러 잠금이 필요하면 std::lock을 사용하여 한 번에 획득함.잠금을 보유한 상태에서 사용자 제공 코드 호출 피하기 (Avoid calling user-supplied code while holding a lock) 사용자 코드가 어떤 작업을 할지 알 수 없으므로 (다른 잠금을 획득할 수도 있음), 중첩된 잠금 지침을 위반하여 교착 상태를 유발할 수 있음.고정된 순서로 잠금 획득하기 (Acquire locks in a fixed order) 둘 이상의 잠금을 획득해야 하고 std::lock으로 한 번에 획득할 수 없다면, 모든 스레드에서 동일한 순서로 잠금을 획득함. 예: 연결 리스트에서 노드를 순회할 때 항상 다음 노드의 잠금을 먼저 획득하고 이전 노드의 잠금을 해제하는 핸드오버핸드(hand-over-hand) 잠금 스타일. 역순 순회는 교착 상태 유발 가능.잠금 계층 사용하기 (Use a lock hierarchy) 애플리케이션을 계층으로 나누고 각 계층에서 잠길 수 있는 모든 뮤텍스를 식별함. 스레드가 뮤텍스를 잠그려 할 때, 이미 더 낮은 계층의 잠금을 보유하고 있다면 해당 뮤텍스를 잠글 수 없도록 함. 런타임에 각 뮤텍스에 계층 번호를 할당하고 각 스레드가 잠근 뮤텍스를 기록하여 이를 확인할 수 있음. hierarchical_mutex는 thread_local 변수를 사용하여 현재 스레드의 잠금 계층 값을 추적. 이 지침들을 잠금 이상으로 확장하기 스레드를 기다리면서 잠금을 보유하는 것은 좋지 않음. 해당 스레드가 진행하기 위해 그 잠금을 필요로 할 수 있기 때문 3.2.6 std::unique_lock을 사용한 유연한 잠금 (Flexible locking with std::unique_lock) std::unique_lock은 std::lock_guard보다 더 많은 유연성을 제공함. std::unique_lock 인스턴스가 항상 연관된 뮤텍스를 소유하지 않아도 됨. 생성자에 std::defer_lock을 전달하면 뮤텍스가 잠기지 않은 상태로 생성되며, 나중에 lock() 멤버 함수를 호출하거나 std::unique_lock 객체를 std::lock()에 전달하여 잠글 수 있음. std::unique_lock은 뮤텍스 소유 여부를 나타내는 플래그를 저장해야 하므로 std::lock_guard보다 공간을 더 차지하고 약간의 성능 저하가 있을 수 있음. owns_lock() 멤버 함수로 현재 잠금을 소유하고 있는지 질의할 수 있음 3.2.7 범위 간 뮤텍스 소유권 이전 (Transferring mutex ownership between scopes) std::unique_lock 인스턴스는 연관된 뮤텍스를 반드시 소유하지 않아도 되므로, 인스턴스를 이동(move)시켜 뮤텍스의 소유권을 이전할 수 있음 함수에서 std::unique_lock 인스턴스를 반환하면 소유권이 호출자에게 이전되어 동일한 잠금 하에 추가 작업을 수행할 수 있음std::unique_lock&lt;std::mutex&gt; get_lock() { extern std::mutex some_mutex; std::unique_lock&lt;std::mutex&gt; lk(some_mutex); // 뮤텍스 잠금 // prepare_data(); return lk; // lk의 소유권이 이동됨 (컴파일러가 std::move 처리)}void process_data() { std::unique_lock&lt;std::mutex&gt; lk(get_lock()); // 반환된 unique_lock으로 소유권 이전 // do_something();} std::unique_lock은 소멸되기 전에 unlock() 멤버 함수를 호출하여 잠금을 해제할 수도 있음. 이는 잠금이 더 이상 필요하지 않은 특정 코드 분기에서 잠금을 해제하여 성능을 향상시키는 데 중요할 수 있음 3.2.8 적절한 세분성으로 잠그기 (Locking at an appropriate granularity) 잠금 세분성(lock granularity)은 단일 잠금으로 보호되는 데이터의 양을 설명하는 용어. 너무 작은 단위로 잠그면(fine-grained lock) 경쟁이 줄지만 관리 오버헤드가 커지고, 너무 큰 단위로 잠그면(coarse-grained lock) 경쟁이 심해져 병렬성이 저하됨 잠금은 필요한 최소 시간 동안만 보유해야 함 잠금을 보유한 상태에서 파일 I/O와 같은 시간이 많이 걸리는 작업은 피해야 함 std::unique_lock을 사용하면 필요 없는 구간에서 unlock()하고 나중에 다시 lock()할 수 있음. void get_and_process_data() { std::unique_lock&lt;std::mutex&gt; my_lock(the_mutex); some_class data_to_process = get_next_data_chunk(); my_lock.unlock(); // process() 호출 전에 잠금 해제 result_type result = process(data_to_process); // 이 작업은 잠금 없이 수행 my_lock.lock(); // 결과를 쓰기 위해 다시 잠금 write_result(data_to_process, result);}3.3 공유 데이터 보호를 위한 대안적인 기능 (Alternative facilities for protecting shared data) 뮤텍스가 가장 일반적인 메커니즘이지만, 특정 시나리오에 더 적합한 보호를 제공하는 대안들이 있음.3.3.1 초기화 중 공유 데이터 보호 (Protecting shared data during initialization) 공유 데이터가 초기화 중에만 동시 접근으로부터 보호되어야 하고, 그 이후에는 명시적인 동기화가 필요 없는 경우가 흔함 (예: 초기화 후 읽기 전용 데이터). 이 경우 초기화가 완료된 후에도 뮤텍스를 잠그는 것은 불필요한 성능 저하를 유발함게으른 초기화(Lazy initialization)와 문제점 필요할 때만 리소스를 초기화하는 방식std::shared_ptr&lt;some_resource&gt; resource_ptr;void foo() { if (!resource_ptr) { resource_ptr.reset(new some_resource); // 1. 초기화 } resource_ptr-&gt;do_something();} 단순히 뮤텍스로 보호하면 모든 스레드가 리소스 사용 전에 뮤텍스를 기다려야 하므로 불필요한 직렬화 발생이중 검사 잠금 패턴(Double-Checked Locking Pattern)과 위험성 잠금을 획득하기 전에 포인터를 먼저 읽고, NULL인 경우에만 잠금을 획득한 후 다시 포인터를 검사하는 방식// (이중 검사 잠금 - 정의되지 않은 동작 유발 가능성 있음)void undefined_behaviour_with_double_checked_locking() { if (!resource_ptr) { // 1. 잠금 외부에서 첫 번째 읽기 std::lock_guard&lt;std::mutex&gt; lk(resource_mutex); if (!resource_ptr) { // 2. 잠금 내부에서 두 번째 읽기 resource_ptr.reset(new some_resource); // 3. 실제 초기화 } } resource_ptr-&gt;do_something(); // 4. 사용} 문제점: 잠금 외부에서의 읽기(1)와 다른 스레드가 잠금 내부에서 수행한 쓰기(3)가 동기화되지 않아 데이터 경쟁 발생 가능성이 있음. 이는 정의되지 않은 동작을 유발함C++ 표준 라이브러리 해결책: std::call_once std::once_flag와 std::call_once를 사용하여 이러한 상황을 안전하고 효율적으로 처리함. std::call_once는 지정된 함수가 정확히 한 번만 호출되도록 보장하며, 일반적으로 뮤텍스를 명시적으로 사용하는 것보다 오버헤드가 적음코드 예제: std::call_once를 사용한 스레드 안전한 게으른 초기화std::shared_ptr&lt;some_resource&gt; resource_ptr_call_once;std::once_flag resource_flag; // 한 번만 실행되도록 보장하기 위한 플래그void init_resource() { resource_ptr_call_once.reset(new some_resource); std::cout &lt;&lt; \"Resource initialized by call_once.\" &lt;&lt; std::endl;}void foo_call_once() { std::call_once(resource_flag, init_resource); // init_resource 함수를 스레드-세이프하게 한 번만 호출 resource_ptr_call_once-&gt;do_something(); std::cout &lt;&lt; \"Resource used by foo_call_once.\" &lt;&lt; std::endl;} std::call_once는 클래스 멤버의 게으른 초기화에도 사용될 수 있음 static으로 선언된 지역 변수의 초기화는 C++11에서 스레드 안전하게 정확히 한 번만 발생하도록 정의되어, std::call_once의 대안으로 사용될 수 있음3.3.2 드물게 업데이트되는 데이터 구조 보호 (Protecting rarely updated data structures) 대부분 읽기 전용이고 가끔만 업데이트되는 데이터 구조(예: DNS 캐시)의 경우, std::mutex를 사용하면 읽기 작업 시 불필요한 직렬화가 발생. 이때는 읽기-쓰기 뮤텍스(reader-writer mutex)가 더 적합함. 이는 단일 “쓰기자(writer)” 스레드에 의한 배타적 접근 또는 여러 “읽기자(reader)” 스레드에 의한 공유 동시 접근을 허용함. C++11 표준 라이브러리는 이를 직접 제공하지 않지만, Boost 라이브러리의 boost::shared_mutex를 사용할 수 있음. 업데이트 연산: std::lock_guard&lt;boost::shared_mutex&gt; 또는 std::unique_lock&lt;boost::shared_mutex&gt; 사용 (배타적 접근). 읽기 전용 연산: boost::shared_lock&lt;boost::shared_mutex&gt; 사용 (공유 접근). 어떤 스레드가 공유 잠금을 가지고 있으면, 배타적 잠금을 획득하려는 스레드는 모든 다른 스레드가 잠금을 해제할 때까지 차단됨. 어떤 스레드가 배타적 잠금을 가지고 있으면, 다른 어떤 스레드도 첫 번째 스레드가 잠금을 해제할 때까지 공유 또는 배타적 잠금을 획득할 수 없음. 3.3.3 재귀적 잠금 (Recursive locking) std::mutex의 경우 이미 잠금을 보유한 스레드가 해당 뮤텍스를 다시 잠그려고 하면 정의되지 않은 동작이 발생함. 스레드가 동일한 뮤텍스를 먼저 해제하지 않고 여러 번 다시 획득해야 하는 경우, C++ 표준 라이브러리는 std::recursive_mutex를 제공함. lock()을 세 번 호출했다면 unlock()도 세 번 호출해야 다른 스레드가 잠글 수 있음. 일반적으로 재귀적 뮤텍스가 필요하다고 생각되면 설계를 변경하는 것이 더 좋음. 흔한 사용 사례는 클래스 멤버 함수가 다른 공개 멤버 함수를 호출하는 경우지만, 이는 클래스 불변성이 깨진 상태에서 두 번째 멤버 함수가 작동해야 함을 의미할 수 있어 좋지 않은 설계로 이어질 수 있음. 더 나은 방법은 잠금을 이미 보유하고 있다고 가정하는 새로운 private 멤버 함수를 추출하여 사용하는 것임" }, { "title": "2장 스레드 관리", "url": "/posts/2%EC%9E%A5-%EC%8A%A4%EB%A0%88%EB%93%9C-%EA%B4%80%EB%A6%AC/", "categories": "Concurrency", "tags": "concurrency", "date": "2024-09-07 00:00:00 +0900", "snippet": "2.1 기본 스레드 관리 (Basic thread management) 모든 C++ 프로그램은 main() 함수를 실행하는 최소 하나의 스레드를 가짐. 추가 스레드를 시작하여 다른 함수를 진입점으로 실행할 수 있으며, 이 스레드들은 초기 스레드 및 서로와 동시에 실행됨. 지정된 진입점 함수가 반환되면 해당 스레드는 종료됨2.1.1 스레드 시작하기 (Launching a thread) C++에서 스레드는 해당 스레드에서 실행할 작업을 지정하는 std::thread 객체를 생성하여 시작. 가장 간단한 경우는 매개변수 없이 void를 반환하는 일반 함수를 작업으로 지정하는 것코드 예제 (단순 스레드 시작)#include &lt;thread&gt; // std::thread 사용을 위해 필요#include &lt;iostream&gt;void do_some_work() { std::cout &lt;&lt; \"Worker thread executing\" &lt;&lt; std::endl; // 실제 작업 수행}int main() { std::thread my_thread(do_some_work); // 새 스레드 시작 // my_thread.join(); // 스레드가 완료될 때까지 기다림 (2.1.2절에서 설명) // my_thread.detach(); // 스레드를 백그라운드에서 실행 (2.1.4절에서 설명) // 중요: my_thread 객체가 소멸되기 전에 join() 또는 detach()를 호출해야 함 // 그렇지 않으면 프로그램이 std::terminate()를 호출하며 종료됨 if (my_thread.joinable()) { // join() 또는 detach()가 호출되지 않았는지 확인 my_thread.join(); } return 0;} #include &lt;thread&gt;: std::thread 클래스 사용을 위한 헤더 포함. void do_some_work(): 새 스레드에서 실행될 함수 정의. std::thread my_thread(do_some_work);: do_some_work 함수를 실행하는 새 스레드 생성 및 시작. my_thread 객체가 이 새 스레드를 나타냄. 중요: std::thread 객체 소멸 전, 해당 스레드에 대해 join() (스레드 완료 대기) 또는 detach() (스레드를 분리하여 백그라운드에서 실행) 명시적 호출 필요. 그렇지 않으면 std::thread의 소멸자가 std::terminate()를 호출하여 프로그램 비정상 종료. std::thread는 함수 포인터뿐만 아니라 함수 호출 연산자(operator())를 가진 클래스의 인스턴스(함수 객체)와 같은 모든 호출 가능 타입(callable type)과 함께 작동함.코드 예제 (함수 객체로 스레드 시작)class background_task {public: void operator()() const { // do_something(); // do_something_else(); std::cout &lt;&lt; \"Background task executing\" &lt;&lt; std::endl; }};// ... main 함수 내 ...background_task f;std::thread my_thread_func_obj(f); // 함수 객체의 복사본이 새 스레드로 전달됨if (my_thread_func_obj.joinable()) { my_thread_func_obj.join();} background_task 클래스: 함수 호출 연산자 정의로 함수 객체로 사용 가능. std::thread my_thread_func_obj(f);: background_task 객체 f의 복사본이 새 스레드의 저장 공간으로 복사되어 실행됨. 따라서 복사본이 원본과 동일하게 동작하는 것이 중요. C++의 \"most vexing parse\"를 피하기 위해 임시 객체를 스레드 생성자에 전달할 때 주의해야 함. 이는 함수 선언과 유사한 구문으로 해석될 수 있기 때문임. 코드 예제 (Most Vexing Parse 피하기)// std::thread my_thread(background_task()); // 오류: 함수 선언으로 해석될 수 있음// 해결 방법 1: 추가 괄호 사용std::thread my_thread_extra_parens((background_task())); // 변수 정의로 해석됨if (my_thread_extra_parens.joinable()) my_thread_extra_parens.join();// 해결 방법 2: 중괄호를 사용한 새로운 초기화 구문 (C++11)std::thread my_thread_braces{background_task()}; // 변수 정의로 해석됨if (my_thread_braces.joinable()) my_thread_braces.join(); 람다 표현식(C++11의 새로운 기능)을 사용하면 이러한 \"most vexing parse\" 문제를 피할 수 있음. 람다 표현식은 로컬 함수를 작성하고 로컬 변수를 캡처할 수 있게 해줌코드 예제 (람다 표현식으로 스레드 시작)std::thread my_thread_lambda([] { // do_something(); // do_something_else(); std::cout &lt;&lt; \"Lambda thread executing\" &lt;&lt; std::endl;});if (my_thread_lambda.joinable()) my_thread_lambda.join(); 스레드가 시작된 후에는 해당 스레드가 완료될 때까지 기다릴지(join()) 또는 독립적으로 실행되도록 분리할지(detach()) 명시적으로 결정해야 함2.1.2 스레드가 완료될 때까지 기다리기 (Waiting for a thread to complete) 스레드가 완료될 때까지 기다리려면 관련된 std::thread 인스턴스에서 join()을 호출함. join()을 호출하면 호출 스레드는 대상 스레드가 종료될 때까지 차단됨. join()은 스레드와 관련된 저장 공간을 정리하므로, std::thread 객체는 더 이상 해당 스레드와 연결되지 않음. 따라서 특정 스레드에 대해 join()은 한 번만 호출할 수 있음. join() 호출 후 joinable()은 false를 반환함코드 예제 (스레드 완료 대기)struct func { int&amp; i; func(int&amp; i_):i(i_){} void operator()() { for(unsigned j=0;j&lt;1000000;++j) { do_something(i); } } }; void oops() { int some_local_state=0; func my_func(some_local_state); std::thread my_thread(my_func); my_thread.detach(); } my_thread.detach()를 my_thread.join()으로 바꾸면 oops 함수가 종료되기 전에 스레드가 완료되어 로컬 변수 파괴 문제를 피할 수 있음2.1.3 예외적인 상황에서 기다리기 (Waiting in exceptional circumstances) std::thread 객체가 소멸되기 전에 join() 또는 detach()를 호출해야 함. 스레드를 기다리려는 경우 예외가 발생하여 join() 호출이 건너뛰어지는 상황을 방지해야 함. 이를 위해 try/catch 블록을 사용하거나 RAII(Resource Acquisition Is Initialization) 관용구를 활용할 수 있음코드 예제 (RAII를 사용한 스레드 완료 대기 - thread_guard)// (요약 및 핵심 부분)class thread_guard { std::thread&amp; t;public: explicit thread_guard(std::thread&amp; t_) : t(t_) {} ~thread_guard() { if (t.joinable()) { // 스레드가 여전히 join 가능한지 확인 t.join(); // 소멸자에서 join 호출 } } thread_guard(thread_guard const&amp;) = delete; // 복사 생성자 삭제 thread_guard&amp; operator=(thread_guard const&amp;) = delete; // 복사 할당 연산자 삭제};// ... f() 함수 내 ...// int some_local_state = 0;// func my_func(some_local_state); // func는 스레드에서 실행될 함수 객체// std::thread t(my_func);// thread_guard g(t); // thread_guard 객체 생성, t의 생명주기 관리// do_something_in_current_thread(); // 이 작업 중 예외 발생 가능// f() 함수가 종료되면 g가 먼저 소멸되고, g의 소멸자에서 t.join()이 호출됨 thread_guard 클래스: std::thread 객체의 참조를 가짐. 소멸자: t.joinable()을 확인하여 스레드가 아직 join되지 않았으면 t.join() 호출. 이는 스레드가 이미 join되었거나 detach된 경우 join()을 다시 호출하는 것을 방지. 복사 생성자와 복사 할당 연산자: = delete로 선언되어 컴파일러에 의해 자동으로 생성되는 것을 막음. 이는 thread_guard 객체가 참조하는 스레드의 유효 범위를 벗어나 복사되거나 할당되는 위험한 상황을 방지. 함수 f 내에서 thread_guard g(t); 선언 시, f 함수의 범위를 벗어날 때 (정상 종료든 예외 발생이든) g의 소멸자가 호출되어 t.join()이 실행되므로 스레드 t가 안전하게 완료됨2.1.4 백그라운드에서 스레드 실행하기 (Running threads in the background) 스레드가 완료될 때까지 기다릴 필요가 없는 경우, detach()를 호출하여 스레드를 백그라운드에서 실행하도록 둘 수 있음. detach()는 std::thread 객체와 스레드 간의 연결을 끊어, std::thread 객체가 소멸될 때 std::terminate()가 호출되는 것을 방지함. 분리된 스레드는 데몬 스레드(daemon threads)라고도 불리며, 일반적으로 애플리케이션 수명 동안 백그라운드 작업을 수행 detach()는 std::thread 객체의 멤버 함수를 호출하여 수행함. detach() 호출 후 std::thread 객체는 더 이상 실제 실행 스레드와 연결되지 않으므로 joinable()은 false를 반환함. join()과 마찬가지로, detach()는 연결된 실행 스레드가 있는 std::thread 객체에 대해서만 호출할 수 있음 (joinable()이 true를 반환하는 경우).코드 예제 (다른 문서를 처리하기 위해 스레드 분리)void edit_document(std::string const&amp; filename){ open_document_and_display_gui(filename); while(!done_editing()) { user_command cmd=get_user_input(); // ... 사용자 입력 처리 부분 ... if(cmd.type==open_new_document) { std::string const new_name=get_filename_from_user(); std::thread t(edit_document,new_name); // 새 스레드 시작하며 파일 이름 전달 t.detach(); // 스레드 분리 } else { process_user_input(cmd); } }} 워드 프로세서가 새 문서를 열 때, 각 문서 편집 창을 자체 스레드에서 실행하는 예를 보여줌. 새 문서를 여는 요청을 처리하는 스레드는 다른 스레드가 완료되기를 기다릴 필요가 없으므로, 새 스레드를 detach()하는 것이 적합. 이 예제는 스레드 시작 함수에 인수를 전달하는 경우도 보여줌2.2 스레드 함수에 인수 전달하기 (Passing arguments to a thread function) std::thread 생성자에 추가 인수를 전달하여 호출 가능 객체나 함수에 인수를 전달할 수 있음. 기본적으로 인수는 내부 저장 공간으로 복사되어 새 실행 스레드에서 접근할 수 있게 됨. 이는 함수 매개변수가 참조를 예상하더라도 마찬가지 코드 예제 (인수 전달)// void f(int i, std::string const&amp; s);std::thread t(f, 3, \"hello\"); // f(3, \"hello\") 호출, \"hello\"는 char const*로 전달 후 새 스레드에서 std::string으로 변환됨// t.join(); // 실제 사용 시 필요 자동 변수에 대한 포인터를 전달할 때는 주의해야 함. 포인터 자체가 복사되므로, 원래 함수가 종료되기 전에 새 스레드에서 해당 포인터가 역참조되지 않으면 정의되지 않은 동작이 발생할 수 있음코드 예제 (잘못된 포인터 인수 전달 및 해결)// (잘못된 경우)void f(int i, std::string const&amp; s);void oops(int some_param) { char buffer[1024]; sprintf(buffer, \"%i\", some_param); std::thread t(f, 3, buffer); // buffer의 포인터가 전달됨 t.detach(); // oops 함수가 종료되면 buffer는 파괴될 수 있음}// (올바른 경우)void not_oops(int some_param) { char buffer[1024]; sprintf(buffer, \"%i\", some_param); std::thread t(f, 3, std::string(buffer)); // std::string으로 변환하여 복사본 전달 t.detach();} 반대로 객체가 복사되지만 실제로는 참조를 원했던 경우도 있음. std::thread 생성자는 함수의 매개변수 타입을 알지 못하고 제공된 값을 그대로 복사하기 때문 이 경우 std::ref를 사용하여 인수를 래핑해야 함. 코드 예제 (참조 전달)void update_data_for_widget(widget_id w, widget_data&amp; data); // data는 참조로 전달되어야 함widget_data data_val;std::thread t(update_data_for_widget, w, std::ref(data_val)); // std::ref를 사용하여 data_val의 참조를 전달t.join(); 멤버 함수 포인터를 스레드 함수로 전달할 수도 있으며, 이 경우 첫 번째 인수로 적절한 객체 포인터를 제공해야 함코드 예제 (멤버 함수 포인터 전달)class X {public: void do_lengthy_work();};X my_x;std::thread t(&amp;X::do_lengthy_work, &amp;my_x); // my_x.do_lengthy_work()를 새 스레드에서 호출t.join(); 인수는 복사될 수 없지만 이동(move)될 수만 있는 경우도 있음. std::unique_ptr와 같은 타입이 그 예임. 소스 객체가 임시 객체이면 이동은 자동으로 수행되지만, 이름 있는 값인 경우 std::move()를 명시적으로 호출해야 함코드 예제 (이동 시맨틱스를 사용한 인수 전달)void process_big_object(std::unique_ptr&lt;big_object&gt; p);std::unique_ptr&lt;big_object&gt; p_val(new big_object);p_val-&gt;prepare_data(42);std::thread t(process_big_object, std::move(p_val)); // p_val의 소유권을 새 스레드로 이전t.join();2.3 스레드 소유권 이전하기 (Transferring ownership of a thread) std::thread 인스턴스는 이동 가능(movable)하지만 복사 불가능(noncopyable)함. 이는 특정 실행 스레드의 소유권이 std::thread 인스턴스 간에 이전될 수 있음을 의미함. 이는 한 번에 하나의 객체만 특정 실행 스레드와 연결되도록 보장하면서 프로그래머에게 소유권 이전 옵션을 제공함코드 예제 (스레드 소유권 이전)void some_function();void some_other_function();std::thread t1(some_function); // t1이 새 스레드 소유std::thread t2 = std::move(t1); // t2가 t1으로부터 소유권 이전받음, t1은 더 이상 스레드와 연결되지 않음t1 = std::thread(some_other_function); // t1이 새 스레드 소유 (임시 객체로부터의 이동은 암시적)std::thread t3;t3 = std::move(t2); // t3가 t2로부터 소유권 이전받음t1 = std::move(t3); // 오류! t1은 이미 스레드를 관리하고 있으므로 std::terminate() 호출됨 std::move(t1): t1의 소유권 명시적 이전. 임시 std::thread 객체로부터의 소유권 이전: std::move() 호출 없이 자동 수행. 이미 스레드를 관리하는 std::thread 객체에 다른 스레드의 소유권 할당 시도: std::terminate() 호출로 프로그램 종료. 이는 소멸 시점에서와 마찬가지로 스레드를 “버리는” 것을 방지하기 위함 std::thread의 이동 지원 덕분에 함수에서 스레드 소유권을 반환하거나 함수로 전달할 수 있음코드 예제 (scoped_thread - RAII를 활용한 스레드 소유권 관리)class scoped_thread{ std::thread t;public: explicit scoped_thread(std::thread t_) : t(std::move(t_)) // 생성자에서 소유권 이전 { if(!t.joinable()) // join 가능 여부 확인 throw std::logic_error(“No thread”); } ~scoped_thread() { t.join(); // 소멸자에서 join } scoped_thread(scoped_thread const&amp;)=delete; scoped_thread&amp; operator=(scoped_thread const&amp;)=delete;};struct func; void f(){ int some_local_state; scoped_thread t(std::thread(func(some_local_state))); // 직접 소유권 전달 do_something_in_current_thread();} 이 클래스는 생성 시 std::thread 객체의 소유권을 가져오고, 소멸 시 해당 스레드를 join()함. 이는 스레드가 범위를 벗어나기 전에 완료되도록 보장 std::thread 객체는 std::vector와 같은 이동을 지원하는 컨테이너에 저장될 수 있음. 이를 통해 여러 스레드를 그룹으로 관리할 수 있음코드 예제 (여러 스레드를 시작하고 완료 대기)void do_work(unsigned id);void f(){ std::vector&lt;std::thread&gt; threads; for(unsigned i=0;i&lt;20;++i) { threads.push_back(std::thread(do_work,i)); } std::for_each(threads.begin(),threads.end(),std::mem_fn(&amp;std::thread::join)); } std::vector&lt;std::thread&gt;를 사용하여 여러 스레드를 시작하고, std::for_each와 std::mem_fn을 사용하여 각 스레드를 join()하는 예제2.4 런타임에 스레드 수 선택하기 (Choosing the number of threads at runtime) C++ 표준 라이브러리는 std::thread::hardware_concurrency() 함수를 제공하여, 프로그램 실행 시 진정으로 동시에 실행될 수 있는 스레드 수에 대한 힌트를 반환 멀티코어 시스템에서는 CPU 코어 수가 될 수 있음. 이 정보가 없으면 0을 반환할 수 있지만, 작업을 스레드 간에 분할하는 데 유용한 가이드가 될 수 있음코드 예제 (parallel_accumulate - 작업 분할// (핵심 로직 요약)template&lt;typename Iterator, typename T&gt;T parallel_accumulate(Iterator first, Iterator last, T init) { unsigned long const length = std::distance(first, last); if (!length) return init; // 빈 범위 처리 unsigned long const min_per_thread = 25; unsigned long const max_threads = (length + min_per_thread - 1) / min_per_thread; // 최대 스레드 수 계산 unsigned long const hardware_threads = std::thread::hardware_concurrency(); unsigned long const num_threads = std::min(hardware_threads != 0 ? hardware_threads : 2, max_threads); // 실제 사용할 스레드 수 결정 unsigned long const block_size = length / num_threads; // 각 스레드가 처리할 블록 크기 std::vector&lt;T&gt; results(num_threads); std::vector&lt;std::thread&gt; threads(num_threads - 1); // 주 스레드를 제외한 스레드 수 Iterator block_start = first; for (unsigned long i = 0; i &lt; (num_threads - 1); ++i) { Iterator block_end = block_start; std::advance(block_end, block_size); // 현재 블록의 끝 threads[i] = std::thread( accumulate_block&lt;Iterator, T&gt;(), // accumulate_block은 각 블록의 합계를 계산하는 함수 객체 block_start, block_end, std::ref(results[i])); // 새 스레드 시작 block_start = block_end; // 다음 블록의 시작 } accumulate_block&lt;Iterator, T&gt;()(block_start, last, results[num_threads - 1]); // 주 스레드가 나머지 블록 처리 std::for_each(threads.begin(), threads.end(), std::mem_fn(&amp;std::thread::join)); // 모든 작업 스레드 완료 대기 return std::accumulate(results.begin(), results.end(), init); // 최종 결과 합산} std::accumulate의 병렬 버전을 간단하게 구현함. 이 함수는 스레드당 최소 요소 수를 고려하여 작업을 스레드 간에 분할 주의: 이 parallel_accumulate 예제는 단순하며, 예외 처리, 비결합 연산자(non-associative operator)로 인한 결과 변동 가능성 등은 고려되지 않았음. 또한, 반복자 요구 사항이 더 엄격하고, T 타입은 기본 생성 가능해야 함 2.5 스레드 식별하기 (Identifying threads) 각 스레드는 std::thread::id 타입의 고유 식별자를 가짐. 스레드 식별자는 두 가지 방법으로 얻을 수 있음식별자 얻는 방법1번 방법 std::thread 객체의 get_id() 멤버 함수 호출 std::thread 객체가 실행 스레드와 연결되어 있지 않으면, “어떤 스레드도 아님(not any thread)”을 나타내는 기본 생성된 std::thread::id 객체를 반환2번 방법 &lt;thread&gt; 헤더에 정의된 std::this_thread::get_id()를 호출하여 현재 스레드의 식별자를 얻음.std::thread::id std::thread::id 객체는 자유롭게 복사하고 비교할 수 있음. 두 std::thread::id 객체가 같으면 동일한 스레드를 나타내거나 둘 다 “어떤 스레드도 아님” 값을 가짐. 같지 않으면 다른 스레드를 나타냄. std::thread::id는 전체 순서(total ordering)를 제공하므로 연관 컨테이너의 키로 사용하거나 정렬할 수 있음. std::hash&lt;std::thread::id&gt;도 제공되어 해시 기반 컨테이너의 키로 사용할 수 있음활용 스레드 ID는 특정 스레드가 특정 작업을 수행해야 하는지 확인하는 데 사용될 수 있음. 또는 스레드별 데이터를 저장하는 데이터 구조의 키로 사용될 수 있음. std::thread::id는 std::cout과 같은 출력 스트림으로 출력할 수 있으며, 주로 디버깅 및 로깅에 유용" }, { "title": "1장 C++의 동시성", "url": "/posts/1%EC%9E%A5-C++%EC%9D%98-%EB%8F%99%EC%8B%9C%EC%84%B1/", "categories": "Concurrency", "tags": "concurrency", "date": "2024-09-01 00:00:00 +0900", "snippet": "1.1 동시성이란 무엇인가? 가장 기본적인 수준에서 동시성은 둘 이상의 개별적인 활동이 동시에 발생하는 것을 의미 컴퓨터 시스템에서의 동시성은 단일 시스템이 여러 독립적인 활동을 순차적이 아닌 병렬적으로 수행하는 것을 말함컴퓨터 시스템에서의 동시성 과거 대부분의 컴퓨터는 단일 프로세서(싱글 코어)를 가지고 있었고, 작업 전환(task switching)을 통해 여러 작업이 동시에 실행되는 것처럼 보이게 했다. 이는 실제 병렬 처리가 아닌 환상에 가까움 반면, 다중 프로세서 또는 멀티코어 프로세서를 가진 컴퓨터는 진정한 하드웨어 동시성(hardware concurrency)을 통해 여러 작업을 실제로 병렬 실행할 수 있다. 동시성에 대한 접근 방식다중 프로세스 (Multiple Processes) 각 프로세스가 자체 스레드에서 실행되며, 운영체제에 의해 보호받는 독립된 주소 공간을 가짐. 프로세스 간 통신(IPC)은 복잡하거나 느릴 수 있지만, 데이터 격리로 인해 안전한 동시 코드 작성이 용이할 수 있음다중 스레드 (Multiple Threads) 단일 프로세스 내에서 여러 스레드가 실행. 스레드들은 주소 공간을 공유하므로 데이터 공유가 용이하지만, 공유 데이터 접근 시 일관성 유지를 위한 프로그래머의 세심한 주의가 필요함.1.2 왜 동시성을 사용하는가? 동시성을 사용하는 주된 이유는 관심사 분리(separation of concerns)와 성능 향상(performance)관심사 분리를 위한 동시성 사용 서로 다른 기능 영역을 별도의 스레드로 분리하여 코드를 더 이해하기 쉽고 테스트하기 용이하게 만들 수 있음. 예를 들어, DVD 플레이어 애플리케이션에서 사용자 인터페이스 처리와 DVD 재생 처리를 별도의 스레드로 분리하면 각 스레드의 로직이 단순해지고 응답성이 향상됨성능을 위한 동시성 사용 멀티코어 프로세서의 가용성이 높아짐에 따라, 소프트웨어가 이러한 추가적인 컴퓨팅 성능을 활용하기 위해서는 여러 작업을 동시에 실행하도록 설계되어야 함작업 병렬성 (Task Parallelism) 단일 작업을 여러 부분으로 나누어 병렬로 실행하여 전체 실행 시간을 줄임.데이터 병렬성 (Data Parallelism) 여러 스레드가 동일한 작업을 데이터의 다른 부분에 대해 수행함동시성을 사용하지 말아야 할 때 동시성으로 얻는 이점보다 비용이 클 때는 사용하지 않는 것이 좋음. 멀티스레드 코드는 이해하고 유지 관리하기 더 복잡하며, 버그 발생 가능성도 높음. 또한, 스레드 시작에는 오버헤드가 따르며, 너무 많은 스레드는 시스템 리소스를 고갈시키거나 작업 전환 비용을 증가시켜 오히려 성능을 저하시킬 수 있음1.3 C++에서의 동시성과 멀티스레딩C++ 멀티스레딩의 역사 1998년 C++ 표준은 스레드의 존재를 인지하지 않았음. 컴파일러 공급업체들은 플랫폼별 확장을 통해 멀티스레딩을 지원해왔음. MFC, Boost, ACE와 같은 C++ 라이브러리들은 플랫폼별 API를 캡슐화하여 객체 지향적인 멀티스레딩 기능을 제공했음새로운 표준(C++11)에서의 동시성 지원 C++11 표준은 새로운 스레드 인지 메모리 모델과 함께 스레드 관리, 공유 데이터 보호, 스레드 간 연산 동기화, 저수준 원자적 연산(atomic operations)을 위한 클래스들을 표준 라이브러리에 포함시킴. Boost 스레드 라이브러리가 새 라이브러리의 주된 모델이 됨C++ 스레드 라이브러리의 효율성 C++ 표준 위원회는 표준 라이브러리, 특히 스레드 라이브러리 설계 시 효율성을 중요하게 고려. 저수준 API를 직접 사용하는 것보다 이점이 거의 없도록 설계되었으며, 대부분의 주요 플랫폼에서 효율적인 구현이 가능하도록 함. 또한, 궁극적인 성능을 위해 저수준 원자적 연산 라이브러리를 제공플랫폼별 기능 C++ 스레드 라이브러리는 포괄적인 기능을 제공하지만, 특정 플랫폼에서는 표준 라이브러리가 제공하는 것 이상의 기능을 제공할 수 있음. 이를 위해 native_handle() 멤버 함수를 통해 기본 구현을 플랫폼별 API로 직접 조작할 수 있도록 지원할 수 있음1.4 시작하기 C++에서 멀티스레드 프로그램을 작성하는 것은 일반적인 C++ 프로그램 작성과 크게 다르지 않지만, 일부 함수가 동시에 실행될 수 있으므로 공유 데이터에 대한 동시 접근이 안전하도록 보장해야 함.#include &lt;iostream&gt;#include &lt;thread&gt; void hello() { std::cout&lt;&lt;\"Hello Concurrent World\\n\";}int main(){ std::thread t(hello); t.join(); } &lt;thread&gt; 헤더를 포함 새 스레드에서 실행될 함수(초기 함수, initial function)를 정의 std::thread 객체를 생성하여 새 스레드를 시작하고, 이 객체의 생성자에 실행할 함수를 전달. 메인 스레드는 새 스레드가 완료될 때까지 join() 멤버 함수를 호출하여 기다려야 함. 그렇지 않으면 주 프로그램이 먼저 종료되어 새 스레드가 실행될 기회를 갖지 못할 수 있음" }, { "title": "1-1 함수 템플릿", "url": "/posts/1-1.%ED%95%A8%EC%88%98-%ED%85%9C%ED%94%8C%EB%A6%BF/", "categories": "Template", "tags": "template", "date": "2024-08-01 00:00:00 +0900", "snippet": "Why Templates? C++은 변수,함수를 정의하거나 다른 종류의 엔티티를 선언할 때 특정 타입을 요구한다. 그런데 그러한 코드는 다른 타입에서도 동일하게 적용된다. 퀵소트 알고리즘의 경우, 데이터가 int이든 string이든 상관없이 구조적으로는 똑같다. 만약 프로그래밍 언어가 이러한 일반성(genericity)을 지원하지 않는다면 불편한 대안밖에 없다 필요한 각 타입에 대해 동일한 동작을 다시 구현 Object나 void* 같은 공통 기본 타입을 위한 일반 코드를 작성 특별한 전처리기를 사용 그런데 이러한 대안들도 보면 각자 단점이 있다. 동일하게 반복 구현하다보면, 실수할 수도 있고 복잡하지만 더 나은 알고리즘을 구현할 수 없다 공통 기본 클래스를 위한 코드를 짜면 타입 체크의 이점을 잃게된다 또한 클래스가 특정 기본 클래스에서 파생되어야 할 수도 있어 코드 관리가 어렵다 특별한 전처리기를 사용하면, 코드가 범위와 타입에 대해 아무런 이해도 없이 “단순한 텍스트 치환 메커니즘”에 의해 대체되기 때문에 이상한 의미 오류가 발생할 수 있다. 템플릿 템플릿은 이러한 문제를 해결할 수 있는 방법으로, 이러한 단점을 피할 수 있다 템플릿은 아직 지정되지 않은 하나 이상의 타입에 대해 작성된 함수나 클래스이다. 템플릿을 사용할 때는 명시적으로 또는 암시적으로 타입을 인수로 전달하고 타입 체크와 범위에 대한 지원을 받을 수 있다 1.1 함수 템플릿 함수 템플릿은 다양한 타입에 대해 호출될 수 있는 기능적 동작을 제공한다 즉, 함수 템플릿은 함수들의 집합이다. 이러한 표현은 일반적인 함수처럼 보이지만, 일반 함수와 달리 파라미터들이 결정되지 않은 상태로, 매개변수화가 되어 있는데 간단한 예제를 살펴보겠다. 템플릿 정의// 더 큰 값을 반환하는 템플릿 함수 template&lt;typename T&gt; T max (T a, T b) { return b &lt; a ? a : b; } 이러한 매개변수들의 타입은 템플릿 매개변수 T로 열려 있다. 위 예시처럼 템플릿 매개변수는 다음과 같은 형태의 문법으로 선언해야 한다: template 문법template&lt;매개변수들의 쉼표로 구분된 리스트&gt; 여기서 &lt; 와 &gt;는 각괄호(angle brackets)라고 typename 키워드를 통해 타입 매개변수를 도입한다. 타입 매개변수 T는 매개변수의 이름으로, 어떤 이름이든 사용할 수 있지만 T로 사용하는 것이 관례다. 타입 매개변수는 호출자가 함수를 호출할 때 결정하는 임의의 타입을 나타낸다. 템플릿이 사용하는 연산을 제공하기만 하면, 어떤 타입(기본 타입, 클래스 등)이든 사용할 수 있다 이 경우 타입 T는 a와 b가 이 연산자로 비교되기 때문에 &lt; 연산자를 지원해야 한다 그리고 위 예시에서의 타입 T는 반환되기 위해 복사 가능해야 한다는 점도 중요하다. 역사적인 이유로 template 키워드 대신 class를 사용하는 경우도 있다. 하지만 이 경우 class의 사용이 오해를 불러 일으킬 수 있기 때문에 권장되지 않는다. class와 달리 struct는 typename 대신 사용할 수 없다 템플릿의 사용// max1.cpp#include \"max1.hpp\"#include &lt;iostream&gt;#include &lt;string&gt;int main(){ int i = 42; std::cout &lt;&lt; \"max(7,i): \" &lt;&lt; ::max(7,i) &lt;&lt; \\n ; double f1 = 3.4; double f2 =-6.7; std::cout &lt;&lt; \"max(f1,f2): \" &lt;&lt; ::max(f1,f2) &lt;&lt; \\n ; std::string s1 = \"mathematics\"; std::string s2 = \"math\"; std::cout &lt;&lt; \"max(s1,s2): \" &lt;&lt; ::max(s1,s2) &lt;&lt; \\n ;} 템플릿을 사용한 함수 max를 이용한 예시가 있는데 각 max 템플릿 호출이 ::로 구분된다 max() 템플릿이 전역 네임스페이스에서 찾기 위함이다. 표준 라이브러리에는 std::max() 템플릿도 존재하며, 특정 상황에서는 이 함수가 호출되거나 혼동을 초래할 수 있다. 템플릿 엔티티 호출 템플릿은 모든 타입을 처리할 수 있는 단일 엔티티로 컴파일되지 않는다 대신, 템플릿이 사용되는 각 타입에 대해 서로 다른 엔티티가 템플릿에서 생성된다 int i = 42;... max(7, i) ...// 위 max는 int를 템플릿 매개변수 'T'로 사용하는 함수 템플릿을 사용int max(int a, int b){ return b &lt; a ? a : b;} 근데 만약 string처럼 std 네임스페이스에서 정의된 경우, C++의 lookup 규칙에 따라 전역의 max 템플릿과 std 내의 max 템플릿 모두 발견될 수 있다.인스턴스화 템플릿 매개변수를 구체적인 타입으로 대체하는 과정을 인스턴스화라고 한다. 이 과정의 결과로 템플릿의 인스턴스가 생성된다. 함수 템플릿을 사용하는 것만으로도 이러한 인스턴스화 과정을 트리거할 수 있으며, 프로그래머가 별도로 인스턴스화를 요청할 필요는 없다. 마찬가지로, max()의 다른 호출도 double과 std::string에 대해 max 템플릿을 인스턴스화하며, 이는 마치 개별적으로 선언되고 구현된 것과 같이 동작합니다:double max(double a, double b);std::string max(std::string a, std::string b); 또한 코드가 유효하다면 void 또한 template 파라미터로 사용할 수 있다.template&lt;typename T&gt; T foo(T*) { } void* vp = nullptr; foo(vp);이중 번역(Two-Phase Translation) 템플릿을 인스턴스화할 때, 해당 템플릿이 내부에서 사용하는 모든 연산을 지원하지 않는 타입에 대해 시도할 경우 컴파일 시 오류가 발생한다.std::complex&lt;float&gt; c1, c2;...::max(c1, c2); // '&lt;' 연산자를 제공하지 않음 - 컴파일 시 오류 발생 따라서, 템플릿은 두 단계로 컴파일된다:1. 정의 시점에서의 검사 인스턴스화 없이, 템플릿 코드 자체는 템플릿 매개변수를 무시한 채로 올바른지 확인된다. 여기에는 다음과 같은 항목들이 포함된다: 예를 들어, 세미콜론이 누락된 경우처럼 구문 오류이 발생한 경우 템플릿 매개변수에 의존하지 않는, 알려지지 않은 이름(타입 이름, 함수 이름 등)을 사용하는 경우 템플릿 매개변수에 의존하지 않는 정적 단언(static assertions)이 확인되는 경우 2. 인스턴스화 시점에서의 검사 템플릿 코드가 다시 한번 확인되어, 모든 코드가 유효한지 검토된다. 특히, 이 단계에서는 템플릿 매개변수에 의존하는 모든 부분이 이중으로 체크됩니다.template&lt;typename T&gt;void foo(T t) { undeclared(); undeclared(t); // 첫 번째 단계: undeclared()가 알려지지 않았을 경우 컴파일 타임 오류 // 두 번째 단계: undeclared(T)가 알려지지 않았을 경우 컴파일 타임 오류 static_assert(sizeof(int) &gt; 10, \"int too small\"); // sizeof(int) &lt;= 10인 경우 항상 실패 static_assert(sizeof(T) &gt; 10, \"T too small\"); // T의 크기가 &lt;= 10인 경우 실패} 정의 시점에서의 검사 한번, 인스턴스화 시점에서의 검사 한번 해서 총 2번 검사하는 이를 이중 탐색(two-phase lookup)이라고 불린다. 일부 컴파일러는 첫 번째 단계에서 모든 검사를 수행하지 않을 수 있다. 그래서 템플릿 코드가 최소한 한 번 인스턴스화될 때까지 일반적인 문제가 나타나지 않을 수 있다컴파일 및 링크 이중 번역(two-phase translation)은 실무에서 템플릿을 처리하는 데 중요한 문제를 야기한다. 즉, 함수 템플릿이 인스턴스화를 유발하는 방식으로 사용될 때, 컴파일러는 결국 그 템플릿의 정의를 참조할 필요가 있다. 이는 일반 함수의 선언만으로도 충분했던 기존의 컴파일 및 링크 구분을 깨뜨리게 된다. 이 문제를 처리하는 방법은 9장에서 다룰 예정이다. 그전까지는 가장 단순한 접근 방식을 취해, 각 템플릿을 헤더 파일 내에 구현하는 방법을 사용하겠다.용어 엔티티 : 템플릿으로부터 생성된 구체적인 함수나 클래스의 인스턴스" }, { "title": "TEnumRange", "url": "/posts/TEnumRange/", "categories": "unreal, Basic", "tags": "unreal", "date": "2024-06-18 00:00:00 +0900", "snippet": "TEnumRange 특정 Enum의 모든 값들을 반복문으로 돌리고 싶을 때 사용 ENUM_RANGE_BY_COUNT 매크로를 선언해야 가능함 #include \"Misc/EnumRange.h\" 헤더파일이 필요함 UENUM()enum class EItemSlot{\tNONE,\tHEAD,\t\tGLOVES,};ENUM_RANGE_BY_COUNT(EItemSlot, EItemSlot::GLOVES);for (EItemSlot ItemSlot : TEnumRange&lt;EItemSlot&gt;()){ // ItemSlot : NONE부터 GLOVES까지 차례대로 반복문 실행}" }, { "title": "4.Cycle && Lock/Unlock", "url": "/posts/4.Cycle/", "categories": "unreal, ControlRig", "tags": "unreal", "date": "2024-06-08 00:00:00 +0900", "snippet": "Cycle 여기서 설명하는 Cycle은 일정 시간을 주기적으로 도는 타이머라고 생각하면 된다. 위 사진에서 가장 바깥 원인 Swing Phase를 기준으로 각각의 발(Leg)는 Offset을 가져 모든 leg가 비율값을 가지게 된다. 그 비율값을 가지고 발을 움직일 때 다른 발이 얼마나 움직이도록 조절한다. 예를 들어 가장 바깥쪽 Cycle을 담당하는 Leg가 이전 위치에서 새로운 위치로 움직이면서 해당 Wolrd Space에 고정(Lock)이 되었다고 한다면 나머지 Leg도 이전 위치에서 다음 위치까지로 움직이는 값을 비율값으로 조절한다. 지금 이 ControlRig에서 사용하는 Mesh는 전갈이기 때문에 이 전갈의 발을 자연스럽게 움직이게 하기 위해서는 하나씩 간격을 두고 움직이는 것이 좋기 때문에 Cycle을 사용하는 것이다 Calculate Cycle Modulo를 이용해서 B를 넘어가면 초과된 양은 Set으로 저장하고 다시 시작하는 방식이다. MasterCyclePercent는 0초 ~ 1초(Modulo의 B) 사이의 시간을 도는 시간이다. Lock &amp;&amp; UnLock (Construction) 발을 Lock상태와 Unlock상태로 적용할 것인데 Lock상태는 발이 멈춰있는 상태이고 Unlock상태는 발을 움직일 수 있는 상태로 취급하면 된다.1. 배열 생성 먼저 발 개수만큼의 크기를 가진 bool 배열을 만든다.2. 각 발마다 Lock 함수를 만들어서 반복문으로 각 발마다 Lock상태인지 체크한다.Lock상태라면 GetSwingPercent는 Lock이나 Unlock을 조절하는 값으로, 0.5로 설정했다. MasterCyclePercent가 이 값보다 작으면 Unlock하는 방식이다 Unlock상태라면 MasterCyclePercent가 이 값보다 크면 lock하는 방식이다결론 전갈의 발을 움직이게 하기 전에 Cycle을 만들어 여러 발을 한 번에 움직이지 않고 다르게 움직여 자연스럽게 움직이게 하기 위함이다. 그 와중 발이 움직이는 상태는 Unlock이고 움직이지 않는 상태는 Lock이다. SwingPercent는 Lock과 Unlock 의 비율을 조절해주는 값이다 " }, { "title": "3.Calculate Velocity", "url": "/posts/3.CalcultaeVelcotiy/", "categories": "unreal, ControlRig", "tags": "unreal", "date": "2024-06-04 00:00:00 +0900", "snippet": "Calculate Velocity ControlRig을 이용하여 Bone을 움직이려면 Velocity를 알아야 한다. 그래서 DeltaTime마다 움직이는 값을 구하기 위해서는 현재와 과거 위치를 비교하여 얼마나 움직였는지, 그리고 그 시간이 얼마 걸렸는지를 계산해서 구하면 된다. 속력 = 거리/시간 1. WorldDelat &amp;&amp; Previous World Transform 갱신하기 이전의 PreviousWolrdTransform의 역행렬과 현재 World에서의 위치를 곱해서 World에서의 1초에 얼마나 움직였는지를 계산한다. 그 다음에 PreviousWorldTransform은 Rig Space안에서의 (0,0,0) 위치에 존재하므로 To World 함수를 이용하여 갱신하면 된다. 2. Set CalculateVelocity 그렇게 구한 WorldDelta를 DeltaTime으로 나눠서 1프레임당 얼마나 움직였는지를 계산한다. 그리고 Spring Interpolate 함수를 이용하여 현재의 Calculate Velocity를 갱신된 Delat 속력으로 보간하여 저장한다. 3. DrawLine Level에서 확인하려면 Comment에 있는 두 명령어를 콘솔에 입력하고 시뮬레이트 상태에서 해당 캐릭터를 움직이면 CalculateVelocity가 Draw된다." }, { "title": "2.FullBody IK", "url": "/posts/2.FullBody-IK-%EC%84%A4%EC%A0%95/", "categories": "unreal, ControlRig", "tags": "unreal", "date": "2024-06-03 00:00:00 +0900", "snippet": "FullBodyIK FullBodyIK는 언리얼에서 제공하는 자동으로 뼈대의 관절을 자동으로 조절해주는 시스템이다.Root Root Bone은 가장 최상단에 있는 Bone으로, 도형의 원점같은 역할을 한다. 이 Root 아래에 있는 Bone들이 영향을 받아서 움직이게 되고, Root 위에 있는 Bone은 무시된다. Effectors Effectors는 Root에 연결된 뼈대들을 조절하기 위해 기준점이 되는 뼈이다. 뼈의 이름, 트랜스폼 등을 저장한다 이전 장을 기준으로 하면 전갈의 다리가 움직이면 나머지 몸도 따라오는 구조로 만들어야 하므로 다리의 끝부분 Bone을 저장한다. 나머지 사용할 기회가 있으면 적을 예정Setting 위 사진은 저장했던 Foot들의 Name과 WorldPosition 배열을 이용해서 Effector에 연결하는 함수다. 단, FullBodyIK는 RigSpace 기준으로 실행되기 때문에 WorldSpace로 저장했던 Position을 다시 Rig Space로 되돌리는 함수인 From World함수를 호출해서 저장해줘야 한다. 그냥 사용한다면 From World를 호출하지 않아도 됨 " }, { "title": "1.Control Rig Start", "url": "/posts/1.ControlRig-Start/", "categories": "unreal, ControlRig", "tags": "unreal", "date": "2024-06-01 00:00:00 +0900", "snippet": "컨트롤 릭(Control Rig) 컨트롤 릭(Control Rig)은 애니메이션이나 리깅 작업에 사용되는 것으로, 캐릭터의 뼈대, 관절등을 움직여서 세밀하게 조절할 수 있다.테스트1. 컨트롤릭 생성 스켈레톤 메시에 우클릭으로 컨트롤릭을 생성할 수 있다.2. 애니메이션 블루프린트에 컨트롤릭 연결 우클릭으로 Control Rig Node를 생성해서 사용하려는 State Machine 같은 다른 노드들과 연결할 수 있다.WorldFinalFootTransform 저장 사용하려는 Mesh는 전갈 모양으로 총 6개의 다리를 가지고 있는데 그 다리들의 위치를 저장한다. GetFoontNames는 다리 뼈의 이름들을 저장한 배열 이 때 컨트롤 릭에서 사용하는 Transform은 Rig Space를 기준으로 하기 때문에 To World 노드를 사용해서 World Space로 변경 해줘야 한다. GetWorldFinalFootTransforms는 다리 뼈들의 WorldSpace 위치를 저장하는 배열 Construction Event(생성자)에서 진행한다 ex)블루프린트의 Event Begin WorldFinalFootTransform 저장 위에서 저장한 World Space에서의 다리 뼈 위치에 Draw Transform을 이용하여 박스를 생성한다. Forwards Solve에서 진행한다 ex)블루프린트의 Event Tick 결과" }, { "title": "Custom Log", "url": "/posts/CustomLog/", "categories": "unreal, Basic", "tags": "unreal", "date": "2024-05-25 00:00:00 +0900", "snippet": " 언리얼에서 새로운 카테고리의 로그를 생성하려면 DECLARE_LOG_CATEGORY_EXTERN 매크로를 사용해야 한다.DECLARE_LOG_CATEGORY_EXTERN 특정 로그 카테고리의 존재를 헤더 파일 등에 선언해준다. 이렇게 선언된 로그 카테고리는 여러 소스 파일에서 접근할 수 있으며, 실제 정의는 다른 곳에서 제공한다. 보통 위 매크로는 선언해주는 것이기 때문에 헤더파일에서 작성한다. // 첫 번째 파라미터는 카테고리 이름,// 두 번째 파라미터는 기본 로그 출력 형식(예: Log, Warning, Error 등),// 세 번째 파라미터는 컴파일 타임 로깅 플래그 (예: All, None 등)// 보통 헤더 파일에 위치하며, 여러 소스 파일에서 접근할 수 있다.DECLARE_LOG_CATEGORY_EXTERN(MyLogCategory, Log, All);DEFINE_LOG_CATEGORY 위에서 선언한 로그를 실제 정의할 때 사용하는 매크로 소스파일에서 작성한다. // 실제로 로그 카테고리를 하나의 소스 파일에서 정의하여 메모리에 할당// 반드시 하나의 소스 파일(.cpp)에서 호출DEFINE_LOG_CATEGORY(MyLogCategory); MyLogCategory에 해당하는 로그 변수가 메모리에 생성되며, UE_LOG 매크로 등을 통해 로그 메시지를 출력할 수 있다." }, { "title": "Retarteing과 Root Motion 애니메이션", "url": "/posts/Retarteing%EA%B3%BC-Root-Motion-%EC%95%A0%EB%8B%88%EB%A9%94%EC%9D%B4%EC%85%98/", "categories": "unreal, Animation", "tags": "unreal", "date": "2024-05-15 00:00:00 +0900", "snippet": "Retarteing과 Root Motion 애니메이션 Root Motion을 사용하는 애니메이션을 Retargeting을 하면 애니메이션은 적용되지만 Root Motion은 전혀 움직이지 않는 현상이 일어났다. 수정하는 방법은 체인 매핑에서 Root을 선택한 다음, 디테일에서 트랜슬레이션 모드를 Globally Scaled로 바꿔주면 된다. " }, { "title": "Leader Emitter", "url": "/posts/Leader-Emitter/", "categories": "unreal, Niagara", "tags": "unreal", "date": "2024-05-12 00:00:00 +0900", "snippet": "Leader Particle 이전 장에서 Map Get에 Particle Attribute Leader값을 사용하면 Niagara 안의 다른 Emitter에서 사용된 값을 가져올 수 있다.순서 Follower Emitter에 Scratch을 추가하고 아래와 Map에 Particle Attribute Leader를 추가한 다음 Map Set에 설정해주면 그 Scratch의 Emitter에서 사용하고자 하는 Niagara의 이름을 넣어주면 된다" }, { "title": "TOptional", "url": "/posts/TOptional/", "categories": "unreal, Basic", "tags": "unreal", "date": "2024-05-10 00:00:00 +0900", "snippet": "TOptional C++17의 std::optional과 유사한 역할을 하는 템플릿 클래스 특정 값이 있을 수도 있고 없을 수도 있는 상황을 표현할 때 사용 주로 사용하는 곳 함수 반환값 초기화되지 않은 상태의 표현 구성 옵션(게임 설정이나 런타임 옵션 등에서 값이 필수적이지 않은 옵션들) 비동기 작업의 결과함수 IsSet() : 값이 있는지 확인하는 함수 Reset() : 갖고 있는 값을 삭제하는 함수예시TOptional&lt;FString&gt; FindPlayerNameByID(int32 PlayerID){ // 예제: 플레이어 ID로 플레이어 이름을 찾는 로직 FString FoundName; bool bPlayerFound = /* 플레이어 검색 로직 */ false; if (bPlayerFound) { // 플레이어 이름이 발견된 경우 Optional에 값 할당 return TOptional&lt;FString&gt;(FoundName); } else { // 값이 없는 경우 빈 Optional 반환 return TOptional&lt;FString&gt;(); }}void TestPlayerNameSearch(){ TOptional&lt;FString&gt; PlayerNameOpt = FindPlayerNameByID(1001); if (PlayerNameOpt.IsSet()) { UE_LOG(LogTemp, Log, TEXT(\"플레이어 이름: %s\"), *PlayerNameOpt.GetValue()); } else { UE_LOG(LogTemp, Warning, TEXT(\"해당 ID를 가진 플레이어를 찾을 수 없습니다.\")); }}" }, { "title": "Custom Niagara Module", "url": "/posts/Custom-Niagara-Module/", "categories": "unreal, Niagara", "tags": "unreal", "date": "2024-05-08 00:00:00 +0900", "snippet": "Custom Niagara Module Custom Niagara Module 을 만드는 방법은 2가지가 있다. 가장 빠른 방법은 Niagara 안에서 새 스크래치 패치 모듈(New Scratch Pad Module)을 만드는 것이다 사진에는 파티클 스폰에서 생성되었지만, 다른 곳에서도 생성이 가능 스크래치 패치 모듈을 만들면 블루프린트와 매우 비슷하게 그래프 노드 형식을 사용한다 차이점은 블루프린트에서는 C++를 사용하지만 스크래치는 HLSL를 이용한다 Scratch를 만들면 Parameter과 Map이 있다. Parameter Parameter에는 C++처럼 NameSpace들로 구분되어 있다. NameSpace의 종류는 아래와 같이 있다. - SYSTEM : 나이아가라 시스템의 전반적인 상태를 관리하며, 모든 구성 요소에 영향 미침(모든 곳에서 읽을 수 있음)- EMITTER : . 각 발사체 내부에서만 접근할 수 있는 변수들을 포함하며, 다른 발사체에는 영향을 미치지 않음 (Emitter와 particle stages에서 읽을 수 있음)- PARTICLES : 각 파티클에 대해 독립적으로 설정되는 변수들이며, 이 변수들은 다른 파티클에 영향을 미치지 않음 (Paritcle stages에서 읽을 수 있음)- INPUT : 외부 입력에 의해 설정되는 변수 (전역에서 접근 가능)- OUTPUT : 외부로 출력되거나 다른 시스템에 전달될 변수로 (전역에서 접근 가능)- STACKCONTEXT : 모듈 스택 내에서 중간 연산 또는 상태 관리에 사용되며, 그 외의 시스템 요소에서는 접근불가(주로 임시적인 계산이나 상태 저장에 활용)- TRANSIENT : 일시적인 데이터나 상태를 저장하는 데 사용되며, 연산이 끝난 후 사라짐(일반적으로 특정 스크립트나 연산 단위에서만 유효) SYSTEM과 EMITTER에 둘 다 Age라는 변수가 있는데 이를 구분하기 위해서는 NameSpace.변수명 형식으로 사용한다 System.Age, Emitter.Age 그래서 이러한 값들은 Niagara의 모듈들에 의해 값을 수정하는 형태로 있다. Niagara의 모듈을 클릭하고 우측 상단에서 파라미터 읽기/쓰기 표시를 사용하면 이 모듈이 현재 사용하고 있는 Parameter 값들을 알 수 있다. Map Scratch를 생성하고 나면 아래와 같은 창이 뜬다 여기서 Map Get(맵 가져오기)에서 새로운 Parameter를 만들고 기존 Parameter에 있는 값들을 Map Set(맵 설정)수정할 수 있다.예시 Map Get에서 float 변수 하나를 만들고 네이밍을 한 다음 Map Set에서 Parameter를 불러와 그 값으로 적용시킬 수 있다. 위 사진은 float으로 만든 LifeTime이라는 값을 파티클에 있는 LifeTime으로 덮어씌우겠다는 의미 이러고 나서 Niagara로 돌아가서 해당 스크래치를 클릭하면 기존 모듈처럼 Detail에서 입력의 LifeTime의 값을 수정할 수 있다. " }, { "title": "Execution Calculation", "url": "/posts/Execution-Calculation/", "categories": "unreal, GAS", "tags": "unreal", "date": "2024-05-05 00:00:00 +0900", "snippet": "UGameplayEffectExecutionCalculation특징 ModMagnitudeCalculate은 하나의 Attribute만 바꾸는 것이 가능했지만 Execution Calculation은 하나 이상의 Attribute를 바꾸는 것이 가능하다 프로그래밍 로직을 짜서 프로그래머가 원하는대로 적용이 가능해 유연성이 좋다 특징2 Preciton을 지원하지 않는다 Instant와 Perodic Effect만 사용이 가능하다 PreAttributeChange에서 캡쳐가 불가하다 Net Execution Policy가 Local Predicted, Server Initiated, Server Only이여도 서버에서만 실행된다 SnapShotSource SnapShot Capture를 사용하면 GameplayEffectSpec이 생성될 때 Attribute Value를 캡쳐한다. SnapShot Capture를 사용하지 않으면 GameplayEffect가 적용될 때 Attribute Value를 캡쳐한다 Target Target은 Snapshot을 사용하든 안하든 GameplayEffect가 적용될 때 Attribute Value를 캡쳐한다코드UCLASS()class AURA_API UExecCalc_Damage : public UGameplayEffectExecutionCalculation{\tGENERATED_BODY()public:\tUExecCalc_Damage();\tvirtual void Execute_Implementation( const FGameplayEffectCustomExecutionParameters&amp; ExecutionParams, FGameplayEffectCustomExecutionOutput&amp; OutExecutionOutput) const override;\t}; UGameplayEffectExecutionCalculation를 상속받는 클래스를 만들고 GameplayEffect가 적용될 때 실행되는 함수 Execute 함수를 상속받아서 사용하면 된다. ExecutionParams는 커스텀 연산할 때 사용할 파라미터가 저장되어있는 변수이고 OutExecutionOutput는 연산하고 나온 값을 저장하기 위한 참조 변수이다 " }, { "title": "Set By Caller", "url": "/posts/Set-By-Caller/", "categories": "unreal, GAS", "tags": "unreal", "date": "2024-05-03 00:00:00 +0900", "snippet": "Set By Caller Key와 Value로 한 쌍으로 이루어진 Gameplay Tag를 이용하는 방식 사용하기 위해서 UGameplayTagsManager의 AddNativeGameplayTag함수를 이용해서 Tag를 추가 그 다음 UAbilitySystemBlueprintLibrary 라이브러리의 AssignTagSetByCallerMagnitude를 사용해서 // Avatar Actor의 ASC를 가져옴const UAbilitySystemComponent* SourceASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(GetAvatarActorFromActorInfo());// GameplayEffect 클래스인 DamageEffectClass를 받아와서 SpecHandle를 생성const FGameplayEffectSpecHandle SpecHandle = SourceASC-&gt;MakeOutgoingSpec(DamageEffectClass, GetAbilityLevel(),SourceASC-&gt;MakeEffectContext());// Projectile-&gt;DamageEffectSpecHandle = SpecHandle;// 싱글톤 클래스에 저장해둔 태그를 가져와서 해당 SpecHandle에 GameplayTags.Damage(Key)와 50.f(Value)를 전달FAuraGameplayTags GameplayTags = FAuraGameplayTags::Get();UAbilitySystemBlueprintLibrary::AssignTagSetByCallerMagnitude(SpecHandle,GameplayTags.Damage,50.f);DamageEffectClass 설정 그 후 DamageEffectClass의 블루프린트를 열어서 Modifier에서 적용시킬 Attribute를 설정하고, Type을 Set by Caller로 적용한 다음 위에서 전달한 Tag를 선택해주면 Tag가 매칭되어 Value(50.f)값을 가져와서 Attribute에게 적용한다." }, { "title": "Dynamic Parameter", "url": "/posts/Dynamic-Parameter/", "categories": "unreal, Niagara", "tags": "unreal", "date": "2024-04-30 00:00:00 +0900", "snippet": "Dynamic Parameter Niagara에서 Material에 직접 값을 바꾸고 싶을 때 사용 블루프린트는 Material의 값을 바꿀 수 있고 Niagara값도 바꿀 수 있다 하지만 Material에서는 블루프린트,나이아가라의 값을 바꿀 수 없다 정리- Blueprint에서 수정 가능 : Niagara, Material- Niagara에서 수정 가능 : Material- Material에서 수정 가능 : 없음Dynamic Parameter 연결 먼저 Niagara에서 사용하는 Material에서 다음과 같이 Dynamic Parameter를 추가해야 한다In Material Dynamic Parameter 노드를 생성하면 4개의 Parameter을 저장할 수 있는데 이름과 기본 값을 설정할 수 있다. Parameter 이름과 Default Value를 설정하고 나서 그 값들을 동적으로 받아서 사용할 수 있다. 여기서 Parameter Index는 여러 개의 Dynamic Parameter에서 구분하기 위한 값이다. In Niagara Niagara에서는 사용하기 위해서는 모듈로 추가해줘야 한다. 추가하고 나서 Detail에 들어가서 사용하고자 하는 Dynamic Parameter의 Index를 체크표시해주고 그 값들을 설정하면 Material에서 그 값들을 불러와서 사용한다" }, { "title": "Gameplay Ability", "url": "/posts/GameplayAbility/", "categories": "unreal, GAS", "tags": "unreal", "date": "2024-04-28 00:00:00 +0900", "snippet": "Gameplay Ability 스킬이나 능력을 정의하기 위한 클래스 서버에 승인(Grant)되어야 하며 승인되고 나면 해당 정보가 담겨있는 Spec 변수는 클라이언트로 복제(Replicate)된다. Activate/DeActivate로 조절이 가능하며 사용하기 위해선 Activate 상태가 되어야 한다. 비용(Cost)와 쿨타임이 존재한다. Ability들은 비동기적으로 실행되며 여러 Ability가 있다면 한 번에 사용할 수도 있다. Ability는 각자 특별한 무언가를 하기 위해 Ability Task를 사용한다. Policy" }, { "title": "Modifier CustomCalculationClass", "url": "/posts/Modifier-Custom-Calculation-Class/", "categories": "unreal, GAS", "tags": "unreal", "date": "2024-04-28 00:00:00 +0900", "snippet": "Modifier - CustomCalculationClass CustomCalculationClass를 사용하기 위해선 GameplayModMagnitudeCalculate 줄여서 MMC라고 부르는 클래스를 정의해야 한다. 그 안에서 CalculateBaseMagnitude라는 함수를 재정의하여 그 안에서 원하는 대로 계산하는 방식이다. 헤더파일UCLASS()class AURA_API UMMC_MaxHealth : public UGameplayModMagnitudeCalculation{\tGENERATED_BODY()public:\tUMMC_MaxHealth();\tvirtual float CalculateBaseMagnitude_Implementation(const FGameplayEffectSpec&amp; Spec) const override;private:\tFGameplayEffectAttributeCaptureDefinition VigorDef;}; 매개변수에는 FGameplayEffectSpec를 받아 해당 변수를 이용하여 계산에 필요한 값을 이용한다. 그리고 Gameplay effects가 적용된 Gameplay attribute를 캡쳐하여 저장하는FGameplayEffectAttributeCaptureDefinition라는 변수도 선언해야 한다. 소스파일// 생성자UMMC_MaxHealth::UMMC_MaxHealth(){\tVigorDef.AttributeToCapture = UAuraAttributeSet::GetVigorAttribute();\tVigorDef.AttributeSource = EGameplayEffectAttributeCaptureSource::Target;\tVigorDef.bSnapshot = false;\tRelevantAttributesToCapture.Add(VigorDef);} 그리고 생성자에서는 캡처할 Attribute와 CaptureSource를 정해주고 배열에다가 저장해준다. bSnapShot은 바로 Capture하는지에 대한 변수 Default값으론 Effect가 적용될 때 Capture됨 // 함수float UMMC_MaxHealth::CalculateBaseMagnitude_Implementation( const FGameplayEffectSpec&amp; Spec) const{\t// Gather tags from source and target\tconst FGameplayTagContainer* SourceTags = Spec.CapturedSourceTags.GetAggregatedTags();\tconst FGameplayTagContainer* TargetTags = Spec.CapturedTargetTags.GetAggregatedTags();\tFAggregatorEvaluateParameters EvaluationParameters;\tEvaluationParameters.SourceTags = SourceTags;\tEvaluationParameters.TargetTags = TargetTags;\tfloat Vigor = 0.f;\tGetCapturedAttributeMagnitude(VigorDef, Spec, EvaluationParameters, Vigor);\tVigor = FMath::Max&lt;float&gt;(Vigor, 0.f);\tint32 PlayerLevel = 1;\tif (Spec.GetContext().GetSourceObject()-&gt;Implements&lt;UCombatInterface&gt;())\t{\t\tPlayerLevel = ICombatInterface::Execute_GetPlayerLevel( Spec.GetContext().GetSourceObject());\t}\treturn 80.f + 2.5f * Vigor + 10.f * PlayerLevel;} 매개변수의 Spec으로 Source와 Target의 Tag를 가져온다 Capture하기 위해 필요한 FAggregatorEvaluateParameters 변수를 선언하고 Tag들을 저장한다. GetCapturedAttributeMagnitude함수로 Capture한 값을 Vigor 로컬 변수에 참조로 값을 받아온다. 그 다음 Level을 가져와서 Level을 적용하고 곱한다. Blueprint 다음과 같이 Magnitude Calculation Type을 Custom Calculation Class로 바꾸고 그 안에 적용할 클래스를 넣으면 적용된다." }, { "title": "Modifier-AttributeBased", "url": "/posts/Modifier-AttributeBased/", "categories": "unreal, GAS", "tags": "unreal", "date": "2024-04-28 00:00:00 +0900", "snippet": "Modifier AttributeBased 가장 위에 있는 Attribute는 적용받는 Attribute를 지정하는 것이고 Modifier Op는 어떻게 계산할지에 대한 연산(Opeartion)이 있다. Modifier Magnitude에서 Type을 지정해줄 수 있는데 이 장에서는 Attribute Based라는 것으로 다른 Attribute의 값을 사용하는 타입이다. Coefficient부터 Pre,Post Multiply Addtive Value는 다음과 같이 계산된다. Coe * (Value + Pre) + Post Attribute to Capture는 다른 Attribute를 지정한다 Attribute Source는 Target과 Self가 있는데 어떤 캐릭터에게 적용시킬지에 대한 것으로, 이 GameplayEffect를 가진 Actor가 Player에게 Overlap되면 적용시키는 것이므로 Actor-&gt;Player의 뜻으로 Target을 지정한다. 결과전 왼쪽이 GameplayEffect를 가진 Actor, 오른쪽이 Player Character.결과후 Vigor의 값 9가 Health 50에 더해져서 Health가 59가 되었다." }, { "title": "Event && Event Handler", "url": "/posts/Event-&&-Event-Handler/", "categories": "unreal, Niagara", "tags": "unreal", "date": "2024-04-25 00:00:00 +0900", "snippet": "Event &amp;&amp; Event Handler 번개를 내리치는 Emitter가 있는데 그 번개가 내리치는 땅에 다른 Niagara를 생성하고 싶다면 Event를 사용해야 한다. Event와 Event Handler를 이용하면 Niagara가 서로 상호작용이 가능하다. Emitter 하나는 데이터 생성을 담당하고, 다른 Emitter는 그 데이터를 받아 반응하는 식이다. Event 종류 Event 종류에는 다음과 같이 있다. Generate Location Event Generate Collision Event Generate Death Event Event를 사용할 때 주의점은 프로퍼티에서 CPU Sprite만 사용이 가능하다는 것이다. 과정1번 먼저 번개가 떨어지는 Emitter의 프로퍼티를 다음과 같이 변경한다 시뮬레이션 타깃은 반드시 CPUSim이여야 하고 퍼시스턴트 ID 필요를 true로 변경해야 함 2번 그 다음 여기서 사용할 것은 Location이므로 Particle Update에서 Generate Location Event를 추가해준다3번 Location을 받을 Emitter에게는 Handler를 받아야 하므로 프로퍼티의 스테이지에서 추가해준다.4번 그러면 아래에 이벤트 핸들러가 생성되는데 여기서 사용할 이벤트와 사용할 이벤트 종류에 대한 모듈을 추가해줘야 한다. 먼저 이벤트 핸들러 프로퍼티에서는 소스에서는 사용할 이벤트를 설정하고 그 외에는 원하는 방식대로 설정한다 5번 마지막으로 이번에 사용할 종류는 Location이므로 이벤트 핸들러에서 Receive Location Event를 추가해준다.결과 번개가 내리치는 땅 부분에 Particle을 생성할 수 있다" }, { "title": "GameplayTag", "url": "/posts/GameplayTag/", "categories": "unreal, GAS", "tags": "unreal", "date": "2024-04-25 00:00:00 +0900", "snippet": "GameplayTag AbilitySystem에서 사용하는 Tag로, GameplayTagManager에서 관리한다 Tag는 온점(.)으로 child와 parent를 구분해서 종속관계처럼 만들 수 있다 Ability.Fire과 Ability.Ice처럼 Ability가 parent이고 그 아래에 Fire과 Ice가 child인 형태 GameplayTagContainer에 저장되며 GameplayTag를 이용하면 특정 Tag를 가지고 있는 Effect나 Actor에게만 어떤 행위든 적용시키거나 제외할 수 있다. Input, Abilities, Attriubtes, Damage Types, Buffs/Debuffs, Messages, Data등 이 외에도 다른 것들도 가능 에디터에서의 게임플레이태그 GAS를 사용하면 에디터의 프로젝트 세팅를 보면 프로젝트 카테고리에 GameplayTags가 추가되어 있다. 들어가면 게임플레이 태그 관리에 현재 있는 Tag들을 볼 수 있다. 프로젝트세팅-&gt;GameplayTags 에디터에서 추가하기 위해선 게임 플래이 태그 관리를 누르고 검색창 옆의 + 버튼을 누른 다음 원하는 태그를 작성하면 된다.추가전추가후프로젝트 폴더/Config/DefaultGameplayTags.ini 그리고 나서 프로젝트 폴더에 들어가서 Config에 있는 DefaultGameplayTags.ini를 메모장으로 열면 다음과 같이 추가된 걸 볼 수 있다. 여기서 코멘트(DevComment)를 바꾸고 나서 에디터를 재실행하면 코멘트가 바뀌는 것도 볼 수 있다. 가장 아래에 에디터에서 추가했던 Attriubtes.Vital.Health이 있다.데이터 테이블 에디터에서 우클릭-&gt;기타-&gt;데이터테이블하고 다음과 같이 GameplayTagTableRow로 만들어주면 Tag전용 데이터 테이블을 생성할 수 있고 만든 테이블로 프로젝트 세팅에 있는 게임 플레이 태그 테이블 목록에 추가시켜주면 데이터 테이블안에 있는 태그들이 자동으로 게임플레이 태그목록에 들어간다." }, { "title": "GameplayDelegate", "url": "/posts/GameplayDelegate/", "categories": "unreal, GAS", "tags": "unreal", "date": "2024-04-25 00:00:00 +0900", "snippet": "Gameplay Delegate GameplayEffect를 다른 Actor나 Self에게 사용하기 위해선 AbilitySystemComponent(ASC)의 Delegate에 Bind를 해야한다Delegate 선언// AbilitySystemComponent.h/** Delegate for when an effect is applied */\tDECLARE_MULTICAST_DELEGATE_ThreeParams( FOnGameplayEffectAppliedDelegate, UAbilitySystemComponent*, const FGameplayEffectSpec&amp;, FActiveGameplayEffectHandle); 다음과 같이 작동시키는 ASC, 발동시킬 GameplayEffect의 Sepc과 Handle을 받는 Delegate가 선언되어 있다.Delegate 변수// AbilitySystemComponent.h/** Called on server whenever a GE is applied to self. This includes instant and duration based GEs. */FOnGameplayEffectAppliedDelegate OnGameplayEffectAppliedDelegateToSelf;/** Called on server whenever a GE is applied to someone else. This includes instant and duration based GEs. */FOnGameplayEffectAppliedDelegate OnGameplayEffectAppliedDelegateToTarget;/** Called on both client and server whenever a duraton based GE is added (E.g., instant GEs do not trigger this). */FOnGameplayEffectAppliedDelegate OnActiveGameplayEffectAddedDelegateToSelf;/** Called on server whenever a periodic GE executes on self */FOnGameplayEffectAppliedDelegate OnPeriodicGameplayEffectExecuteDelegateOnSelf;/** Called on server whenever a periodic GE executes on target */FOnGameplayEffectAppliedDelegate OnPeriodicGameplayEffectExecuteDelegateOnTarget; 위와 같이 server와 clinet, Self와 Target등에 따라 여러가지 Delegate가 선언되어 있고 목적에 맞는 Delegate에 바인딩 시켜서 브로드캐스트를 하면 된다." }, { "title": "Custom Sprite Alignment", "url": "/posts/Custom-Sprite-Alignment/", "categories": "unreal, Niagara", "tags": "unreal", "date": "2024-04-23 00:00:00 +0900", "snippet": "Custom Sprite Alignment 기본적으로 모든 Sprite는 카메라를 향한 평면을 기준으로 사용된다. 그 때문에 Sprite Renderer로 Niagara를 만든다면 부자연스러운 현상이 발생한다 ex) 땅으로 떨어지는 번개가 바닥을 치지 않고 화면을 기준으로 위에서 아래로 내려옴 그 상황을 바로 잡기 위해 설정을 바꿔야 하는데 방법이 2가지가 있다. Sprite Renderer에 있는 Alignment와 Facing Mode가 있다 하지만 여기서는 Alignment을 다룬다 과정 먼저 Sprite Renderer에서 Alignment의 속성 값을 Custom Alignment로 변경해준다 그 이후에 Particle Spawn에 있는 Sprite Facing and Alignment를 추가한다 Sprite Facing은 Facing Mode가 Custom Facing Vector일 때 적용되는 속성이다 하지만 여기서 사용할 내용은 Alignment이기 때문에 이 장과 관련이 없다 다음은 Sprite Alginment은 Alignment가 Custom Alignment일 때 적용되는 속성이다 이 설정한 벡터 값으로 Sprite가 정렬된다. " }, { "title": "PostGameplayEffectExecute", "url": "/posts/PostGameplayEffectExecute/", "categories": "unreal, GAS", "tags": "unreal", "date": "2024-04-23 00:00:00 +0900", "snippet": "PostGameplayEffectExecute Attribute의 기본값을 수정하기 위해 GameplayEffect가 실행되기 직전에 호출되는 함수 속성의 기본값을 수정할 때처럼 오직 실행중에만 호출되기 때문에, 만약 몇초동안 어떤 버프를 주는 그런 GameplayEffect가 적용될 때는 호출되지 않는다 " }, { "title": "PreAttributeChange", "url": "/posts/PreAttributeChange/", "categories": "unreal, GAS", "tags": "unreal", "date": "2024-04-22 00:00:00 +0900", "snippet": "PreAttributeChange UAttributeSet에 있는 가상함수 Attribute의 Current Value의 값을 바꾸기 전에 호출되는 함수 PreAttributeModify/PostAttribute modify보다 LowLevel임. 이 함수에서 어떤 것이든 발동시킬 수도 있기 때문에 막기 위해 추가적인 Context을 제공하지는 않는다 Effect발동, Duration기반 Effect, Stacking 변화, Effect제거 등등. 위와 같은 항목들보다는 Health = Clamp(Health, 0, MaxHealth) 같이 속성 값을 단순히 제한하는 등의 단순한 검증을 수행하는 함수이다. 나중에 PostGameplayEffectExecute에서 복잡한 처리를 한다. " }, { "title": "Stacking", "url": "/posts/Stacking/", "categories": "unreal, GAS", "tags": "unreal", "date": "2024-04-21 00:00:00 +0900", "snippet": "Stacking 어떤 버프 또는 디버프(,이 경우 게임플레이 이펙트)를 가진 대상에게 다시 적용하는 것은 물론 어떤 상황을 처리하는 정책 이전 장에서 만든 포션처럼 GameplayEffect Actor를 만들어서 사용하면 되는데 만약 여러 개를 동시에 먹으면 그 효과가 중첩되어 포션의 회복량이 그만큼 늘어나게 된다. 이렇게 중첩되는 효과보단 하나씩 처리하기 위해 사용하는 옵션이 Stacking이다 Stacking DetailStacking Type 기본적으로 None이며 다른 옵션은 Aggregate by Source , Aggregate by Target이 있다. 포션같이 영향을 주는 SourceActor와 포션을 먹으면 피가 차는 것 같이 영향을 받는 TargetActor가 있다고 가정한다. 이 때 Aggregate by Source는 이 SourceTarget이 주는 영향을 의미한다. Aggregate by Target는 TargetActor가 받는 영향을 의미한다. Stack Limit Count 한 번에 적용할 수 있는 Effect의 개수를 의미한다. 만약 Type이 Aggregate by Source이라면, 각각의 SourceTarget이 하나의 TargetActor에게 Stack Limit Count만큼 줄 수 있다. SourceTarget이 2개,Stack Limit Count가 2라면 총 4번의 영향을 줄 수 있음 만약 Type이 Aggregate by Target이라면, 하나의 TargetActor가 받을 수 있는 영향을 의미한다 SourceTarget이 2개,Stack Limit Count가 2여도, Target기준이므로 2번의 영향만 받음 Stack Duration Refresh Policy 같은 GameplayEffect를 Stack에 추가할 때, 현재 처리되고 있는 GameplayEffect의 Duration을 처리하는 정책(Policy)종류 Refresh on Successful Apllication Never Refresh Stack Period Reset Policy 다른 GameplayEffect으로 Stack이 들어올 때, 현재 처리되고 있는 GameplayEffect의 Period를 Reset할지를 결정하는 정책(Policy)종류 Refresh on Successful Apllication Never Refresh Stack Expiration Policy 모든 Stack이 끝날 때 처리하는 정책종류 Clear Entire Stack Remove Single Stack and Refresh Duration Refresh Duration " }, { "title": "Instant Gameplay Actor", "url": "/posts/Instant-Gameplay-Actor/", "categories": "unreal, GAS", "tags": "unreal", "date": "2024-04-20 00:00:00 +0900", "snippet": "Potion(ApplyEffectActor) 생성 이전 장에서의 클래스 ApplyEffectActor로 만든 Blueprint를 만든다 그 다음에 Blueprint로 ApplyEffectToTarget 함수를 호출하여 충돌할 때 발생할 GameplayEffect 종류를 설정하면 된다 여기서 만들 포션은 한번 회복하고 끝인 형태이므로 Instant 버전으로 만들고 만약 몇초동안 조금씩 차는 형태라면 Duration 형태로 만들면 된다. GameplayEffect 클래스 생성 이제 위에서 Instant Gameplay Effect Class에 적용할 Blueprint를 만들면 된다. 이 Blueprint에서는 실제 포션의 회복량, 적용할 Attribute를 설정한다 아래와 같이 Duration Policy에는 Instant 적용 포션은 HP를 회복하는 아이템이므로 Attribute에는 따로 생성해준 Health변수 적용 Modifier OP는 단순히 값을 더하는 형태이므로 Add Modifier Magnitude에서는 HP를 회복하기 위한 방법들이 여러가지 있는데 단순하게 사용하기 위해서Scalable Float를 설정하고 그 밑에는 값(HP 회복량)을 설정해주면 된다. " }, { "title": "GenerateBand", "url": "/posts/GenerateBand/", "categories": "unreal, Niagara", "tags": "unreal", "date": "2024-04-19 00:00:00 +0900", "snippet": "GenerateBand 가로 or 세로 Band을 가진 텍스쳐 이 텍스쳐를 이용해서 끝 부분쪽의 Opacity를 낮추는데 사용할 수 있다. GenerateBand 텍스쳐 기존의 GenerateBand Width를 수정하여 크기를 조정" }, { "title": "ApplyEffectActor", "url": "/posts/ApplyEffectActor/", "categories": "unreal, GAS", "tags": "unreal", "date": "2024-04-19 00:00:00 +0900", "snippet": "Duration Policy Instant : 일회성 행동 Duration : 일정 시간동안 적용 Infinite : 무한 Effect 관련 변수 설정 EffectActor는 충돌해서 효과를 적용하기 때문에 그와 관련된 변수들을 제작// 충돌 상태의 Enum classUENUM(BlueprintType)enum class EEffectApplicationPolicy : uint8{\tApplyOnOverlap,\tApplyOnEndOverlap,\tDoNotApply};// 삭제 관련의 Enum classUENUM(BlueprintType)enum class EEffectRemovalPolicy : uint8{\tRemoveOnEndOverlap,\tDoNotRemove};// Instant형식UPROPERTY(EditAnywhere, BlueprintReadOnly, Category= \"Applied Effects\")TSubclassOf&lt;UGameplayEffect&gt; InstantGameplayEffectClass;UPROPERTY(EditAnywhere, BlueprintReadOnly, Category= \"Applied Effects\")EEffectApplicationPolicy InstantEffectApplicationPolicy = EEffectApplicationPolicy::DoNotApply;/* Duration,Infinite도 위 Instant 2개 변수와 똑같이 선언, 길어서 생략*/// 지워야 할 Effect 객체들을 저장하는 Map 자료구조TMap&lt;FActiveGameplayEffectHandle, UAbilitySystemComponent*&gt; ActiveEffectHandles;Effect를 다른 액터에게 적용하는 함수 GameplayEffect를 다른 Actor에게 적용하려면 우선 해당 Actor가 ASC를 갖고 있는지 확인해야 한다. 그 다음에는 GAS에서 제공하는 함수들로 적용한다 void AAuraEffectActor::ApplyEffectToTarget(AActor* TargetActor, TSubclassOf&lt;UGameplayEffect&gt; GameplayEffectClass){\t// Get ASC\tUAbilitySystemComponent* TargetASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(TargetActor);\tif(TargetASC == nullptr) return;\tcheck(GameplayEffectClass);\t // MakeEffectContext : Effect에 관련된 정보를 가지고 있는 Context를 생성\tFGameplayEffectContextHandle EffectContextHandle = TargetASC-&gt;MakeEffectContext(); // AddSourceObject : Effect가 만들어지게 된 원인 객체를 설정\tEffectContextHandle.AddSourceObject(this); // MakeOutgoingSpec : Effect에 필요한 Spec을 만드는 함수\tconst FGameplayEffectSpecHandle EffectSpecHandle = TargetASC-&gt;MakeOutgoingSpec(GameplayEffectClass,ActorLevel,EffectContextHandle);\t// ApplyGameplayEffectSpecToSelf : 스스로에게 Effect를 적용하는 함수\tFActiveGameplayEffectHandle ActiveEffectHandle = TargetASC-&gt;ApplyGameplayEffectSpecToSelf(*EffectSpecHandle.Data.Get()); // Infinite Effect중 지워야 하는 객체들을 추가\tconst bool bIsInfinite = EffectSpecHandle.Data.Get()-&gt;Def.Get()-&gt;DurationPolicy == EGameplayEffectDurationType::Infinite;\tif(bIsInfinite &amp;&amp; InfiniteEffectRemovalPolicy == EEffectRemovalPolicy::RemoveOnEndOverlap)\t{\t\tActiveEffectHandles.Add(ActiveEffectHandle, TargetASC);\t}}Effect 충돌Overlap 위에서 만든 변수들로 충돌할 때 Enum class로 충돌 타입인지를 확인하고 적용한다void AAuraEffectActor::OnOverlap(AActor* TargetActor){\tif(InstantEffectApplicationPolicy == EEffectApplicationPolicy::ApplyOnOverlap)\t{\t\tApplyEffectToTarget(TargetActor, InstantGameplayEffectClass);\t}\t/* Duration,Infinite도 위 Instant와 똑같이 설정, 길어서 생략 */}EndOverlap Overlap과 마찬가지로 EndOverlap에서도 확인하고 지워야할 Effect가 있다면 찾아서 지워주는 작업을 한다.void AAuraEffectActor::OnEndOverlap(AActor* TargetActor){\tif(InstantEffectApplicationPolicy == EEffectApplicationPolicy::ApplyOnEndOverlap)\t{\t\tApplyEffectToTarget(TargetActor, InstantGameplayEffectClass);\t}\t/* Duration,Infinite도 위 Instant와 똑같이 설정, 길어서 생략 */\t\tif(InfiniteEffectRemovalPolicy == EEffectRemovalPolicy::RemoveOnEndOverlap)\t{\t\tUAbilitySystemComponent* TargetASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(TargetActor);\t\tif(!IsValid(TargetASC)) return;\t\tTArray&lt;FActiveGameplayEffectHandle&gt; HandlesToRemove;\t\tfor (TTuple&lt;FActiveGameplayEffectHandle, UAbilitySystemComponent*&gt; HandlePair : ActiveEffectHandles)\t\t{\t\t\tif(TargetASC == HandlePair.Value)\t\t\t{\t\t\t\tTargetASC-&gt;RemoveActiveGameplayEffect(HandlePair.Key, 1);\t\t\t\tHandlesToRemove.Add(HandlePair.Key);\t\t\t}\t\t}\t\tfor(auto&amp; Handle : HandlesToRemove)\t\t{\t\t\tActiveEffectHandles.FindAndRemoveChecked(Handle);\t\t}\t}}" }, { "title": "노이즈 텍스쳐 만들기", "url": "/posts/%EB%85%B8%EC%9D%B4%EC%A6%88-%ED%85%8D%EC%8A%A4%EC%B3%90-%EB%A7%8C%EB%93%A4%EA%B8%B0/", "categories": "unreal, Niagara", "tags": "unreal", "date": "2024-04-15 00:00:00 +0900", "snippet": " 랜덤으로 Noise Texture를 만들기 위한 방법 이 장에서 만드는 Noise는 Perlin Noise라 한다. Material, RenderTarget 생성 먼저 사용할 Material과 Render Target을 생성해준다. 그리고 셰이딩 모델은 unlit으로 설정한다 Material 그래프 언리얼에서 제공하는 Noise Node를 사용하여 임의의 Noise값들을 생성 RandomSeed는 float4 파라미터를 통해서 생성된 Noise를 조절 CheapConst과 EdgeSharpness 파라미터는 선명도를 조절하기 위해 사용Material Node들 설정 그다음 Material 에서 우클릭 -&gt; Noise로 Noise Node를 생성하고 클릭해서 다음과 같이 설정한다 타일링은 True, 터뷸런스는 False Scale은 노이즈 셀의 크기를 결정하는 값으로, Repeat Size와 동일하게 맞춰준다 Levels는 흐릿함 정도를 나타내는 값 Output Min,Max는 UV와 맞춰주기 위해 0, 1로 설정 Material Instance 생성 Material의 Instance를 생성한다 그러면 파라미터값을 조절해서 원하는 Noise Texture를 만들 수 있다. 이 Noise를 Texture로 만들려면 Baking을 해야 하는데 그 전에 RenderTarget 설정부터 한다. RenderTarget 설정 처음에 만들었던 RenderTarget의 디테일에서 다음과 같이 변경한다 X크기 ,Y크기는 사용할 텍스쳐 크기로 원하는 크기로 조절한다 렌더 타겟 포맷을 RTF RGBA8 SRGB로 바꿔준다. Baking 나중에.." }, { "title": "TSubclassOf && SpawnActor && SpawnActorDeferred", "url": "/posts/TSubclassOf-&&-SpawnActor-&&-SpawnActorDeferred/", "categories": "unreal, Unreal Etc", "tags": "unreal", "date": "2024-04-15 00:00:00 +0900", "snippet": "TSubclassOf UClass 유형의 안전성을 보장해 주는 템플릿 클래스 TSubclassOf를 사용하면 템플릿 클래스를 상속받는 클래스를 지정해줄 수 있다. // AActor를 상속받는 모든 클래스를 Detail창에서 지정할 수 있음UPROPERTY(EditDefaultsOnly)TSubclassOf&lt;AActor&gt; ActorClass;SpawnActor Actor를 World에 배치하는 템플릿 함수로 GetWorld()로 호출할 수 있다. C++에서 BP 객체를 생성하기 위해서 TSubclassOf와 같이 사용한다 // 생성할 class or BP UPROPERTY(EditDefaultsOnly)TSubclassOf&lt;AActor&gt; TestActorClass;// 저장할 포인터UPROPERTY(VisibleAnywhere)AActor* TestActor;// 사용FVector ActorLocation = FVector::ZeroVector;FRotator ActorRotator = FRotator::ZeroRotator;// 템플릿에는 클래스, 파라미터는 TSubclassOf 클래스, 위치, 회전 순으로 넣어준다GetWorld()-&gt;SpawnActor&lt;AActor&gt;(TestActorClass,ActorLocation,ActorLocation);SpawnActorDeferred SpawnActorDeferred와 SpawnActor의 다른점은 FinishSpawning 함수를 호출하는지 안하는지의 차이이다. SpawnActor는 바로 월드에 배치하는 반면에, SpawnActorDeffered함수는 원하는 오브젝트의 객체를 생성하고 액터의 FinishSpawning함수를 호출 할 때에만 월드에 배치한다. " }, { "title": "Control Rig 기초", "url": "/posts/Control-Rig-%EA%B8%B0%EC%B4%88/", "categories": "unreal, ControlRig", "tags": "unreal", "date": "2024-04-13 00:00:00 +0900", "snippet": "컨트롤릭 엔진에서 바로 캐릭터를 애니메이팅하는 언리얼 엔진의 솔루션 Mesh에 있는 Bone을 움직이거나 Bone의 위치,회전 정보등으로 LineTrace하는 데에 사용한다 컨트롤 릭 생성 우클릭-&gt;애니메이션-&gt;컨트롤릭으로 생성할 수 있다 만약 이전에 생성해둔 다른 컨트롤릭이 없다면 기존의 블루프린트 컨트롤릭이 하나 있는데 그것을 base로 생성하면 된다 컨트롤 릭 초기화 처음 만들고 나서 왼쪽 아래에 릭 계층구조에 있는 Import Hierarchy를 누르면 Mesh를 누르는 창이 뜨는데 사용할 Mesh를 넣어주면 된다.컨트롤 릭 사용 Foot Bone에 다가가서 그 값으로 Line Trace를 해보겠다. 먼저 우클릭 -&gt; Get Transform으로 Bone에 다가가기 위한 함수를 호출한다. 그 안에 이름이 있는데 사용할 Bone의 이름을 찾아준다. 이 때 실제 bone이 아닌 ik(가상) bone을 사용해서 실제 Bone은 수정되지 않고 ik bone에 의해서 수정되게끔 하는 것이 좋다 나중에 실제 bone을 움직이고 난다면 나중에 수정할 때 어려워질 수도 있기 때문 그래서 ik Foot Bone에 넣어서 위치값을 구하고 그 위치값에서 빼기,더하기로 LineTrace의 Start,End 위치를 구한 다음 DrawLine 함수로 그려준다. 부딪히는 위치를 그리고 싶다면 다음과 같이 Trace로 Hit Location을 구하고 Draw Transform으로 그려주면 된다결과 Draw Line Draw Transform공식 문서 https://dev.epicgames.com/documentation/ko-kr/unreal-engine/control-rig-in-unreal-engine" }, { "title": "소유권 공유 자원 관리에는 shared_ptr를 사용하라", "url": "/posts/19.Use-shared_ptr-for-shared-ownership-resource-management/", "categories": "Modern Effective C++", "tags": "modern effective c++", "date": "2024-04-13 00:00:00 +0900", "snippet": " 자동으로 작동하면서 모든 종류의 자원에 적용하며 그 시점을 예측할 수 있는(소멸자처럼) 자원 관리 시스템을 위한 것이 shared_ptr이다.shared_ptr shared_ptr를 통한 객체의 수명은 객체에 접근한 shared_ptr들의 수명에 의해 결정된다. 객체가 가리키던 마지막 shared_ptr가 객체를 더이상 가리키게 되지 않는다면, shared_ptr는 자신이 가리키는 객체를 파괴한다. 참조 횟수(reference counter) shared_ptr는 자신이 객체를 가리키는 최후의 공유 포인터임을 아는 방법은 바로 참조 횟수이다 참조 횟수는 그 자원이 가리키는 shared_ptr들의 개수에 해당한다 shared_ptr의 생성자가 참조횟수를 증가시키고, 소멸자는 감소시킨다 복사 대입 연산자는 증가,감소 둘 다 수행한다. sp1 = sp2 이런 식이면, sp1이 가리키던 참조 횟수는 감소하고 sp2가 가리키는 참조 횟수는 증가된다 shared_ptr가 자원의 참조 횟수를 감소한 후, 그 횟수가 0이 되었다면 그 자원을 가리키는 shared_ptr가 없다는 뜻으로 그 자원을 파괴한다. 참조 횟수 관리 성능 shared_ptr의 크기는 raw 포인터의 두배이다 내부적으로 자원을 가리키는 raw 포인터뿐만 아니라 자원의 참조 횟수를 가리키는 raw 포인터도 저장해야 하기 때문 참조 횟수를 담을 메모리는 반드시 동적 할당 해야 한다. 개념적으로 참조 횟수는 공유 포인터가 가리키는 객체에 연관되지만, 그 객체는 참조 횟수를 전혀 알지 못한다 따라서 객체는 참조 횟수를 담을 장소를 따로 마련하지 않는다. 항목 21에서 설명하지만, make_shared로 shared_ptr를 생성하면 동적할당 비용을 피할 수 있다. 다만 make_shared를 사용할 수 없는 상황도 존재한다` 참조 횟수의 증감은 반드시 원자적 연산이어야 한다. 여러 스레드가 참조 횟수를 동시에 읽고 쓰기 위함 shared_ptr의 생성자가 참조횟수를 증가시키지 않는 경우 그것은 바로 이동 생성이다 기존의 shared_ptr를 이동해서 새 shared_ptr를 생성하면 원본 shared_ptr는 nullptr이 된다 즉, 새로운 shared_ptr의 수명이 시작되는 시점에서 기존 shared_ptr는 자원을 가리키지 않는 상태가 된다 이런 경우, 복사보다 이동이 빠르다 shared_ptr의 커스텀 삭제자 unique_ptr처럼 delete를 기본적인 자원 파괴 매커니즘으로 사용하고 있으며, 커스텀 삭제자를 지원한다 하지만 구체적인 방식은 다른데, unique_ptr에서는 삭제자 형식이 스마트 포인터의 형식의 일부였지만, shared_ptr는 그렇지 않다 // 커스텀 삭제자auto logginDel = [](Widget* pw) { makeLogEntry(pw) ; delete pw; };// 삭제자 형식이 포인터 형식의 일부임unique_ptr&lt;Widget,decltype(loggingDel)&gt; upw(new Widget, loggingDel);// 삭제자 형식이 포인터 형식의 일부가 아님shared_ptr&lt;Widget&gt; spw(new Widget, loggingDel); shared_ptr는 사용하는 커스텀 삭제자의 형식을 서로 다르게 해도, 같은 형식으로 사용할 수 있어서 그 형식의 객체를 담는 컨테이너 안에 넣을 수 있어서 설계적으로 유연하다// 서로 다른 커스텀 삭제자auto customDeleter1 = [](Widget* pw) {...};auto customDeleter2 = [](Widget* pw) {...};// 를 이용한 서로 다른 shared_ptrshared_ptr&lt;Widget&gt; pw1(new Widget, customDeleter1);shared_ptr&lt;Widget&gt; pw2(new Widget, customDeleter2);// 를 담는 컨테이너vector&lt;shared_ptr&lt;Widget&gt;&gt; vpw { pw1, pw2 }; 또다른 unique_ptr과의 차이점은 커스텀 삭제자를 지정해도 shared_ptr 객체의 크기가 변하지 않는다 삭제자와 무관하게 shared_ptr의 크기는 항상 포인터 두 개 분량이다 하지만 함수 객체를 커스텀 삭제자로 사용할 수 있다는 점 + 함수 객체가 임의의 분량 자료를 담을 수 있다는 점을 생각하면, 커스텀 삭제자가 얼마든지 커질 수 있다는 결론이 나온다 그래서 shared_ptr이 임의의 크기의 삭제자를 추가적인 메모리 없이 지칭하는 비결은 무엇이냐 하면 사실 그런 것은 없다 단, 그 메모리가 shared_ptr의 일부가 아닐 뿐이다 추가 메모리는 힙에 할당되며, shared_ptr객체의 생성자가 shared_ptr의 커스텀 할당자 지원을 활용하는 경우에는 그 할당자가 관리하는 메모리가 쓰인다 shared_ptr객체가 자신이 가리키는 객체에 대한 참조횟수를 가리키는 포인터도 담는다고 했는데 사실 참조 횟수는 제어 블록이라 부르는 더 큰 자료구조의 일부이다 제어 블록(Control Block) shared_ptr가 관리하는 객체당 하나의 제어 블럭이 존재한다 이 안에는 참조 횟수, 약한 횟수(항목 21), 커스텀 삭제자(사용했으면) 등 이 있다 객체의 제어 블록은 shared_ptr가 생성될 때 설정된다 제어블록의 생성 여부에 관해 다음과 같은 규칙을 유추할 수 있다. 제어 블록의 규칙 make_shared는 항상 제어블록을 생성한다 공유 포인터가 가리킬 객체를 새로 생성하므로, make_shared가 호출되는 시점에서 그 객체에 대한 제어 블록이 존재할 가능성은 전혀 없다 고유 소유권 포인터(unique_ptr)로부터 shared_ptr 객체를 생성하면 제어 블록이 생성된다 unique_ptr은 제어 블록을 사용하지 않아,그전에 이미 존재할 가능성은 없다. raw 포인터로 shared_ptr 생성자를 호출하면 제어 블록이 생성된다 이미 제어 블록이 있는 객체로부터 shared_ptr를 생성하고 싶다면, raw 포인터가 아닌 shared_ptr나 weak_ptr를 생성자의 인수로 지정하면 된다. shared_ptr나 weak_ptr를 받는 shared_ptr 생성자들은 새로운 제어 블록을 만들지 않는다 shared_ptr의 생성자에 raw 포인터를 사용하는 것은 피하자 위의 규칙들에서 비롯되는 한가지 결과는, 하나의 raw 포인터로 여러 개의 shared_ptr를 생성하면 가리켜지는 객체에 여러 개의 제어 블록이 생성되어 미정의 행동이 된다. 제어 블록이 여러 개라는 것은 참조 횟수 또한 여러 개라는 것이며, 객체 또한 여러 번 파괴된다 auto pw = new Widget;// 첫 번째 제어블록 생성shared_ptr&lt;Widget&gt; spw1(pw, loggingDel);// 두 번째 제어블록 생성shared_ptr&lt;Widget&gt; spw2(pw, loggingDel); 이러한 잘못된 용법에서 배울 점은 두 가지가 있다.배울 점 shared_ptr의 생성자에 생 포인터를 넘겨 주는 것은 피하자 대안은 make_shared를 사용하자 커스텀 삭제자를 사용하는 경우 make_shared를 호출할 수 없는데, 이 경우 raw 포인터를 사용할 수 밖에 없다 shared_ptr 생성자를 raw 포인터로 호출할 수 밖에 없는 상황에는 raw 포인터 변수를 거치지 말고 new의 결과로 직접 전달하자 그러면 같은 raw 포인터로 다른 shared_ptr의 생성자에 사용하는 경우가 없어진다 결론 이것만은 잊지 말자! shared_ptr는 임의의 공유 자원의 수명을 편리하게 관리할 수 있는 수단을제공한다 대체로 shared_ptr 객체는 그 크기가 unique_ptr 객체의 두배이며,제어 블록에 관련된 추가 부담을 유발하며, 원자적 참조 횟수 조작을요구한다 자원은 기본적으로 delete를 통해 파괴되지만, 커스텀 삭제자를 지원한다삭제자 형식은 shared_ptr의 형식에 아무 영향도 끼치지 않는다 raw 포인터 형식의 변수로부터 shared_ptr를 생성하는 일은 피해야 한다. " }, { "title": "Gameplay Effects", "url": "/posts/Gameplay-Effects/", "categories": "unreal, GAS", "tags": "unreal", "date": "2024-04-12 00:00:00 +0900", "snippet": "Gameplay Effects UGameplayEffect타입의 객체로, Attribute값이나 Tag를 바꿀 때 사용하는 클래스 데이터로만 이루어져 있고, Modifiers 과 Executions으로 Attribute 값을 바꿀 수 있다. Modifier 게임 플레이나, Attribute 값이 바뀔 때 사용되는 복잡한 계산등 다양한 종류가 있다. Modifier은 magnitude(크기)라는 값을 가지고 이 값으로 연산에 따라 Attribute값을 수정한다. Modifier Operator Add 값을 더하는 연산 Multiply 값을 곱하는 연산 Divide 값을 나누는 연산 Overide magnitude에 주어진 값으로 Attribute값을 설정한다. magnitude는 위의 4가지 연산을 가지고 Modifier CalculateModifier Calculation Type Scalable float magnitude값 혹은 Data Table에 의한 값에 의한 설정 Attribute Based 다른 Attribute에 기반하여 계산하는 타입 ex) Strength란 값에 따라 Damage가 바뀜 Custom Calculation Class(MMC) 값을 위한 전용 클래스 Set by Caller Key,Value 형식 Key에는 Name이나 Gameplay Tag으로 사용할 수 있다 Execution 하나 이상의 Attribute를 바꿀 수 있고 코딩하기에 따라 원하는 방식으로 설정 가능한 강력한 방법Duration Policy Instant 일회성 행동 Has Duration 제한된 시간 동안 적용 Infinite 무한 Stacking 어떤 버프 또는 디버프(,이 경우 게임플레이 이펙트)를 가진 대상에게 다시 적용하는 것은 물론 어떤 상황을 처리하는 정책Add Gameplay Tags 게임 플레이 태그를 이용해서 사용하는 방법Grant AbilitiesGameplay Effect Spec Gameplay Effect의 경량화, 즉 최적화 버전" }, { "title": "움직이는 애니메이션 제자리에서 실행하기(With RootMotion)", "url": "/posts/%EC%9B%80%EC%A7%81%EC%9D%B4%EB%8A%94-%EC%95%A0%EB%8B%88%EB%A9%94%EC%9D%B4%EC%85%98-%EC%A0%9C%EC%9E%90%EB%A6%AC%EC%97%90%EC%84%9C-%EC%8B%A4%ED%96%89%ED%95%98%EA%B8%B0(With-RootMotion)/", "categories": "unreal, ControlRig", "tags": "unreal", "date": "2024-04-12 00:00:00 +0900", "snippet": " 이번 장은 Root bone은 한 곳에 고정된 채 다른데에서 움직이는 애니메이션을 Root bone의 중심으로 이동시키기 위한 장1. 컨트롤 릭 굽기 먼저 사용할 애니메이션을 클릭한다 그 다음 우측 상단 시퀀스에서 편집을 클릭한 다음 컨트롤 릭에 굽기를 누른 다음 CR_Mannequin_Body를 클릭한다 CR_Mannequin_Body는 프로젝트를 만들 때 자동으로 제공해줌 아무래도 스켈레톤 메쉬가 다르면 해당 스켈레톤 매쉬의 CR이 필요함. 때문에 기본 스켈레톤 메쉬로 애니메이션을 제작한 후, 컨트롤 릭을 통해 다른 스켈레톤 메쉬로 옮기는 것이 좋아보임 그 후에 컨트롤릭에 굽기를 클릭하면 레벨 시퀀스가 생성된다2. 레벨 시퀀스 설정 생성하면 다음과 같이 생성된 시퀀스가 보이는데 아래에 있는 2개의 트랙 CR_Mannequin_Body 중 Key(동그라미)가 없는 트랙을 삭제해준다. 그래야 애니메이션이 움직임 삭제하고 나서 Key가 존재하는 트랙에서 root_ctrl을 찾은 다음 아래와 같이 드래그해서 파란색인 곳의 Key들을 전부 삭제한다 내가 지정하는 프레임에 Key를 넣어서 내가 원하는 위치와 회전을 root bone에 적용시키기 위함 그 이후에 root_ctrl의 오른쪽에 있는 +버튼으로 root bone의 위치를 정해줄 수 있다.3. root bone 위치 정하기 이 애니메이션은 root_ctrl의 위치가 처음에는 바닥에 있는 형태이다 root_ctrl의 Key를 넣어줄 특정 프레임에서 root_ctrl을 움직이고 난 후 아까 위에서 보았던 +버튼키를 눌러주면 된다 그러면 아래와 같이 빨간색 원으로 해당 프레임의 root_ctrl의 회전과 위치값을 설정해줄 수 있다. 채워지지 않는 프레임들은 가장 가까운 2개의 키 root_ctrl값들에 의해 보간되어 자연스럽게 움직인다 4.링크된 애니메이션 시퀀스 생성 그러고 나서 다음과 같이 우클릭하고 나서 링크된 애니메이션 시퀀스 생성을 클릭한다 그러면 애니메이션을 저장할 폴더와 이름이 나오는데 원하는대로 설정하고 그 이후에 아래와 같이 옵션이 뜨는데 이 역시 그냥 애니메이션 시퀀스 익스포트를 눌러도 무방하다 그러면 루트본이 움직이는 형태의 애니메이션이 생성되는데 이 루트본의 위치를 중심으로 하는 제자리 애니메이션으로 바꾸기 위해서는 해당 애니메이션의 디테일창으로 들어가 루트 모션 활성화를 True로 바꿔주면 된다." }, { "title": "UV 조작", "url": "/posts/UV-%EC%A1%B0%EC%9E%91/", "categories": "unreal, Niagara", "tags": "unreal", "date": "2024-04-11 00:00:00 +0900", "snippet": "UV 채널 스태틱 메시 내 데이터 세트로, 각 메시의 버텍스를 2D 스페이스 좌표에 매핑한다 U는 텍스쳐의 가로축, V는 텍스쳐의 세로축을 가리킨다 텍스처 좌표는 보통 0~1 사이로 유지되며 (0,0)은 텍스처의 왼쪽 하단을 나타내고 (1,1)은 오른쪽 상단을 나타낸다. U 또는 V 의 값이 1 초과, 0 미만 경우, 텍스쳐의 다른 면을 래핑하게 된다 예를 들어 V의 값 1.25는 0.25로 취급된다. 머티리얼에서 UV 조절하기기본 텍스쳐 먼저 사용할 기본 텍스쳐는 다음과 같다UVTile UVTile은 TexCoord(텍스쳐 좌표)를 임의의 값을 곱해서 확대,축소를 할 수 있는 개념이다 기본적인 TexCoord의 범위는 0 ~ 1인데 곱하기2 를 하면 0 ~ 2가 된다 UVTile 값이 2가 되면 다음과 같이 된다 UVOffset UVOffset은 U 혹은 V의 값을 조절하여 텍스쳐를 움직이는 개념이다 U가 0.5, V는 0일 경우 (가로 이동) U가 0, V가 0.5일 경우 (세로 이동) U가 0.5, V가 0.5일 경우 (가로, 세로 둘 다 이동)" }, { "title": "Sub UV Animation", "url": "/posts/Sub-UV-Animation/", "categories": "unreal, Niagara", "tags": "unreal", "date": "2024-04-09 00:00:00 +0900", "snippet": "Sub UV Animation 여러 개의 그림이 같은 크기로 있는 텍스쳐에 사용하기 위한 모듈 Particle Update에서 추가할 수 있다. 예시 사진 가로로 8개, 세로로 8개의 그림이 있는 텍스쳐.과정1.Sprite Render Render에서 Sprite Render를 추가한다. 그 다음 Material에 사용할 UV Texture를 넣어주고 Detail에서 Sub Image Size에서 가로,세로로 자를 개수를 적어준다. 2.Sub UV Animation Particle Update에서 Sub UV Animation을 추가한다 Detail에서 Source에서 Sprite Render를 추가하고 맨 위에 Start Frame과 End Frame을 지정해준다. 위 사진은 8*8 형식의 텍스쳐이므로 0 ~ 63 (총 64개)로 짤라서 사용한다. 더 빠르게 재생하기 위해선 배수로 늘려주면 된다 (64개이므로 0~127 등) " }, { "title": "소유권 독점 자원의 관리에는 unique_ptr를 사용하라", "url": "/posts/18.Use-unique_ptr-for-exclusive-ownership-resource-management/", "categories": "Modern Effective C++", "tags": "modern effective c++", "date": "2024-04-09 00:00:00 +0900", "snippet": "unique_ptr unique_ptr는 raw 포인터와 같은 크기는 아니지만, 같은 크기라고 가정하는 것이 비합리적인 일은 아니며, 대부분의 연산은 raw 포인터와 정확히 동일한 명령들을 실행한다. nullptr이 아닌 unique_ptr은 항상 자신이 가리키는 객체를 소유하고 이동하면 소유권이 원본 포인터에서 대상 포인터로 옮겨진다. unique_ptr은 복사가 허용되지 않아 이동 전용 형식이다. 예시 unique_ptr의 흔한 용도는 계통구조 안의 객체를 생성하는 팩토리 함수의 반환 형식으로 사용된다.class Investment { ... };class Stock : public Investment { ... };class Bond : public Investment { ... }; 이런 계통구조의 팩토리 함수는 흔히 힙에 객체를 생성하고 객체를 가리키는 포인터를 돌려준다. unique_ptr를 사용하면 객체가 더 이상 필요하지 않게 되었을 때 자동으로 삭제하기 때문에 흔히 사용된다. // 팩토리 함수template&lt;typename... Ts&gt;unqiue_ptr&lt;Investment&gt; makeInvestment(Ts&amp;&amp; ... params);{ ... // unique_ptr&lt;Investment&gt; 형식 auto pInvestment = makeInvestment( ... );} // pInvestment 파괴 그런데 unqiue_ptr를 소유권 이전에 사용할 수도 있다. 팩토리 함수가 돌려준 unique_ptr이 어떤 객체의 컨테이너 안에 들어가고, 그 후 객체가 파괴되면 unique_ptr가 가리키고 있던 자원도 파괴된다. 그러한 파괴를 조절하기 위해서 커스텀 삭제자를 사용하면 된다. 커스텀 삭제자 unique_ptr의 기본적인 자원 파괴는 unique_ptr이 가리키고 있는 raw 포인터에 delete를 적용함으로써 수행한다. 커스텀 삭제자는 해당 자원의 파괴 시점에서 호출되는 임의의 함수이다 만약 팩토리 함수가 만든 객체를 직접 delete로 파괴할 수 없고 로그 항목을 기록한 후에 파괴해야 한다면, 다음과 같이 구현하면 된다. // unique_ptr&lt;Investment&gt; 형식template&lt;typename... Ts&gt;auto makeInvestment(Ts&amp;&amp;... params){ auto delInvmt = [](Investment* pInvestment) { makeLogEntry(pInvestment); delete pInvestment; }; unique_ptr&lt;Investment,decltype(delInvmnt)&gt; pInv(nullptr,delInvmnt); if(...) { pInv.reset(new Stock(forward&lt;Ts&gt;(params)...)); } else if(...) { pInv.reset(new Bond(forward&lt;Ts&gt;(params)...)); } return pInv;} delInvmt는 팩토리 함수가 돌려준 객체에 대한 커스텀 삭제자. 커스텀 삭제자(pInv)를 사용하기 위해선 두 번째 인수를 지정해야 한다. 이 함수의 기본적인 전략은 null의 unique_ptr를 만들고 적절한 형식의 객체를 가리키게 한 후 반환하는 것이다 raw 포인터를 unqiue_ptr에 넣는 것은 금지되어 컴파일되지 않기 때문에 new로 생성한 객체의 소유권을 pInv에 부여하기 위해 reset 함수 호출 커스텀 삭제자는 부모 포인터 형식의 매개변수로 받기 때문에 부모 형식으로 삭제된다. 즉, 기반 클래스 포인터를 통해 파생 클래스의 객체를 삭제하기 때문에 소멸자는 virtual 소멸자를 사용해야 한다. 주의점 커스텀 삭제자를 사용할 때 함수 포인터나 상태가 많은 람다 표현식을 사용하면 unique_ptr의 객체의 크기가 상당히 커질 수 있다. 커스텀 삭제자 때문에 unique_ptr가 허용 가능한 수준 이상으로 커진다면, 설계 자체를 바꿔야할 수도 있다. pimpl unique_ptr의 흔한 용도는 팩토리 함수 뿐만 아니라 Pimpl의 관용구의 구현 매커니즘으로 더 많이 사용된다. 항목 22에서 다룰 예정 unique_ptr과 shared_ptr unqiue_ptr은 shared_ptr로의 변환이 쉽고 효율적이다.// unique_ptr 팩토리 함수이지만 shared_ptr로 반환 가능shared_ptr&lt;Investment&gt; sp = makeInvestment( ... ); 때문에 unique_ptr이 팩토리 함수의 반환 형식으로 아주 적합한 이유의 핵심적인 부분이다. 팩토리 함수는 자신이 돌려준 객체를 호출자의 독점적 소유인지, 소유권을 공유하는지는 알 수 없다. 팩토리 함수가 unqiue_ptr를 반환한다면 호출자는 가장 효율적인 스마트 포인터를 사용하고, 유연하게 shared_ptr로 변환도 가능하다 결론 이것만은 잊지 말자! unique_ptr는 독점 소유권 의미론을 가진 자원의 관리를 위한, 작고 빠른이동 전용 스마트 포인터 기본적인 자원 파괴는 delete이지만, 커스텀 삭제자를 지정할 수도 있다.상태 있는 삭제자나 함수 포인터를 사용하면 unique_ptr의 크기도 커진다. unique_ptr은 shared_ptr로 손쉽게 변환할 수 있다. " }, { "title": "Attribute", "url": "/posts/Attribute/", "categories": "unreal, GAS", "tags": "unreal", "date": "2024-04-08 00:00:00 +0900", "snippet": "Attribute Set(AS) Attribute를 관리하는 클래스 만약 생성자에서 ASC와 AS를 같이 생성했다면 자동적으로 묶어줄 수 있다. ASC는 여러 개의 AS를 가질 수 있지만 같은 클래스의 AS는 여러 개를 가질 순 없다 ASC에서 AS를 접근할 때 애매해지기 때문 그래서 보통 하나의 AS에 여러 개의 Attribute를 가지는 형태를 사용한다. Attribute Attribute는 AS에 저장되는 FGameplayAttributeData 구조체를 갖는 객체이고, 이 구조체의 변수 타입들은 float다.USTRUCT(BlueprintType)struct GAMEPLAYABILITIES_API FGameplayAttributeData{\tGENERATED_BODY()\tFGameplayAttributeData()\t\t: BaseValue(0.f)\t\t, CurrentValue(0.f)\t{}\tFGameplayAttributeData(float DefaultValue)\t\t: BaseValue(DefaultValue)\t\t, CurrentValue(DefaultValue) {}\tvirtual ~FGameplayAttributeData() {}\tfloat GetCurrentValue() const;\tvirtual void SetCurrentValue(float NewValue);\tfloat GetBaseValue() const;\tvirtual void SetBaseValue(float NewValue);protected:\tUPROPERTY(BlueprintReadOnly, Category = \"Attribute\")\tfloat BaseValue;\tUPROPERTY(BlueprintReadOnly, Category = \"Attribute\")\tfloat CurrentValue;}; FGameplayAttributeData는 기본적으로 BaseValue와 CurrentValue가 있다. BaseValue는 Attribute의 기본 값 CurrentValue는 GameplayEffect에 의해 BaseValue값에서 수정된 값 Attribute는 코드로 바로 값을 바꿀 순 있지만, Gameplay Effect를 이용하는 것이 더 선호되는 방법이다. Gameplay Effect이 더 선호되는 이유는 Attribute값이 바뀌는 것을 예측(Prediction)하기 때문 Attribute 생성 Attribute를 생성하려면 Attribute Set 클래스에서 생성하고 Multi에 적용시키기 위해 다음과 같은 작업을 걸쳐야 한다. 변수들은 FGameplayAttributeData 타입으로 선언 UPROPERTY에 ReplicatedUsing를 사용하고 OnRep_(VariableName) 함수를 선언 GetLifetimeReplicatedProps 함수에서 DOREPLIFETIME 선언 OnRep_(VariableName) 함수에서도 GAMEPLAYATTRIBUTE_REPNOTIFY를 선언해야 한다. ATTRIBUTE_ACCESSORS는 Attribute의 Get, Set, Init 함수를 쉽게 만들어주기 위한 매크로로, GAS에서 지원하고 있다. 관용적으로 사용하는 느낌으로 적어주면 된다. 헤더파일// Attribute의 Get,Set 함수들을 쉽게 만들어주기 위한 매크로#define ATTRIBUTE_ACCESSORS(ClassName, PropertyName) \\GAMEPLAYATTRIBUTE_PROPERTY_GETTER(ClassName, PropertyName) \\GAMEPLAYATTRIBUTE_VALUE_GETTER(PropertyName) \\GAMEPLAYATTRIBUTE_VALUE_SETTER(PropertyName) \\GAMEPLAYATTRIBUTE_VALUE_INITTER(PropertyName)UCLASS()class AURA_API UAuraAttributeSet : public UAttributeSet{\tGENERATED_BODY()public: UAuraAttributeSet();\tvirtual void GetLifetimeReplicatedProps(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps) const override;\tUPROPERTY(BlueprintReadOnly, ReplicatedUsing= OnRep_Health) // 변수 Replicate\tFGameplayAttributeData Health;\tATTRIBUTE_ACCESSORS(UAuraAttributeSet, Health); // Get,Set 함수 선언\tUPROPERTY(BlueprintReadOnly, ReplicatedUsing= OnRep_MaxHealth)\tFGameplayAttributeData MaxHealth;\tATTRIBUTE_ACCESSORS(UAuraAttributeSet, MaxHealth);\t// OnRep : 변수의 값이 바뀌면 호출되는 함수\tUFUNCTION()\tvoid OnRep_Health(const FGameplayAttributeData&amp; OldHealth) const;\tUFUNCTION()\tvoid OnRep_MaxHealth(const FGameplayAttributeData&amp; OldMaxHealth) const;}소스파일UAuraAttributeSet::UAuraAttributeSet(){ // ATTRIBUTE_ACCESSORS로 생성된 Init(VariableName) 함수를 통해 해당 변수의 값을 초기화\tInitHealth(100.f); InitMaxHealth(100.f);}void UAuraAttributeSet::GetLifetimeReplicatedProps(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps) const{\tSuper::GetLifetimeReplicatedProps(OutLifetimeProps);\t// REPNOTIFY_Always: 변수의 값이 바뀌지 않아도 항상 Replicate\t// REPNOTIFY_OnChanged : 변수의 값이 바뀌면 Replicate \tDOREPLIFETIME_CONDITION_NOTIFY(UAuraAttributeSet, Health, COND_None, REPNOTIFY_Always);\tDOREPLIFETIME_CONDITION_NOTIFY(UAuraAttributeSet, MaxHealth, COND_None, REPNOTIFY_Always);}void UAuraAttributeSet::OnRep_Health(const FGameplayAttributeData&amp; OldHealth) const{\tGAMEPLAYATTRIBUTE_REPNOTIFY(UAuraAttributeSet, Health, OldHealth);}void UAuraAttributeSet::OnRep_MaxHealth(const FGameplayAttributeData&amp; OldMaxHealth) const{\tGAMEPLAYATTRIBUTE_REPNOTIFY(UAuraAttributeSet, MaxHealth, OldMaxHealth);}" }, { "title": "GAS Replication Mode", "url": "/posts/GAS-ReplicationMode/", "categories": "unreal, GAS", "tags": "unreal", "date": "2024-04-07 00:00:00 +0900", "snippet": "Replication Mode Ability System Componet 안에는 Replicate와 관련된 Replication Mode가 있다. Mode는 총 3가지고 EGameplayEffectReplicationMode enum 안에 있으며, Full, Minimal, Mixed가 있다. /** gameplay effects가 클라이언트에 어떻게 복사되는지 */UENUM()enum class EGameplayEffectReplicationMode : uint8{\t/** Only replicate minimal gameplay effect info. Note: this does not work for Owned AbilitySystemComponents (Use Mixed instead). */\tMinimal,\t/** Only replicate minimal gameplay effect info to simulated proxies but full info to owners and autonomous proxies */\tMixed,\t/** Replicate full gameplay info to all */\tFull,};Full 싱글 플레이때 사용하는 게임 모드 Gameplay Effect는 모든 클라이언트에게 복제된다 Mixed 멀티플레이 게임이면서 Player Character에게 사용하는 모드 Gameplay Effect가 자기 자신 클라이언트에게만 복제된다. Gameplay Cue와 Gameplay Tag는 모든 클라이언트에게 복제한다 Mixed 모드는 OwnerActor의 Actor는 반드시 Controller여야 한다. PlayerState에서는 자동적으로 Possessedby에서 설정되지만 Mixed이면서 OwnerActor가 PlayerState가 아닐 경우, OwnerActor의 SetOwner함수에서 반드시 Controller를 Owner로 설정해줘야 한다. Minimal 멀티플레이 게임이면서 AI 기반 캐릭터에게 사용하는 모드 Gameplay Effect는 복제되지 않는다 Gameplay Cue와 Gameplay Tag는 모든 클라이언트에게 복제한다 " }, { "title": "Ability Actor info", "url": "/posts/Ability-Actor-info/", "categories": "unreal, GAS", "tags": "unreal", "date": "2024-04-06 00:00:00 +0900", "snippet": "GAS의 Pawn과 PlayerState 차이점 GAS를 사용하려면 Pawn 혹은 PlayerState 클래스에서 Ability System Component(ACS)와 Attribute Set(AS)을 추가해야 한다.Pawn 클래스에 ACS와 AS를 추가했을 경우 멀티플레이 게임에서는 Pawn이 죽을 경우 그 Pawn을 삭제하고 Respawn할 수 있다. 이 때 Pawn이 삭제된다면 ASC와 AS 또한 없어지고 데이터 또한 날라간다. Respawn한 Pawn은 Default값을 가진 상태의 ACS와 AS를 얻게 된다. 하지만, 단순하게 만들 AI 캐릭터같은 경우는 State 클래스가 필요도 없고 Logic에서 바로 Pawn 클래스에 다가가서 값을 가져올 수 있다. PlayerState 클래스에 ACS와 AS를 추가했을 경우 Pawn이 죽는다 해도 Player State 클래스에 남아있기 때문에 ASC와 AS의 데이터가 날라가지 않는다. 또한 Respawn한 Pawn한테 PlayerState를 그대로 적용할 수 있다. 결론 플레이어 관련 Pawn이라면 Player State Class가 적절할테고, AI Enemy같은 경우는 Pawn(Character) Class에 구현하는 것이 적절할 것이다.Ability Actor info Enemy같은 경우는 클래스에 ASC와 AS를 생성하는 것과 달리, Player는 Player State란 클래스에 따로 생성하기 때문에 ASC가 누구의 Owner인지 알 수가 없다. Player State 클래스를 이용하면 저장된 ASC와 AS를 다른 Pawn에 바로 적용할 수 있지만 그 때마다 Owner가 바뀌기 때문에 Owner를 정해줘야 한다. 그래서 ASC에는 두 종류의 변수가 있는데 하나는 Owner Actor이고 다른 하나는 Avatar Actor이다. Owner Actor ASC를 소유하고 있는 클래스를 의미Avatar Actor ASC를 사용하면서 World에 있는 Actor를 의미Enemy의 경우 Enemy 클래스에 바로 ASC와 AS를 생성하기 때문에 Owenr Actor와 Avatar Actor가 같다.Player의 경우 Player는 Player State에서 생성하기 때문에 Owner Actor는 Player State가 되고, Avatar Actor는 Player State를 사용하는 캐릭터가 된다.함수 ASC에는 Owner Actor와 Avatar Actor를 설정하는 함수를 지원한다./***\tInitialized the Abilities' ActorInfo - the structure that holds information about who we are acting on and who controls us.* OwnerActor is the actor that logically owns this component.*\tAvatarActor is what physical actor in the world we are acting on. Usually a Pawn but it could be a Tower, Building, Turret, etc, may be the same as Owner*/virtual void InitAbilityActorInfo(AActor* InOwnerActor, AActor* InAvatarActor); 이 함수의 선언 시점은 Controller가 Pawn에 Possess한 후에 해야 한다. 그리고 어떤 클래스에 ASC를 선언했냐에 따라 사용하는 함수가 Server, Client 등 다르다. Character Class가 ASC를 갖고 있는 경우 Server에 OwnerActor와 AvatarActor를 설정하려면 Character 클래스에 있는 PossessedBy 함수를 사용해야 한다. PossessedBy 함수는 Pawn이 PlayerController에게 빙의(possess)되는 시점에 호출되는 함수 PossessedBy 함수는 함수에서만 실행되기 때문에 클라이언트는 적용되지 않음 그래서 클라이언트에 적용하기 위해서는 Controller 클래스에 있는 AcknowledgePossession 함수에서 함수를 호출해야 한다. AcknowledgePossession 함수는 PossessedBy와 기능은 같지만, 클라이언트의 LocalPawn에서 호출된다. Player State가 ASC를 갖고 있는 경우 Server의 경우 위와 마찬가지로 PossesedBy 함수를 사용한다 Client는 OnRep_PlayerState 함수에서 실행한다. OnRep 함수는 PlayerState 변수의 값이 변할 때 복제되어 호출되는 함수로, 서버에서 PlayerState가 Possesed 함수를 호출하면서 값이 바뀌면 그 값이 Client에 복제되어 적용된다. Enemy의 경우 Server와 Client 모두 BeginPlay에서 호출하면 된다." }, { "title": "두 Actor 사이의 각도 구하기", "url": "/posts/%EB%91%90-Actor-%EC%82%AC%EC%9D%B4%EC%9D%98-%EA%B0%81%EB%8F%84-%EA%B5%AC%ED%95%98%EA%B8%B0/", "categories": "unreal, math", "tags": "unreal", "date": "2024-04-05 00:00:00 +0900", "snippet": "과정 먼저 Player의 위치를 기준으로 설명한다. Player의 Forward Vector와 Player으로부터 TargetActor 쪽으로의 방향을 구한다 이 때 두 방향 벡터는 Normalize한 값으로 만들어줘야 한다. ForwardVector는 이미 Normalize한 상태 PlayerToTargetVector는 GetSafeNormal2D()함수를 통해 Z축을 제외한 2D Vector의 Normalize 값 // Player Forward Vectorconst FVector PlayerForward = GetActorForwardVector();// Player To Targetconst FVector TargetLoc = TargetActor-&gt;GetActorLocation();\tconst FVector PlayerLoc = GetActorLocation();\tconst FVector PlayerToTargetVector = (TargetLoc - PlayerLoc).GetSafeNormal2D(); 내적을 계산하면 |A||B|cosθ인데 A,B 벡터 둘다 Normalize한 값이므로 cosθ만 남게 된다const double DotValue = FVector::DotProduct(PlayerForward,PlayerToTargetVector); cosθ값에 Acos 함수로 라디안 값을 도출하고 라디안 값에 (180.f/PI)를 곱해서 각도로 변경한다double Degree = FMath::Acos(DotValue) * (180.f/PI); 그런데 내적은 0~180도만 나와서 음수가 나오지 않기 때문에 외적을 사용해서 시계,반시계 방향을 구해 적용한다const FVector CrossProduct = FVector::CrossProduct(PlayerForward,PlayerToTargetVector);// 시계 방향이면 양수, 반시계 방향이면 음수if(CrossProduct.Z &lt; 0.f) { Degree *= -1.f; }내적 활용앞뒤 판별 위 과정에서 얻은 내적(DotValue)의 값이 양수(+)면 앞 음수(-)면 뒤로 판별한다.시야 판별 시야각을 α라고 했을 때, 위 과정에서 얻은 내적(DotValue)의 값이 DotValue &gt;= α/2이면 시야각 안에 있는 것이고 DotValue &lt;= α/2이면 밖에 있는 것이다.외적 활용좌우 판별 외적의 값을 v라고 했을 때,1. v &gt; 0 이면 반시계2. v = 0 이면 중앙3. v &lt; 0 이면 시계평면의 법선 벡터 구하기 점 A,B,C의 위치를 알고 있다면 AB, BC 벡터를 구하고 둘이 외적하면 알 수 있다." }, { "title": "Game Ability System", "url": "/posts/Game-Ability-System/", "categories": "unreal, GAS", "tags": "unreal", "date": "2024-04-05 00:00:00 +0900", "snippet": "Game Ability System Game Ability System은 언리얼엔진5부터 제공하는 기능으로, RPG나 MOBA(AOS장르)를 만들기에 적합한 시스템이다. 공식적인 내용은 https://github.com/tranek/GASDocumentation에서 확인할 수 있다. GAS 클래스 종류Ability System Component (ASC) GAS에서 제공하는 Component로, 가장 핵심이 되는 컴포넌트이다. 캐릭터를 GAS에 사용하기 위해선 반드시 사용해야 하고 GAS의 Main Component이다. Attribute Set 캐릭터의 특성같은 것들을 위한 클래스인 Attribute를 관리하는 클래스로, Attribute를 GAS System와 상호작용하기 위해서 사용한다.Gameplay Ability 캐릭터가 하는 행위, 행동들을 함수로 캡슐화하여 사용하기 위한 클래스 Gameplay Ability는 Ability Task라는 작업 단위들을 비동기식으로 실행할 수도 있다. Ability Task Gameplay Ability는 1프레임에서만 실행하기 때문에 별로 유연성이 좋지 않다. 시간차 or 특정 시점에서의 델리게이트로 실행되는 액션을 하려면 AbilityTask를 사용해야 한다. Gameplay Effect Attribute의 값을 바꿀 때 사용되는 클래스 즉시 바꾸거나, 시간에 따라 바꾸거나, 일정 시간마다 채우는 등 여러 파라미터와 연관지어 계산할 수 있다. Gameplay Cue Particle System이나 Sound등을 Multi에서 다룰 수 있다.Gameplay Tag Gameplay Tag는 GAS가 아닌 다른곳에서도 사용할 수 있으며, 무언가 식별하기 위해 사용할 수 있다.GAS 적용 먼저 Build.cs에서 모듈을 추가해줘야 하는데 \"GameplayTags\", \"GameplayTasks\", \"GameplayAbilities\"를 추가해줘야 한다. 그 다음, 캐릭터에서 GAS를 사용하기 위해서는 Ability System Component(ASC)과 Ability Set(AS), IAbilitySystemInterface를 추가해줘야 한다. IAbilitySystemInterface 안의 순수 가상 함수인 GetAbilitySystemComponent를 정의하고 ASC와 AS를 CreateDefaultSubobject함수로 생성해야 한다. class GAMEPLAYABILITIES_API IAbilitySystemInterface{\tGENERATED_IINTERFACE_BODY()\t/** Returns the ability system component to use for this actor. \tIt may live on another actor, such as a Pawn using the PlayerState's component */\tvirtual UAbilitySystemComponent* GetAbilitySystemComponent() const = 0;};// 헤더파일, Player State으로 예를 들었지만 Pawn도 똑같이 추가해주면 된다.class AURA_API AAuraPlayerState : public APlayerState, public IAbilitySystemInterface{\tGENERATED_BODY()public:\tAAuraPlayerState();\tvirtual UAbilitySystemComponent* GetAbilitySystemComponent() const;protected:\tUPROPERTY()\tTObjectPtr&lt;UAbilitySystemComponent&gt; AbilitySystemComponent;\tUPROPERTY()\tTObjectPtr&lt;UAttributeSet&gt; AttributeSet;};// 소스코드AAuraPlayerState::AAuraPlayerState(){\tAbilitySystemComponent = CreateDefaultSubobject&lt;UAuraAbilitySystemComponent&gt; (TEXT(\"AbilitySystemComponent\"));\tAbilitySystemComponent-&gt;SetIsReplicated(true);\tAttributeSet = CreateDefaultSubobject&lt;UAuraAttributeSet&gt;(TEXT(\"AttributeSet\"));\t\tNetUpdateFrequency = 100.f;}UAbilitySystemComponent* AAuraPlayerState::GetAbilitySystemComponent() const{\treturn AbilitySystemComponent;}" }, { "title": "Cast", "url": "/posts/Cast/", "categories": "unreal, Basic", "tags": "unreal", "date": "2024-04-05 00:00:00 +0900", "snippet": "Cast&lt;T&gt;(Object)정의 UObject를 상속받는 객체들 간의 안전한 캐스팅을 제공하는 함수사용 시점 객체가 특정 타입일 가능성이 있지만 확실하지 않을 때 사용하고 실패하면 nullptr을 반환장점 런타임에 안전하게 캐스팅을 시도할 수 있고, 캐스팅 실패 시 오류 없이 안전하게 처리할 수 있다CastChecked&lt;T&gt;(Object)정의 Cast와 유사하지만, 캐스팅 실패 시 강제로 오류를 발생시키는 함수사용 시점 캐스팅이 반드시 성공해야 하는 경우 사용. 예를 들어, 특정 함수가 항상 특정 타입의 객체를 반환해야 하는 경우장점 잘못된 캐스팅을 초기에 발견하고 디버깅할 수 있도록 도움. 개발 중에 타입 불일치를 빠르게 확인할 수 있음ConstCast&lt;T&gt;(Object)정의 객체의 const 속성을 제거하는 캐스트사용 시점 const로 정의된 객체의 속성을 변경해야 하는 경우 사용DynamicCast&lt;T&gt;(Object)정의 C++의 dynamic_cast와 유사하게 동작하며, 객체의 실제 타입을 런타임에 체크사용 시점 UObject가 아닌 일반 C++ 클래스 간의 캐스팅이 필요할 때 사용장점 런타임에 객체의 타입을 안전하게 확인할 수 있다.단점 성능이 중요한 부분에서는 주의가 필요StaticCast&lt;T&gt;(Object)정의 C++의 static_cast와 동일하게 작동하며, 컴파일 타임에 타입을 체크사용 시점 타입이 명확히 정의되어 있고, 캐스팅 실패 가능성이 전혀 없는 경우에 사용장점 Cast&lt;T&gt;보다 빠르며, 불필요한 런타임 체크를 피할 수 있다.ReinterpretCast&lt;T&gt;(Object)정의 메모리의 비트 패턴을 그대로 유지한 채 타입을 변환하는 캐스트사용 시점 포인터 타입 간의 변환이 필요할 때 사용SafeCast&lt;T&gt;(Object)정의 UObject의 안전한 캐스팅을 보장하는 함수사용 시점 객체가 유효한지 확인하면서 캐스팅할 때 사용ExactCast&lt;T&gt;(Object)정의 객체가 정확히 지정된 타입인지 확인한 후 캐스팅. 상속된 타입은 허용되지 않음사용 시점 객체가 특정한 타입이어야만 할 때 사용 객체의 타입이 정확히 일치하는지 확인해야 하는 경우 사용" }, { "title": "Depth", "url": "/posts/Depth/", "categories": "unreal, Niagara", "tags": "unreal", "date": "2024-04-04 00:00:00 +0900", "snippet": "Depth 머티리얼 표현식 렌더링되는 픽셀의 깊이를 다루는 머티리얼 표현식DepthFade 반투명 오브젝트와 불투명 오브젝트가 겹칠 때 일어나는 이음새를 감추는 데 사용입력 Opacity : DepthFade 전 오브젝트에 대한 기존 불투명도 Fade Distance : 페이드가 발생하기 시작하는 월드 스페이스 상의 거리 PixelDepth 현재 렌더링되고 있는 픽셀의 뎁스 또는 카메라에서의 거리를 출력하는 머티리얼 표현식SceneDepth 기존의 씬 깊이를 출력하는 머티리얼 표현식 PixelDepth 와 비슷하나, PixelDepth 는 현재 그려지고 있는 픽셀의 깊이만 샘플링할 수 있는 반면, SceneDepth 는 어느 위치의 깊이도 샘플링할 수 있습니다. CustomDepth 화면에 보이는것과 상관없이 카메라와 물체 사이의 거리 SceneTexture을 생성한 후 Scene Texture ID에서 CustomDepth를 선택하면 된다. " }, { "title": "Collision", "url": "/posts/Collision/", "categories": "unreal, Basic", "tags": "unreal", "date": "2024-04-04 00:00:00 +0900", "snippet": "콜리전 반응 총 3가지로, Block, Overlap, Ignore이 있다.Block 서로 Block인 두 액터 사이에 발생 Simulation Generates Hit Events이 켜져 있어야 Event Hit이 발생한다 Overlap Overlap으로 설정하면 마치 서로 Ignore하는것 처럼 보이지만, Generate Overlap Events이 켜져있으면 겹칠 때 이벤트가 발생한다. Generate Overlap Events이 꺼져있으면 Ignore과 Overlap은 똑같다. Ignore 액터 서로에게 영향을 끼치지 못한다.콜리전 활성화(Enabled)No Collision 아무런 충돌 반응 없음Query Only 공간 쿼리(레이캐스트, 스윕, 오버랩)에 사용Physics Only 피직스 시뮬레이션(리지드 바디, 컨스트레인트) 전용Collision Enabled 공간 쿼리(레이캐스트, 스윕, 오버랩)와 시뮬레이션(리지드 바디, 컨스트레인트)에 모두 사용할 수 있음콜리전 오브젝트 타입월드 스태틱(World Static) 움직이지 않는 액터에 사용월드 다이내믹(World Dynamic) 애니메이션 or 코드에 영향받는 액터에 사용폰(Pawn) 제어를 받을 수 있는 액터에 사용피직스 바디(Physics Body) Physics Simulation으로 움직이는 액터에 사용비히클(Vehicle),디스트럭션(Destructible) Vehicle, Destructible 등이 사용커스텀 콜리전 편집-&gt;프로젝트 세팅-&gt;콜리전에서 오브젝트 채널과 트레이스 채널을 추가할 수 있음 프리셋에서 내가 원하는 Collision 에 대한 세팅이 가능 " }, { "title": "Blend Mode", "url": "/posts/BlendMode/", "categories": "unreal, Niagara", "tags": "unreal", "date": "2024-04-03 00:00:00 +0900", "snippet": " Blend Mode는 이 Material을 다른 픽셀 앞에 렌더링할 때, 엔진에서 이 Material( 소스 컬러 )과 이미 프레임 버퍼에 있는 것( 대상 컬러 )을 결합하는 방식을 조절하는 방식종류 Detail부분에 있으며 다음과 같이 있다.Opaque(불투명) 빛이 통과하지도, 투과되지도 않는 표면을 정의. 즉, 뒤가 보이지 않음 플라스틱, 금속, 돌, 그리고 기타 표면 유형 대부분에 적합 Masked 가시성을 켜기와 끄기 둘 중에서 선택적으로 제어해야 할 때 사용 쇠창살 같은 거를 생각해보면 중간 중간 뚫려 있어 뒤에가 보이는데 이럴 때 Maksed를 사용 Maksed 모드는 컬링된 픽셀을 그리지 않아서 리플렉션(Reflection)이 전혀 보이지 않는다. Specular나 Reflection을 유지하고 싶다면 Translucent(반투명)을 사용해야 한다. 오파시티 마스크 클립 값(Opacity Mask Clip Value) 이 값에 따라 가시성을 조절할 수 있다. 이 프로퍼티 값에는 0~1의 Scalar 값으로 사용되고 그 이상의 어두운 픽셀은 렌더링되지 않는다 이 사진은 양면(Two Side) 프로퍼티가 True로 설정되어 있어 박스 안도 볼 수 있다. Translucent(반투명) 일정한 형태의 투명도가 필요한 오브젝트에 사용한다. 투명도 수준을 조절할 수 있다는 점에서 Maksed와 다르다 오파시티(Opacity) 값이나 텍스처를 받은 다음, 검은색 영역은 완전히 투명하게, 흰색 영역은 완전히 불투명하게, 그리고 그 중간의 다양한 그러데이션 값은 그에 상응하는 투명도를 구현하는 방식으로 표면에 적용 Translucent Material을 사용할 때 중요한 고려사항은 반투명 머티리얼이 스페큘러 효과를 지원하지 않는다는 것이다. 표면에 Reflection이 보이지 않는다는 뜻 Additive 단순히 머티리얼의 픽셀을 취해서 배경의 픽셀에 더하는 것 Additive는 픽셀에 더하는 것이기 때문에 겹쳐진 부분이 더 밝아지는 것을 사진에서 알 수 있다. 어두워지지 않는다는 뜻으로, 모든 픽셀 값을 더하기 때문에 검은색은 투명하게만 렌더링된다. 불, 증기, 홀로그램과 같은 다양한 특수 효과에 좋다. Translucent처럼 스페큘러 효과(리플렉션)를 반영하지 않는다 단점 밝은 색의 배경에서는 잘 보이지 않을 수 있다.Modulate 머티리얼의 값에 배경의 픽셀 값을 곱한다 어두워지는 이펙트를 구현할 때 사용한다. Emissive Color로 표면 컬러를 정의한다 AlphaComposite 알파를 미리 곱한 텍스처를 가진 머티리얼에서 사용된다 이미지가 저장되기 전에 RGB 컬러 채널이 알파 채널에 미리 곱해진다는 것을 의미한다. 밝은 컬러의 파티클 및 VFX에 Additive 또는 Translucent 대신 유용하게 사용할 수 있다. Additive와 비교하면 가시성이 더 높고, 밝은 색의 배경에서 더 높은 컬러 채도를 유지한다. AlphaHoldout 스페이스에서 머티리얼의 알파를 ‘유지’하여 오브젝트를 통과해 바로 뒤에 구멍을 만드는 방식알아두면 좋은점 Additive의 Emissive Color값이 0이 되는 부분은 투명해지지만, Translucent의 Emissive Color값이 0이 되는 부분은 어두워진다. 이를 이용하여 배경을 어둡게 할지 투명하게 할지 적용할 수 있다. 공식문서 https://dev.epicgames.com/documentation/ko-kr/unreal-engine/material-blend-modes-in-unreal-engine" }, { "title": "GetClass와 StaticClass", "url": "/posts/GetClass%EC%99%80-StaticClass/", "categories": "unreal, Unreal Etc", "tags": "unreal etc", "date": "2024-04-03 00:00:00 +0900", "snippet": "GetClass UObjectBase의 클래스에 정의되어 있으며, 런타임에서 실제 객체의 클래스를 조회할때 사용된다.StaticClass CDO에 저장되어 있는 클래스, 즉 컴파일 시점의 클래스에 대한 정보들을 가져온다차이UPROPERTY(EditDefaultsOnly)int Test = 1; 이러한 변수가 있을 때 에디터에서 int값을 10으로 바꾸고 이 변수에 대해 GetClass를 사용하면 런타임에서의 값인 10을 가져오고 StaticClass를 사용하면 컴파일 시점에서의 값인 1을 가져온다." }, { "title": "특수 멤버 함수들의 자동 작성 조건을 숙지하라", "url": "/posts/17.Understand-special-member-function-generation/", "categories": "Modern Effective C++", "tags": "modern effective c++", "date": "2024-04-03 00:00:00 +0900", "snippet": " C++에서의 특수 멤버 함수들은 스스로 작성하는 멤버 함수를 의미한다. C++98에서는 기본 생성자,소멸자,복사 생성자, 복사 대입 연산자가 있는데, 이 함수들은 명시적으로 선언되어 있지 않지만 사용될 때 작성된다. 작성된 특수 멤버 함수들은 암묵적으로 public이자 inline이며 가상 소멸자를 상속받는 클래스를 제외하고는 non-virtual이다. C++11 특수 멤버 함수 작성에 관한 규칙 C++11에서 들어와서는 특수 멤버 함수 그룹에 이동 생성자와 이동 대입 연산자가 추가되었다.class Widget {public: Widget(Widget&amp;&amp; rhs); Widget&amp; operator=(Widget&amp;&amp; rhs);}; 이들에 대해서는 복사 관련 생성자와 규칙이 비슷하다.이동 연산의 주의점 이동 연산들은 필요할 때만 작성되며, non-static 멤버에 관해서만 이동을 수행한다 그런데 항상 이동 연산이 실제로 일어난다는 보장은 없다. 사실 멤버별 이동은 멤버별 이동 요청에 가깝다. 이유는 이동이 활성화되지 않은 형식은 그 형식이 제공하는 복사 연산들을 통해서 이동되기 때문이다. 결국 이동 연산을 지원하지 않는다면 복사 연산이 수행된다가 핵심이다. 이동 연산 작성되는 조건 이동 연산은 복사 연산들의 것과 조금 다르다복사 연산 조건 복사 연산은 서로 독립적이라 하나를 선언한다고 다른 하나의 작성이 방지되지는 않는다 즉, 복사 연산을 선언하고 복사 대입 연산자를 명시적으로 선언하지 않은 상태에서 복사 대입 연산자를 사용하면 컴파일러가 자동으로 작성한다. 이동 연산 조건 하지만 이동 연산은 독립적이지 않아 둘 중 하나를 선언하면 컴파일러는 다른 하나를 작성하지 않는다 이유는 이동 생성자가 적합하지 않은 클래스라면 이동 대입 연산자 역시 적합하지 않을 가능성이 높기 때문이다 복사 연산과 이동 연산 관계 복사 연산을 하나라도 명시적으로 선언한 클래스에 대해서는 이동 연산들이 작성되지 않는다 이유는 복사 연산을 선언했다는 것은 일반적인 객체 복사 방식(멤버별 복사)이 그 클래스에 대해 적합하지 않고, 그렇다면 이동 연산 역시 적합하지 않을 가능성이 높기 때문이다 반대 방향도 마찬가지로, 이동 연산을 하나라도 명시적으로 선언하면 컴파일러는 복사 연산들을 비활성화한다3의 법칙 3의 법칙이란 복사 생성자, 복사 대입 연산자, 소멸자 중 하나라도 선언했다면 나머지 둘도 전부 선언해야 한다라는 의미이다. 복사 대입 연산자를 프로그래머가 직접 지정해야 하는 경우는 그 클래스가 어떤 형태로든 자원 관리를 수행하기 때문에 생긴다 근데 그러한 클래스는 거의 항상 (1) 복사 연산이 수행하는 자원 관리를 다른 복사 연산에도 수행해야 하며, (2) 클래스 소멸자 역시 자원 관리에 참여한다. 이동 연산 작성 조건 정리 클래스에 대한 이동 연산들은 다음 세 조건이 모두 만족되고 필요할 때만 자동으로 작성된다.1. 클래스에 그 어떤 복사 연산도 선언되어 있지 않다2. 클래스에 그 어떤 이동 연산도 선언되어 있지 않다.3. 클래스에 소멸자가 선언되어 있지 않다.default 만일 클래스 중에 소멸자나 복사 연산 중 하나를 선언하면 복사 연산들이 자동으로 작성된다는 점에 의존하는 것이 있다면, 그런 의존성이 사라지도록 클래스를 업그레이드 하는 것이 바람직하다. C++11에서는 기본 행동을 사용하겠다는 의사를 =default를 이용해 명시적으로 표현할 수 있다. class Widget{public: ~Widget(); Widget(const Widget&amp;) = default; Widget&amp; operator=(const Widget&amp;) = default;}; 이러한 접근 방식은 다형적 기반 클래스, 즉 파생 클래스 객체를 조작하는 데 사용하는 인터페이스를 정의하는 클래스에 유용한 경우가 많다. 대체적으로 가상 소멸자가 있다. 소멸자를 가상으로 만드는 것 이외에는 변경할 것이 없는 기본 구현이 적합한 경우에 default를 사용하면 좋다. default의 다른 용도 독자가 소멸자를 직접 선언하면 이동 연산들의 자동 작성이 금지된다. 만일 그러한 사용자 선언 소멸자를 두면서도 이동을 지원하고 싶다면, 이동 연산에 =default를 지정하면 된다 이동 연산들을 직접 선언하면 복사 연산들이 비활성되지만, 복사 연산 역시 지원하고 싶다면 =default를 지정하면 된다 class Base{public: virtual ~Base() =default; Base(Base&amp;&amp;) = default; Base&amp; operator&amp;(Base&amp;&amp;) = default; Base(const Base&amp;) =default; Base&amp; operator=(const Base&amp;) = default;};특수 멤버 함수들을 관장하는 C++11 규칙들 정리1. 기본 생성자 :- C++98의 규칙과 같다.- 클래스에 사용자 선언 생성자가 없는 경우 자동으로 작성한다.2. 소멸자 :- C++98 규칙들과 본질적으로 같다.- 유일한 차이는 소멸자가 기본적으로 noexcept라는 점이다.- C++98에서처럼, 기본적으로 작성되는 소멸자는 기반 클래스 소멸자가 virtual일 때만 virtual로 작성한다.3. 복사 생성자 :- 런타임에서는 C++98과 동일하다.- 즉, non-static 자료 멤버들을 멤버별로 복사 생성한다.- 클래스에 사용자 선언 복사 생성자가 없을 때에만 자동으로 작성된다.- 클래스에 이동 연산이 하나라도 선언되어 있다면 삭제된다.- 사용자 선언 복사 대입 연산자나 소멸자가 있는 클래스에서 복사 생성자의 자동 작성 기능은 비권장이다.4. 복사 대입 연산자 : - 런타임에서는 C++98과 동일하다.- 즉, non-static 자료 멤버들을 멤버별로 복사 대입한다.- 클래스에 사용자 선언 복사 대입 연산자가 없을 때에만 자동으로 작성된다.- 클래스에 이동 연산이 하나라도 선언되어 있다면 삭제된다.- 사용자 선언 복사 대입 연산자나 소멸자가 있는 클래스에서 복사 생성자의 자동 작성 기능은 비권장이다.5. 이동 생성자와 이동 대입 연산자 :- 각각 non-static 자료 멤버의 멤버별 이동을 수행한다.- 클래스에 사용자 선언 복사 연산들과 이동 연산, 소멸자가 없을때에 자동으로 작성한다멤버 함수 템플릿과 특수 멤버 함수 자동 작성 관계 멤버 함수 템플릿이 존재한다고 해도 특수 멤버 함수의 자동 작성이 비활성화된다는 규칙은 없다class Widget{ template&lt;typename T&gt; Widget(const T&amp; rhs); template&lt;typename T&gt; Widget&amp; operator=(const T&amp; rhs);}; 이 템플릿들이 복사 생성자나 복사 대입 연산자들의 서명과 일치하는 함수들로 인스턴스화될 가능성이 있지만, 컴파일러는 여전히 복사 연산들과 이동 연산들을 작성한다.결론 이것만은 잊지 말자! 컴파일러가 스스로 작성할 수 있는 멤버 함수들, 즉 기본 생성자와 소멸자,복사 연산들, 이동 연산들을 가리켜 특수 멤버 함수라고 부른다. 이동 연산들은 이동 연산들이나 복사 연산들, 소멸자가 명시적으로 선언되어있지 않는 클래스에만 자동으로 작성된다. 복사 생성자는 복사 생성자가 명시적으로 작성되지 않은 클래스에 대해서만자동으로 작성되며, 이동 연산이 있다면 삭제된다.복사 대입 연산자는 복사 대입 연산자가 명시적으로 작성되지 않은 클래스에대해서만 자동으로 작성되며, 이동 연산이 있다면 삭제된다.소멸자가 명시적으로 선언되 클래스에서 복사 연산들이 자동으로 작성되는기능은 비권장이다. 멤버 함수 템플릿 때문에 특수 멤버 함수의 자동 작성이 금지 되는 경우는전혀 없다. " }, { "title": "Graphic Sprite", "url": "/posts/Graphic-Sprite/", "categories": "unreal, Niagara", "tags": "unreal", "date": "2024-04-02 00:00:00 +0900", "snippet": "Graphic Sprite Sprite는 이전에도 설명했듯이, 카메라를 향하는 평면이다. 파티클은 CPU Sprite을 사용하는데 GPU Sprite와 CPU Sprite의 차이는 어떤 거로 처리하냐의 차이일 뿐이다. 하지만 GPU를 사용하면 많은 수의 파티클을 처리하는데는 CPU보다 효율적이다. 그렇다고 특정 모델은 CPU Sprite를 사용하는 것이 더 효율적일 수 있으니 상황에 따라 선택해야 한다. Detail 프로퍼티에서 설정이 가능하며 GPU인지 CPU인지는 Detail에서 설정이 가능하다." }, { "title": "Directory 추가하기", "url": "/posts/Directory-%EC%B6%94%EA%B0%80%ED%95%98%EA%B8%B0/", "categories": "unreal, Unreal Etc", "tags": "unreal etc", "date": "2024-04-02 00:00:00 +0900", "snippet": " 기본적으로 클래스에서 헤더파일에 추가할 때 폴더가 있다면 /를 붙여 파일 경로를 찾아서 헤더파일으로 선언한다. (프로젝트이름).build.cs에 경로를 추가하면 해당 경로를 헤더파일로 선언할 때 /로 경로를 찾지 않아도 된다. // 포함 경로 추가 코드PrivateIncludePaths.Add();// 예시// 프로젝트 이름이 MyProject이고 그 이름을 포함 경로에 추가하면 // MyProject/OtherFile.h 이런식이 아니라 OtherFile.h만 선언해도 작동한다.PrivateIncludePaths.Add(\"MyProject\");" }, { "title": "Force", "url": "/posts/Force/", "categories": "unreal, Niagara", "tags": "unreal", "date": "2024-04-01 00:00:00 +0900", "snippet": "Curl Noise Force 파티클에게 힘을 무작위성으로 부여하고 싶을 때 사용하는 모듈 Particle Update에서 추가할 수 있다. DetailNoise Strength 무작위성의 강도를 조절하는 값Noise Frequency Noise에 따라 무작위성이 정해져서 결국 해당 값에 따른 무작위성이 발생한다 그래서 Noise값을 바꿔서 다른 무작위성을 바꿀 수 있다. Drag 파티클의 속도를 줄여줄 때 사용하는 모듈 Particle Update에서 추가할 수 있다. DetailDrag 속도를 줄일 힘을 조절하는 값Rotational Drag 회전 속도를 줄일 힘을 조절하는 값Vortex Velocity Detail에 있는 Axis(축)을 기준으로 회전시키는 모듈 Particle Update에서 추가할 수 있다. DetailVelocity Amount 회전하는 힘을 조절하는 값Vortex Axis X,Y,Z축은 Roll/Pitch/Yaw 처럼 해당 축을 기준으로 회전한다Wind Force 부가적인 공기 저항(Air Resistance) 파라미터와 함께 바람 힘을 적용시킬 수 있는 모듈파티클이 바람 방향으로 풍속보다 빠르게 움직이는 경우에는 추가적인 힘이 가해지지 않는다.DetailWind Wind Speed : 바람의 방향을 정하는 값 Wind Speed Scale : 바람의 힘을 정하는 값 Turbulence(난기류)" }, { "title": "LineTrace와 ShapeTrace", "url": "/posts/LineTrace%EC%99%80-ShapeTrace/", "categories": "unreal, Basic", "tags": "unreal", "date": "2024-04-01 00:00:00 +0900", "snippet": "LineTrace Start 부터 End 까지 Line을 쏴서 충돌할 오브젝트나 채널을 정해서 FHitResult 타입의 변수에 저장하는 개념 LineTrace를 이용하면 총구 쪽의 상대방, 아이템과 상호작용 등 여러가지가 가능하다 GetWorld()함수에서 실행할 수 있다. 종류 LineTrace의 종류에는 Single과 Multi로 나눠지고, Channel과 ObjectType으로 나눠진다.Single/Multi Single은 부딪힌 첫 번째 Object를 반환한다 Multi는 부딪힌 모든 Object를 반환한다 Channel/ObjectType Channel은 CollisionChannel에서 사용하는 유형을 지정하여 해당 유형에만 LineTrace가 작동하도록 설정한다 ObjectType은 특정 오브젝트들을 LineTrace하기 위해 사용한다 // FHitResult : 결과를 저장할 변수// FVector : 시작 위치, 끝 위치// ECollisionChannel : Line에 충돌할 Collision Channel을 설정// 아래는 기본적으로 추가하지 않아도 작동// FCollisionQueryParams : 무시할 Actor 혹은 Tag를 추가 등 할 수 있다.// FCollisionResponseParams : 무시할 Channel을 추가할 수 있다GetWorld()-&gt;LineTraceSingleByChannel( HitResult, Start, End, ECollisionChannel::ECC_Visibility); 좌측은 Single, 우측은 MultiShapeTrace 도형(박스,캡슐,구)으로 부딪히는 Object가 있다면 FHitResult 타입 변수에 저장하는 개념 UKismetSystemLibrary 의 static 함수로 사용할 수 있다. 문서 https://dev.epicgames.com/documentation/ko-kr/unreal-engine/traces-in-unreal-engine---overview" }, { "title": "const 멤버 함수를 스레드에 안전하게 작성하라", "url": "/posts/16.Make-const-member-functions-thread-safe/", "categories": "Modern Effective C++", "tags": "modern effective c++", "date": "2024-04-01 00:00:00 +0900", "snippet": " 수학 분야에서 다항식을 대표하는 클래스를 마련 해 두는것이 편리하여 다항식의 root들, 즉 다항식이 0으로 평가되는 값들을 계산하는 멤버 함수를 작성하는데 수정하지 않을 것이므로 const로 작성하는 것이 자연스럽다. 다항식의 root는 필요할 때에만 실제로 계산해서 캐시에 저장하고, 그렇지 않으면 그냥 캐시에 있는 값ㅇ르 돌려주도록 root를 구현하는 것이 바람직하다 다음은 이를 위한 기본적인 접근 방식의 코드이다 class Polynomial {public: using RootsType = std::vector&lt;double&gt;; RootsType roots() const { if(!rootsAreVaild){ // 캐시가 유효치 않으면 .. // root을 계산해서 rootVals에 저장 rootsAreValid = true; } return rootsVals; }private: mutable bool rootsAreValid { false }; mutable RootsType rootVals{};}; roots는 개념적으로 자신이 속한 Polynomal 객체를 변경하지 않는다. 그러나 캐싱을 위해서는 rootVals와 rootsAreValid의 변경이 필요할 수 있어서 mutable로 선언한다. 근데 두 스레드가 하나의 Polynomal 객체에 대해 roots를 동시에 호출한다고 가정해본다. Polynomal p;/* 스레드1 */auto rootsOfP = p.roots();/* 스레드2 */auto valsGivingZero = p.roots(); 기본적으로 이 코드는 합당하지만, 두 스레드가 접근한다면 스레드 하나 혹은 둘이 자료 멤버를 수정할 수도 있다. 이 클라이언트 코드는 서로 다른 스레드들이 같은 메모리를 동기화 없이 읽고 쓰려할 수 있는 즉 경쟁 상태(data race)를 발생시킬 수 있어 미정의 행동이 유발될 수 있다. mutex 근본적인 문제는, roots가 const로 선언되어 있지만 스레드에 안전하지 않다는 것이다. 이 문제를 해결하기 위해선 통상적인 동기화 수단인 mutex를 사용하는 것이다. class Polynomial {public: using RootsType = std::vector&lt;double&gt;; RootsType roots() const { std::lock_guard&lt;std::mutex&gt; g(m); if(!rootsAreVaild){ // 캐시가 유효치 않으면 .. // root을 계산해서 rootVals에 저장 rootsAreValid = true; } return rootsVals; }private: mutable std::mutex m; mutable bool rootsAreValid { false }; mutable RootsType rootVals{};}; mutex 변수인 m이 mutable로 선언된 이유는 m을 잠그고 푸는 멤버 함수는 non-const이지만 roots 안에서는 m이 const 객체로 간주되기 때문이다. mutex는 복사,이동이 불가하기 때문에, 추가하면 클래스의 복사,이동도 사라진다는 점을 주목해야 한다. atomic 이런 뮤텍스를 도입하는 것이 과하다고 느껴질 수 있어서 그를 대신한 atmoic을 사용하면 된다.class Point{public: double distanceFromOrigin() const noexcept { ++callCount; // 함수 호출횟수를 세기 위한 atomic 변수 return ... }private: mutable std::atomic&lt;unsigned&gt; callCount { 0 };}; atomic 역시 mutex처럼 복사,이동이 불가하기 때문에, 추가하면 클래스의 복사,이동도 사라진다는 점을 주목해야 한다. atmoic은 동기화가 필요한 변수 하나 또는 메모리 장소 하나에 대해서는 적합하지만, 둘 이상의 변수나 메모리 장소를 하나의 단위로서 조작해야 할 때는 뮤텍스를 꺼내는 것이 바람직하다 결론 이것만은 잊지 말자! 동시적 문맥에서 쓰이지 않을 것이 확실한 경우가 아니라면, const 멤버함수는 스레드에 안전하게 작성하자 std::atomic 변수는 뮤텍스에 비해 성능상의 이점은 있지만, 하나의 변수또는 메모리 장소를 다룰 때에만 적합하다. " }, { "title": "Shape Location", "url": "/posts/Shape-Location/", "categories": "unreal, Niagara", "tags": "unreal", "date": "2024-03-31 00:00:00 +0900", "snippet": "Shape Location 파티클의 위치를 조절해주는 모듈 Particle Spawn에서 추가할 수 있다 DetailShape Primitive 파티클이 생성되는 위치는 Shape 모양을 기준으로 지정한다 종류에는 Sphere(구), Cylinder(원기둥), Box/Plane(박스,평면), Torus(원환면,도넛모양), Ring/Disc(반지), Cone(꼬깔)이 있다. 종류를 고르면 Radius(반지름)이나 Height(높이)를 지정하여 범위를 지정한다 Distribution(분포도) Shape에 따라 값이 다르지만 대개로 Mode에서 Random으로 무작위로 사용하거나 Direct를 고르고 값을 설정해서 원하는 모양으로 할 수 있다Transform Scale,Rotation,Offset등이 있고 실제 Level에서 배치될 때 유용하다. X축이든 Y축이든 바라보고 싶게할 때 Rotation을 이용 " }, { "title": "Scale && Color && Curve", "url": "/posts/Scale-&&-Color-&&-Curve/", "categories": "unreal, Niagara", "tags": "unreal", "date": "2024-03-31 00:00:00 +0900", "snippet": "Scale Sprite Size 시간이 지남에 따라 Particle의 크기를 조절하는 모듈 Particle Update에서 추가할 수 있다. 보통 Curve를 이용하여 눈으로 쉽게 조절할 수 있다. Scale Color 시간이 지남에 따라 Particle의 색깔을 조절하는 모듈 Particle Update에서 추가할 수 있다. 보통 Curve를 이용하여 눈으로 쉽게 조절할 수 있다. Curve 여러 모듈에서 사용할 수 있는 기능으로, 위 그래프처럼 시간(가로)에 따라 값(세로)이 적용시킬 수 있다. Uniform Curve Index에서 Random Range ~~를 이용해서 Min ~ Max 사이의 랜덤 값을 적용시킬 수도 있다. " }, { "title": "Add Velocity", "url": "/posts/Add-Velocity/", "categories": "unreal, Niagara", "tags": "unreal", "date": "2024-03-30 00:00:00 +0900", "snippet": "Add Velocity 파티클에 속도를 추가하는 모듈 Particle Spawn에서 추가할 수 있다 DetailVelocity Mode Linear : X,Y,Z축 값을 조절해서 원하는 방향으로 설정이 가능하다 From Point : 점(Point)을 기준으로 Random 방향으로 퍼져나감 In Cone : 꼬깔(Cone) 모양으로 퍼져나감 Velocity Speed Scale 속력을 지정해주는 값Rotation Rotation Mode로 Default, Axis Angle, Yaw/Pitch/Roll, Quaternion, Matrx, None 까지 지원한다." }, { "title": "Emitter Update", "url": "/posts/Emitter-Update/", "categories": "unreal, Niagara", "tags": "unreal", "date": "2024-03-28 00:00:00 +0900", "snippet": "사진 Spawn Burst Instantaneous : 모든 이미터가 자발적으로 한 번에 스폰시킬 수 있는 모듈 Spawn Per Unit : 이미터가 움직인 거리에 따라 파티클을 스폰시킬 수 있는 모듈 Spawn Rate : 특정 속도로 꾸준히 파티클을 스폰시킬 수 있는 모듈 " }, { "title": "Niagara && Emitter", "url": "/posts/Niagara-&&-Emitter/", "categories": "unreal, Niagara", "tags": "unreal", "date": "2024-03-27 00:00:00 +0900", "snippet": "Niagara System Niagara Emitter을 여러 개를 가질 수 있는 것Niagara Emitter World에 배치하거나 생성할 수 있는 emitter container 파티클을 생성하고 제어하는 역할 우클릭 -&gt; FX -&gt; 나이아가라 이미터 를 통해서 만들 수 있고 생성하면 3종류가 있는데 처음 만들 때는 빈 이미터 생성을 클릭하여 생성한다. 기본설정 맨 위에서 시작하여 맨 아래까지 순서대로 실행되며 이 중 렌더를 먼저 설정해야 한다.렌더러 렌더러는 스프라이트 렌더러, 메쉬 렌더러, 리본 렌더러 총 3종류가 있다.스프라이트 렌더러(Sprite Renderer) 스프라이트를 이용하여 파티클을 생성하는 방법 스프라이트(Sprite)는 2D 카메라가 보는 평면이고 이 평면은 언제나 카메라를 향하고 있다 메쉬 렌더러 (Mesh Renderer) 파티클을 Mesh 형태로 생성하는 방법리본 렌더러(Ribborn Renderer) World에 존재하는 Actor같은 것에 붙어서 움직일 때 같이 파티클이 생성되는 방식 간단하게 사용해 보려면 Spawn Count를 늘리고 Particle Spawn에서 Ribborn Width Mode를 Direct Set으로 설정한 다음 너비를 조절한 다음, 캐릭터에게 붙여서 움직이면 된다. 이미터 업데이트 총 4가지가 있고 순서대로 살펴본다. 여기서 Spawn은 BeginPlay, Update는 Event Tick과 비슷한 역할이다. 이미터 스폰(Emitter Spawn) 이미터가 시작되는 스테이지이며 보통 몇가지 속성을 사용할 순 있지만 잘 사용되지는 않는다.이미터 업데이트(Emitter Update) 여기서 파티클의 수를 지정할 수 있다 자주 사용하는 3가지 모듈이 있는데 이 모듈을 통해서 파티클이 어떻게 생성할 지를 결정할 수 있다. 파티클 스폰(Particle Spawn) 크기(Size)/ 위치(Location) / 색깔(Color)을 조절하고 수명(Life time)또한 조절한다.파티클 업데이트(Particle Update) 움직임(Movement)/ 스케일링(Tick마다 크기가 바뀌는) / Fading(점점 사라지거나 선명해지는)을 조절한다." }, { "title": "가능하면 항상 constexpr을 사용하라", "url": "/posts/15.Use-constexpr-whenever-possible/", "categories": "Modern Effective C++", "tags": "modern effective c++", "date": "2024-03-24 00:00:00 +0900", "snippet": " constexpr을 객체에 적용했을 때에는 본질적으로 const의 강화 버전처럼 작용하지만, 함수에 적용했을 때에는 상당히 다른 의미로 작용한다.constexpr 개념 constexpr은 어떠한 값이 단지 상수일 뿐만 아니라 컴파일 시점에 알려진다는 점을 나타낸다. 그러나 개념만 이해하면 constexpr을 함수에 적용할 때 상황이 미묘해지기 때문에 부족하다. 결론부터 말하면, constexpr 함수의 결과가 const가 아닐 수 있다는 점과 컴파일 시점에서 알려지지 않을 수 있다는 점은 constexpr의 장점이다. constexpr 객체의 경우 constexpr이 적용된 객체는 실제로 const이며, 값은 실제로 컴파일 시점에서 알려진다. 컴파일 시점에 알려지는 값들에는 특별한 권한이 있는데, 그 중 하나는 읽기 전용 메모리에 배치될 수 있다. 이 점은 내장형 시스템 개발자에게 중요할 수 있다. 상수이자 컴파일 시점에서 알려진 정수 값을 C++에서 정수 상수 표현식(integral constant expression)이 요구되는 문맥에서 사용할 수 있다는 것이다. // constexpr의 경우int sz; // non-constexpr 변수constexpr auto arraySize1 = sz; // 오류std::array&lt;int, sz&gt; data1; // 오류constexpr auto arraySize2 = 10; // 통과,10은 컴파일 시점 상수std::array&lt;int, arraySize2&gt; data2; // 통과// const의 경우int sz;const auto arraySize = sz; // 통과std::array&lt;int, arraySize&gt; data; // 오류, 컴파일 시점에 알려지지 않음 간단히 말해, 모든 constexpr 객체는 const이지만, 모든 const 객체가 constexpr인 것은 아니다.constexpr 함수 constexpr 객체의 사용에 있어 constexpr 함수가 관여하면 좀 더 흥미로워 진다. constexpr 함수에 대한 관점은 아래와 같다. 1. 컴파일 시점 상수를 요구하는 문맥에 constexpr 함수를 사용할 수 있다. 그런 문맥에서, 만일 constexpr 함수에 넘겨주는 인수의 값이 컴파일 시점에서 알려진다면, 함수의 결과는 컴파일 도중에 계산된다. 알려지지 않는다면 컴파일이 거부된다.2. 컴파일 시점에서 알려지지 않는 하나 이상의 값들로 constexpr 함수를 호출하면 함수는 보통의 함수처럼 작동한다. 즉, 그 결과는 실행시점에서 계산된다. 이는 같은 연산을 수행하는 함수를 두 버전(컴파일 상수버전과 일반 버전)을 나누어서 구현할 필요가 없음을 뜻하고 constexpr함수를 두 가지 용도로 사용하면 된다. 만약 컴파일을 위해 constexpr 버전의 pow값이 필요하다고 가정한다.constexprint pow(int base, int exp) noexcept // 예외 X{ ...}constexpr auto numConds = 5; // 조건 개수std::array&lt;int, pow(3,numConds)&gt; results; // 3^numConds개 요소를 담음 pow 앞에 constexpr이 있다고 하여 반드시 const값을 돌려주는 것이 아니라 그 constexpr은 오직 base와 exp가 컴파일 시점 상수일 때만 pow의 결과를 컴파일 시점 상수로 사용할 수 있다는 뜻이다. 즉, 매개변수도 constexpr이여야 결과도 constexpr이다. 런타임 상황의 constexpr 만약 매개 변수가 컴파일 시점 상수가 아니라면 pow의 결과도 런타임에서 계산될 수 있다.auto base = readFromDB(\"base\");auto exp = readFromDB(\"exponent\");auto baseToExp = pow(base, exp); // 런타임에서 pow함수 호출 constexpr 함수는 컴파일 시점 값들로 호출했을 때 반드시 컴파일 시점 결과를 산출할 수 있어야 하므로, 구현에 제약이 따른다. 하지만 C++11과 C++14의 제약이 조금 다르다. C++11 C++11에서 constexpr 함수는 실행 가능 문장이 “많아야” 하나이고 보통의 경우 그 문장은 return이다.constexpr int pow(int base, int exp) noexcept{ return (exp == 0 ? 1 : base * pow(base,exp - 1));}C++14 하지만 C++14에서는 constexpr 함수에 대한 제약이 상당히 느슨해져서 다음과 같은 구현이 허용된다.constexpr int pow(int base, int exp) noexcept{ auto result = 1; for(int i = 0; i&lt; exp; ++i) result *= base; return result;}리터럴 형식 constexpr 함수는 반드시 리터럴 형식을 받고 돌려주어야 한다. C++11에서 void를 제외한 모든 내장 형식이 리터럴 형식이고, 사용자 형식도 적절하게 사용하면 리터럴 형식으로 만들 수 있다. class Point{public: // 생성자 constexpr Point(double xVal,double yVal) noexcept : x(xVal), y(yVal) {} // 함수 constexpr double xValue() const noexcept { return x; } constexpr double yValue() const noexcept { return y; }private: double x,y;}; 생성자를 constexpr로 선언할 수 있는 이유는 인수들이 컴파일 시점에 알려진다면 생성된 Point 객체의 자료 멤버들 값도 컴파일 시점에서 알려질 수 있기 때문이다. 결과적으로, Point의 Get함수들은 다른 constexpr 객체를 초기화하는 constexpr 함수를 작성하는 것이 간능하다 constexpr Point midpoint(const Point&amp; p1, const Point&amp; p2) noexcept{ return { (p1.xValue() + p2.xValue()) / 2, (p1.yValue() + p2.yValue()) / 2 };}constexpr auto mid = midpoint(p1,p2);constepxr는 객체나 함수의 인터페이스의 일부 constexpr을 지정한다는 것은 이 함수(또는 객체)를 C++이 상수 표현식을 요구하는 문맥에서 사용할 수 있음을 의미하는 것이다. 어떤 객체나 함수를 constexpr로 선언한다면, 클라이언트는 그런 문맥으로 사용할 것이다. 나중에 바꾸면 미정의 행동이 되어버리기 때문에 가능한 한 항상 constexpr을 최대한 오래 유지하라는 의미이다. 결론 이것만은 잊지 말자! constexpr 객체는 const이며, 컴파일 도중에 알려지는 값들로 초기화한다 constexpr 함수는 그 값이 컴파일 도중에 알려지는 인수들로 호출하는 경우컴파일 시점 결과를 산출한다 constexpr 객체나 함수는 non-constexpr 객체,함수보다 광범위한 문맥에서사용할 수 있다 constexpr은 객체나 함수의 인터페이스의 일부이다. " }, { "title": "예외를 방출하지 않을 함수는 noexcept로 선언하라", "url": "/posts/14.Declare-functions-noexcept-if-they-won-t-emit-exceptions/", "categories": "Modern Effective C++", "tags": "modern effective c++", "date": "2024-03-21 00:00:00 +0900", "snippet": "C++98 예외명세 프로그래머는 함수에서 발생할 수 있는 예외 형식들을 요약하고, 그래서 함수의 구현이 수정되면 예외 명세도 바꿔야 할 가능성이 생겼다. 그런데 예외 명세가 변하면 호출자가 원래의 예외 명세에 의존할 수 있어 클라이언트 코드가 깨질 수 있다. 대체로 컴파일러는 함수 구현, 예외명세, 클라이언트 코드 사이 일관성 유지에 아무런 도움을 주지 않아 C++98에서는 예외 명세가 득보다 실이 컸다. C++11 예외명세 C++11에서는 함수가 예외를 하나라도 방출하는지의 여부에 의미가 있다고 생각하여 함수 선언시 함수가 예외를 방출하지 않을 것임을 명시할 때는 noexcept 키워드를 사용하면 된다. 함수를 noexcept로 선언할 것인지의 여부는 인터페이스 설계상의 문제이다. 함수의 예외 방출 행동은 클라이언트에게 아주 중요한 사항이다. 함수의 호출자는 함수의 noexcept 여부를 조회할 수 있고, 그 조회 결과는 호출 코드의 예외 안정성이나 효율성에 영향을 미친다. 그런만큼 함수의 noexcept 여부는 멤버 함수의 const 여부만큼이나 중요한 정보이다. noexcept 장점 예외를 만들지 않을 함수에 noexcept를 적용하는 것에 또 다른 장점이 있는데 그것은 컴파일러가 더 나은 목적 코드(object code)를 산출할 수 있다는 것이다 함수 f를 호출했을 때 호출자가 예외를 받게 되는 일이 절대 없게 하고 싶다고 한다. int f(int x) throw(); // f는 예외를 방출하지 않음 C++98 방식int f(int x) noexcept(); // f는 예외를 방출하지 않음 C++11 방식 실행시점에서 어떤 예외가 f 바깥으로 나오면 f의 예외 명세가 위반된다.C++98 C++98에서는 예외 명세가 위반되면 호출 스택이 f를 호출한 지점에 도달할 때까지 풀리며, 그 지점에서 몇가지 동작이 취해진 후 프로그램이 종료된다.C++11 C++11에서는 실행시점 행동이 약간 다르다. C++11에서 프로그램이 실행 종료되기 전에 호출 스택이 풀릴 수도 있고, 풀리지 않을 수도 있다. 호출 스택이 풀리는 것과 풀릴 수도 있는 것의 차이는 컴파일러 코드 작성에 놀랄 만큼 큰 영향을 미친다 noexcept 함수에서 컴파일러의 최적화기는 예외가 함수 바깥으로 전파될 수 있다고 해도 실행시점 스택을 풀기 가능 상태로 유지할 필요가 없다. 또한 예외가 noexcept 함수를 벗어난다고 해도 noexcept 함수 안의 객체들을 반드시 생성의 반대 순서로 파괴해야 하는 것도 아니다. 그러나 예외 명세가 throw()인 함수에는 그러한 최적화 유연성이 없으며, 예외 명세가 아예 없는 함수 역시 마찬가지로 그런 유연성이 없다. 반환형식 함수이름(매개변수목록) noexcept; // 최적화 여지가 가장 크다반환형식 함수이름(매개변수목록) throw(); // 최적화 여지가 더 작다반환형식 함수이름(매개변수목록); // 최적화 여지가 더 작다 예외를 산출하지 않을 함수는 noexcept로 선언하는 것이 좋은 이유는 이 예만으로 충분하지만, 다른 이유가 있는 함수들도 있다.이동 연산 C++98에서는 기존 메모리에 있는 객체를 파괴하고 일일이 복사했지만 C++11에서는 더 큰 메모리 조각을 새로 할당하고, 기존 메모리 요소를 새 조각으로 옮긴다. 이 접근방식 덕분에 push_back은 강한 예외 안전성을 보장할 수 있었다. 즉, 요소들을 복사하는 도중에 예외가 던져져도 요소들이 파괴되지 않아 vector의 상태는 변하지 않는다. 이러한 점에서 push_back의 예외 안전성 보장이 위반될 수 있다. push_back에서 예외 발생 기존 메모리에서 n개의 요소를 이동한 후 (n+1)번째 요소를 이동하는 도중에 예외가 발생하면 push_back 연산이 완료되지 못하고 실패한다. 그런데 vector는 이미 수정된 상태여서 요소들이 다른곳으로 이동했는데, 그것들을 원래대로 복원하는 것이 불가능할 수 있다. 각 객체를 원래의 메모리로 다시 이동하는 연산 자체에서도 예외가 발생할 수 있기 때문이다 가능하면 이동하되 필요하면 복사한다 기존 코드 행동이 push_back이 보장하는 예외 안전성에 의존할 수도 있다는 점에서, 심각한 문제이기 때문에 이동 연산들이 예외를 방출하지 않음이 확실하지 않은 한 C++11 컴파일러는 push_back 안의 복사 연산들을 소리없이 이동 연산들로 대체하지 않는다. 그리고 push_back뿐만 아니라, 표준 라이브러리의 여러 함수는 이러한 가능하면 이동하되 필요하면 복사한다 전략을 활용한다. 그래서 이동 연산이 예외를 방출하지 않음을 함수가 어떻게 알아낼 수 있는지는 주어진 연산이 noexcept로 선언되어 있는지를 확인하면 된다. swap noexcept가 특히나 바람직한 다른 예로 swap 함수가 있다. swap은 여러 STL 알고리즘 구현에서 핵심 구성요소이며, 복사 대입 연산자들에서도 흔히 사용된다. 여러 곳에서 사용되기 때문에 noexcept를 통해서 최적화할 가치가 크다. 표준 라이브러리에 있는 swap들의 noexcept 여부는 사용자 정의 swap들의 noexcept 여부에 어느정도 의존한다. template&lt;class T, size_t N&gt;void swap(T (&amp;a)[n], T(&amp;b)[n]) noexcept(noexcept(swap(*a,*b)));template&lt;class T1, class T2&gt;struct pair { // ... void swap(pair&amp; p) noexcept(noexcept(swap(first,p.first))) &amp;&amp; noexcept(noexcept(swap(second,p.second)));}; 이 함수들은 조건부 noexcept이여서, 이들이 noexcept 인지에 대한 것은 noexcept 절 안의 표현식들이 noexcept인지에 의존한다. 더 높은 수준의 자료구조들의 교환이 일반적으로 noexcept인지의 여부가 오직 더 낮은 수준의 구성요소들의 교환이 noexcept인지의 여부에 의존한다는 사실은, swap 함수를 작성할 때 가능한 한 항상 noexcept를 지정하는 것이 바람직하다는 뜻이다. 정확성 noexcept가 제공하는 최적화 기회도 중요하지만, 더 중요한 것은 정확성이다. 함수의 구현이 예외를 방출하지 않는다는 성질을 확실히 할때만 noexcept로 선언해야 한다. 만일 함수를 noexcept로 선언하고 나중에 마음을 바꾼다면, 흡족할 수습 방안이 없어 클라이언트 코드가 깨질 위험이 있다. 예외 중립적 함수 중요한 것은 대부분의 함수가 예외에 중립적이다 예외 중립적 함수는 스스로 예외를 던지지 않지만, 예외를 던지는 다른 함수들을 호출할 수 있다. 다른 함수가 예외를 던지면 예외 중립적 함수는 그 예외를 그대로 통과시킬 수 있어서 예외 중립적 함수는 결코 noexcept가 될 수 없다. 기본적인 noexcept 함수 모든 메모리 해제 함수와 모든 소멸자는 암묵적으로 noexcept 함수이다. 소멸자가 암묵적으로 noexcept로 선언되지 않는 경우는, 예외 방출 가능성을 명시적으로 밝힌 (noexcept(false)로 선언된) 소멸자를 가진 형식의 자료 멤버가 클래스에 있을 때 뿐이다. 표준 라이브러리에는 하나도 없다. 결론 이것만은 잊지 말자! noexcept는 함수의 인터페이스 일부이다. 이는 호출자가 noexcept 여부에의존할 수 있음을 뜻한다. noexcept 함수는 비noexcept 함수보다 최적화의 여지가 크다. noexcept는 이동 연산들과 swap,메모리 해제 함수들, 그리고 소멸자들에특히나 유용하다 대부분의 함수는 noexcept가 아닌 예외에 중립적이다. " }, { "title": "iterators보다 const_iterators를 선호하라", "url": "/posts/13.Prefer-const_iterators-to-iterators/", "categories": "Modern Effective C++", "tags": "modern effective c++", "date": "2024-03-18 00:00:00 +0900", "snippet": " const_iterators는 const를 가리키는 포인터의 STL 버전이다. const_iterators는 수정하면 안되는 값을 가리키기 때문에, 수정할 필요가 없을 때는 항상 const_iterators를 사용하는 것이 바람직하다. C++11는 물론 C++98에서도 그러는게 좋았지만, C++98에서 const_iterators로 관행을 지키는 것이 그리 달갑지는 않았다. 그런 반복자를 생성하기도 어렵고, 활용에도 제약이 있기 때문이다. C++98 버전 const_iterator vector&lt;int&gt;에서 1983을 찾고 1998을 넣는다고 가정을 한다. 만약 1983을이 없다면 vector의 맨 끝에 삽입한다. // C++98버전std::vector&lt;int&gt; values;std::vector&lt;int&gt;::iterator it = std::find(values.begin(),valeus.end(),1983);values.insert(it,1998); 그러나 이 코드는 iterator가 가리키는 것을 전혀 수정하지 않으므로, iterator가 최선의 선택은 아니다. iterator 대신 const_iterator를 사용하도록 코드를 고치는 것이 쉬워야 하지만, C++98에서는 그렇지 않았다. 다음은 개념적으로 건전하지만 실제로 정확하지 않은 접근 방식이다. // C++98버전typedef std::vector&lt;int&gt;::iterator IterT;typedef std::vector&lt;int&gt;::const_iterator ConstIterT;std::vector&lt;int&gt; values1;...ConstIterT ci = std::find(static_cast&lt;ConstIterT&gt;(values.begin()), static_cast&lt;ConstIterT&gt;(values.end()), 1983);values.insert(static_cast&lt;IterT&gt;(ci), 1998); //컴파일이 안될 수 있음 std::find 호출에서 static_cast를 사용한 것은, value가 non-const 컨테이너이며 C++98에서 const_iterator를 얻는 간단한 방법이 없었기 때문이다. static_cast를 사용하지 않더라도 가능은 하지만, 결국 작위적인 왜곡이 관여하게 필요하다 const_iterator를 얻는다 하더라도 C++98에서는 삽입과 삭제의 위치를 iterator로만 지정할 수 있기 때문에 const_iterator는 허용되지 않았다. 앞의 코드에서 const_iterator를 다시 iterator로 캐스팅한 이유가 const_iterator를 insert에 그대로 넘겨주면 컴파일이 되지 않기 때문이다. 하지만 넘겨주더라도 const_iterator에서 iterator로의 이식성 있는 변환은 존재하지 않아 컴파일이 되지 않을 수도 있다. C++11 버전의 const_iterator 하지만 C++11에서는 const_iterator를 얻기 쉽고 사용하기도 쉽다. 컨테이너 멤버 함수 cbegin과 cend는 const_iterator를 돌려주고 non-const 컨테이너도 그렇다. 그리고 삽입,삭제 위치를 지정하는 목적으로 반복자를 사용하는 STL 멤버 함수들은 실제로 const_iterator를 사용한다. iterator를 사용하는 기존 C++98 코드를 C++11에서 const_iterator를 사용하도록 개정하는 것은 아주 간단하다. std::vector&lt;int&gt; values;auto it = std::find(values.cbegin(), values.cend(), 1983); // cbegin과 cend를 사용valeus.insert(it, 1998); const_iterator에 대한 C++11의 지원에서 뭔가 부족한 점이 발견되는 상황은 최대한 일반적인 라이브러리 코드를 작성할 때 분이다. 그런 코드는 begin,end 함수를 멤버 함수가 아니라 비멤버 함수로 제공해야 하는 컨테이너들과 컨테이너 비슷한 자료구조들이 존재한다는 점을 고려한다. 내장 배열이 그러한 경우에 해당하며, 인터페이스가 오직 자유 함수들로만 이루어진 서드파티 라이브러리들도 그러한 경우이다. 그래서 일반성을 극대화한 코드는 특정 멤버 함수의 존재를 요구하는 대신 그 멤버 함수에 상응하는 비멤버 함수를 사용한다. // targetVal의 첫 출현을 찾고 그 위치에 insertVal를 삽입template&lt;typename C, tpyename V&gt;void findAndInsert(C&amp; container, const V&amp; targetVal, const V&amp; insertVal) { using std::cbegin; using std::cend; // 비멤버 cbegin,cend 사용 auto it = std::find(cbegin(container),cend(container),targetVal); container.insert(it, insertVal);} 이 템플릿은 C++14에서는 잘 작동하고 C++11에서는 begin과 end가 있지만, cbegin과 cend, rbegin, rend, crbegin, crend가 없어 작동하지 않는다. C++11에서 최대한 일반적인 코드를 작성하고, 사용하는 라이브러리들이 모두 누락된 비멤버 cbegin과 friend에 대한 템플릿을 제공하지 않는다면, 직접 구현하는 것도 어렵지 않다. template&lt;class C&gt;auto cbegin(const C&amp; container) -&gt; decltype(std::begin(container)){ return std::begin(container);} 컨테이너 같은 자료구조를 대표하는 임의의 인수 형식 C를 받고, 해당 const 참조 매개변수 container를 통해서 그 자료구조에 접근한다. C가 통상적인 컨테이너라면 container는 const버전에 대한 참조가 된다 그러한 const 컨테이너에 대해 비멤버 begin 함수를 호출하면 const_iterator 형식의 반복자가 반환된다. 이 템플릿이 돌려주는 것이 바로 그 반복자이다. 이런 구현 방식의 장점은, begin 멤버함수를 제공하지만 cbegin 멤버함수는 제공하지 않는 컨테이너에 대해서도 작동한다는 것이다. 즉,begin만 직접적으로 제공하는 컨테이너에 대해서도 이 비멤버 cbegin을 사용할 수 있다. 결론 다시 기본으로 돌아가서, 이번 항목의 요점은 가능한 const_iterator를 사용하라는 것이다. 이 조언의 근본적인 동기는 const를 사용하는 것이 의미가 있는 경우에는 항상 const를 사용하는 것이 바람직하다는 것인데, 이 조언은 C++11이전에도 참이였다. C++98에서 반복자를 다룰 때 이 조언이 전혀실용적이지 않지만, C++11에서는 두드러지게 실용적이고, C++14는 C++11에서 마무리하지 못한 몇가지 단점까지 해결한다. 이것만은 잊지 말자! iterator보다 const_iterator를 선호하자 최대한 일반적인 코드에서는 begin, end, rbegin 등의 비멤버 버전들을 해당 멤버 함수들보다 선호하라 " }, { "title": "Property None 에러", "url": "/posts/Property-None-%EC%97%90%EB%9F%AC/", "categories": "unreal, Unreal Etc", "tags": "unreal etc", "date": "2024-03-10 00:00:00 +0900", "snippet": " 가끔 블루프린트에서 값을 바꾸다가 Property가 None이라는 로그가 뜨면서 에러가 발생 이 에러에 걸리면 해당 변수의 Detail창에 아무것도 뜨지 않음 이유는 UPROPERTY에서 바꾸고 진행하다가 생기는 에러 해결 방법은 변수명을 한 번 바꾸면 된다. 한 번 바꾸고 다시 기존의 변수명으로 바꿔도 정상 작동한다. " }, { "title": "렌더링 관련 커맨드", "url": "/posts/%EB%A0%8C%EB%8D%94%EB%A7%81-%EA%B4%80%EB%A0%A8-%EC%BB%A4%EB%A7%A8%EB%93%9C/", "categories": "unreal, Unreal Etc", "tags": "unreal etc", "date": "2024-02-23 00:00:00 +0900", "snippet": "현재 Scene의 렌더링 정보 확인 언리얼 에디터에서 콘솔 키( ` )를 누르고 stat scenerendering을 치면 현재 렌더링되고 있는 Scene의 정보가 나타난다. Shift + L로 활성화/비활성화 가능 ~ 사진1 아래 창에 Mesh draw calls로 드로우콜을 확인할 수 있다.~사진2렌더링 일시정지 콘솔 창에서 FreezeRendering을 치면 현재 Scene의 렌더링을 일시 정지시킬 수 있다.뒤에 있는 메쉬 선으로 렌더링하기 r.VisualizeOccludedPrimitives 1를 입력하면 가려진 메쉬들을 선으로 렌더링한다.~사진3~사진4액터 병합으로 드로우콜 줄이기 툴-&gt;액터 병합으로 Static Mesh들을 하나의 Mesh로 만들어서 드로우콜을 줄일 수 있다.프로파일링 관련 커맨드 stat Unit : 프레임,게임 스레드,렌더링 스레드, GPU 시간, 드로우 표시~사진 stat Unit stat UnitGraph : stat Unit 데이터를 그래프로 확인~사진 stat UnitGraph참고 영상이나 홈페이지 https://www.youtube.com/watch?v=maHHsDd3j5A&amp;list=PLmQyxlVz7a7q38Six_EsLdp_nsc_aRJf7 https://docs.unrealengine.com/5.0/ko/stat-commands-in-unreal-engine/ " }, { "title": "재정의 함수들을 override로 선언하라", "url": "/posts/12.Declare-overriding-functions-override/", "categories": "Modern Effective C++", "tags": "modern effective c++", "date": "2024-02-20 00:00:00 +0900", "snippet": " C++의 객체 지향 프로그래밍에는 클래스,상속,가상함수를 중심으로 돌아간다. 그 중에 있는 가상 함수는 잘못 사용하기가 매우 쉽다. 가상함수가상함수의 필수조건 가상함수의 재정의가 일어나려면 다음과 같은 여러 필수조건을 만족해야 한다. 부모 클래스 함수가 반드시 가상 함수여야 한다. 부모 클래스의 함수와 자식 클래스의 함수가 같은 이름이어야 한다.(소멸자 예외) 부모 클래스의 함수와 자식 클래스의 함수의 매개변수 형식이 반드시 동일해야 한다. 부모 클래스의 함수와 자식 클래스의 함수의 const성이 동일해야 한다. 부모 클래스의 함수와 자식 클래스의 함수의 반환 타입과 예외 명세가 반드시 호환되어야 한다. 위는 C++98에서도 적용되는 규칙들이고, 이후 C++11에서 다음과 같은 조건 하나가 추가되었다. 멤버 함수들의 참조 한정사가 동일해야 한다. 참조 한정사 참조 한정사는 C++11의 기능으로, 이 기능으로 멤버 함수를 왼값 or 오른값에만 사용할 수 있게 제한할 수 있다. 가상 함수가 아닌 멤버 함수에도 가능하다. // 선언class Widget {public: void doWork() &amp;; // *this가 왼값일 때만 호출 void doWork() &amp;&amp;; // *this가 오른값일 때만 호출};// 적용Widget makeWidget(); // 팩토리 함수(오른값 반환)Widget w; // 보통 객체 (왼값 반환)...w.dowork(); // 왼값 전용 함수를 호출makeWidget().dowork(); // 오른값 전용 함수를 호출 주의해야할 점은 부모 클래스의 가상 함수에 참조 한정사가 있다면, 재정의하는 자식 클래스의 가상 함수에도 같은 참조 한정사가 있어야 한다.참조 한정사 사용 예시 멤버 함수 참조 한정사를 붙여야 하는 상황이 흔치 않지만,다음과 같은 경우에 사용한다 만약 Widget 클래스에 vector 멤버가 있고 그것에 직접 접근할 수 있는 멤버 함수를 클라이언트에게 제공한다고 한다. // 클래스class Widget{public: using DataType = std::vector&lt;double&gt;; DataType&amp; data() { return values; }private: DataType values;};// 사용Widget w;auto vals1 = w.data(); // w.values를 vals1에 복사 data의 반환 형식은 왼값 참조이며 왼값 참조는 정의상 왼값으로 취급되므로, vals1은 복사 생성된다. 다음으로, Widget을 생성하는 팩토리 함수가 있고 이 팩토리 함수를 통해 변수를 초기화한다고 한다. // 팩토리 함수Widget makeWidget();// 팩토리 함수로 초기화auto vals2 = makeWidget().data(); // Widget 안에 있는 values를 vals2에 복사 이 Widget::data 도 왼값 참조를 돌려주며 복사 생성되지만, Widget은 makeWidget이 돌려준 임시객체이다. 그 임시 객체 안의 vector를 복사보다 이동이 바람직하지만, data가 왼값 참조를 돌려주기 때문에 C++의 규칙들을 준수하는 컴파일러는 반드시 복사 연산을 위한 코드를 작성해야 한다. 정말로 필요한 것은 data가 오른값 Widget에 대해 호출될 경우에는 반드시 오른값을 돌려주게 하는 것이다. 참조 한정사 버전으로 오버로딩하면 그런 일이 가능하다. class Widget{public: using DataType = std::vector&lt;double&gt;; DataType&amp; data() &amp; { return values; } // 왼값 참조 한정사 DataType&amp;&amp; data() &amp;&amp; { return values; } // 오른값 참조 한정사private: DataType values;}; 왼값 참조 한정사는 왼값 참조를 돌려주고, 오른값 참조 한정사는 오른값 참조 한정사를 돌려준다.auto vals1 = w.data(); // 왼값 참조로, 복사 생성auto vals2 = makeWidget().data(); // 오른값 참조로, 이동 생성 하지만 멤버 함수에 참조 한정사가 붙어 있다면, 그 함수의 모든 오버로딩 함수들도 참조 한정사를 지정해야 한다. 이는 참조 한정되지 않은 오버로딩이 왼값 객체와 오른값 객체 모두에 대해 호출될 수 있기 때문이다. 그런 오버로딩은 참조 한정된 오버로딩들과 경쟁하며, 따라서 그 함수에 대해 모든 호출이 중의적인 호출로 변한다. 결론 이것만은 잊지 말자! 멤버 함수 참조 한정사를 이용하면 멤버 함수가 호출되는 객체(*this)의 왼값 버전과오른값 버전을 다른 방식으로 처리할 수 있다. " }, { "title": "정의되지 않은 비공개 함수보다 삭제된 함수를 선호하라", "url": "/posts/11.Prefer-deleted-functions-to-private-undefined-ones/", "categories": "Modern Effective C++", "tags": "modern effective c++", "date": "2024-02-17 00:00:00 +0900", "snippet": "함수들에 대한 접근 금지 다른 개발자에게 제공할 코드를 작성할 때, 그 개발자가 코드의 특정 함수를 호출하지 못하게 하는 가장 흔한 방법은 그 함수를 선언하지 않는 것이다. 그런 상황은 C++이 자동으로 작성하는 멤버 함수들에게 발생하는데 보통 복사 생성자와 복사 대입 연산자이다. C++98에서는 그런 함수들의 접근을 막기 위해 private으로 선언하고 정의하지 않기였지만,C++11에서는 = delete를 사용하여 접근을 금지한다. // C++98class A {private: void Func(); // 정의하지 않고 선언만하기};// C++11class A {public: void Func() = delete; // 접근 금지 키워드(=delete)사용};삭제된 함수(=delete)와 private의 차이 이 둘은 얼핏 보면 취향 문제인 것 같지만, 생각보다 차이가 크다. 삭제된 함수는 어떤 방법으로든 사용할 수 없어 friend나 멤버함수에서 접근하지 못한다. 삭제된 함수의 관례 삭제된 함수는 private이 아니라 public으로 선언하는 것이 관례인데 이유가 있다. 클라이언트 코드가 멤버 함수를 사용하려 할 때, C++은 먼저 그 함수의 접근성을 검사한 후에야 삭제 여부를 검사한다. 컴파일러 도중, private이라고 문제를 삼는 컴파일러가 있기 때문이다. 삭제된 함수의 장점1 중요한 장점 중 하나는, 그 어떤 함수도 삭제할 수 있지만, 반면 private은 멤버함수에만 적용할 수 있다. 비멤버(non-member) 함수 하나를 예시로 설명한다 C에서 물려받은 성질때문에, 암묵적 변환이 가능하다면 그대로 수행하기 때문에 논리적이지 않은 코드들도 문제없이 컴파일이 가능하다. bool isLucky(int num);if(isLukcy('a')) ... // 가능 char버전if(isLukcy(true)) ... // 가능 bool버전if(isLukcy(3.5)) ... // 가능 double버전 하지만 반드시 정수여야 한다면 위의 호출들이 아예 컴파일되지 않게 하는 것이 바람직하다. 그렇게 하기 위해서 사용된 오버로딩 함수들을 명시적으로 삭제하는 것이다 bool isLucky(int number);bool isLucky(char) = delete; // 삭제bool isLucky(bool) = delete; // 삭제bool isLucky(double) = delete; // 삭제 삭제된 함수는 비록 사용할 수 없지만, 오버로딩 과정에서 후보로 간주된다. 삭제된 함수 선언들이 있다고 할 때, 바람직하지 않은 함수 호출이 거부되는 것도 그 이유때문이다. 삭제된 함수의 장점2 두 번째 장점은 원하지 않는 템플릿 인스턴스화를 방지하는 것이다 다음과 같은 포인터를 매개 변수로하는 템플릿 함수가 있다고 한다 template&lt;typename T&gt;void processPointer(T* ptr); 포인터 중 특별한 포인터가 2가지가 있는데 void*와 char*가 있다. void*는 역참조,증가,감소가 아예 불가능하다는 점에서 특별하다 char*는 개별 문자를 가리키는 것이 아니라 C 스타일 문자열을 나타낸다는 점에서 특별하다 이 특수 포인터들에는 특별한 처리가 필요한 경우가 많은데, 템플릿이 이 특수 포인터로 호출하지 못하게 한다고 가정한다. 이를 달성하는 것은 삭제만 하면 되기 때문에 쉬운 일이다. template&lt;&gt;void processPointer&lt;void&gt;(void*) = delete;template&lt;&gt;void processPointer&lt;char&gt;(char*) = delete;// const 버전도 추가template&lt;&gt;void processPointer&lt;const void&gt;(const void*) = delete;template&lt;&gt;void processPointer&lt;const char&gt;(const char*) = delete; 더욱 철저하게 하고싶으면 volatile버전과 다른 표준 문자 형식들인 wchar_t등 다른 포인터들에 대한 버전도 삭제해야 한다.삭제된 함수의 장점3 그리고 또 흥미로운 점은, 클래스 안의 함수 템플릿의 일부 인스턴스화를 방지하려는 목적의 private 선언 접근방식은 적용할 수 없다 멤버 함수 템플릿의 한 특수화의 접근 수준을 그 템플릿 자체와 다르게 지정하는 것이 불가능하기 때문이다. class Widget {public: template&lt;typename T&gt; void processPointer(T* ptr) { ... }private: template&lt;&gt; // 오류 void processPointer&lt;void&gt;(void*);}; 이것이 불가능한 이유는, 템플릿 특수화는 반드시 클래스 범위가 아닌 이름공간 범위에서 작성해야 한다는 것이다. 삭제된 함수에는 다른 접근 수준을 지정할 필요가 없으므로 이런 문제가 없다. 멤버 함수를 바깥에서 삭제하는 것은 가능하다. class Widget {public: template&lt;typename T&gt; void processPointer(T* ptr) { ... }};template&lt;&gt; // 삭제void Widget::processPointer&lt;void&gt;(void*) = delete;결론 이것만은 잊지 말자! 정의되지 않은 비공개 함수보다 삭제된 함수를 선호해라 비멤버 함수와 템플릿 인스턴스를 비롯한 그 어떤 함수도 삭제가 가능하다. " }, { "title": "범위 없는 enum보다 범위 있는 enum을 선호하라", "url": "/posts/10.Prefer-scoped-enums-to-unscoped-enums/", "categories": "Modern Effective C++", "tags": "modern effective c++", "date": "2024-02-14 00:00:00 +0900", "snippet": "enum과 enum class 범위 일반적으로, 한 중괄호 쌍 안에서 이름을 선언하면 그 이름은 해당 중괄호 쌍이 정의하는 범위로 한정된다. 하지만 enum의 변수들은 적용되지 않는다. enum Color { black, white };auto white = false; // 오류! enum Color의 white와 중복된다. 하지만 enum class는 그런 누수가 발생하지 않는다.enum class Color { black, white };auto white = false; // 정상 작동Color c = white; // 오류! 이 범위에 white라는 이름은 없음Color c = Color::white; // 정상 작동암묵적 정수 변환 enum은 암묵적으로 정수로 변환된다enum Color { black, white };auto a = black;if(black &lt; 10) // black은 자동적으로 정수 0으로 변환되어 작동된다 하지만 enum class는 암묵적으로 정수로 변환되지 않는다. 만약 변환하고 싶다면 static_cast를 이용한다 enum class Color { black, white };auto a = Color::black;if(black &lt; 10) // 오류! black이 자동으로 정수로 변환되지 않는다....if(static_cast&lt;int&gt;(a) &lt; 10&gt;) // 이상하긴 하지만 정상 작동전방 선언 enum과 다르게 enum class는 전방 선언이 가능하여 미리 선언할 수 있다.enum Color; // 오류enum class Color; // 정상 작동 enum은 전방 선언의 차이로 인해 단점이 생기는데, 가장 주목할 만한 것은 컴파일 의존 관계이다.enum Status = { good = 0, failed = 1,}; 다음과 같은 형태에서 새 열거자를 추가한다면enum Status = { good = 0, failed = 1, incomplete = 100}; 결국 다시 컴파일해야 하는 상황이 오게 되어버린다. 하지만 enum class은 전방 선언으로 인해 다시 컴파일 필요가 없어진다. enum class Status; // 전방 선언void Func(Status s); // 전방 선언된 enum class 사용바탕 형식 (컴파일러가 결정하는 방법) enum은 바탕 형식은 없지만 콜론(:) 뒤에 선언하여 바탕 형식을 바꿀 수 있다.enum Color : std::uint8_t; // int이지만 uint_8로 변경 이로 인해 전방 선언이 가능하게 된다. enum class의 바탕 형식은 int로, enum과 마찬가지로 바탕 형식을 바꿀 수 있다.enum class Status; // 기본적인 바탕 형식은 intenum class Status : std::uint32_t; // 바탕 형식을 uint32_t로 변경 컴파일러는 enum class의 열거자들의 크기를 미리 알게된다. 결국 차이점은 enum는 바탕 형식을 지정해야만 전방 선언이 가능하지만 enum class는 지정하지 않아도 가능하다 튜플 그런데 enum이 유용한 상황이 적어도 하나는 존재한다. 그것은 C++11의 tuple 안에 있는 필드를 지칭할 때이다. // 웹사이트에서 사용할 튜플using UserInfo = std::tuple&lt;string, // 사용자 이름 string, // 이메일 주소 size_t&gt; // 평판치 주석에는 튜플의 각 필드가 뜻하는 바가 적혀 있지만, 다른 소스 파일에서 마주친다면 각 필드가 무엇을 뜻하는지 알기 힘들다.UserInfo uInfo;auto val = std::get&lt;1&gt;(uInfo) // 필드 1의 값을 획득 하지만 enum을 사용하면 간편해진다.enum UserInfoFields { uiName, uiEmail, uiReputation };UserInfo uInfo;auto val = std::get&lt;uiEmail&gt;(uInfo); // 이메일 주소를 획득 이 코드가 작동하는 이유는 암묵적 변환때문이다.결론 이것만은 잊지 말자! C++98 스타일의 enum을 범위 없는 enum이라 부른다 범위 있는 enum(enum class)의 열거자들은 그 안에서만 보인다.이 열거자들은 오직 캐스팅을 통해서만 다른 형식으로 변환한다. enum과 enum class 모두 바탕 형식 지정을 지원한다.enum class는 기본 바탕 형식이 int이지만, enum은 없다 enum class는 항상 전방 선언이 가능하다.enum은 바탕 형식을 지정해야만 전방 선언이 가능하다 " }, { "title": "typedef보다 별칭 선언을 선호하라", "url": "/posts/9.Prefer-alias-declarations-to-typedefs/", "categories": "Modern Effective C++", "tags": "modern effective c++", "date": "2024-02-10 00:00:00 +0900", "snippet": " 긴 형식을 여러 번 입력하지 않기 위해 typedef를 사용하곤 한다. 하지만 typedef 보다는 C++ 11에서부터 제공하는 using을 사용하는 것이 좋다 typedef와 using 기본적으로 typedef와 using이 하는 일은 동일하다. 무엇이 다른지를 이야기하기 전에 함수포인터에서는 using이 typedef보다 직관적이라는 점을 먼저 이야기한다. // 둘 다 (int,const string&amp;) 매개변수를 가진 FP라는 이름의 함수를 저장하는 변수typedef void (*FP)(int, const string&amp;);using FP = void (*)(int, const string&amp;);템플릿 이제 using이 typedef보다 선호되어야 하는 이유를 이야기하자면 템플릿이다. typedef는 템플릿화할 수 없지만 using은 템플릿화가 가능하다. 템플릿화된 별칭 선언을 별칭 템플릿이라고 한다. C++98에서는 템플릿화된 struct 안에 내포된 typedef들을 활용하는 편법을 동원해야 표현할 수 있었던 것들은 C++11에서는 쉽게 using으로 표현이 가능하다. // typedef 버전template&lt;typename T&gt;struct MyAllocList { typedef list&lt;T, MyAlloc&lt;T&gt;&gt; type;};MyAllocList&lt;Widget&gt;::type lw; // struct안에 선언한 typedef 타입으로 생성// using 버전template&lt;typename T&gt;using MyAllocList = list&lt;T, MyAlloc&lt;T&gt;&gt;;MyAllocList&lt;Widget&gt; lw; // using으로 만든 타입로 선언typename 심지어 typedef 버전을 템플릿안에서 사용하려면 typename까지 붙여줘야 한다는 귀찮은 점이 있다. 하지만 using을 사용하면 typename을 붙일 이유도 없다 typedef의 경우// typedef 버전template&lt;typename T&gt;class Widget {private: // struct안의 typedef로 선언된 type을 템플릿에서 사용하기 위해 // 맨 앞에 typename을 붙여야 함. typename MyAllocList&lt;T&gt;::type list;}; 클래스 템플릿(Widget)안에서 MyAllocList&lt;T&gt;::type을 만난 컴파일러가 형식의 이름인지 모른다. 이유는 MyAllocList&lt;T&gt;::type이 형식 이외의 어떤 것을 지칭할 가능성이 남아 있기 때문이다 아래의 예시처럼 멤버 변수를 지칭하는 가능성이 있음 class Wine{...};// T가 Wine인 경우(특수화)template&lt;&gt;class MyAllocList&lt;Wine&gt; {private: enum class WineType { White, Red, Rose }; WineType type;}; 이런 경우도 있기 때문에 typedef을 템플릿에서 사용할 때 typename을 붙여줘야 한다.using의 경우// using 버전template&lt;typename T&gt;using MyAllocList = list&lt;T, MyAlloc&lt;T&gt;&gt;;template&lt;typename T&gt;class Widget {private: MyAllocList&lt;T&gt; list; // typename 없이 선언}; 컴파일러는 클래스 템플릿(Widget)을 처리하는 과정에서 MyAllocList&lt;T&gt;(using으로 만든 변수)에 도달할 때, MyAllocList&lt;T&gt;가 이미 형식의 이름인지 알고 있기 때문에 typename을 붙일 필요도 없고 붙여서도 안된다. 이런 형식을 비의존적 형식이라고 한다. C++11과 C++14의 type trait(형식 특질) 템플릿 메타 프로그래밍(TMP)에서의 어떤 형식 T는, T에 담긴 const나 &amp;를 제거하는 경우가 있다. 위 예의 ::type 처럼 C++11 C++11에서의 type trait는 &lt;type_traits&gt; 헤더안의 템플릿을 이야기한다. 이 헤더에는 수십 가지 type trait가 모두 형식 변환을 수행하진 않지만, 예측 가능한 인터페이스를 제공한다. 변환을 적용하고자 하는 형식 T가 주어졌을 때, 그 결과의 형식은 std::변환&lt;T&gt;::type이다. std::remove_const&lt;T&gt;::type // const T -&gt; Tstd::remove_reference&lt;T&gt;::type // T&amp;,T&amp;&amp; -&gt; Tstd::add_lvalue_reference&lt;T&gt;::type // T -&gt; T&amp;C++14 C++14에서는 별칭 템플릿이 더 나은 방식임을 알고 C++11의 모든 형식 변환에 대한 별칭 템플릿 버전을 C++14에 포함시켰다. 그리고 그 결과의 형식은 std::변환_t이다. std::remove_const&lt;T&gt;::typestd::remove_const_t&lt;T&gt;std::remove_reference&lt;T&gt;::typestd::remove_reference_t&lt;T&gt;std::add_lvalue_reference&lt;T&gt;::typestd::add_lvalue_reference_t&lt;T&gt; 만약 C++14버전을 C++11버전으로 사용해야 하는 일이 있다면 다시 using을 사용해서 바꿀 수도 있다.template&lt;class T&gt;using remove_const_t = typename remove_const&lt;T&gt;::type;결론 이것만은 잊지 말자! typedef는 템플릿화를 지원하지 않지만,using은 지원한다. 별칭 템플릿(using)은 ::type 접미어를 붙일 필요가 없다.템플릿 안의 typedef를 지칭할 때는 typename 접두사를 붙여야 하는 경우가많다 C++14는 C++11의 모든 형식 특질 변환에 대한 별칭 템플릿들을 제공한다. " }, { "title": "0과 NULL보다 nullptr를 선호하라", "url": "/posts/8.Prefer-nullptr-to-0-and-NULL/", "categories": "Modern Effective C++", "tags": "modern effective c++", "date": "2024-02-07 00:00:00 +0900", "snippet": " 요점부터 말하면 리터럴 0은 int이고 포인터가 아니다. 포인터만 사용할 수 있는 위치에 0이 있으면 C++은 null 포인터로 해석하지만, 이는 최후의 수단이다 C++의 기본적인 방침은, 0은 int이지 포인터가 아니라는 것이다. NULL 실용적인 관점에서는 NULL도 마찬가지지만, 다소 불확실한 세부 사항이 존재한다. 흔치 않지만, 컴파일러가 NULL에 int 이외의 정수 형식을 부여할 수도 있기 때문이다 C++98에서 이 점이 야기하는 주된 문제는 포인터와 정수 형식에 대한 오버로딩이 의외의 방식으로 해소된다. // 3가지 오버로딩void f(int);void f(bool);void f(void*);f(0); // f(int) 호출f(NULL); // 컴파일되지 않을 수도 있지만, 보통은 f(int) // f(void*)를 호출하는 경우는 없다 NULL은 0L(long의 0)으로 정의되어 있다면 이 호출은 중의적이다 long-&gt;int, long-&gt;bool, long-&gt;void* 모두 우선순위가 같음 이 호출의 문제점은 소스코드의 외관상 의미와 실제 의미가 다르다는 것이다. 널 포인터로 f를 호출하는게 아닌 정수로 f를 호출하는게 되어버림 nullptr nullptr은 NULL과 다르게 정수 형식도 아니고 그렇다고 포인터 형식도 아니다. nullptr는 모든 형식의 포인터라고 생각하면 된다. nullptr의 실제 형식은 std::nullptr_t인데, 이 타입은 nullptr 형식으로 정의된다. nullptr_t는 모든 raw 포인터 형식으로 암묵적 변환이 가능하며, 이 때문에 nullptr은 모든 형식의 포인터처럼 행동한다. 앞에 나온 f 함수를 nullptr로 전달한다면 정수 매개변수가 아닌 포인터 형식의 매개변수가 호출된다. f(nullptr); // void* 호출nullptr은 코드의 명확성도 올려준다. 만약 auto 변수가 관여하는, 다음과 같은 코드가 있다고 한다.auto result = SomeFunc(...);if(result == 0) // result는 정수인지 포인터인지 알 수 없음 SomeFunc 함수의 반환 형식을 모른다면 result가 정수인지 포인터인지 알 수 없다. 하지만 nullptr로 사용한다면 result가 포인터 형식임이 명백해진다. auto result = SomeFunc(...);if(result == nullptr) // result는 포인터 형식템플릿에서의 nullptr nullptr은 템플릿에서 더욱 활약한다. 적절한 뮤텍스를 잠근 상태에섬나 호출해야 하는 함수가 있는데, 그 함수들이 다음처럼 각자 다른 종류의 포인터를 받는다고 가정한ㄷ다. int f1(shared_ptr&lt;Widget&gt; spw);double f2(uniuqe_ptr&lt;Widget&gt; spw)bool f3(Widget* pw); 다음과 같은 함수들은 0과 NULL, nullptr 모두 정상 작동한다.std::mutex f1m, f2m, f3m;using MuxGuard = std::lock_guard&lt;std::mutex&gt;;{ MuxGuard g(f1m); auto result = f1(0);}{ MuxGuard g(f2m); auto result = f2(NULL);}{ MuxGuard g(f3m); auto result = f1(nullptr);} 이러면 코드가 중복되므로, 이 코드를 템플릿화한다.template&lt;typename FuncType, typename MuxType, typename PtrType&gt;decltype(auto) lockAndCall(FuncType func, MuxType&amp; mutex, PtrType ptr){ using MuxGuard = lock_guard&lt;MuxType&gt;; MuxGuard g(mutex); return func(ptr);} 이러한 템플릿 버전의 함수는 0과 NULL은 컴파일되지 않고 nullptr만 가능하다.auto result1 = lockAndCall(f1, f1m, 0); // 오류auto result2 = lockAndCall(f2, f2m, NULL); // 오류auto result3 = lockAndCall(f3, f3m, nullptr); // 작동 첫 호출인 0을 넘겨주면 컴파일러가 0의 형식을 파악하기 위해 템플릿 형식 연역을 적용하는데, 0의 형식은 항상 int라는 것이다. 매개변수 ptr 형식은 int가 되고, int 형식은 shared_ptr&lt;Widget&gt;과 호환되지 않아 컴파일 오류 두 번째 호출인 NULL 역시 0과 같이 int 형식으로 연역되어, unique_ptr&lt;Widget&gt;과 호환되지 않아 컴파일 오류가 발생한다. 반면, nullptr만 호출에 문제가 없고 ptr을 f3에 전달하면 std::nullptr_t에서 Widget*로의 암묵적 변환이 일어난다. 결론 0과 NULL은 정수 형식으로도 되기 때문에 애매모호한 상황이 발생하거나 의도치 않은 결과가 일어날 수 있지만 nullptr는 항상 포인터 형식을 가리키기 때문에 이러한 문제들을 해결할 수 있다. 0과 NULL은 정수,포인터 둘 다 가능하여 오버로딩 문제에 민감하지만, nullptr은 그렇지 않다. 이것만은 잊지 말자! 0과 NULL보다 nullptr를 선호하자. 정수 형식과 포인터 형식에 대한 오버로딩은 피하자. " }, { "title": "객체 생성 시 괄호 (()) 와 중괄호 ({})를 구분해라", "url": "/posts/7.Distinguish-between-()-and-when-creating-objects/", "categories": "Modern Effective C++", "tags": "modern effective c++", "date": "2024-02-03 00:00:00 +0900", "snippet": "초기화 구문들 C++11에서 초기화값을 괄호,등호,중괄호로 사용할 수 있다. 등호와 중괄호로 같이 사용할 수도 있다. int x(0); // 괄호int y = 0; // 등호int z{ 0 }; // 중괄호int z = { 0 }; // 등호와 중괄호 초기화 구문에 있는 등호를 보고 C++ 초보자는 등호가 꼭 대입이 일어난다고 착각한다. 일반적으로 등호는 대입 형식이지만, 사용자 정의 형식에서는 초기화 or 대입이 각각 다른 함수로 호출ㄷ된다. Widget w1; // 기본 생성자Widget w2 = w1; // 복사 생성자w1 = w2; // 복사 대입 연산자균일 초기화(uniform initialization) 초기화 구문이 주는 혼동을 막기 위해, C++11에서 균일 초기화를 도입했다 어디서나 사용할 수 있고 개념상 모든 것을 표현할 수 있는 단 한 종류의 초기화다. 균일 초기화는 중괄호를 사용하며 이를 중괄호 초기화라 부른다 vector&lt;int&gt; v{1, 3, 5}; // 벡터 안에 1,3,5 요소로 초기화클래스 non-static 멤버 초기화 중괄호 구문은 non-static 멤버의 기본 초기화 값을 지정하는데 사용할 수도 있다. C++ 11에서는 등호 역시 초기화에 사용할 수 있다. class Widget{private: int x{ 0 }; // 가능 int y = 0; // 가능 int z(0); // 오류! 괄호는 초기화에 사용X};복사할 수 없는 객체 반면, 복사할 수 없는 객체(예를 들어 std::atomic)는 중괄호나 괄호로는 초기화가 되지만, 등호로는 초기화되지 않는다.atomic&lt;int&gt; ai1{ 0 }; // 가능atomic&lt;int&gt; ai2(0); // 가능atomic&lt;int&gt; ai3 = 0; // 오류 이렇게 중괄호 초기화는 C++이 지원하는 3가지 초기화 표현식 지정 방법 중 어디서나 사용할 수 있는 구문이다.암묵적 좁히기 변환(narrow conversion) 방지 중괄호 초기화의 혁신적인 기능 하나는, 내장 기능들 사이의 암묵적 좁히기 변환(narrow conversion)을 방지해 준다는 것이다. 중괄호 초기치에 있는 어떤 표현식 값을 초기화하려는 객체의 형식으로 온전하게 표현할 수 있도록 보장되지 않는다면, 컴파일러는 반드시 보고해야 한다. double x,y,z;int sum1 { x + y + z }; // double합을 int로 표현하지 못할 수 있어 보고 괄호나 등호는 이러한 좁히기 변환을 점검하지 않는다가장 성가신 구문 해석(most vexing parse) 중괄호 초기화의 또 다른 특징은 가장 성가신 구문 해석(most vexing parse)에 자유롭다는 것이다. 가장 성가신 구문 해석(most vexing parse)은 \"선언으로 해석할 수 있는 것은 항상 선언으로 해석해야 한다\"라는 C++의 규칙에서 비롯된 하나의 부작용이다. 만약 기본 생성자로 객체를 생성하려 했지만 의도와 달리 함수로 선언하게 됐다면 이 부작용에 의해 나타난 현상이다. // Widget 생성자 호출Widget w1(10);// 생성자가 아닌 Widget을 반환 타입으로 가지는 w2라는 이름의 함수를 선언Widget w2(); 하지만 매개변수 목록을 중괄호로 감싸면 함수를 선언할 수 없으므로 중괄호를 사용하면 된다.// 인수 없이 Widget의 생성자 호출Widget w3{};중괄호 초기화의 단점 중괄호 초기화의 단점은 종종 예상치 못한 행동을 보여준다. 그러한 단점들은 중괄호와 std::initializer_list, 생성자 오버로딩 사이 뒤얽힌 관계에서 비롯된다. std::initializer_list std::initializer_list가 들어있지 않는 생성자 호출이라면 괄호와 중괄호의 의미는 같다. 하지만 std::initializer_list가 들어있는 생성자가 있을 경우 그 버전을 강하게 선호하는 경향이 있다. // std::initializer_list 생성자 추가 전class Widget{public: Widget(int i, bool b); Widget(int i, double b);};Widget w1{10,true}; // int, boolWidget w2{10,5.0}; // int, double// std::initializer_list 생성자 추가 후class Widget{public: Widget(int i, bool b); Widget(int i, double b); Widget(std::initializer_list&lt;long double&gt; il); // 추가};Widget w3(10,true); // int,boolWidget w4{10,true}; // initializer_list 버전 호출 복사, 이동생성자와 initializer_list 복사 생성이나 이동 생성이 일어났을 상황에서도 initializer_list 생성자 버전이 기회를 가로치는 경우도 있다.// 연산자 추가class Widget{public: Widget(int i, bool b); Widget(int i, double b); Widget(std::initializer_list&lt;long double&gt; il); operator float() const; // 추가};Widget w1; // 기본 추가Widget w2(w1); // 복사 생성자 호출Widget w3{w1}; // initializer_list 생성자 버전 호출Widget w4(std::move(w1)); // 이동 생성자 호출Widget w5{std::move(w1)}; // initializer_list 생성자 버전 호출initializer_list 생성자 에러 심지어 initializer_list 생성자 버전이 최선이여도,그 생성자를 호출할 수 없는 기이한 현상이 생기기도 한다.class Widget{public: Widget(int i, bool b); Widget(int i, double b); Widget(std::initializer_list&lt;bool&gt; il);};Widget w{10, 5.0}; // 오류! 좁히기 변환이 필요 위와 같은 경우, int와 double을 각각 bool로 변환해야 하는데 좁히기 변환은 중괄호 초기화에서 허용되지 않아 컴파일이 되지 않는다. 컴파일러가 initializer_list가 아닌 오버로딩 함수를 고를 때에는 중괄호 초기치의 인수 형식들을 initializer_list 안의 형식으로 변환이 아예 없을 경우뿐이다. 괄호와 중괄호 경우의 수 마지막으로, 생성자의 오버로딩 중 initializer_list 버전이 있는 경우에서 괄호와 중괄호같은 경우 다음과 같다. 중괄호는 기본 생성자 호출, 괄호는 함수 선언이 되어버린다. initializer_list가 비어있는 생성자 버전을 호출하고 싶을 경우 괄호와 중괄호를 같이 사용해야 한다. class Widget{public: Widget(); Widget(std::initializer_list&lt;int&gt; il);};Widget w1; // 기본 생성자Widget w2{}; // 기본 생성자 호출Widget w3(); // 함수 선언이라 오류Widget w4({}); // 빈 initializer_list 생성자 호출Widget w5; // 빈 initializer_list 생성자 호출vector에서의 괄호와 중괄호 vector안에도 initializer_list 생성자 버전이 있는데 이 생성자 때문에 괄호와 중괄호의 의미가 달라진다.vector&lt;int&gt; v1(10, 20); // 값이 20인 원소 10개 생성vector&lt;int&gt; v2{10, 20}; // 값이 10인 원소와 값이 20인 원소, 총 2개 원소템플릿에서의 괄호와 중괄호 템플릿을 작성하는 프로그래머에겐 객체 생성 시 괄호와 중괄호 중 어떤 것을 사용해야 하는지 모르는 경우가 생긴다.template&lt;typename T, typenames... Ts&gt;void doSomeWork(Ts&amp;&amp;... params){ // params...으로부터 지역 T 객체 생성} 함수 본문에 지역 T객체를 생성하는 코드를 다음과 같이 바꿀 수 있다.T localObject(std::forward&lt;Ts&gt;(params)...); // 괄호T localObject{std::forward&lt;Ts&gt;(params)...}; // 중괄호 그리고 다음과 같은 호출 코드를 생각해보자std::vector&lt;int&gt; v;doSomework&lt;std::vector&lt;int&gt;&gt;(10, 20); 이렇게 되면 괄호를 사용하면 요소가 10개인 vector, 중괄호를 사용하면 요소가 2개인 vector가 생긴다. 어느 쪽이 옳은지는 doSomeWork 작성자가 알수 없고 호출자만이 알 수 있다. 이는 표준 라이브러리 함수 std::make_unique와 std::make_shared가 해결해야 했던 문제와 동일하다. 두 함수는 내부적으로 괄호를 사용하고,그러한 결정을 인터페이스의 일부에 문서화함으로써 문제를 해결한다. 결론 이것만은 잊지 말자! 중괄호 초기화는 가장 광범위하게 적용할 수 있는 초기화 구문이며, 좁히기 변환을 방지하고, C++의 가장 성가신 구문 해석에 자유롭다 생성자 오버로딩에서 중괄호 초기화는 가능한 initialize_list 매개변수가있는 생성자를 우선적으로 선택한다 괄호와 중괄호의 선택이 의미 있는 차이를 만드는 예는 인수 두개로 vector&lt;T&gt;을 생성하는 것이다. 템플릿 안에서 객체를 생성할 때 중괄호인지 괄호인지 선택하기 어려울 수 있다. " }, { "title": "auto가 원치 않은 형식으로 연역될 때에는 명시적 형식의 초기치를 사용하라", "url": "/posts/6.Use-the-explicitly-typed-initializer-idiom-when-auto-deduces-undesired-types/", "categories": "Modern Effective C++", "tags": "modern effective c++", "date": "2024-01-30 00:00:00 +0900", "snippet": " 항목 5에서 설명했듯이, auto에는 여러 장점이 있지만 의도치 않은 결과로 이어질 경우도 있다.vector&lt;bool&gt;// vector의 bool 변수들은 Widget이 특정 기능을 지원하는지를 의미vector&lt;bool&gt; features(const Widget&amp; w);Widget w;// 인덱스 5는 Widget의 우선순위를 나타냄bool highPriority = features(w)[5];// w를 우선순위에 맞게 처리processWidget(w, highPriority); 위 코드는 정상적으로 작동하는데, 만약 highPriority의 명시적 형식을 auto로 대체한다면 상황이 매우 달라진다.auto highPriority = features(w)[5];processWidget(w, highPriority); // 미정의 행동! 여기서 미정의 행동이 발생하는 이유는 vector&lt;bool&gt;의 operator[]가 돌려주는 것은 그 컨테이너의 한 요소에 대한 참조가 아니라, vector&lt;bool&gt;::reference 형식의 객체를 돌려주기 때문이다. vector&lt;bool&gt;이 자신의 bool들을 bool당 1비트의 압축된 형태로 표현하도록 명시되어 있기 때문에,vector&lt;bool&gt;::reference는 대리자 클래스로 사용 그래서 vector&lt;T&gt;의 operator는 T&amp;를 돌려줘야 하지만, C++에서는 비트에 대한 참조는 금지되어 있기 때문에 bool&amp;를 돌려주지 못해 우회책인 reference를 사용하는 것이다. 대리자 클래스 하지만 이러한 reference같은 대리자 클래스는 개념적으로 원래 보이지 않도록 설계되어 있어 쓰이고 있는지를 알기가 힘들다 보통 라이브러리의 문서로 알 수 있고 문서화의 결함은 헤더 파일이 채워주기도 한다. 소스코드에서 대리자 객체의 존재를 완전히 숨길 수 있는 경우가 거의 없다. 일반적으로 대리자 객체는 클라이언트가 호출하도록 만들어진 어떤 함수가 돌려주며, 그런 함수의 서명을 보면 대리자 객체의 존재를 확인할 수 있는 경우가 많다. // vector&lt;bool&gt;::operator[]namespace std { template&lt;class Allocator&gt; class vector&lt;bool, Allocator&gt; { public: // ... class reference { ... }; // 대리자 클래스 reference operator[](size_type n); // 대리자 클래스 반환 }}형식 명시 초기치 관용구(explicitly typed initializer idiom) auto가 다른 형식을 연역하는게 auto 자체의 문제점은 아니기 때문에 해결하는 방법은 auto가 다른 형식을 연역하도록 강제하는 것이다. 변수를 auto로 선언하되, 초기화 표현식의 형식을 auto가 연역하길 원하는 형식으로 캐스팅한다. auto highPriority= static_cast&lt;bool&gt;(features(w)[5]); 이전처럼 vector&lt;bool&gt;::reference 객체를 돌려주되, 캐스팅때문에 표현식의 형식은 bool이 되어 변수의 형식도 bool로 연역된다결론 이것만은 잊지 말자! 보이지 않는 대리자 형식 때문에 auto가 초기화 표현식의 형식을 잘못연역할 수 있다. 형식 명시 초기치 관용구는 auto가 원하는 형식을 연역하도록 강제한다. " }, { "title": "명시적 형식 선언보다는 auto를 선호하라.", "url": "/posts/5.Prefer-auto-to-explicit-type-declarations/", "categories": "Modern Effective C++", "tags": "modern effective c++", "date": "2024-01-27 00:00:00 +0900", "snippet": " auto 덕분에 다음과 같은 문제점을 피할 수 있다.초기화 문제 auto를int x1; // 문맥에 따라 초기화되지 않을 수 있음auto x2; // 오류! 초기화 필수auto x3 = 0; // 작동간단한 표현template&lt;typename It&gt;void dwim(It b, It e){ for(; b != e; ++b) { // typename std::iterator_traits&lt;It&gt;::value_type을 auto로 표현 auto currValue = *b; // ... }}명시적 지정 클로저 형식은 컴파일러만 알고 있어 명시적으로 지정하는 것이 불가능했지만,C++14에서는 람다 표현식의 매개변수에도 auto를 적용이 가능하다// const std::unique_ptr&lt;Widget&gt;&amp;를 auto로 표현auto derefLess = [](const auto&amp; p1, const auto&amp; p2) { return *p1 &lt; *p2 }; 여기서 auto 대신 std::function을 사용하면 되지 않을까라는 의문이 있을 수도 있다.std::function 일단 std::function에 대해서 설명하자면, C++11 표준 라이브러리의 한 템플릿으로,함수 포인터 개념을 일반화한 것이다. 함수 포인터는 함수만 가리킬 수 있지만, std::function은 호출 가능한 객체이면 어떤 것이라도 가리킬 수 있다. 함수 포인터를 만들 때 그 포인터가 가리키는 함수 형식을 만드는 것처럼 std::function도 포인터의 함수 형식을 지정해야 한다. std::function의 함수 형식은 템플릿 매개변수를 통해 지정한다 std::function&lt;bool&gt;(const std::unique_ptr&lt;Widget&gt;&amp;, const std::unique_ptr&lt;Widget&gt;&amp;)&gt; Func; 람다 표현식이 산출하는 클로저는 호출 가능 객체로 std::function 객체에 저장할 수 있다.std::function&lt;bool&gt;(const std::unique_ptr&lt;Widget&gt;&amp;, const std::unique_ptr&lt;Widget&gt;&amp;)&gt; Func = [](const std::unique_ptr&lt;Widget&gt;&amp; p1, const std::unique_ptr&lt;Widget&gt;&amp; p2) {return *p1 &lt; *p2; };std::function과 auto 차이 std::function과 auto사이에 외견상의 차이보다 더 중요한 것이 있다. auto로 선언된 변수와 클로저를 담는 변수는 클로저와 같은 형식이며, 따라서 그 클로저가 요구되는 만큼의 메모리만 사용한다. 그러나 클로저를 담는 std::function으로 선언된 변수 형식은 std::function 템플릿의 한 인스턴스이며, 크기는 고정되어있다. 그런데 그 크기가 요구된 클로저를 저장하기에 부족할 수 있으며, 그런 경우std::function은 힙 메모리를 할당해서 클로저를 저장한다. 결과적으로 std::function은 auto로 선언된 객체보다 메모리를 더 많이 소비한다. 그리고 인라인화(inlining)를 제한하고 간접 함수 호출을 산출하는 구현 세부사항 때문에,std::function 객체를 통해 클로저를 호출하는 것은 거의 항상 auto로 선언된 객체를 통해 호출하는 것보다 느리다. 즉, 결론은 std::function 접근 방식은 auto 접근방식보다 메모리와 시간을 더 많이 소비하며, 경우에 따라 메모리 부족 예외를 유발할 수도 있다. 암묵적 변환1 : 형식 단축 auto의 또 다른 장점은 형식 단축(type shortcut)관련 문제를 피할 수 있다는 것이다. 형식 관련은 다음과 같다. vector&lt;int&gt; v;// ...unsinged sz = v.size(); v.size()의 반환 형식은 vector::size_type이지만, 그 점을 아는 개발자가 별로 없어 unsigned라고 선언해버린다. 그런데 32비트에서는 위 두 형식의 크기가 같지만, 64비트에서는 unsigned는 32비트, vector::size_type은 64비트이다. 32비트에서 64비트로 이식할 때 이러한 문제를 해결하기 위해 auto를 사용하면 된다. 암묵적 변환2 : 형식 불일치 다음과 같은 장점도 있다.unordered_map&lt;string, int&gt; m;for(const pair&lt;string,int&gt;&amp; p : m){ // ... p로 뭔가 수행} 위 코드에서 문제점이 있는데, 키 부분이 const이므로, 선언한 변수와 달리pair의 형식은 pair&lt;string,int&gt;가 아닌 pair&lt;const string,int&gt;가 되어버린다. 변수 p와 선언된 변수의 형식이 달라서 컴파일러는 p의 형식을 선언된 변수의 형식으로 바꾸려고 한다. 반복문에서 컴파일러는 p를 묶고자 하는 형식의 임시 객체를 생성하고, m의 각 객체를 복사하고, 참조 p를 그 임시 객체에 묶음으로써 그러한 변환을 실제로 수행한다. 이러한 의도치 않은 형식 불일치 역시 auto로 해결이 가능하다. 결론 이것만은 잊지 말자! auto 변수는 반드시 초기화해야 하고, 이식성 또는 효율성 문제를 유발할 수있는 형식 불일치가 발생하는 경우가 거의 없으며, 대체로 변수의 형식을 명시적으로 지정할 때보다 타자량도 더 적다. auto로 형식을 지정한 변수는 항목2와 항목6에서 설명한 문제점들을 겪을 수있다. " }, { "title": "연역된 형식을 파악하는 방법을 알아두라.", "url": "/posts/4.Know-how-to-view-deduced-types/", "categories": "Modern Effective C++", "tags": "modern effective c++", "date": "2024-01-24 00:00:00 +0900", "snippet": " 형식 연역 결과를 직접 확인하는 수단은 필요한 시점에 따라 다르다. 이번 항목에선 3가지 시점으로 살펴본다. IDE 편집기 IDE 코드 편집기는 프로그램 개체(변수,매개변수,함수 등)을 마우스 커서에 올리면 개채 형식을 표현해준다. 이런 일이 가능하려면 코드가 어느정도 컴파일 가능한 상태여야 한다. IDE안에 C++ 컴파일러가 실행되어 알려준다. 컴파일러 진단 메세지 일반적으로 컴파일러가 연역한 형식을 파악하는데 효과적인 방법은 원하는 형식 때문에 컴파일 문제가 발생하게 만드는 것이다.실행시점 출력 형식 정보를 printf를 이용해 표시하는 접근 방식은 실행시점에서만 사용할 수 있지만, 출력 서식을 완전히 제어할 수 있다는 장점이 있다. 그렇다고 해서 printf 사용을 권장하지 않는다. " }, { "title": "decltype의 작동 방식을 숙지하라", "url": "/posts/3.Understand-decltype/", "categories": "Modern Effective C++", "tags": "modern effective c++", "date": "2024-01-21 00:00:00 +0900", "snippet": " decltype은 주어진 이름이나 표현식의 형식을 알려주는 키워드 하지만 가끔 예상밖의 결과를 제공 대부분의 경우 템플릿과 auto와 달리 decltype은 그대로의 결과를 도출한다.const int i = 0; // decltype(i)는 const intbool f(const Widget&amp; w); // decltype(w)는 const Widget&amp; // decltype(f)는 bool(const Widget&amp;)if(f(w)) // decltype(f(w))는 boolstruct Point{ int x,y; // decltype(Point::x)는 int}; // decltype(Point::y)는 inttemplate&lt;typename T&gt;class vector { public: T&amp; operator[](std::sizee_t index);};vector&lt;int&gt; v; // decltype(v)는 vector&lt;int&gt;if(v[0] == 0) // decltype(v[0])는 int&amp;템플릿의 operator[]C++11 C++11에서 decltype은 함수의 반환 형식이 그 매개변수 형식들에 의존하는 함수 템플릿을 선언할 때 주로 사용된다 T의 객체를 담은 container의 operator[] 연산은 T&amp;를 돌려주는데,중요한 점은 container의 operator[]의 반환 형식이 container에 따라 다르다. decltype을 이용하면 그런 함수의 반환 형식을 손쉽게 표현할 수 있다. template&lt;typename Container, typename Index&gt;auto authAndAccess (Container&amp; c, Index i) -&gt; decltype(c[i]){ // ... return c[i];} 여기서 auto는 형식 영역이 아닌, 후행 반환 형식(trailing return type)으로 사용된다. 후행 반환 형식은 return type을 매개변수 목록 다음에 선언하겠다는 것 후행 반환 형식은 매개변수의 타입을 선언한 후에 return type을 정할 수 있음 C++14 C++11에서는 람다 함수로 반환 형식의 연역을 허용하며,C++14에서는 확장해서 모든 람다와 모든 함수의 return type의 연역을 허용한다. C++ 14에서는 위 코드에서 후행 반환 형식을 사용하지 않고 auto만 사용해도 작동한다. template&lt;typename Container, typename Index&gt;auto authAndAccess (Container&amp; c, Index i){ // ... return c[i];} 항목2에서 설명했듯이, 함수 반환 형식이 auto라면 컴파일러는 템플릿 형식 연역을 적용한다. 항목1에서는 템플릿 형식 연역 과정에서 초기화 표현식의 참조성이 무시된다고 설명했었다. 컨테이너에 대한 operator[] 연산이 대부분 T&amp;를 돌려주는데, 위 두 규칙때문에 다음과 같은 코드가 에러가 발생한다. std::deque&lt;int&gt; d;authAndAccess(d,5) = 10; // d[5]를 돌려주고 10을 d[5]에 배정하는 코드 // 오른값에 다시 오른값을 배정해버려 에러 발생 d[5]는 int&amp;를 돌려주지만, 위 함수의 auto때문에 참조가 제거되어 반환 형식은 int가 되어버린다. 반환값인 int는 오른값이고 이 int에 10을 배정하려는 코드가 되어버려서 컴파일되지 않는다. decltype(auto)함수 반환 형식 C++14부터 추가된 decltype(auto)를 통해 decltype 형식 연역을 적용할 수 있다. auto는 해당 형식이 연역되어야 함을 뜻하고,decltype은 연역 과정에서 decltype 형식 연역 규칙들이 적용되어야 함을 의미한다. template&lt;typename Container, typename Index&gt;decltype(auto) authAndAccess (Container&amp; c, Index i) // decltype을 추가{ // ... return c[i];} 이제 authAndAccess의 반환 형식은 실제로 c[i]의 반환 형식과 일치한다. c[i]가 T&amp;를 돌려주는 경우 T&amp;를 돌려주고, c[i]가 하나의 객체를 돌려주는 흔치않은 경우여도 역시 같은 형식의 객체를 돌려준다. 변수 및 초기화 표현식Widget w;const Widget&amp; cw = w;auto myWidget1 = cw; // auto 형식 연역 // 형식은 Widgetdecltype(auto) myWidget2 = c2; // decltype 형식 연역 // 형식은 const Widget&amp; 하지만 고칠 사항이 두 부분이 있다.첫 번째template&lt;typename Container, typename Index&gt;decltype(auto) authAndAccess(Container&amp; c, Index i); // Container&amp; 컨테이너 c는 non-const 객체에 대한 왼값 참조로 사용되는데, 문제점은이 때문에 함수에 오른값 컨테이너는 전달할 수 없다. 오른값도 받기 위해선 오버로딩 방법도 있지만, 보편 참조를 사용하는 것이 관리하기도 편하다. template&lt;typename Container, typename Index&gt;decltype(auto) authAndAccess(Container&amp;&amp; c, Index i); // Container&amp;&amp; 지금 시점에선 이 템플릿의 형식과 인덱스 객체의 형식은 알 수 없다. 항목25에 따라, 보편 참조에 std::forward를 사용하면 된다. template&lt;typename Container, typename Index&gt;decltype(auto) authAndAccess(Container&amp;&amp; c, Index i);{ // ... return std::forward&lt;Container&gt;(c)[i];}두 번째 decltype은 아주 가끔 예상 밖의 결과를 제공한다. 그래서 완전히 이해하려면 몇 특별한 경우에 익숙해져야 하는데 여기서는 한 가지만 소개한다. decltype을 이름에 적용하면 이름에 대해 선언한 형식이 나오는데 대체로 이름은 왼값 표현식이지만 decltype 행동에 영향을 주진 않는다. 하지만 이름보다 복잡한 왼값 표현식에 대해서는 decltype은 항상 왼값 참조를 반환한다. 형식이 T인 어떤 왼값 표현식에 대해 decltype은 T&amp;를 반환 그래서 아래와 같은 경우가 생긴다. decltype(auto) f1(){ int x = 0; return x; // x는 int}decltype(auto) f2(){ int x = 0; return (x); // (x)는 int&amp;} f1과 달리 f2는 더욱 위험한 것이 참조로 반환하기 때문에 미정의 행동을 발생시킬 수 있다.결론 이것만은 잊지 말자! decltype은 항상 변수나 표현식의 형식을 아무 수정 없이 보고한다. decltype은 형식이 T이고 이름이 아닌 왼값 표현식에 대해서는 항상 T&amp;를보고한다. C++14는 decltype(auto)를 지원한다. decltype(auto)는 auto처럼 초기치로부터 형식을 연역하지만, 형식 연역 과정에서 decltype 규칙을적용한다. " }, { "title": "변수", "url": "/posts/%EB%B3%80%EC%88%98/", "categories": "python", "tags": "python", "date": "2024-01-20 00:00:00 +0900", "snippet": "변수 변수는 데이터를 저장하는 이름을 부여한 메모리 공간이다.변수명 = 변수에 저장할 값a = 3 위에서 a는 변수의 이름, 3이라는 정수형 객체가 저장된 메모리의 위치를 가리키게 된다. 즉, 변수 a는 객체가 저장된 메모리의 위치를 가리키는 레퍼런스이다상수가 아닌 정수형 객체 파이썬의 모든 자료형은 객체이다. 그러므로 위의 예시에서 3은 상수가 아닌 정수형 객체다. &gt;&gt;&gt; a = 3&gt;&gt;&gt; b = 3&gt;&gt;&gt; a is bTrue a와 b 둘 다 3이라는 정수형 객체를 가리키므로 파이썬의 내장 함수인 is를 사용하면 True를 리턴하게 된다 3이라는 객체를 가리키고 있는 변수는 2개이므로 레퍼런스 카운트가 2개란는 뜻이다 변수 만드는 방법# 튜플, 괄호 생략 가능함a,b = ('python','life')# 리스트[a,b] = ['python','life']# 여러 개의 변수에 같은 값을 대입a = b = 'python'# 위의 방법을 사용하여 아래와 같이 사용 가능a = 3b = 3a,b = b,a # a와 b의 값을 바꿈# a는 5, b는 3만든 변수 없애기 del 이라는 내장 함수를 사용하면 된다a = 3b = 3del(a)del(b)리스트를 변수에 넣고 복사하고자 할 때 주의 사항a = [1,2,3]b = aa[1] = 4# a는 [1,4,3]# b는 [1,2,3]이 아닌 [1,4,3] 여기서 b에 a리스트를 대입했으므로 a의 리스트를 바꾸면 b의 리스트도 바뀌게 된다레퍼런스를 피하는 방법[:] 이용# [:]를 뒤에 붙이면 복사가 됨b = a[:]copy 모듈 이용# 아래는 copy 모듈을 사용하기 위한 코드from copy import copyb = copy(a)" }, { "title": "Count", "url": "/posts/Count/", "categories": "", "tags": "", "date": "2024-01-18 00:00:00 +0900", "snippet": "" }, { "title": "auto의 형식 연역 규칙을 숙지하라", "url": "/posts/2.Understand-auto-type-deduction/", "categories": "Modern Effective C++", "tags": "modern effective c++", "date": "2024-01-18 00:00:00 +0900", "snippet": "auto와 템플릿 auto 형식은 한가지 예외만 빼면 템플릿과 똑같이 작동한다. auto 형식 연역과 템플릿 형식 연역 사이에는 직접적인 대응 관계가 존재한다. // 템플릿template&lt;typename T&gt;void f(ParamType param);f(expr); auto를 이용한 변수는 템플릿의 T와 동일한 역할을 하며, 변수의 형식 지정자는 ParamType과 동일한 역할을 한다.auto x = 27; // autoconst auto cx = x; // const autoconst auto&amp; rx = x; // const auto&amp; 위 변수들의 형식들을 연역할 때 컴파일러는 선언마다 템플릿 함수 하나와 해당 초기화 표현식으로 템플릿 함수를 호출하는 구문의 존재하는 것처럼 행동한다.// auto로 선언한 변수가 아래 템플릿과 똑같이 작동template&lt;typename T&gt;void func_for_x(T param);func_for_x(27);// const auto로 선언한 변수가 아래 템플릿과 똑같이 작동template&lt;typename T&gt;void func_for_cx(const T param);func_for_cx(x);// const auto&amp;로 선언한 변수가 아래 템플릿과 똑같이 작동template&lt;typename T&gt;void func_for_rx(const T&amp; param);func_for_rx(x);auto 형식 연역 항목 1의 템플릿 형식 연역처럼 auto도 형식 연역 3가지 경우로 나뉜다. 형식 지정자가 포인터나 참조형식이지만 보편 참조는 아닌 경우 형식 지정자가 보편 참조인 경우 형식 지정자가 포인터도 아니고 참조도 아닌 경우 경우 1과 3auto x = 27; // 경우 3 (포인터,참조 아님)const auto cx= x; // 경우 3 (포인터,참조 아님)const auto&amp; rx =x; // 경우 1 (rx는 보편 참조가 아닌 참조)경우 2auto&amp;&amp; uref1 = x; // x는 int, 왼값이므로 // uref1는 int&amp;auto&amp;&amp; uref2 = cx; // cx는 const int,왼값이므로 // uref2는 const int&amp;auto&amp;&amp; uref3 = 27; // 27은 int, 오른값이므로 // uref3은 int&amp;&amp;배열,함수 항목1에서 non-const참조 형식 지정자의 경우 배열,함수 이름이 함수 포인터로 붕괴했는데, auto 역시 똑같이 작동한다.// 주석은 변수의 형식const char name[] = \"R.N.Briggs\"; // const char[13]auto arr1 = name; // const char*auto&amp; arr2 = name; // const char(&amp;)[13]void someFunc(int, double); // void(int,double)auto func1 = someFunc; // void(*)(int,double)auto&amp; func2 = someFunc; // void(&amp;)(int,double)다른점 균일 초기화(uniform initialization)를 지원하는 C++11에서 다음과 같이 사용이 가능하다// C++98int x1 = 27;int x2(27);// C++11int x3 = { 27 };int x4{27}; 항목5에서 설명하지만, 고정된 형식 대신 auto를 이용하면 장점이 있지만, auto로 바꾸면 이전과 의미가 달라지는 것들이 생긴다.auto x1 = 27; // intauto x2(27); // intauto x3 = {27}; // std::initializer_list&lt;int&gt;auto x4 { 27 }; // std::initializer_list&lt;int&gt; auto의 특별한 형식 연역 규칙때문인데 중괄호로 감싸인 형태면 형식은 initializer_list이 되어버린다. 이러한 중괄호 초기치때문에 템플릿 함수에서 컴파일이 거부되는 경우가 생긴다. auto x = {11,23,9};template&lt;typename T&gt;void f(T param) ;f({ 11, 23, 9 }); // T에 대한 형식을 연역할 수 없음 템플릿 T타입을 initializer_list로 하면 정상적으로 연역된다.template&lt;typename T&gt;void f(std::initializer_list&lt;T&gt; initList) ;f({ 11, 23, 9 }); // T에 대한 형식을 연역할 수 없음 정리하자면 auto 형식 연역과 템플릿 형식 연역의 실질적인 차이는,auto는 중괄호 초기치가 std::initialize_list를 나타낸다고 가정하지만,템플릿 형식 연역은 그렇지 않다함수 반환 형식 auto C++11은 이전까지 알면 되지만, C++14에서는 함수 반환 형식을 auto로 지정해서 컴파일러가 연역하게 만들 수 있으며(항목 3)람다 매개변수 선언에 auto를 사용하는 것도 가능하다. 그러나 auto의 그런 용법들은 auto 형식 연역이 아닌 템플릿 형식 연역의 규칙들로 적용된다. 그래서 중괄호 초기리를 돌려주는 반환형식을 auto로 지정하면 컴파일 실패 // 함수 반환 형식 autoauto createInitList(){ return {1,2,3}; // 오류! {1,2,3}의 형식 연역 불가}// 람다 매개변수 형식 autostd::vector&lt;int&gt; v;auto resetV = [&amp;v](const auto&amp; newValue) { v = newValue; } // C++14resetV({1,2,3}); // 오류! {1,2,3}의 형식 연역 불가결론 이것만은 잊지 말자! auto 형식 연역은 대체로 템플릿 형식 연역과 같지만, auto 형식 연역은중괄호 초기치가 std::initialize_list를 나타낸다고 가정하는 반면 템플릿 형식 연역은 그렇지 않다. 함수의 반환 형식이나 람다 매개변수에 쓰인 auto에 대해서는 auto 형식연역이 아니라 템플릿 형식 연역이 적용된다. " }, { "title": "자료형의 참과 거짓", "url": "/posts/%EC%9E%90%EB%A3%8C%ED%98%95%EC%9D%98-%EC%B0%B8%EA%B3%BC-%EA%B1%B0%EC%A7%93/", "categories": "python", "tags": "python", "date": "2024-01-16 00:00:00 +0900", "snippet": "자료형의 참과 거짓 자료형마다 참과 거짓이 있는데 다음과 같다.* 문자열- \"python\" : 참- \"\" : 거짓* 리스트- [1,2,3] : 참- [] : 거짓* 튜플- () : 거짓* 딕셔너리- {} : 거짓* 숫자형- 0이 아닌 숫자 : 참- 0 : 거짓* None : 거짓 문자열,리스트,튜플,딕셔너리 등의 값이 비어있으면 거짓이 되고 숫자는 0일 때 거짓이 된다" }, { "title": "DISTINCT && ORDERED BY && LIMIT && LIKE", "url": "/posts/DISTINCT-&&-ORDERED-BY-&&-LIMIT/", "categories": "MySQL", "tags": "mysql", "date": "2024-01-16 00:00:00 +0900", "snippet": "DISTINCT SELECT DISTINCT &lt;열&gt; FROM &lt;테이블&gt;를 사용하면 TABLE안에 있는 열에서 중복되는 이름을 제거할 수 있다.SELECT DISTINCT author_name, name books;CONTACT 만약 하나의 Row에서만이 아니라 여러 가지의 Row가 전부 중복될 때 제거하고 싶다면 CONTACT를 사용하면 된다. 아래는 author_fname과 author_lname이 모두 중복되는 행만 삭제한다. -- 1번 방법SELECT DISTINCT CONCAT(author_fname,' ', author_lname) FROM books;-- 2번 방법SELECT DISTINCT author_fname, author_lname FROM books;ORDERED BY SELECT &lt;열&gt;... FROM &lt;테이블&gt; ORDERED BY &lt;열&gt;의 형태로 테이블에 선택된 열들은 ORDERED BY 열을 기준으로 정렬된다. 기본적으로 오름차순(ASCE)이지만 맨 뒤에 DESC를 붙이면 내림차순이 된다. -- books에 있는 모든 열은 author_lname를 기준으로 정렬된다.SELECT * FROM books ORDER BY author_lname; SELECT * FROM booksORDER BY author_lname DESC; SELECT * FROM booksORDER BY released_year; ORDER BY &lt;숫자&gt;는 SELECT에서 숫자 순서에 해당하는 열을 기준으로 정렬한다. ORDER BY &lt;열,열..&gt;은 여러 열을 넣으면 맨 앞의 열부터 정렬한다. 아래 2번째 예시에서는 첫 번째로 author_lname로 먼저 정렬하고 두 번째로 author_fname을 기준으로 정렬한다. -- 2 번째인 author_fname을 기준으로 정렬SELECT book_id, author_fname, author_lname, pagesFROM books ORDER BY 2 desc;-- 처음에 author_lname를 기준으로 정렬, 이 후에 author_fname를 기준으로 정렬SELECT book_id, author_fname, author_lname, pagesFROM books ORDER BY author_lname, author_fname;LIMIT LIMIT &lt;숫자&gt;을 이용하면 LIMIT뒤에 있는 숫자만큼의 데이터만 가져온다.-- books 테이블안에 있는 title열에서 3번째 데이터까지만 가져옴SELECT title FROM books LIMIT 3;-- released_year를 기준으로 내림차순 정렬해서 5번째 데이터까지 가져옴SELECT title, released_year FROM books ORDER BY released_year DESC LIMIT 5;LIKE 일정 부분만을 가지고 검색하여 결과를 얻고 싶을 때 사용 WHERE &lt;열&gt; LIKE '%&lt;문자&gt;%' 는 열 중에서 문자를 가진 열을 검색한다. 위에서 %는 아무 문자가 들어와도 상관이 없다는 의미 만약 %&lt;문자&gt;로 앞에만 적었다면 맨 뒤가 문자인 열만 검색된다. WHERE &lt;열&gt; LIKE '_'는 문자열의 길이가 _의 개수만큼과 동일한 문자열을 검색 -- 문자열 중 da가 들어간 문자열 검색SELECT title, author_fname, author_lname, pages FROM booksWHERE author_fname LIKE '%da%'; -- 아래 예시는 _가 4개 있으므로 길이가 4인 문자열 검색SELECT * FROM booksWHERE author_fname LIKE '____'; -- 문자열 중 맨 뒤가 n이 들어간 문자열 검색SELECT title, author_fname, author_lname, pages FROM booksWHERE author_fname LIKE '%n';-- 문자열 중 맨 앞이 a가 들어간 문자열 검색SELECT title, author_fname, author_lname, pages FROM booksWHERE author_fname LIKE 'a%';-- 중간에 문자가 a가 들어가며 앞뒤로 문자가 하나씩 있는 문자열 검색SELECT * FROM booksWHERE author_fname LIKE '_a_';" }, { "title": "템플릿 형식 연역(template type deduction)을 이해하자", "url": "/posts/1.Understand-template-type-deduction/", "categories": "Modern Effective C++", "tags": "modern effective c++", "date": "2024-01-15 00:00:00 +0900", "snippet": " C++ 템플릿은 강력한 기능으로, auto 키워드도 템플릿 형식 연역을 기반으로 작동한다. 하지만 auto는 템플릿에 비해 직관성이 좋지는 않다. 템플릿 작동 방식// 템플릿template&lt;typename T&gt;void f(ParamType param);// 호출f(expr); // expr로부터 T와 ParamType을 연역 컴파일러는 expr을 이용하여 두 가지 형식을 연역한다. 하나는 T에 대한 형식이고 다른 하나는 ParamType에 대한 형식이다 이 두 형식이 다른 경우가 많은데 ParamType에 흔히 const나 &amp;, &amp;&amp;가 붙는 경우가 많아서이다. T에 대한 형식 T에 대한 형식은 위에서 함수에 전달된 인수인 expr의 타입과 같을거라고 예상되지만, 항상 그런것은 아니다 T에 대한 형식은 expr의 형식뿐만 아니라, ParamType의 형태에도 의존한다 ParamType이 포인터 Or 참조 형식이지만 보편 참조는 아닐 경우 이 경우 다음과 같이 진행된다. 만일 expr이 참조 형식이면 참조 부분을 무시한다. 그런 다음 expr의 형식을 ParamType에 대해 대응하여 T의 형식을 결정한다. T&amp;template&lt;typename T&gt;void f(T&amp; param) //param은 &amp;int x = 27; // intconst int cx = x; // const intconst int&amp; rx = x; // const int&amp;f(x); // T는 int, // param의 형식은 int&amp;f(cx); // T는 const int, // param의 형식은 const int&amp;f(rx); // T는 const int, // param의 형식은 const int&amp; 주목할 점 cx와 rx는 const여서 T가 const int로 연역되었다. rx는 참조지만 T는 비참조로 연역되었다. 이유는 참조성이 무시되기 때문 const T&amp;template&lt;typename T&gt;void f(const T&amp; param) //param은 const &amp;int x = 27; // intconst int cx = x; // const intconst int&amp; rx = x; // const int&amp;f(x); // T는 int, // param의 형식은 const int&amp;f(cx); // T는 const int, // param의 형식은 const int&amp;f(rx); // T는 const int, // param의 형식은 const int&amp; 주목할 점 T&amp;와 다른 점은 param이 const에 대한 참조로 간주되어, const가 T로 일부로 연역될 필요는 없다. T*template&lt;typename T&gt;void f(T* param) //param은 포인터int x = 27; // intconst int* px = &amp;x; // const *f(x); // T는 int, // param의 형식은 int*f(cx); // T는 const int, // param의 형식은 const int* 주목할 점 param이 참조가 아니라 포인터라도 형식 연역은 본질적으로 같은 방식으로 진행된다. ParamType이 보편 참조일 경우 보편 참조 매개변수를 받는 경우, 왼값인지 오른값인지에 따라 달라진다. 왼값이라면, T와 ParamType 둘 다 왼값 참조로 연역된다 템플릿 형식 연역에서 T가 참조 형식으로 연역되는 경우는 이것이 유일하다. ParamType의 선언 구문은 오른값 참조와 같은 모습이지만, 연역된 형식은 왼값 참조다. 오른값이면 정상적인 (첫 번째 경우) 규칙들로 적용된다. template&lt;typename T&gt;void f(T&amp;&amp; param) //param은 보편 참조int x = 27; // intconst int cx = x; // const intconst int&amp; rx = x; // const int&amp;// 왼값f(x); // T는 int&amp;, // param의 형식은 int&amp;f(cx); // T는 const int&amp;, // param의 형식은 const int&amp;f(rx); // T는 const int&amp;, // param의 형식은 const int&amp;// 오른값f(27); // T는 int, // param의 형식은 int&amp;&amp; 각 해당 형식으로 연역되는 구체적인 이유는 항목24에 기술하겠다. 여기서는 왼값 참조나 오른값 참조 매개변수들에 대한 규칙들과는 다르다라는 점만 기억하자. ParamType이 포인터도 아니고 참조도 아닌 경우 이 경우는 함수가 값으로 전달(pass-by-value)되는 상황이다.template&lt;typename T&gt;void f(T param); param은 인수의 복사본, 즉 새로운 객체이기 때문에 expr에서 T가 연역되는 과정에서 다음과 같은 규칙이 적용된다. 이전처럼, 만일 expr의 형식이 참조면, 참조 부분은 무시된다. expr의 참조성을 무시한 후, expr이 const면 const 역시 무시한다. volatile도 무시한다. int x = 27; // intconst int cx = x; // const intconst int&amp; rx = x; // const int&amp;// 왼값f(x); // T와 param 둘 다 intf(cx); // T와 param 둘 다 intf(rx); // T와 param 둘 다 int param은 복사본이므로 cx와 rx의 const와는 무관하고 const가 무시되는 이유가 바로 이것이다. 명심할 점은 const나 volatile이 값 전달 매개변수에 대해서만 무시한다는 것이다. const에 대한 참조나 포인터인 매개변수의 경우, expr의 const성이 보존된다. template&lt;typename T&gt;void f(T param);const char* const ptr = \"ABC\" // ptr은 const 객체를 가리키는 const 포인터f(ptr); 위의 경우, ptr 왼쪽에 있는 const때문에 ptr의 주소 자체는 const가 된다. ptr를 f에 전달하면 그 포인터를 구성하는 비트들이 param에 복사된다. 즉,포인터 자체는 값으로 전달된다. 값 전달 방식이기 때문에 param은 const char*의 형태로 연역된다. ptr가 가리키는 것의 const성은 보존되나, ptr 자체의 const 성은 ptr를 복사해서 새 포인터 param을 생성하는 도중에 사라진다. 배열 인수 배열 형식과 포인터는 비슷해 보이지만, 다르다 배열과 포인터를 바꿔서 사용할 수 있는 이유는 배열이 배열의 첫 원소를 가리키는 포인터로 붕괴(decay)한다라는 점에서 비롯된다. // 형식은 const char[2]const char name[] = \"Hi\";// 배열(name)이 포인터로 붕괴const char* ptrToName = name; 그런데 값 전달 매개변수를 받는 템플릿으로 전달되면 어떻게 될까? 우선, 배열 형식의 함수 매개변수는 없기 때문에 만들 수 없다. void myFunc(int Param[]);void myFunc(int* Param); 템플릿에 넣기 전에, 위처럼 배열 매개변수와 포인터 매개변수의 동치성은 C에서 부터 이어져 왔다 그래서 이러한 아래와 같이 전달되는 배열 형식은 포인터 형식으로 연역된다. template&lt;typename T&gt;void f(T Param);f(name); // 배열이지만 T는 const char*로 연역 여기서 한가지 요령이 있는데, 함수의 매개변수를 배열로 선언할 순 없지만 배열에 대한 참조로 선언할 수 있다.template&lt;typename T&gt;void f(T&amp; Param);f(name); // 참조되어 T는 const char[2]로 연역 이러한 점을 이용하면 다음과 같은 경우도 가능하다.// 배열의 크기를 컴파일 시점 상수로서 돌려주는 템플릿 함수// constexpr로 사용하여 함수 호출 결과를 컴파일 도중에 사용 가능template&lt;typename T, std::size_t N&gt;constexpr std::size_t arraySize(T (&amp;)[N]) noexcept{ return N;}int main(){ // 원소 개수 3 int keyVals[] = { 1, 2, 3 }; // 원소 개수 3 std::array&lt;int, arraySize(keyVals)&gt; mappedVals;}함수 인수 배열뿐만 아닌, 배열에 대한 형식 연역처럼 함수와 함수포인터도 적용된다.void someFunc(int, double); // void(int, double)template&lt;typename T&gt;void f1(T Param); // 값 전달template&lt;typename T&gt;void f2(T&amp; Param); // 참조 전달// 함수포인터로 연역됨f1(someFunc); // void(*)(int,double)// 함수 참조로 연역됨f2(someFunc); // void(&amp;)(int,double)결론 이것만은 잊지 말자! 템플릿 형식 연역 도중 참조 형식의 인수는 비참조로 취급. 즉, 참조성 무시 보편 참조 매개변수에 대한 형식 연역 과정에서 왼값 인수는 특별 취급 값 전달 방식 매개변수에 대한 형식 연역 과정에서 const 또는 volatile 인수는 non-const, non-volatile로 취급 템플릿 형식 연역 과정에서 배열이나 함수 이름에 해당하는 인수는 포인터로붕괴. 단, 그런 인수가 참조를 초기화하는데 쓰이면 포인터로 붕괴하지 않음. " }, { "title": "문자열", "url": "/posts/%EB%AC%B8%EC%9E%90%EC%97%B4/", "categories": "MySQL", "tags": "mysql", "date": "2024-01-14 00:00:00 +0900", "snippet": "Mysql 문자열 관련 함수 Document 주소 https://dev.mysql.com/doc/refman/8.0/en/string-functions.htmlCONCAT CONCAT('값1' , '값2' ...)의 형태로 값에는 문자열, 열 이름 등을 넣어 사용한다. CONCAT_WS('기호','값1','값2' ...)의 형태로 기호는 값 사이에 구분자를 넣는 형태로 사용된다. -- pi 문자열과 ckle 문자열을 합쳐 pickleSELECT CONCAT('pi', 'ckle'); -- books 테이블안의 author_fname와 author_lname 두 열을 합친 형태를-- author_name이라는 열의 이름 형태로 출력 (중간에 공백 추가 ' ')SELECT CONCAT(author_fname,' ', author_lname) AS author_name FROM books; -- 첫 번째 값인 '-'가 각 열과 합쳐지는 사이에 추가되는 버전SELECT CONCAT_WS('-',title, author_fname, author_lname) FROM books;Substring SUBSTRING(\"문자열\", 시작위치 인덱스, 문자열 길이)의 형태로 사용할 수 있다. 0부터 시작이 아닌 1부터 시작 숫자가 하나만 주어졌다면 시작 인덱스부터 끝까지 반환 음수라면 마지막 인덱스를 기준으로 시작위치 설정 -- 1번째부터 길이 4까지 (Hell)SELECT SUBSTRING('Hello World', 1, 4); -- 7번째부터 끝까지 (World)SELECT SUBSTRING('Hello World', 7); -- 끝에서 3번째부터 끝까지 (rld)SELECT SUBSTRING('Hello World', -3); -- books 테이블의 title 열의 모든 행을 기준으로 -- 1번째 자리부터 10번째 자리까지 'short title'이라는 열의 이름으로 출력SELECT SUBSTRING(title, 1, 10) AS 'short title' FROM books;SELECT SUBSTR(title, 1, 10) AS 'short title' FROM books;Replace REPLACE(str, from_str, to_str)의 형태로 str안에서 from_str을 찾고 to_str로 바꾼다. from_str이 없다면 작동하지 않고, 대소문자 구분해야 함. -- %$#@o WorldSELECT REPLACE('Hello World', 'Hell', '%$#@');-- HellO W*rldSELECT REPLACE('HellO World', 'o', '*'); -- books 테이블의 title 열의 e를 3으로 바꿈SELECT REPLACE(title, 'e ', '3') FROM books;Reverse REVERSE(str)은 str 문자열을 거꾸로 출력해주는 함수-- dlroW olleHSELECT REVERSE('Hello World');CHAR_LENGTH CHAR_LENGTH(str)은 str 문자열의 길이를 반환하는 함수-- 11SELECT CHAR_LENGTH('Hello World');UPPER &amp;&amp; LOWER UPPER과 LOWER은 str문자열을 전부 대문자(Upper) 혹은 소문자(Lower)로 바꿔주는 함수--HELLO WORLDSELECT UPPER('Hello World'); --hello worldSELECT LOWER('Hello World');그 외 INSERT, LEFT, RIGHT, TRIM 정도의 함수가 도움이 된다." }, { "title": "집합", "url": "/posts/%EC%A7%91%ED%95%A9/", "categories": "python", "tags": "python", "date": "2024-01-12 00:00:00 +0900", "snippet": "집합 집합에 관련된 것들을 쉽게 처리하기 위해 만들어진 자료형 집합 자료형은 set 키워드를 통해 만들 수 있다. s1 = set([1,2,3])s1# {1,2,3} 위와 같이 set()의 괄호 안에 리스트를 입력하여 만들거나 문자열을 입력할 수도 있다.s2 = set(\"Hello\")s2# {'e','l','o','H'}집합 자료형의 특징 위의 set 문자열의 결과를 보면 l이 두개였지만 하나만 들어가고 순서도 제각각인데 이것은 set의 특징때문이다. set의 특징 중복을 허용하지 않는다. 순서가 없다(unordered) 리스트와 튜플은 순서가 있어 인덱싱을 통해 자료형 값을 얻을 수 있지만 set 자료형은 순서가 없어 인덱싱을 사용하지 못한다. set의 자료형에 저장된 값을 인덱싱으로 접근하려면 다음과 같이 리스트나 튜플로 변환한 후 해야한다. 리스트s1 = set([1,2,3])l1 = list(s1) # set을 리스트로 변환l1# [1,2,3]l1[0]# 1튜플t1 = tuple(s1) # set을 튜플로 변환t1# (1,2,3)t1[0]# 1집합 자료형 활용 set 자료형이 유용하게 사용되는 경우는 교집합,합집합,차집합을 구하는 경우이다. 먼저 다음과 같이 set 자료형 2개가 있다고 가정한다. s1 = set([1,2,3,4,5,6])s2 = set([4,5,6,7,8,9])교집합 두 set 변수의 교집합은 &amp; 기호를 이용하여 구할 수 있다.s1 &amp; s2# {4,5,6} intersection 함수를 사용해도 동일한 결과를 리턴한다.s2.intersection(s1)# {4,5,6}합집합 합집합은 | 기호를 이용하여 구할 수 있다.s1 | s2# {1,2,3,4,5,6,7,8,9} union 함수로 구할 수도 있다.s1.union(s2)# {1,2,3,4,5,6,7,8,9}차집합 차집합은 - 기호를 이용해서 구할 수 있다.s1 - s2# {1,2,3}s2 - s1# {8,9,7} difference를 이용해서 구할 수도 있다.s1.difference(s2)# {1,2,3}s2.difference(s1)# {8,9,7}집합 관련 함수add set 자료형에 값을 추가할 수 있다.s1 = set([1,2,3])s1.add(4)s1# {1,2,3,4}update set 자료형에 한꺼번에 여러 값을 추가할 수 있다.s1 = set([1,2,3])s1.update([4,5,6])s1# {1,2,3,4,5,6}remove set 자료형에서 특정 값을 지울 수 있다.s1 = set([1,2,3])s1.remove(2)s1# {1,3}" }, { "title": "Aliases && UPDATE && DELETE", "url": "/posts/Alias-&&-UPDATE-&&-DELETE/", "categories": "MySQL", "tags": "mysql", "date": "2024-01-07 00:00:00 +0900", "snippet": "Aliases SELECT &lt;열 이름&gt; as &lt;바꿀 이름&gt;의 형태로 사용한다. 이 명령어는 테이블의 값을 영구적으로 바꾸는게 아닌, 출력 값을 일시적으로만 바꾸는 역할 -- 기존의 cat_id라는 열을 id라는 열으로 출력-- 영구적인 것은 아니라 다음에 사용할 때는 기존의 cat_id로 사용SELECT cat_id AS id, name FROM cats;UPDATE 테이블에 있던 데이터를 바꿀 때 사용 UPDATE &lt;테이블 이름&gt; SET &lt;바꿀 값&gt; WHERE &lt;조건&gt;의 형태로 WHERE은 안써도 가능하지만, 쓰지 않으면 모든 행에 적용시켜버린다. -- cats 테이블의 breed열의 값을 모두 Shorthair로 바꿈UPDATE cats SET breed='Shorthair';-- breed(품종)가 Tabby인 행의 breed값을 Shorthair로 바꿈UPDATE cats SET breed='Shorthair' WHERE breed='Tabby';-- Misty란 이름을 가진 행의 age를 14로바꿈UPDATE cats SET age=14 WHERE name='Misty';DELETE 테이블에서 있는 데이터를 삭제 DELETE FROM &lt;테이블 이름&gt;은 테이블의 모든 행을 삭제하지만,DELETE FROM &lt;테이블 이름&gt; WHERE &lt;조건&gt;으로 조건에 해당하는 행만 삭제할 수 있다. -- cats 테이블의 name이 Egg인 행 삭제DELETE FROM cats WHERE name='Egg';-- 모든 행 삭제DELETE FROM cats;" }, { "title": "SELECT && WHERE", "url": "/posts/Select-&&-Where/", "categories": "MySQL", "tags": "mysql", "date": "2024-01-06 00:00:00 +0900", "snippet": "SELECTSELECT * FROM SELECT * FROM &lt;테이블 이름&gt;에서 *는 테이블의 모든 행을 표시한다는 뜻으로 사용된다.-- 테이블의 모든 행 표시하기SELECT * FROM cats; SELECT name FROM SELECT &lt;열 이름&gt; FROM &lt;테이블 이름&gt;에서 name은 테이블에서 해당 열만 사용한다는 뜻이다.-- cats 테이블의 age 열만 가져오기SELECT age FROM cats; ,를 이용해서 한 번에 여러 열을 표시할 수도 있다-- cats 테이블의 name, breed 한번에 가져오기SELECT name, breed FROM cats;WHERE WHERE 조건을 사용해서 조건에 해당하는 행만 사용할 수 있다.-- cats 테이블에서 age가 4인 행SELECT * FROM cats WHERE age = 4;-- cats 테이블에서 name이 Egg인 행SELECT * FROM cats WHERE name ='Egg';" }, { "title": "기본키", "url": "/posts/%EA%B8%B0%EB%B3%B8%ED%82%A4/", "categories": "MySQL", "tags": "mysql", "date": "2023-12-21 00:00:00 +0900", "snippet": "기본키 DESC &lt;테이블 이름&gt;을 통해 테이블을 열어보면 Key라는 값이 있다. 만약 같은 이름의 테이블이 여러 개 있다면 구분하기 힘들어지는데 그럴 때 사용하는 기본 키(Primary Key)는 고유 식별자라고 생각하면 된다. 행 뒤에 PRIMARY KEY를 추가해서 필수이면서 고유한 값이라고 알려주는 것이다. -- 1번 방법CREATE TABLE unique_cats (\tcat_id INT PRIMARY KEY, name VARCHAR(100) NOT NULL, age INT NOT NULL);-- 2번 방법CREATE TABLE unique_cats2 (\tcat_id INT, name VARCHAR(100) NOT NULL, age INT NOT NULL, PRIMARY KEY (cat_id)); 만약 Key값이 겹친다면 에러가 발생한다.AUTO_INCREMENT 기본 키는 NOT NULL의 형태여서 반드시 넣어줘야 하는데 깜빡하고 안 적는 경우도 생길 수도 있다. 그럴 때 1부터 시작해서 자동으로 증가시켜주는 AUTO_INCREMENT라는 키워드를 사용하면 된다. -- Primary key로 사용할 cat_id에 AUTO_INCREMENT 선언CREATE TABLE unique_cats3 ( cat_id INT AUTO_INCREMENT, name VARCHAR(100) NOT NULL, age INT NOT NULL, PRIMARY KEY (cat_id));" }, { "title": "Dictionary", "url": "/posts/Dictionary/", "categories": "python", "tags": "python", "date": "2023-12-18 00:00:00 +0900", "snippet": "Dictionary Key와 Value로 만들어진 자료구조. Key와 Value 서로 한 쌍이고, 중괄호로 만들어지며 쉼표로 구분한다. # 콜론(:) 앞에 있는 것이 Key이고 뒤에 있는 것이 Value# Key : name , phone# Value : pey , 01012345678dic = {\"name\":\"pey\",\"phone\":\"01012345678\"} Dictionary 객체에게 Key에 해당하는 값을 인덱스로 주면 Key와 한 쌍이었던 Value값을 사용할 수 있다.print(dic[\"name\"])# pey추가 위에서는 선언과 동시에 초기화를 한 상태이고 Dictionary에 따로 값을 넣을려면 다음과 같이 해야 한다. 그리고 Dictionary에 추가되는 순서의 원칙은 없다 # 생성a = {1: 'a'}# Key는 2, Value는 b라는 한 쌍을 추가a[2] = 'b'삭제 삭제할 때는 del 키워드를 사용한다.# Key값이 1인 쌍을 삭제del a[1]중첩과 List Dictionary의 Value값에는 List와 다른 Dictionary를 사용할 수 있다. 단, Key값에는 List와 Dictionary는 사용할 수 없다. # Animal이라는 Key에 {Dog,Cat}이라는 List로 이뤄진 Valuetest = {\"Animal\" : {\"Dog\",\"Cat\"} }# Animal이라는 Key에 또 다른 Dictionary인 Value가 들어가 있는 상태# Mammal이라는 Key값과 {Dog,Cat}이라는 List로 이뤄진 Valuetest2 = {\"Animal\" : {\"Mammal\" : {\"Dog\",\"Cat\"} }}Dictionary 함수keys keys 함수는 객체안의 Key만 모아서 dict_keys라는 객체를 리턴한다.a = {\"name\": \"pey\", \"phone\": \"0119993323\", \"birth\": \"1118\"}print(a.keys())# dict_keys('name','phone','birth') 다음과 같이 사용할 수도 있다.a = {\"name\": \"pey\", \"phone\": \"0119993323\", \"birth\": \"1118\"}for k in a.keys(): print(k)# name# phone# birth list로 반환하려면 다음과 같이 하면 된다.list(a.keys())# ['phone','birth','name']values Key만 얻는 것 처럼 Value만 얻는 방법도 있다. keys 함수와 다르게 dict_values라는 객체에 리턴된다. a.values()#dict_values(['pey','0119993323','1118'])items items 함수는 key와 value의 쌍을 tuple로 묶은 값을 dict_items 객체로 돌려준다.a.items()# dict_items([('name','pey'), ('phone','011993323'), ('birth','1118')])clear clear 함수는 dictionary의 모든 요소를 삭제한다. 빈 dictionary는 {}로 표현한다. a.clear()# {}get get(x) 함수는 x라는 key에 해당하는 value를 돌려준다. 만약 x라는 값이 없다면, 에러가 발생한다. a.get('name')# 'pey'in in은 해당 key가 dictionary 안에 있는지 확인하는 함수이다. \"Key\" in \"객체\"와 같은 방식으로 사용한다. 'name' in aTrue'email' in aFalse" }, { "title": "파이썬 함수", "url": "/posts/%ED%8C%8C%EC%9D%B4%EC%8D%AC-%ED%95%A8%EC%88%98/", "categories": "python", "tags": "python", "date": "2023-12-17 00:00:00 +0900", "snippet": "함수 파이썬에서 함수를 만들 때는 def 키워드와 괄호를 이용하여 함수를 선언할 수 있다.# 들여쓰기가 되는곳 까지 함수의 영역def my_function(): print(\"Hello\") print(\"Bye\")# 함수 실행으로 Hello와 Bye 출력my_function()인자 괄호 안에 함수 안에서 사용할 변수를 선언하고, 호출할 때는 해당 인자로 사용할 변수를 보낼 수 있다.# Angela 라는 문자열을 name에 받고 print에서 출력def greet_with_name(name): print(f\"Hello {name}\")# Angela 라는 문자열을 함수에 전달greet_with_name(\"Angela\") 인자는 여러 개를 선언할 수 있고, 사용할 때는 순서가 중요하다.# 순서대로 name에는 Jack, location에는 Nowhere이라는 문자열이 전달됨def greet_with(name, location): print(f\"Hello {name}\") print(f\"What is it like in {location}\")greet_with(\"Jack\",\"Nowhere\") 하지만 함수의 인자의 이름에 등호와 함께 값을 넣는 방식으로 지정해서 넣어줄 수도 있다.def greet_with(name, location): print(f\"Hello {name}\") print(f\"What is it like in {location}\")# name인자를 지정해서 Jack을 넣고, location를 지정해서 Nowhere를 넣는 방식greet_with(name = \"Jack\", location = \"Nowhere\")" }, { "title": "Tuple", "url": "/posts/Tuple/", "categories": "python", "tags": "python", "date": "2023-12-16 00:00:00 +0900", "snippet": "Tuple(튜플) 튜플은 리스트와 거의 비슷하지만 몇 가지가 다르다. 리스트는 []의 형태로 사용하지만, 튜플은 ()의 형태로 사용한다. 리스트는 그 값의 생성,삭제,수정이 가능하지만, 튜플은 값을 바꿀 수 없다. # 튜플 형태# 리스트와 다른 점# t2처럼 1개의 요소만 가질 때 콤마(,)를 반드시 붙여야 함# t4의 1,2,3 같이 괄호()를 생략해도 무방하다.t1 = ()t2 = (1,)t3 = (1,2,3)t4 = 1,2,3t5 = ('a','b',('ab','cd'))튜플과 리스트 튜플과 리스트는 비슷하지만 구분해서 사용하는 것이 유리하다. 튜플과 리스트의 가장 큰 차이점은 값을 변화시킬 수 있는지에 달려있다. 튜플 요소값 삭제,변경시 오류 삭제시 오류가 발생.t1 = (1,2,'a','b')del t1[0] # 오류! 변경시 오류가 발생t1 = (1,2,'a','b')t1[0] = 'c'튜플의 사용법 값을 변화시킬 수 없는 점을 제외하면 리스트와 동일하므로, 다음과 같이 작동할 수 있다.인덱싱하기# 인덱싱t1 = (1,2,'a','b')t1[0] # 1t1[3]# 'b'슬라이싱t1 = (1,2,'a','b')t1[1:]# (2,'a','b')더하기t1 = (1,2,'a','b')t2 = (3,4)t1 + t2# (1,2,'a','b',3,4)곱하기t2 = (3,4)t2 * 3# (3,4,3,4,3,4)" }, { "title": "Default Value", "url": "/posts/Default-Value/", "categories": "MySQL", "tags": "mysql", "date": "2023-12-16 00:00:00 +0900", "snippet": "Default Value 테이블을 생성하고 열을 추가할 때, 기본값을 설정할 수 있다.-- name의 기본값은 'no name provided'이고 age의 기본값은 99CREATE TABLE cats3 ( name VARCHAR(20) DEFAULT 'no name provided', age INT DEFAULT 99 );-- age에는 2가 들어가지만 name에는 아무런 값이 없어서 기본값인 no name provided으로 설정된다.INSERT INTO cats3(age)VALUES (2); 여기서 기본값을 설정한다고 null이 될 수 없다는 뜻은 아니다. 기본값이 들어가 있어서 NULL이 기본적으로 될 수는 없지만, 원한다면 NULL로 설정할 수도 있다. -- name에도 NULL, age에도 NULL이 들어간다.INSERT INTO cats3(name, age) VALUES(NULL, NULL); 그래서 NULL도 허용하지 않으면서 기본값을 설정하는 것도 가능하다.CREATE TABLE cats4 ( name VARCHAR(20) NOT NULL DEFAULT 'unnamed', age INT NOT NULL DEFAULT 99);-- Error!-- INSERT INTO cats4(name, age) VALUES(NULL, NULL);" }, { "title": "\\NULL과 따옴표", "url": "/posts/NULL%EA%B3%BC-%EB%94%B0%EC%98%B4%ED%91%9C.md/", "categories": "MySQL", "tags": "mysql", "date": "2023-12-15 00:00:00 +0900", "snippet": "NULL 테이블에 NULL 이 들어있을 수도 있는데 NULL의 값이 YES라는 의미는 값이 없다는 것을 의미한다. 단, 값이 없다는 것과 0이라는 것과는 다른 의미 , (0은 숫자, NULL은 값이 전혀 없다는 뜻) -- 테이블CREATE TABLE cats ( name VARCHAR(50), age INT);-- name에는 Bean이라는 문자열이 들어갔지만, age의 int값이 없어 NULL로 표시된다.INSERT INTO cats(name)VALUES ('Bean'); 만약 NULL값을 넣고 싶지 않다면 테이블의 행에 NOT NULL을 추가하여 NULL값을 허용하지 않을 수도 있다.CREATE TABLE cats2 ( name VARCHAR(100) NOT NULL, age INT NOT NULL);-- NOT NULL이 들어간 행인 age에는 값이 들어가지 않아서 Error 발생-- INSERT INTO cats(name)-- VALUES ('Bean');따옴표 문자열을 넣을 때 작은 따옴표만 사용하거나 큰 따옴표만 사용하는 방식으로도 가능하다. 하지만 문제가 될 수도 있어 가능하면, 큰 따옴표를 넣는 것이 좋다. 그리고 만약 문자열안에 따옴표가 들어간다면 \\를 이용하여 표시할 수 있다. -- shops 테이블 생성CREATE TABLE shops(name VARCHAR(100));-- '앞에 \\를 붙여서 '가 들어가도록 표현INSERT INTO shops(name)VALUES (\"marry\\'s pizza\");" }, { "title": "파이썬 반복문", "url": "/posts/%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EB%B0%98%EB%B3%B5%EB%AC%B8/", "categories": "python", "tags": "python", "date": "2023-12-14 00:00:00 +0900", "snippet": "반복문(for) List의 각 항목에 개별적으로 접근할 때 사용 for과 in 키워드를 사용한다 for 다음에는 단일 항목에 대한 이름을 부여하고 in 다음에는 반복문에 사용할 List 변수를 넣어준다. fruits = [\"Apple\",\"Peach\",\"Pear\"]for fruit in fruits: print(fruit)# 출력'''ApplePeachPear'''range 위 반복문에서 List같은 변수가 아닌 형태로 반복문을 돌릴 때 range를 사용할 수 있다. 단 마지막 숫자는 포함되지 않는다. # 6은 포함되지 않고 1 ~ 5for number in range(1, 6): print(number)# 출력'''12345''' range를 사용하면 index는 기본적으로 1씩 올라가지만 range의 3번 째 매개변수에 idx가 올라가는 값을 조절할 수 있다.# 1 ~ 10 사이 숫자에서 1부터 3씩 늘어나는 형태for number in range(1, 11,3): print(number)# 출력'''14710'''while while 키워드를 이용하여 조건이 true라면 계속 실행하는 반복문을 만들 수도 있다.# hurdles가 0이 될 때까지 반복hurdles = 5;while hurdles &gt; 0: hurdles -= 1 print(hurdles) while not을 이용하여 부정문으로도 반복문을 만들 수도 있다. while의 경우, 조건이 true이여야만 실행했지만, while not은 조건이 false값이 나와야 실행된다. hurdles = 5;while not hurdles &lt; 0: hurdles -= 1 print(hurdles)" }, { "title": "Table", "url": "/posts/Table/", "categories": "MySQL", "tags": "mysql", "date": "2023-12-14 00:00:00 +0900", "snippet": "Table 구조화된 형식으로 관련된 데이터 컬렉션 데이터베이스는 이러한 테이블을 여러 개를 가지고 있는 형식 테이블 안에 데이터가 저장될 때는 바이너리 형식으로 저장된다. 데이터베이스 안에 테이블 생성 USE &lt;name&gt;으로 선택한 데이터베이스 안에 다음과 같이 테이블을 추가할 수 있다. &lt;이름&gt; &lt;자료형&gt; 순서이며 추가할 때는 ,로 변수끼리 구분한다. -- CREATE TABLE &lt;테이블 이름&gt; ( 변수들 );CREATE TABLE cats ( name VARCHAR(50), age INT);CREATE TABLE dogs ( name VARCHAR(50), breed VARCHAR(50), age INT);SHOW Table SHOW TABLES를 통해 현재 데이터베이스가 가지고 있는 모든 테이블을 알 수 있다. SHOW COLUMNS FROM &lt;테이블 이름&gt; 혹은 DESC &lt;테이블 이름&gt;을 통해 지정한 테이블의 열들을 볼 수 있다. Delete Table DROP TABLE &lt;테이블 이름&gt; 명령어로 테이블을 삭제할 수도 있다.INSERT INTO Table INSERT INTO &lt;Table 이름&gt;와 VALUES라는 명령어로 테이블에 데이터를 삽입할 수 있다. 먼저 사용할 테이블 이름 뒤에 괄호와 그 안에 테이블의 열에 해당하는 변수를 선언하고 VALUES뒤에 괄호 안에 변수에 전달할 값들을 작성하면 된다. -- 단, VALUES에 넣을 값들과 cats의 변수와 순서는 같아야 함.INSERT INTO cats (name, age) VALUES ('Blue Steele', 5);INSERT INTO cats (name, age) VALUES ('Jenkins', 7); VALUES 뒤에 괄호로 한번에 여러 개를 넣을 수도 있다.-- 한번에 3개의 테이블 데이터 삽입INSERT INTO cats (name, age) VALUES ('Meatball', 5), ('Turkey', 1), ('Potato Face', 15);" }, { "title": "List", "url": "/posts/List/", "categories": "python", "tags": "python", "date": "2023-12-13 00:00:00 +0900", "snippet": "List 서로 관계있는 변수들을 저장할 때 사용하는 자료구조 []를 사용하여 변수를 저장하고 데이터 형식은 상관없이 저장할 수 있다. List안에 저장되어 있는 변수를 사용하려면 해당 변수의 인덱스를 사용하면 된다. 음수 인덱스를 사용하면 가장 뒤쪽부터 시작한다. Alphabet = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\"]print(Alphabet[0])# Aprint(Alphabet[-1])# F대입 List에 있는 index에 다른 값을 대입해도 가능하다.Alphabet[0] = \"Z\"print(Alphabet[0])# Zappend List의 append 함수를 이용하면 List의 마지막에 변수를 삽입할 수 있다.Alphabet = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\"]Alphabet.append(\"G\")print(Alphabet[-1])# Gextend List의 extend를 사용하면 List의 마지막에 여러 변수를 한 번에 넣을 수 있다. 단 여러 개를 넣을 때 리스트 형식인 []를 사용해야 한다. Alphabet = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\"]Alphabet.extend([\"G\",\"H\"])print(Alphabet[-1])# H" }, { "title": "데이터 자료형", "url": "/posts/%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%9E%90%EB%A3%8C%ED%98%95/", "categories": "MySQL", "tags": "mysql", "date": "2023-12-13 00:00:00 +0900", "snippet": "Data types 만약 고양이에 대한 정보를 저장하기 위한 Cats라는 Database가 있다면 Table에서는 Age,Breed,Name등이 있을 것이다. 그런데 만약 아무 타입이나 저장할 수 있도록 만든다면 Age같은 숫자만 들어가야 하는 곳에 텍스트 형식이 들어가버리는 현상이 나타날 수도 있다. 아래에 데이터 종류를 나열했지만, 보통 전부 사용하지는 않는다고 한다. Numeric INT SMALLINT TINYINT MEDIUMINT BIGINT DECIMAL FLOAT DOUBLE BITString Types CHAR VARCHAR BINARY VARBINARY BLOB TINYBLOB MEDIUMBLOB LONGBLOB TEXT TINYTEXT MEDIUMTEXT LONGTEXT ENUMData type DATE DATETIME TIMESTAMP TIME YEARvarchar(a variable-length string) 자주 사용하는 데이터 종류 중 하나로, char와 다르게 길이가 가변적이다.-- 길이 100개로 제한된 텍스트varchar(100)" }, { "title": "랜덤", "url": "/posts/%EB%9E%9C%EB%8D%A4/", "categories": "python", "tags": "python", "date": "2023-12-12 00:00:00 +0900", "snippet": "랜덤 랜덤값을 사용하기 위해선 랜덤 모듈을 집어 넣어야 한다.import randomrandint 매개변수1과 매개변수2 사이의 랜덤 int값을 반환하는 함수# 1 ~ 10 사이의 정수 random_integer = random.randint(1,10)print(random_integer)random 0과 1사이의 랜덤 소숫값을 반환하는 함수 단, 1은 포함하지 않음 # 0.0000000... ~ 0.9999999...random_float = random.random()print(random_float) random 함수에 내가 원하는 maximum 숫자(n)를 곱해서 0부터 n까지의 실수를 반환할 수 있다.# 뒤에 곱해지는 숫자에 맞춰 최댓값이 정해짐random_value = random.random() * 100" }, { "title": "파이썬 조건문", "url": "/posts/%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EC%A1%B0%EA%B1%B4%EB%AC%B8/", "categories": "python", "tags": "python", "date": "2023-12-10 00:00:00 +0900", "snippet": "if else 조건문은 if와 else를 사용 if의 조건에 맞으면 else 이전까지의 코드가 실행 아니면 else의 코드가 실행 주의할 점은 if나 else에 들여쓰기가 되면 안됨 그리고 :(콜론) 키워드를 통해 조건문의 끝을 알림 print(\"Welcome to the rollercoaster!\")height = int(input(\"What is yout height in cm\"))if height &gt;= 120: print(\"You can ride the rollercoaster!\")else: print(\"Sorry. you can`t\")elif if문에서 else 이전에 또 다른 조건을 걸기 위한 키워드 C++에서 사용하는 else if를 파이썬에서는 elif로 작성 print(\"Welcome to the rollercoaster!\")height = int(input(\"What is yout height in cm\"))if height &gt;= 120: print(\"You can ride the rollercoaster!\") age = int(input(\"What is your age\")) if age&lt; 12: print(\"pay $5\") elif age &lt;= 18 print(\"pay $7\") else print(\"pay $12\")else: print(\"Sorry. you can`t\")and, or 논리 연산자 &amp;&amp; 와   를 파이썬에서는 and와 or로 변경해서 사용 andscore = int(input(\"Input your score\"))# score이 90 이상 100 이하면 Goodif score&gt;=90 and score &lt;=100: print(\"Good\")else: print(\"NotGood\")orheight = int(input(\"Input your score\"))# height가 200이상이거나 120이하면if height &gt;= 200 or height &lt;= 120: print(\"You can`t ride\")else: print(\"You can ride\")" }, { "title": "Database관련 명령어", "url": "/posts/Database%EA%B4%80%EB%A0%A8-%EB%AA%85%EB%A0%B9%EC%96%B4/", "categories": "MySQL", "tags": "mysql", "date": "2023-12-10 00:00:00 +0900", "snippet": "Show show databases;를 사용하면 현재 가지고 있는 데이터베이스의 목록을 보여준다.Create CREATE DATABASE &lt;name&gt;; 이라는 명령어로 데이터 베이스를 생성할 수 있다. 이름(name)에는 공백이 들어가면 문제가 생길 수 있기 때문에 넣지 않는 것이 좋다. 그리고 명령어 CREATE DATABASE는 소문자로 써도 상관없다. Delete DROP DATABASE &lt;name&gt;;이라는 명령어로 데이터 베이스를 삭제할 수 있다.Use Use &lt;database name&gt;; 명령어를 통해 사용할 수 있다. 해당 데이터베이스에 정보를 삽입,삭제,검색,새로운 데이터베이스 생성 등등 을 하기 위해 먼저 사용하는 명령어이다. SELETE SELECT database(); 명령어를 통해 현재 사용하고 있는 데이터베이스를 알 수 있다.화면 정리 system cls; 혹은 \\! cls라는 명령어를 통해 화면을 비울 수 있다." }, { "title": "F-String", "url": "/posts/F-String/", "categories": "python", "tags": "python", "date": "2023-12-07 00:00:00 +0900", "snippet": "F-String F-String은 문자열 앞에 f를 붙이는 것으로, 다른 변수와 연동할 수 있다.score = 0height = 1.8isWinning = True# f-Stringprint(f\"your score is {score}\")print(f\"your hegiht is {height}\")print(f\"you are winning is {isWinning}\")'''your score is 0your height is 1.8you are winning is True'''" }, { "title": "연산", "url": "/posts/%EC%97%B0%EC%82%B0/", "categories": "python", "tags": "python", "date": "2023-12-06 00:00:00 +0900", "snippet": "연산# 더하기1 + 2# 빼기5 - 4# 곱하기7 * 6# 나누기9 / 3# 제곱2 ** 3 연산 처리 순서# ()# **# * /# + -반올림,올림,내림반올림 반올림 함수는 round 를 사용print(round(8/3))print(round(7/3))# 출력# 3# 2 round 함수의 두 번째 매개변수에 반올림할 자릿수를 결정할 수 있다.print(round(8/3, 2))# 출력# 2.67내림 내림은 // 키워드 혹은 floor 를 사용print(floor(8/3))print(8 // 3)올림 올림은 ceil를 사용print(ceil(8/3))" }, { "title": "변수 && 데이터 타입", "url": "/posts/%EB%B3%80%EC%88%98%EC%99%80-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%83%80%EC%9E%85/", "categories": "python", "tags": "python", "date": "2023-12-04 00:00:00 +0900", "snippet": "변수 C++과 다르게 자료형 없이 이름만 선언하는 방식name = \"Hello\"print(name)# Hello# len 함수는 문자열의 길이를 반환하는 함수name = input(\"What is your name?\")length = len(name)print(length)# What is your name?Jack# 4데이터 타입문자열 Python에서 문자열에 []를 이용하면 해당 인덱스의 문자를 뽑을 수 있다. 이렇게 문자열에서 특정 요소를 추출하는 방법을 Sub-script라고 한다. print(\"Hello\"[0])# 출력# H \" \"안에 들어있는 숫자는 문자열, 그냥 선언한 숫자는 int형 취급print(\"123\" + \"456\")# 출력# 123456print (123 + 456)# 출력# 579Int 보통 숫자를 표현할 때 ,를 이용해서 표현하기도 하는데 Python에서도 _를 이용해서 표현할 수 있다. 하지만 실제 값을 계산하거나 사용할 때는 붙여진 상태 그대로 사용된다. print(123_456)# 출력# 123456Float 소수점을 가지는 숫자의 자료형3.141592Bool 항상 두가지의 값만 가지는 자료형으로, True 또는 False값만 가진다. C++과 다른점은 맨 앞의 글자가 소문자가 아닌 대문자로 사용 TrueFalsetype type 키워드를 통해 변수의 자료형을 알 수 있다.print(type(123))print(type(\"123\"))print(type(3.14))print(type(True))'''&lt;class 'int'&gt;&lt;class 'str'&gt;&lt;class 'float'&gt;&lt;class 'bool'&gt;'''str str 키워드를 통해 다른 자료형을 문자열로 바꿀 수 있다.print(str(123))print(str(3.14))print(str(True))print(type(str(123)))print(type(str(3.14)))print(type(str(True)))'''print(str(123))print(str(3.14))print(str(True))print(type(str(123)))print(type(str(3.14)))print(type(str(True)))'''" }, { "title": "출력, 입력, 주석", "url": "/posts/%EC%B6%9C%EB%A0%A5,-%EC%9E%85%EB%A0%A5,-%EC%A3%BC%EC%84%9D/", "categories": "python", "tags": "python", "date": "2023-12-03 00:00:00 +0900", "snippet": "출력 print(“”) 형식 특이점은 큰 따옴표 혹은 작은 따옴표 둘 중 하나로 감싸서 사용해도 상관없다. 하지만 안에 큰 따옴표를 쓸거면 밖은 작은 따옴표,혹은 작은 따옴표를 사용한다면 밖은 큰 따옴표를 사용해야 한다. 그리고 맨 뒤에 세미콜론(;)이 없어도 작동하며 다른 줄에 작성하면 이어지지 않고 개행이 됨print(\"'Test'\")print('\"Test'\")\"\"\"'Test'\"Test\"\"\"\" 하지만 \\n을 이용해서 한 번에 두 줄을 사용할 수도 있음.print(\"Test1\\nTest2\")\"\"\"Test1Test2\"\"\"문자열 붙이기 간단하게 +를 이용하여 두 문자열을 붙임print(\"Hello\" + \"World\")# Hello World주석 한 줄 주석은 # 을 이용 여러 줄 주석은 \"\"\" 혹은 '''를 이용하여 감싼다.# 한 줄 주석\"\"\"여러 줄 주석\"\"\"입력 input 키워드를 이용해서 입력할 수 있다.# 괄호 안에 전달되는 값은 사용자에게 전달input(\"What is your name\")# 그래서 다음과 같이 print와 엮어서 사용 가능print(\"Hello\" + input(\"What is your name:\"))\"\"\"What is your name: WorldHello World\"\"\"파이썬 코딩할 때 주의점 만약 맨 처음에 공백이 들어간 상태로 코딩을 한다면 오류가 발생한다. print(\"Hello\") # 맨 앞에 공백이 들어가 오류 발생print(\"Hello\") # 작동" }, { "title": "accumulate", "url": "/posts/accumulate/", "categories": "코딩테스트", "tags": "coding test", "date": "2023-11-10 00:00:00 +0900", "snippet": "accumulate numeric 헤더파일에서 사용할 수 있는 함수로, vector의 합을 바로 반환한다#include &lt;numeric&gt;vector&lt;int&gt; v;// 3번째 값은 처음 초기화int sum = accumulate(v.begin(),v.end(),0);" }, { "title": "vector로 queue 초기화", "url": "/posts/vector%EB%A1%9C-queue-%EC%B4%88%EA%B8%B0%ED%99%94/", "categories": "코딩테스트", "tags": "coding test", "date": "2023-11-07 00:00:00 +0900", "snippet": "vector로 queue 초기화 다음과 같이 하면 반복문을 쓰지 않아도 초기화 가능vector&lt;int&gt; v;queue&lt;int&gt; q { {begin(v),end(v)} };" }, { "title": "최장 증가 부분 수열", "url": "/posts/%EC%B5%9C%EC%9E%A5-%EC%A6%9D%EA%B0%80-%EB%B6%80%EB%B6%84-%EC%88%98%EC%97%B4/", "categories": "코딩테스트", "tags": "coding test", "date": "2023-11-03 00:00:00 +0900", "snippet": "LIS 예시 : https://www.acmicpc.net/problem/11053방법 1 이중 반복문 시간복잡도 : O(n^2) dp 배열은 i 번째 원소가 가질 수 있는 최대증가수열의 길이를 뜻한다. 수열 A = {10, 20, 10, 30, 20, 50} 인 경우 dp[4]는 3이다. {10, 20, 10, 30, 20 …} n이 10,000을 넘어가면 시간초과가 발생할 수 있다. int arr[MAX]; // 인덱스마다 각 입력값int dp[MAX]; // 인덱스마다 각 증가 수열의 길이int max = 0;dp[0] = 1;for(int i=1;i&lt;N;i++) { dp[i] = 1; // i 를 기준으로 인덱스 0 에서부터 i-1까지 체크한다 // 길이를 기준 for(int j=0;j&lt;i;j++) { if (arr[i] &gt; arr[j] &amp;&amp; dp[j] + 1 &gt; dp[i]) { // 증가 수열 dp[i] = dp[j] + 1; } } if (max &lt; dp[i]) { max = dp[i]; }}방법 2 시간복잡도 : O(nlogn) 배열 마지막 요소보다 새로 들어오는 수가 크다면, 배열에 넣는다. 그렇지 않다면, 그 수가 들어갈 자리에 들어가 있는 값을 교체한다(lower_bound 로 들어갈 자리를 찾음) lower_bound : 주어진 값보다 작지 않은(같거나 큰) 첫번째 원소의 iterator를 반환 dp 벡터의 사이즈가 LIS가 된다 단점 : 정답밖에 모른다. 경로를 역추적 할 수 없다. #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#define endl \"\\n\"using namespace std;// LIS로 풀자int n;int answer;vector&lt;int&gt;v;vector&lt;int&gt;lis; // 인덱스마다 각 증가 수열의 길이int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { int tmp; cin &gt;&gt; tmp; v.push_back(tmp); } lis.push_back(v[0]); for (int i = 1; i &lt; n; i++) { if (lis.back() &lt; v[i]) { // lis의 맨 뒤의 원소보다 큰 값이 들어오면 삽입 lis.push_back(v[i]); } else { // lis의 맨 뒤 원소보다 작은 값이면, 그 원소가 들어갈 위치에 삽입 int idx = lower_bound(lis.begin(), lis.end(), v[i]) - lis.begin(); lis[idx] = v[i]; } } answer = lis.size(); cout &lt;&lt; answer; return 0;}" }, { "title": "유니온 파인드", "url": "/posts/%EC%9C%A0%EB%8B%88%EC%98%A8%ED%8C%8C%EC%9D%B8%EB%93%9C/", "categories": "코딩테스트", "tags": "coding test", "date": "2023-11-02 00:00:00 +0900", "snippet": "//원래 자기 자신이 부모. 연결되면서 부모를 정함void init(){\tfor (int i = 1; i &lt;= n; i++)\tparent[i] = i;}//부모를 찾는 함수 (이렇게 구하는걸 경로 압축이라고 한다)//모든 경로가 부모를 가르키게 함//상수 시간의 복잡도를 가짐int Find(int x){\tif (parent[x] == x) return x;\treturn parent[x] = Find(parent[x]);}//두 노드를 연결 시키는 것//기준을 정해서 연결시키는 것이 헷갈리지 않음//작은쪽이 부모 or 큰쪽이 부모void Union(int x, int y){\tx = Find(x);\ty = Find(y);\tif (x != y)\t{\t\tif (x &lt; y)\t\t\tparent[y] = x;\t\telse\t\t\tparent[x] = y;\t}}" }, { "title": "문자열 관련", "url": "/posts/%EB%AC%B8%EC%9E%90%EC%97%B4-%EA%B4%80%EB%A0%A8/", "categories": "코딩테스트", "tags": "coding test", "date": "2023-11-01 00:00:00 +0900", "snippet": "회문 회문은 처음부터 끝까지 거꾸로 읽어도 똑같이 읽히는 수 또는 문자열bool is_palindrome(string str) { bool flag = true; for (int i = 0; i &lt; str.size() / 2; i++) { // 처음부터 가운데 전까지 검사 if (str[i] != str[str.size()-1-i]) { // 문자열이 다를 경우 flag = false; // 팰린드롬이 아님. break; } } return flag;}문장의 모든 단어 뒤집기void ReverseWords(string* s){ reverse(begin(*s), end(*s)); size_t start = 0, finish; while((finish = s-&gt;find(\" \",start) != string::npos) { // \" \"(공백) 찾을 때마다 문자열 뒤집기 reverse(begin(*s) + start, begin(*s) +finish); start = finish + 1; } // 마지막 단어 뒤집기 reverse(begin(*s) + start, end(*s));}" }, { "title": "문자열 검색", "url": "/posts/%EB%AC%B8%EC%9E%90%EC%97%B4-%EA%B2%80%EC%83%89/", "categories": "코딩테스트", "tags": "coding test", "date": "2023-10-31 00:00:00 +0900", "snippet": " 문자열 검색 문제에서 사용되는 알고리즘 한 문자열이 다른 문자열안에 검색되는지 판별할 때 단순무식하게 구현한다면 다음과 같이 구현할 수 있다. // H문자열 안에 N문자열이 포함되는지 확인하는 함수vector&lt;int&gt; naiveSearch(const string&amp; H, const string&amp; N){ vector&lt;int&gt; ret; // H문자열의 begin부터 N문자열을 비교해서 matched가 true면 문자열 반환 for(int begin = 0; begin + N.size() &lt;= H.size(); ++begin) { bool matched = true; for(int i = 0; i &lt; N.size(); i++) // 만약 다르다면 H의 다른 인덱스에서 비교 시작 if(H[begin + i] != N[i]) { matched = false; break; } // N의 모든 문자가 H에 포함되었다면 시작 인덱스 추가 if(matched) ret.push_back(begin); } return ret;} C의 strstr(), C++ 문자열의 string::find() 등이 이와 같은 알고리즘을 사용한다.KMP(Knuth-Morris-Pratt) 알고리즘 만약 어떤 문자열안에서 \"aabaabac\"문자열을 찾는다고 한다. 단순한 알고리즘이라면 i번째 인덱스가 아니라면 i+1번째 인덱스에서 처음부터 비교할테지만,KMP알고리즘은 문자열을 비교하면서 다음 시작 위치가 될 수 없는 곳을 체크하여 반복문을 줄이는 방식이다. 시간 복잡도는 O(NlogN) #include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstring&gt; // 문자열 처리를 위한 라이브러리// LPS (Longest Prefix Suffix) 배열을 생성하는 함수void LPSArray(char* pattern, int M, std::vector&lt;int&gt;&amp; lps) { int length = 0; // 이전까지 매칭된 접두사와 접미사의 길이 lps[0] = 0; // 첫 번째 인덱스는 항상 0 int i = 1; // 패턴의 길이 M만큼 반복하며 LPS 배열 계산 while (i &lt; M) { if (pattern[i] == pattern[length]) { length++; // 접두사와 접미사가 일치하면 길이를 증가 lps[i] = length; // 현재 인덱스에 해당하는 LPS 값 저장 i++; } else { if (length != 0) { // 일치하는 부분이 없으면 이전 위치로 이동하여 다시 비교 length = lps[length - 1]; } else { // 더 이상 일치하는 부분이 없으면 0으로 설정 lps[i] = 0; i++; } } }}// KMP 알고리즘을 사용한 문자열 검색 함수void KMPSearch(char* pattern, char* txt) { int M = strlen(pattern); // 패턴의 길이 int N = strlen(txt); // 텍스트의 길이 std::vector&lt;int&gt; lps(M); // LPS 배열 생성 // 패턴을 미리 처리하여 LPS 배열을 계산 LPSArray(pattern, M, lps); int i = 0; // 텍스트의 인덱스 int j = 0; // 패턴의 인덱스 // 텍스트와 패턴을 비교하며 검색 while ((N - i) &gt;= (M - j)) { if (pattern[j] == txt[i]) { // 패턴의 현재 문자가 텍스트와 일치하면 인덱스를 증가 j++; i++; } if (j == M) { // 패턴이 완전히 일치하면 일치한 위치 출력 std::cout &lt;&lt; \"패턴이 위치한 인덱스: \" &lt;&lt; i - j &lt;&lt; std::endl; j = lps[j - 1]; // 다음 매칭을 위해 패턴의 이전 위치로 이동 } else if (i &lt; N &amp;&amp; pattern[j] != txt[i]) { // 일치하지 않는 경우 LPS 배열을 이용해 패턴의 인덱스를 이동 if (j != 0) j = lps[j - 1]; else i = i + 1; } }}" }, { "title": "lower_bound && upper_bound", "url": "/posts/lower_bound-&&-upper_bound/", "categories": "코딩테스트", "tags": "coding test", "date": "2023-10-27 00:00:00 +0900", "snippet": "lower_bound 기본 형태template&lt; class ForwardIt, class T &gt;ForwardIt lower_bound( ForwardIt first, ForwardIt last, const T&amp; value );template&lt; class ForwardIt, class T &gt;constexpr ForwardIt lower_bound( ForwardIt first, ForwardIt last, const T&amp; value );template&lt; class ForwardIt, class T &gt;constexpr ForwardIt lower_bound( ForwardIt first, ForwardIt last, const T&amp; value );template&lt; class ForwardIt, class T, class Compare &gt;constexpr ForwardIt lower_bound( ForwardIt first, ForwardIt last, const T&amp; value, Compare comp ); 구현// 기본 버전template &lt;class ForwardIt, class T&gt;ForwardIt lower_bound(ForwardIt first, ForwardIt last, const T&amp; value) { ForwardIt it; typename std::iterator_traits&lt;ForwardIt&gt;::difference_type count, step; count = std::distance(first, last); while (count &gt; 0) { it = first; step = count / 2; std::advance(it, step); if (*it &lt; value) { first = ++it; count -= step + 1; } else count = step; } return first;}// Compare 함수 버전template&lt;class ForwardIt, class T, class Compare&gt;ForwardIt lower_bound(ForwardIt first, ForwardIt last, const T&amp; value, Compare comp){ ForwardIt it; typename std::iterator_traits&lt;ForwardIt&gt;::difference_type count, step; count = std::distance(first, last); while (count &gt; 0) { it = first; step = count / 2; std::advance(it, step); if (comp(*it, value)) { first = ++it; count -= step + 1; } else count = step; } return first;} lower_bound는 범위 [first, last) 안의 원소들 중에서 value 보다 크거나 같은 첫 번째 원소를 리턴한다. 만일 그런 원소가 없다면 last 를 리턴한다. lower_bound를 사용하기 전에는 오름차순으로 정렬되어 있어야 한다.#include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; using namespace std;int main() { vector&lt;int&gt; vec{ 7,4,1,9,2 }; sort(vec.begin(), vec.end()); auto lower = std::lower_bound(vec.begin(), vec.end(), 3); // 4 auto lower2 = std::lower_bound(vec.begin(), vec.end(), 1); // 2 auto lower3 = std::lower_bound(vec.begin(), vec.end(), 10); // vec.end() : 마지막 반복자 cout &lt;&lt; *lower &lt;&lt; '\\n'; cout &lt;&lt; *lower2 &lt;&lt; '\\n'; // cout &lt;&lt; *lower3 &lt;&lt; '\\n'; 에러!}upper_bound 기본 형태template&lt; class ForwardIt, class T &gt;ForwardIt upper_bound( ForwardIt first, ForwardIt last, const T&amp; value );template&lt; class ForwardIt, class T &gt;ForwardIt upper_bound( ForwardIt first, ForwardIt last, const T&amp; value );template&lt; class ForwardIt, class T &gt;ForwardIt upper_bound( ForwardIt first, ForwardIt last, const T&amp; value );template&lt; class ForwardIt, class T, class Compare &gt;constexpr ForwardIt upper_bound( ForwardIt first, ForwardIt last, const T&amp; value, Compare comp ); 구현// 기본 버전template&lt;class ForwardIt, class T&gt;ForwardIt upper_bound(ForwardIt first, ForwardIt last, const T&amp; value){ ForwardIt it; typename std::iterator_traits&lt;ForwardIt&gt;::difference_type count, step; count = std::distance(first, last); while (count &gt; 0) { it = first; step = count / 2; std::advance(it, step); if (!(value &lt; *it)) { first = ++it; count -= step + 1; } else count = step; } return first;}// Compare 함수 버전template&lt;class ForwardIt, class T, class Compare&gt;ForwardIt upper_bound(ForwardIt first, ForwardIt last, const T&amp; value, Compare comp){ ForwardIt it; typename std::iterator_traits&lt;ForwardIt&gt;::difference_type count, step; count = std::distance(first, last); while (count &gt; 0) { it = first; step = count / 2; std::advance(it, step); if (!comp(value, *it)) { first = ++it; count -= step + 1; } else count = step; } return first;} upper_bound는 범위 [first, last) 안의 원소들 중에서 value 보다 큰 첫 번째 원소를 리턴한다. 만일 그런 원소가 없다면 last 를 리턴한다. upper_bound는 사용하기 전에는 오름차순으로 정렬되어 있어야 한다.#include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; using namespace std;int main() { vector&lt;int&gt; vec{ 7,4,1,9,2 }; sort(vec.begin(), vec.end()); auto lower = std::upper_bound(vec.begin(), vec.end(), 3); // 4 auto lower2 = std::upper_bound(vec.begin(), vec.end(), 5); // 7 auto lower3 = std::upper_bound(vec.begin(), vec.end(), 10); // vec.end() : 마지막 반복자 cout &lt;&lt; *lower &lt;&lt; '\\n'; cout &lt;&lt; *lower2 &lt;&lt; '\\n'; // cout &lt;&lt; *lower3 &lt;&lt; '\\n'; 에러!}응용#include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; using namespace std;int main() { vector&lt;int&gt; vec{ 8,1,6,12,4,10,15}; sort(vec.begin(), vec.end()); // 1,4,6,8,10,12,15 cout &lt;&lt; \"5 이상 10 이하의 갯수 : \" &lt;&lt; upper_bound(vec.begin(), vec.end(), 10) - lower_bound(vec.begin(), vec.end(), 5); // 3 (6,8,10)}" }, { "title": "fill, memest", "url": "/posts/fill,-memset/", "categories": "코딩테스트", "tags": "coding test", "date": "2023-10-26 00:00:00 +0900", "snippet": "memsetvoid* memset( void* dest, int value, std::size_t count ); memset은 int 부분을 unsigned char로 변환한다. 즉, 1byte 단위로 메모리를 초기화 한다는 뜻이다. 이러한 특징때문에 만약 자료형이 1byte를 넘어가면 값을 자동으로 그 자료형의 크기에 맞추기 때문에-1, 0으로만 초기화가 가능하다. #include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main(){ int arr1[3]; int arr2[5];\tmemset(arr1, 0, sizeof(arr1));\tmemset(arr2, -1, sizeof(arr2)); for (int i = 0; i &lt; 3; i++) { cout &lt;&lt; arr1[i] &lt;&lt; '\\n'; } for (int i = 0; i &lt; 5; i++) { cout &lt;&lt; arr2[i] &lt;&lt; '\\n'; }} 만약 1같은 값으로 초기화한다면 1byte를 4byte로 늘려서 8비트씩 4개 전부 00000001 이 모양이기 때문에 전혀 다른 값이 나와버린다.filltemplate&lt; class ForwardIt, class T &gt;void fill( ForwardIt first, ForwardIt last, const T&amp; value );template&lt; class ForwardIt, class T &gt;constexpr void fill( ForwardIt first, ForwardIt last, const T&amp; value );template&lt; class ExecutionPolicy, class ForwardIt, class T &gt;void fill( ExecutionPolicy&amp;&amp; policy, ForwardIt first, ForwardIt last, const T&amp; value ); fill 은 memset과 달리 반복자(Iterator)를 사용하는 자료구조에도 사용이 가능하다.#include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; using namespace std;int main() { vector&lt;int&gt; myvector(5); // 0 0 0 0 0 std::fill(myvector.begin(), myvector.begin() + 3, 5); // 처음부터 3번째 반복자까지 5로 초기화 // 5 5 5 0 0} 하지만 memset이 low level에서 처리하기때문에 fill보단 memset이 좀더 빠르다" }, { "title": "비트 관련", "url": "/posts/%EB%B9%84%ED%8A%B8%EA%B4%80%EB%A0%A8/", "categories": "코딩테스트", "tags": "coding test", "date": "2023-10-26 00:00:00 +0900", "snippet": "비트중 1의 개수short CountBits(unsigned int x){\tshort num_bits = 0; // x가 0이 되기 전까지 최하위 비트와 비교하면서 // 1이면 추가하고 (x &amp; 1); // 끝나면 최하위 비트 삭제 (x &gt;&gt;= 1)\twhile (x)\t{\t\tnum_bits += x &amp; 1;\t\tx &gt;&gt;= 1;\t}\treturn num_bits;}매우 큰 수에 대한 패리티 구하기 패리티 : 정보 전달 과정에서 오류가 생겼는지 검사하는 값으로 전체 비트의 개수를 2로 나눈 나머지 값 두 가지 방법이 있는데 하나는 다수의 비트를 한번에 처리하는 방법이고 다른 하나는 연산 결과를 룩업테이블(lookup table)에 캐시 형태로 저장하는 방법이다. 캐시 형태로 저장하기 64비트의 패리티 값은 너무 크기 때문에 모두 저장할 수 없다 (2의 64승) 따라서 16비트 4개로 나눈 후, 각 숫자의 패리티 값을 구하고 나온 4개의 패리티값의 패리티를 구하면 된다. 2의 16승은 65536으로 배열에 저장할 수 있고 64가 16으로 나눠 떨어져서 10비트씩 나누는 것보다 코드가 간단함 short parity(unsigned long long x){ const int kMaxSize = 16; const int kBitMask = 0xFFFF; // 1111 1111 1111 1111 // 16비트 하나씩 비교, return kPreComputedParity[x &gt;&gt; (3 * kMaskSize)] ^ kPreComputedParity[(x &gt;&gt; (2 * kMaskSize)) &amp; kBitMask] ^ kPreComputedParity[(x &gt;&gt; kMaskSize) &amp; kBitSize)] ^ kPreComputedParity[x &amp; kBitMask];} 시간 복잡도는 해시 테이블의 키값에 따라 달라진다. 해시 테이블에 사용될 키값의 비트 수가 L이고 전체 비트 수가 n이라면 시간 복잡도는 O(n/L)이 된다.다수의 비트를 한번에 처리 8비트 숫자를 사용해서 설명하려고 한다. 8비트가 1101 0111이라고 가정한다. 11010111을 4비트로 나눠 (1101), (0111)로 만들고 둘이 XOR한 연산한 값이 11010111의 패리티 값과 같다. 1101은 다시 (11)(01), 0111은 (01)(11)으로 XOR을 하면 (10) , (10)이 나오고 둘이 다시 XOR하면 (00)으로 패리티 값이 0이 나온다 결국 11010111의 패리티는 (00)의 XOR값인 0이다.short Parity(unsigned long long x){ x ^= x &gt;&gt; 32; x ^= x &gt;&gt; 16; x ^= x &gt;&gt; 8; x ^= x &gt;&gt; 4; x ^= x &gt;&gt; 2; x ^= x &gt;&gt; 1; return x &amp; 0x1;} 단어 크기가 n일 때 시간 복잡도는 O(log n)이 된다비트 연산 관련비트 세팅// 이렇게 하면 1비트가 10개로 줄세워진 값을 얻을 수 있다.int bit = (1 &lt;&lt; 10) - 1;비트 변경// p번째 비트를 변경 1이면 0, 0이면 1bit |= (1 &lt;&lt; p);특정 비트가 1인지 확인bool isSet = n &amp; (1 &lt;&lt; i);비트 삭제// p번째 비트를 0으로 만듦bit &amp;= ~(1 &lt;&lt; p);비트 토글 (1이면 0, 0이면 1)// p번째 비트를 Togglebit ^= (1 &lt;&lt; p);비트 초기화bit &amp;= ~(1 &lt;&lt; p);집합의 크기 구하기int bitCount(int x){ if ( x == 0 ) return 0; return x % 2 + bitCount(x / 2);}최하위 비트 자리수 구하기// bit가 1000 1000이라면// -bit는 2의 보수때문에 ~bit에 +1를 더한 값인 0111 1000이 된다.// 1000 1000// 0111 1000 결과는 다음과 같이 되고 4번째 bit가 최하위 비트가 된다.int resultBit = ( bit &amp; -bit );최하위 비트 지우기// - 1을 통해 최하위 비트를 끄고 그 밑 비트를 전부 킨 다음// AND 연산을 통해 최하위 비트 1을 0으로 만든다.// bit가 10 1000이라면 bit - 1은 10 0111이기 때문에 AND 연산을 하면// 10 0000이 되어버린다.bit &amp;= (bit - 1);N의 가장 낮은 비트의 1 구하기N &amp; -N비트 개수 세기int count = 0;while (n) { n &amp;= (n - 1); count++;}" }, { "title": "vector나 배열 안의 중복된 원소 삭제하기", "url": "/posts/vector%EB%82%98-%EB%B0%B0%EC%97%B4-%EC%95%88%EC%9D%98-%EC%A4%91%EB%B3%B5%EB%90%9C-%EC%9B%90%EC%86%8C-%EC%82%AD%EC%A0%9C%ED%95%98%EA%B8%B0/", "categories": "코딩테스트", "tags": "coding test", "date": "2023-10-26 00:00:00 +0900", "snippet": "vector 안의 중복된 원소 삭제#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt; using namespace std; int main(){ vector&lt;int&gt; vec; int arr[] = {7,2,1,2,7,5}; vec.assign(arr, arr+6); //벡터 원소 할당 sort(vec.begin(), vec.end()); vec.erase(unique(vec.begin(), vec.end()), vec.end()); return 0;}// 결과// 1 2 5 7배열 안의 중복된 원소 삭제 시간 복잡도 O(n)로, 공간을 O(n)만큼 추가로 해시 테이블을 사용해서 쉽게 구현할 수 있다. 배열 A를 순회하면서 해시 테이블에 원소를 넣고 확인 공간 복잡도 O(1)로 배열 A를 순회하면서 A[i]와 A[i+1]이 같다면 i+2 이후의 원소들을 모두 왼쪽으로 한 칸씩 옮기는 무식한 방법도 잇다. 시프팅(원소 옮기기)이 시간 복잡도의 주요 원인이므로 개선하려면 횟수를 줄여야 하는데 줄이기 위해 정렬해야 한다. int DeleteDuplicates(vector&lt;int&gt;* A_ptr){ vector&lt;int&gt;&amp; A = *A_ptr; if (empty(A)) return 0; int write_index = 1; for (int i = 1; i &lt; size(A); ++i) { if (A[write_index - 1] != A[i]) { A[write_index++] = A[i]; } } return write_index;}int main(){ vector&lt;int&gt; vec{ 2,3,5,7,7,11,11,11,13 }; int cnt = DeleteDuplicates(&amp;vec); vec.resize(cnt); // 남아있는 원소는 전부 날려버림 return 0;}" }, { "title": "max_element, min_element", "url": "/posts/max_element,-min_element/", "categories": "코딩테스트", "tags": "coding test", "date": "2023-10-05 00:00:00 +0900", "snippet": "max_element 기본 형태 #include&lt;algorithm&gt;에 들어가있는 함수로, 정렬되어 있지 않은 함수에서 최대값과 최소값을 구할 때 사용한다. max_element, min_element 함수의 기본 형태는 다음과 같다. https://en.cppreference.com/w/cpp/algorithm/max_element template&lt; class ForwardIt &gt;ForwardIt max_element( ForwardIt first, ForwardIt last );template&lt; class ForwardIt &gt;constexpr ForwardIt max_element( ForwardIt first, ForwardIt last ); // throw가 던져지면 ExecutionPolicy는 에러 보고template&lt; class ExecutionPolicy, class ForwardIt &gt;ForwardIt max_element( ExecutionPolicy&amp;&amp; policy,ForwardIt first, ForwardIt last ); compare 함수도 들어가 있는 기본 형태template&lt; class ForwardIt, class Compare &gt;ForwardIt max_element( ForwardIt first, ForwardIt last, Compare comp );template&lt; class ForwardIt, class Compare &gt;constexpr ForwardIt max_element( ForwardIt first, ForwardIt last,Compare comp );template&lt; class ExecutionPolicy, class ForwardIt, class Compare &gt;ForwardIt max_element( ExecutionPolicy&amp;&amp; policy,ForwardIt first, ForwardIt last, Compare comp ); 매개변수 타입에 있는 It은 Iterator로, 결국 Iterator를 지원하는 클래스를 대상으로 최대값을 찾아주는 역할을 할 수 있다.max_element 구현 이 또한 https://en.cppreference.com/w/cpp/algorithm/max_element에 나와있음.// 기본 버전template&lt;class ForwardIt&gt;ForwardIt max_element(ForwardIt first, ForwardIt last){ if (first == last) return last; ForwardIt largest = first; ++first; for (; first != last; ++first) if (*largest &lt; *first) largest = first; return largest;}// Compare 함수가 들어가 있는 버전template&lt;class ForwardIt, class Compare&gt;ForwardIt max_element(ForwardIt first, ForwardIt last, Compare comp){ if (first == last) return last; ForwardIt largest = first; ++first; for (; first != last; ++first) if (comp(*largest, *first)) largest = first; return largest;}min_element 기본 형태template&lt; class ForwardIt &gt;ForwardIt min_element( ForwardIt first, ForwardIt last );template&lt; class ForwardIt &gt;constexpr ForwardIt min_element( ForwardIt first, ForwardIt last ); // throw가 던져지면 ExecutionPolicy는 에러 보고template&lt; class ExecutionPolicy, class ForwardIt &gt;ForwardIt min_element( ExecutionPolicy&amp;&amp; policy, ForwardIt first, ForwardIt last ); compare 함수도 들어가 있는 기본 형태template&lt; class ForwardIt, class Compare &gt;ForwardIt min_element( ForwardIt first, ForwardIt last, Compare comp );template&lt; class ForwardIt, class Compare &gt;constexpr ForwardIt min_element( ForwardIt first, ForwardIt last, Compare comp );template&lt; class ExecutionPolicy, class ForwardIt, class Compare &gt;ForwardIt min_element( ExecutionPolicy&amp;&amp; policy, ForwardIt first, ForwardIt last, Compare comp ); 매개변수 타입에 있는 It은 Iterator로, 결국 Iterator를 지원하는 클래스를 대상으로 최소값을 찾아주는 역할을 할 수 있다.min_element 구현// 기본 버전template&lt;class ForwardIt&gt;ForwardIt min_element(ForwardIt first, ForwardIt last){ if (first == last) return last; ForwardIt smallest = first; ++first; for (; first != last; ++first) if (*first &lt; *smallest) smallest = first; return smallest;}// Compare 함수가 들어가 있는 버전template&lt;class ForwardIt, class Compare&gt;ForwardIt min_element(ForwardIt first, ForwardIt last, Compare comp){ if (first == last) return last; ForwardIt smallest = first; ++first; for (; first != last; ++first) if (comp(*first, *smallest)) smallest = first; return smallest;}예시 max_element 함수나 min_element 함수의 반환값이 Iterator이므로 포인터 연산자 *를 사용해서 해당 값에 접근할 수 있다. 만약 정렬되어 있다면, 정렬된 기준으로 최대값 최소값을 찾는 것이 더 효율적이다. #include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;array&gt;#include &lt;vector&gt;#include &lt;list&gt;using namespace std;int main(){\tarray&lt;int, 6&gt; arr = { 1,4,9,22,3,6 };\tvector&lt;int&gt; vec = { 16,9,4,2,6,8 };\tlist&lt;int&gt; li = { 4,8,14,1,5,3 }; // 배열\tcout &lt;&lt; *max_element(arr.begin(), arr.end()) &lt;&lt; '\\n';\tcout &lt;&lt; *min_element(arr.begin(), arr.end()) &lt;&lt; '\\n'; // 벡터\tcout &lt;&lt; *max_element(vec.begin(), vec.end()) &lt;&lt; '\\n';\tcout &lt;&lt; *min_element(vec.begin(), vec.end()) &lt;&lt; '\\n'; // 리스트\tcout &lt;&lt; *max_element(li.begin(), li.end()) &lt;&lt; '\\n';\tcout &lt;&lt; *min_element(li.begin(), li.end()) &lt;&lt; '\\n';}" }, { "title": "Set,Priority_queue 정렬", "url": "/posts/Set,Priority_queue-%EC%A0%95%EB%A0%AC/", "categories": "코딩테스트", "tags": "coding test", "date": "2023-10-05 00:00:00 +0900", "snippet": "Set 기본 형태// C++ 17 이전template&lt; class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;&gt; class set;// C++ 17namespace pmr {template&lt; class Key, class Compare = std::less&lt;Key&gt;&gt; using set = std::set&lt;Key, Compare, std::pmr::polymorphic_allocator&lt;Key&gt;&gt;;} Set은 두 번째 인자인 Compare 클래스가 비교 함수로 사용되는 인자이며, less (오름차순) 구조체가 기본적으로 설정되어 있다. less 구조체는 다음과 같은 operator()를 지원하며, Set 변수에 넣으면 바꾼 연산자로 정렬 기준을 사용할 수 있다. // 기본 형태constexpr bool operator()(const T &amp;lhs, const T &amp;rhs) const { return lhs &lt; rhs; }Set 정렬 예시 백준 1187번 문제(단어 정렬) Set의 두 번째 인자로, operator() 연산자를 가진 구조체를 사용함으로써 정렬 순서를 커스텀할 수 있다. 이 때 operator() 연산자의 매개변수는 첫번째 매개변수의 타입과 일치해야 한다. #include &lt;iostream&gt;#include &lt;set&gt;using namespace std;struct Cmp {\tbool operator() (const string&amp; a, const string&amp; b) const {\t\tif (a.size() == b.size())\t\t\t// 길이가 같으면 \t\t\treturn a &lt; b;\t\t\t\t\t// 사전순\t\telse\t\t\treturn a.size() &lt; b.size();\t\t// 아니면 길이순\t}};int main() { // operator()를 지원하는 구조체를 인자로 넣어 정렬 기준 사용\tset&lt;string, Cmp&gt; sets; int n;\tcin &gt;&gt; n;\tstring tmp;\tfor (int i = 0; i &lt; n; i++) {\t\tcin &gt;&gt; tmp;\t\tsets.insert(tmp);\t}\tfor (const string str : sets) {\t\tcout &lt;&lt; str &lt;&lt; '\\n';\t}\treturn 0;}Priority_queue 기본 형태template&lt; class T, class Container = std::vector&lt;T&gt;, class Compare = std::less&lt;typename Container::value_type&gt;&gt; class priority_queue; Priority_queue는 T타입 vector를 사용해서 정렬하기 때문에 Compare을 사용하려면 vector&lt;T&gt;도 같이 선언해줘야 한다.Priority_queue 사용 예시 기본적으로 오름차순을 지원하는 priority_queue를 내림차순으로 바꾸는 방법#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;int main(void) {\tpriority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq;\tpq.push(5);\tpq.push(1);\tpq.push(7);} set과 마찬가지로 less 구조체를 사용하기 때문에 정렬을 커스텀하기 위해선 operator()를 지원하는 구조체를 따로 선언해서 넣어줘야 한다.#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;struct Cmp {\tbool operator() (pair&lt;int,int&gt;&amp; a, pair&lt;int, int&gt;&amp; b){\t\tif (a.first == b.first)\t\t\t// first가 같으면\t\t\treturn a.second &gt; b.second;\t// second를 오름차순으로 정렬\t\telse \t\t\treturn a.first &lt; b.first;\t// first가 다르면 first를 기준으로 내림차순\t}};int main() {\tpriority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, Cmp&gt; pq;\tpq.push(make_pair(1, 7));\tpq.push(make_pair(4, 2));\tpq.push(make_pair(4, 4));\tpq.push(make_pair(6, 8));\twhile(!pq.empty())\t{\t\tpair&lt;int, int&gt; Cur = pq.top();\t\tcout &lt;&lt; Cur.first &lt;&lt; \" \" &lt;&lt; Cur.second &lt;&lt; '\\n';\t\tpq.pop();\t}\treturn 0;}/* 첫번째는 오름차순으로 정렬되다가 같다면 두 번째는 내림차순으로 정렬6 84 24 41 7*/ " }, { "title": "Editor Utility Widget", "url": "/posts/Editor-Utility-Widget/", "categories": "unreal, Editor", "tags": "unreal", "date": "2023-09-25 00:00:00 +0900", "snippet": "Editor Utility Widget Editor Utility Widget은 UMG(Unreal Motion Graphics)에 기반한 Slave Widget이다. 에디터 탭을 만들기에 유저 친화적이며 블루프린트에 노출(Expose)이 된다. 위젯 만들기 일단 컨텐츠 브라우저에 가서 마우스 우클릭한 다음에, 에디터 유틸리티 -&gt; 에디터 유틸리티 위젯을 생성하고 다음과 같이 만들어준다. 캔버스 패널 가로 상자 디테일뷰 버튼 - 텍스트 클래스 만들기 그리고 다음과 같이 EditorUtilityWidget을 상속받은 클래스를 만들어준다.UCLASS()class SUPERMANAGER_API UQuickMaterialCreationWidget : public UEditorUtilityWidget{\tGENERATED_BODY()public:#pragma region QuickMaterialCreationCore\tUFUNCTION(BlueprintCallable)\tvoid CreateMaterialFromSelectedTextures();\tUPROPERTY(EditAnywhere,BlueprintReadWrite, Category=\"CreateMaterialFromSelectedTextures\")\tFString MaterialName = TEXT(\"M_\");#pragma endregion };#include \"DebugHeader.h\"void UQuickMaterialCreationWidget::CreateMaterialFromSelectedTextures(){\tDebugHeader::Print(TEXT(\"Working\"),FColor::Cyan);} 그리고 위젯에서 디테일뷰에 가서 표시할 카테고리를 생성해서 인덱스에 사용할 변수와 동일한 카테고리를 넣어줘야 디테일 뷰에서 해당 변수를 사용할 수 있다. 그리고 블루프린트에서 다음과 같이 추가한다. 결과 디테일 뷰에 Material Name이 들어갔고 Button으로 CreateMaterialFromSelectedTextures 함수 호출" }, { "title": "Interface", "url": "/posts/Interface/", "categories": "unreal, Basic", "tags": "unreal", "date": "2023-09-25 00:00:00 +0900", "snippet": " 인터페이스는 서로 연관없는 클래스들끼리 공통의 함수를 지원할 수 있게 해줄수 있는 클래스이다. 예를 들어 어떠한 트리거를 발동시키면 반응하는 함수를 필요할 수 있는데 클래스마다 타입이 다를 수 있어(APawn,AActor,UDataAsset 등)이러한 모든 클래스에게 같은 함수를 지원하고 싶을 때 인터페이스를 사용하면 좋다. 언리얼에서는 이러한 인터페이스 클래스를 따로 지원한다. 언리얼 에디터에서 인터페이스를 상속받는 클래스를 만든다면 다음과 같이 생성될 수 있다. UINTERFACE(MinimalAPI)class UTestInterface : public UInterface{\tGENERATED_BODY()};class RPGPROJECT_API ITestInterface{\tGENERATED_BODY()} 여기서 ITestInterface에 순수 가상 함수를 넣어 인터페이스처럼 사용할 수 있다. 일반 함수도 함수 선언은 가능하다. 차이점 여기서 인터페이스와 일반 클래스의 차이점은 크게 두가지가 있다. 하나는, UCLASS 대신 UINTERFACE를 사용한다 다른 하나는,U가 붙은 Interface 클래스는 실제 인터페이스가 아닌, 언리얼 엔진의 리플렉션 시스템을 위해 존재하는 비어있는 클래스이다실제 인터페이스는 I가 붙은 Interface 클래스이다. 인터페이스 지정자 인터페이스 지정자에는 다음과 같이 있다.BlueprintType 인터페이스를 블루프린트로 노출시키는 지정자DependsOn=(ClassName1,ClassName2, ...) 나열된 ClassName1… 등은 인터페이스 앞에 컴파일이 된다MinimalAPI 클래스의 타입만 다른 모듈에서 사용할 수 있도록 노출시킨다. 클래스는 타입변환 가능하지만, 그 클래스의 함수는 (인라인 메서드를 제외하고) 호출할 수 없다 그로인해, 다른 모듈에서 접근할 수 없는 함수가 모두 필요치 않은 클래스에 대해 모든 것을 익스포트하지 않아 컴파일 시간이 빨라집니다. TScriptInterface 언리얼 엔진에서 특정 인터페이스를 구현하는 객체에 대한 안전한 참조를 관리하기 위해 제공되는 템플릿 클래스 UObject를 기반으로 하는 객체와 해당 객체가 구현한 인터페이스를 함께 보관하며, C++ 코드와 블루프린트 간의 상호작용을 원활하게 함 사용 이유 인터페이스의 안전한 관리: TScriptInterface는 인터페이스를 관리할 때 발생할 수 있는 다양한 오류를 방지합니다. 예를 들어, 일반적인 포인터로 인터페이스를 관리하면 발생할 수 있는 참조 무결성 문제를 해결 C++에서 정의된 인터페이스를 블루프린트에서도 안전하게 사용예시UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Interface Example\")TScriptInterface&lt;IMyInterface&gt; MyInterfaceInstance;인터페이스 상속확인 예를 들어 어떤 인터페이스를 상속받아 그 인터페이스의 함수로 특정 행동을 구현했다면, 다른 클래스에서 특정 행동을 하는 Actor만 따로 추출해서 따로 기능을 만들고 싶을 때도 있는데 그럴때 인터페이스 상속을 확인하는 방법을 알아야 한다. 인터페이스를 상속하고 있는지 확인하고 싶으면 다음과 같은 코드를 작성하면 된다. // 여기서 OtherActor은 인터페이스를 상속하고 있는지 확인하고 싶은 클래스 변수// 방법1, ImplementsInterface를 사용 if(OtherActor-&gt;GetClass()-&gt;ImplementsInterface(UTestInterface::StaticClass())){ UE_LOG(LogTemp,Warning,TEXT(\"This Actor is inherited TestInterface1\"));}// 방법2, Implements&lt;&gt; 템플릿을 사용if(OtherActor-&gt;Implements&lt;UTestInterface&gt;()){ UE_LOG(LogTemp,Warning,TEXT(\"This Actor is inherited TestInterface2\"));}// 방법3, Cast를 사용if(ITestInterface* TestInterface = Cast&lt;ITestInterface&gt;(OtherActor)){ UE_LOG(LogTemp,Warning,TEXT(\"This Actor is inherited TestInterface3\"));} 충돌 델리게이트로 확인한 결과, 하단에 3개의 로그가 뜨는 모습" }, { "title": "Timer", "url": "/posts/Timer/", "categories": "unreal, Basic", "tags": "unreal", "date": "2023-09-23 00:00:00 +0900", "snippet": "Timer 어떠한 함수를 일정 시간마다 호출 하기 위한 기능이다. ex) 마우스 왼클릭을 누르고 있으면 총에서 총알이 0.3초 간격으로 계속 발사되는 등.. Timer는 FTimerManager 타입인 Timer Manager에서 관리한다. FTimerManager는 GameInstance와 World에 존재한다. Timer는 C++ 함수 포인터, TFunction Objects, Delegate와 함께 사용할 수 있다. 사용할 함수SetTimer World나 GameInstance를 통해 FTimerManager를 호출하고 FTimerManager에서 SetTimer란 함수를 통해 타이머를 설정할 수 있다. 오버로딩으로 여러 인자가 있지만 대표적으로 사용하는 함수 인자는 다음과 같다. 함수 포인터 버전 타이머// TimerManager.htemplate&lt; class UserClass &gt;FORCEINLINE void SetTimer( FTimerHandle&amp; InOutHandle, // 타이머 핸들UserClass* InObj, // 함수 포인터의 객체typename FTimerDelegate::TMethodPtr&lt; UserClass &gt; InTimerMethod, // 함수 포인터float InRate, // 타이머 주기bool InbLoop = false, // 루프 설정float InFirstDelay = -1.f) // 타이머 시작 시간{ InternalSetTimer( InOutHandle, FTimerUnifiedDelegate( FTimerDelegate::CreateUObject(InObj, InTimerMethod) ), InRate, InbLoop, InFirstDelay);} 델리게이트 버전 타이머FORCEINLINE void SetTimer(FTimerHandle&amp; InOutHandle, // 타이머 핸들FTimerDelegate const&amp; InDelegate, // 델리게이트float InRate, // 타이머 주기bool InbLoop, // 루프 설정float InFirstDelay = -1.f) // 타이머 시작 시간{ InternalSetTimer( InOutHandle, FTimerUnifiedDelegate(InDelegate), InRate, InbLoop, InFirstDelay);}ClearTimer 타이머를 종료시키기 위해선 다음 함수를 호출해야 한다. ID 역할을 하는 FTimerHandle을 인자로 사용해야 한다.FORCEINLINE void ClearTimer(FTimerHandle&amp; InHandle){ if (const FTimerData* TimerData = FindTimer(InHandle)) { InternalClearTimer(InHandle); } InHandle.Invalidate();}예시 USphereComponent의 충돌 델리게이트를 이용해서 타이머를 설정해보려 한다.헤더파일public: // 타이머에 사용할 변수들 FTimerHandle TimerHandle; float TimerDelay = 1.f; int Minute = 0; void TimerFunc();protected: virtual void BeginPlay() override;private: USphereComponent* SphereComponent;소스파일void ATestActor::BeginPlay(){\tSuper::BeginPlay();\t // 충돌 설정\tSphereComponent-&gt;OnComponentBeginOverlap.AddDynamic(this, &amp;ATestActor::BeginCollide);\tSphereComponent-&gt;OnComponentEndOverlap.AddDynamic(this, &amp;ATestActor::EndCollide);}// 타이머 함수void ATestActor::TimerFunc(){\t++Minute;\tUE_LOG(LogTemp, Warning, TEXT(\"%d\"), Minute);}void ATestActor::BeginCollide(...) // 매개변수는 길어서 적지 않음.{\tif(AMainCharacter* MainCharacter = Cast&lt;AMainCharacter&gt;(OtherActor))\t{\t\tUE_LOG(LogTemp,Warning,TEXT(\"BeginCollide\"));\t\tGetWorld()-&gt;GetTimerManager().SetTimer(\t\t\tTimerHandle, // 핸들\t\t\tthis, // 함수(델리게이트)의 객체\t\t\t&amp;ATestActor::TimerFunc, // 타이머에 사용할 함수(델리게이트)\t\t\tTimerDelay); // 딜레이\t}}void ATestActor::EndCollide(...) // 매개변수는 길어서 적지 않음.{\tif(AMainCharacter* MainCharacter = Cast&lt;AMainCharacter&gt;(OtherActor))\t{\t\tif(TimerHandle.IsValid())\t\t{\t\t\tUE_LOG(LogTemp,Warning,TEXT(\"EndCollide\")); // TimerHandle에 저장되어 있는 타이머 종료\t\t\tGetWorld()-&gt;GetTimerManager().ClearTimer(TimerHandle);\t\t\tMinute = 0;\t\t}\t}}사진 TestActor와 충돌을 시작하면 다음과 같이 주기(TimerDelay초) 마다 아래에 텍스트가 뜬다. TestActor와 충돌을 끝내면 EndCollide가 호출되면서 더 이상 텍스트가 뜨지 않는다." }, { "title": "Custom Icon", "url": "/posts/Custom-Icon/", "categories": "unreal, Editor", "tags": "unreal", "date": "2023-09-22 00:00:00 +0900", "snippet": "아이콘 생성 및 등록 먼저 아이콘을 사용하려면 FSlateStyleSet 타입을 사용해야 한다 그래서 이 타입을 사용할 클래스를 처음에 내가 만든 플러그인에 클래스를 추가하고 다음과 같이 작성한다.#pragma once#include \"Styling/SlateStyle.h\"class FSuperManagerStyle{public:\tstatic void InitializeIcons();\tstatic void ShutDown();private:\tstatic FName StyleSetName;\tstatic TSharedRef&lt;FSlateStyleSet&gt; CreateSlateStyleSet(); // 생성\tstatic TSharedPtr&lt;FSlateStyleSet&gt; CreatedSlateStyleSet; // 저장public:\tstatic FName GetStyleSetName() {return StyleSetName;}}; 그 다음 플러그인의 Resources에 사용할 아이콘을 넣어준다. 그리고 나서 cpp 파일은 다음과 같다.#include \"CustomStyle/SuperManagerStyle.h\"#include \"Interfaces/IPluginManager.h\"#include \"Styling/SlateStyleRegistry.h\"FName FSuperManagerStyle::StyleSetName = FName(\"SuperManagerStyle\");TSharedPtr&lt;FSlateStyleSet&gt; FSuperManagerStyle::CreatedSlateStyleSet = nullptr;void FSuperManagerStyle::InitializeIcons(){\tif(!CreatedSlateStyleSet.IsValid())\t{\t\tCreatedSlateStyleSet = CreateSlateStyleSet();\t\tFSlateStyleRegistry::RegisterSlateStyle(*CreatedSlateStyleSet);\t}}TSharedRef&lt;FSlateStyleSet&gt; FSuperManagerStyle::CreateSlateStyleSet(){\tTSharedRef&lt;FSlateStyleSet&gt; CustomStyleSet = MakeShareable(new FSlateStyleSet(StyleSetName)); // Slate Style 생성\t// 플러그인 경로를 찾고 그다음 Icon이 있는 경로 찾기\tconst FString IconDirectory = IPluginManager::Get().FindPlugin(TEXT(\"SuperManager\"))-&gt;GetBaseDir() / \"Resources\";\tCustomStyleSet-&gt;SetContentRoot(IconDirectory); // 루트 설정\tconst FVector2D Icon16x16 (16.f,16.f);\tCustomStyleSet-&gt;Set(\"ContentBrowser.DeleteUnusedAsset\", // 아이콘과 맵핑할 이름 설정\tnew FSlateImageBrush(IconDirectory/\"DeleteUnusedAsset.png\",Icon16x16)); // 이미지 설정(경로,크기)\t\treturn CustomStyleSet;}void FSuperManagerStyle::ShutDown(){\t} 먼저 위 코드를 작성하기 전에 build.cs파일에서 \"Projects\" 모듈이 있어야 IPluginManager가 작동한다. 일단 CreateSlateStyleSet 함수는 FSlateStyleSet 타입을 생성하는 함수이므로 변수를 생성한다. 플러그인의 Resources 폴더에 있을 경로를 찾기 위해 플러그인 경로를 FindPlugin 함수로 찾고 SetContentRoot 함수로 루트를 설정한다 Set 함수로는 아이콘의 이름과 아이콘 경로,크기를 설정한다 마지막으로 함수의 반환값을 static 멤버 변수로 저장하고 RegisterSlateStyle 함수로 등록한다 아이콘 사용 그 다음 위에서 만든 FSuperManagerStyle 클래스를 Menu Entry에 사용하기 위해 다음과 같이 추가한다.// SuperManager.cpp#include \"CustomStyle/SuperManagerStyle.h\"void FSuperManagerModule::StartupModule(){\tFSuperManagerStyle::InitializeIcons(); InitCBMenuExtention(); RegisterAdvanceDeletionTab();} 그리고 InitCBMenuExtention() 함수안에 있는 Menu Entry를 추가하는 함수로 가서 아이콘을 설정하는 매개변수를 바꿔주면 된다.void FSuperManagerModule::AddCBMenuEntry(FMenuBuilder&amp; MenuBuilder){\tMenuBuilder.AddMenuEntry\t(\t\tFText::FromString(TEXT(\"Delete UnUsed Assets\")),\t\t// 타이틀\t\tFText::FromString(TEXT(\"Safely delete all unused assets under folder\")),\t// 툴팁\t\tFSlateIcon(),\t// 아이콘\t\tFExecuteAction::CreateRaw(this,&amp;FSuperManagerModule::OnDeleteUnusedAssetbuttonClicked) // 호출할 함수\t); ...} 아이콘 생성 그리고 StartupModule에 있는 커스텀 에디터를 여는 함수 RegisterAdvanceDeletionTab에서 SetIcon을 추가하면 마찬가지로 아이콘이 뜬다.void FSuperManagerModule::RegisterAdvanceDeletionTab(){\tFGlobalTabmanager::Get()-&gt;RegisterNomadTabSpawner(FName(\"AdvanceDeletion\"),\t\tFOnSpawnTab::CreateRaw(this, &amp;FSuperManagerModule::OnSpawnAdvanceDeletionTab))\t.SetDisplayName(FText::FromString(TEXT(\"Advance Deletion\")))\t.SetIcon(FSlateIcon(FSuperManagerStyle::GetStyleSetName(),\"ContentBrowser.AdvanceDeletion\"));} 좌측 상단에 아이콘이 뜸.ShutDown 그리고 생성했던 SlateStyle들은 따로 UnRegister 함수를 해준다.// SuperManagerStyle.cppvoid FSuperManagerStyle::ShutDown(){\tif(CreatedSlateStyleSet.IsValid())\t{\t\tFSlateStyleRegistry::UnRegisterSlateStyle(*CreatedSlateStyleSet);\t\tCreatedSlateStyleSet.Reset();\t}}// SuperManager.cppvoid FSuperManagerModule::ShutdownModule(){\tFGlobalTabmanager::Get()-&gt;UnregisterNomadTabSpawner(FName(\"AdvanceDeletion\"));\tFSuperManagerStyle::ShutDown();}" }, { "title": "Debug Tool", "url": "/posts/Debug-Tool/", "categories": "unreal, Editor", "tags": "unreal", "date": "2023-09-21 00:00:00 +0900", "snippet": " 에디터로 만들 수 있는 종류를 확인하고 싶으면 툴 -&gt; 디버그 -&gt; 디버그툴로 들어간 다음 디버그 툴에서 테스트 스위트 버튼을 클릭하면 다음과 같이 StarshipGallery라는 위젯이 뜬다.Debug ToolStarShip Gallery Starship Gallery에 있는 기능들을 커스텀 에디터에서 구현할 수 있는데 Starship Gallery에 있는 기능을 C++ 코드로 보려면 다음과 같이 SStarShipGallery.cpp 코드를 찾아가면 된다.Widget Reflector 이번에도 툴 -&gt; 디버그에 가서 위젯 리플렉터를 클릭하면 다음과 같이 화면이 뜬다. 여기서 왼쪽 중간에 있는 히트 테스트 가능 위젯 선택을 클릭하면 언리얼 에디터에 마우스를 올린 위젯을 경로를 찾아준다. Viewport에 마우스를 올리면 다음과 같이 Viewport에 사용된 SViewport의 경로를 찾아감 UnRegister 처음 커스텀 에디터를 열 때 StartupModule에서 해당 커스텀 에디터를 등록했던 것처럼 마지막엔 해당 커스텀 에디터를 등록해제 해야한다.void FSuperManagerModule::ShutdownModule(){\tFGlobalTabmanager::Get()-&gt;UnregisterNomadTabSpawner(FName(\"AdvanceDeletion\"));}" }, { "title": "Dynamic && Multicast Deletgate && Event", "url": "/posts/Dynamic-&&-Multicast-Deletgate-&&-Event/", "categories": "unreal, Basic", "tags": "unreal", "date": "2023-09-21 00:00:00 +0900", "snippet": "다이나믹 델리게이트 다이내믹 델리게이트는 싱글 델리게이트의 기능과 비슷하고 직렬화(Serialize)와 리플렉션(Reflection) 가능하다. 다이나믹 델리게이트는 싱글 델리게이트와 달리 블루프린트 객체와 연동이 가능하다 블루프린트 함수와 연동하기 위한 UFUCNTION 매크로가 있어야 바인딩이 가능하고 없으면 에러가 발생한다. 블루프린트와 연동하기 위해 직렬화(serialize)를 해야하기 때문에 싱글 델리게이트보다 속도는 느리다. 여기서 직렬화라는 의미는 다이나믹 델리게이트는 함수 포인터가 아닌 함수 이름을 기반으로 등록해서 호출한다라는 뜻이다. // 다이내믹 델리게이트 선언DECLARE_DYNAMIC_DELEGATE();// RetVal과 &lt;Num&gt;Param은 싱글 델리게이트와 사용 방법은 동일하지만// &lt;Num&gt;Param의 경우 인자의 이름도 뒤에 적어줘야 한다.DECLARE_DYNAMIC_DELEGATE_OneParam(FDynamicOneParam, int, num);DECLARE_DYNAMIC_DELEGATE_RetVal(FString, FDynamicRetVal);다이나믹 바인딩// Dynamic Delegate 전용 바인딩 함수BindDynamic(ObjectPointer, FuncName);// 바인딩된 Delegate를 삭제RemoveDynamic(ObjectPointer, FuncName);다이나믹 실행 싱글 델리게이트와 동일하게 구성되어 있다.Execute()ExecuteIfBound()IsBound() Execute()는 바인딩된 함수를 실행, 바인딩된 함수가 없다면 에러 발생 ExecuteIfBound()는 바인딩이 되어있는지 확인하고 true면 함수를 실행하고, 아니면 아무일도 일어나지 않음 IsBound()는 델리게이트 변수가 바인딩이 되어있는지 확인하는 함수로 바인딩 돼 있으면 true, 아니면 false 반환 예시 다이나믹 델리게이트 선언// MainCharacter.h, 델리게이트 선언DECLARE_DYNAMIC_DELEGATE(FDynamicDelegate);UPROPERTY(BlueprintReadOnly)FDynamicDelegate DynamicDelegate;// MainCharacter.cpp, 바인딩한 델리게이트 실행void AMainCharacter::PrintBindFunc(){\tif(DynamicDelegate.IsBound()) \t{ DynamicDelegate.Execute(); }\telse { UE_LOG(LogTemp,Warning,TEXT(\"DynamicDelegate is not bound\"));\t}} 다른 클래스에서 바인딩// TestActor.cppvoid ATestActor::DynamicFunc(){\tUE_LOG(LogTemp,Warning,TEXT(\"Dynamic Delegate Execute\"));}MainCharacter-&gt;DynamicDelegate.BindDynamic(this,&amp;ATestActor::DynamicFunc); 함수 호출 C++에서 선언한 Dynamic Delegate를 블루프린트에서 호출 (BlueprintReadOnly)멀티캐스트 델리게이트 멀티캐스트 델리게이트는 여러 개의 함수를 바인딩할 수 있다.// 멀티캐스트 델리게이트 선언DECLARE_MULTICAST_DELEGATE(); 멀티캐스트에도 다이나믹 델리게이트가 있다. 즉, 여러 개의 함수를 바인딩하면서 블루프린트 객체와 연동이 가능 // 다이나믹 멀티캐스트 델리게이트 선언DECLARE_DYNAMIC_MULTICAST_DELEGATE()DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam()멀티캐스트 바인딩 멀티캐스트는 여러 함수를 바인딩하기 때문에 바인딩을 해제하는 함수를 제외하고 싱글 델리게이트의 바인딩과 매우 유사하다.멀티캐스트 실행 델리게이트에 바인딩한 오브젝트에게 알림을 보내서 바인딩한 모든 함수를 호출한다.Broadcast();예시 멀티캐스트 델리게이트 선언// MainCharacter.h, 델리게이트 선언DECLARE_MULTICAST_DELEGATE(FMultiDelegate);FMultiDelegate MultiDelegate;// MainCharacter.cpp, 바인딩한 델리게이트 실행void AMainCharacter::PrintBindFunc(){\tif(MultiDelegate.IsBound()) { MultiDelegate.Broadcast(); } // 바인딩된 모든 함수 호출\telse { UE_LOG(LogTemp,Warning,TEXT(\"Multi Delegate is not bound\"));\t}} 다른 클래스에서 바인딩// TestActor.cppvoid ATestActor::MultiFunc(){\tUE_LOG(LogTemp,Warning,TEXT(\"Multi Func Execute\"));}void GlobalFunc(){\tUE_LOG(LogTemp,Warning,TEXT(\"GlobalFunc Execute\"));}// 클래스 함수MainCharacter-&gt;MultiDelegate.AddUObject(this,&amp;ATestActor::MultiFunc);// 전역 함수MainCharacter-&gt;MultiDelegate.AddStatic(GlobalFunc);// 람다 함수MainCharacter-&gt;MultiDelegate.AddLambda([](){UE_LOG(LogTemp,Warning,TEXT(\"Lambda Execute\"))}); " }, { "title": "Help Text", "url": "/posts/Help-Text/", "categories": "unreal, Editor", "tags": "unreal", "date": "2023-09-20 00:00:00 +0900", "snippet": "Help Text Combox에 대한 텍스트와 현재 눌러서 받아오는 폴더의 경로를 추가하려 한다. 먼저, 그러기 위해선 STextBlock을 생성하는 함수를 만든다. TSharedRef&lt;STextBlock&gt; SAdvanceDeletionTab::ConstructComboHelpTexts(const FString&amp; TextContent,\tETextJustify::Type TextJustify){\tTSharedRef&lt;STextBlock&gt; ConstructedHelpText =\tSNew(STextBlock)\t.Text(FText::FromString(TextContent))\t.Justification(TextJustify)\t.AutoWrapText(true); // AutoWrapText는 텍스트가 길면 자동으로 줄바꿈하는 함수\treturn ConstructedHelpText;} 이제 텍스트를 추가하기 전에, 폴더 경로를 모듈에서 받아와야 하므로 SLATE_ARUGMENT로 FolderPath를 받는 FString을 작성하고 모듈에서는 에셋 데이터와 함께 폴더 경로도 넘겨준다class SAdvanceDeletionTab : public SCompoundWidget{\tSLATE_BEGIN_ARGS(SAdvanceDeletionTab) {}\tSLATE_ARGUMENT(TArray&lt;TSharedPtr&lt;FAssetData&gt;&gt; ,AssetsDataToStore)\tSLATE_ARGUMENT(FString, CurrentSelectedFolder) // 이 라인 추가\t\tSLATE_END_ARGS() // ...}// 모듈TSharedRef&lt;SDockTab&gt; FSuperManagerModule::OnSpawnAdvanceDeletionTab(const FSpawnTabArgs&amp; SpawnTabArgs){\treturn SNew(SDockTab).TabRole(ETabRole::NomadTab)\t[\t\tSNew(SAdvanceDeletionTab)\t\t.AssetsDataToStore(GetAllAssetDataUnderSelectedFolder())\t\t.CurrentSelectedFolder(FolderPathSelected[0]) // 이 라인 추가 // FolderPathSelected[0]는 GetAllAssetDataUnderSelectedFolder() 함수에서 // UEditorAssetLibrary::ListAssets로 저장했던 폴더 경로\t];} 이제 Construct 함수에서 ComboBox를 만드는 함수 아래에 작성하여 같은 라인에 만들어준다.void SAdvanceDeletionTab::Construct(const FArguments&amp; InArgs){ // ... ChildSlot\t[ // ... +SVerticalBox::Slot()\t\t.AutoHeight()\t\t[\t\t\tSNew(SHorizontalBox)\t\t\t+SHorizontalBox::Slot()\t\t\t.AutoWidth()\t\t\t[\t\t\t\tConstructComboBox()\t\t\t]\t\t\t// Help text for Combo box slot\t\t\t+SHorizontalBox::Slot()\t\t\t.FillWidth(.6f)\t\t\t[\t\t\t\tConstructComboHelpTexts(\t\tTEXT(\"Specify the listing condition in the drop. Left mouse button click to go to where asset is located\"),\t\t\t\tETextJustify::Center)\t\t\t]\t\t\t// Help text for Combo box slot\t\t\t+SHorizontalBox::Slot()\t\t\t.FillWidth(.1f)\t\t\t[\t\t\t\tConstructComboHelpTexts(\t\t\tTEXT(\"Current Folder:\\n\") + InArgs._CurrentSelectedFolder,\t\t\t\tETextJustify::Right)\t\t\t]\t\t] ]}사진 중앙에는 ComboBox에 대한 설명과 오른쪽에는 ListView를 클릭한 폴더 경로를 보여준다." }, { "title": "Single Delegate", "url": "/posts/Single-Delegate/", "categories": "unreal, Basic", "tags": "unreal", "date": "2023-09-20 00:00:00 +0900", "snippet": "Delegate Delegate는 임의 오브젝트의 멤버 함수를 다른 오브젝트에게 동적으로 바인딩(binding)을 시켜서, 다른 오브젝트에서 바인딩한 멤버 함수를 호출할 수 있도록 하는 기법 Delegate는 관찰자 패턴이라는 디자인 패턴에서 관찰자가 피관찰자에게 어떤 이벤트에 대한 반응으로 콜백 함수를 호출시키는 방식으로도 사용된다. 이 디자인 패턴의 장점은 관찰자와 피관찰자를 1:1관계로 만들어 준다는 것이다. 관찰자는 피관찰자의 목록을 멤버 변수로 두고 관찰자에게 신호를 주면 관찰자는 피관찰자들에게 Broadcast(방송)을 하여 피관찰자들에게 바인딩한 멤버 함수를 호출시킨다. 싱글 델리게이트// 반환 타입이 void이고 인자가 없는 함수를 바인딩DECLARE_DELEGATE( DelegateName ) // void Function()// 반환 타입이 void이고 인자가 n개인 함수를 바인딩\t// // void Function( &lt;Param1&gt;, &lt;Param2&gt;, ... )DECLARE_DELEGATE_&lt;Num&gt;Params( DelegateName, Param1Type, Param2Type, ... ) // 반환타입이 RetVal이고 인자가 없는 함수를 바인딩, 가장 앞에 반환 타입을 기록. // &lt;RetVal&gt; Function()DECLARE_DELEGATE_RetVal( RetValType, DelegateName ) &lt;Num&gt;Params같은 경우, 선언할 때 순서와 사용할 때 순서는 같아야 한다.싱글 델리게이트 함수1.델리게이트 실행 함수 Execute()는 바인딩된 함수를 실행, 바인딩된 함수가 없다면 에러 발생 ExecuteIfBound()는 바인딩이 되어있는지 확인하고 true면 함수를 실행하고, 아니면 아무일도 일어나지 않음 IsBound()는 델리게이트 변수가 바인딩이 되어있는지 확인하는 함수로 바인딩 돼 있으면 true, 아니면 false 반환 2.바인딩 관련 함수BindStatic BindStatic은 전역 함수를 바인딩할 수 있다.void TestGlobalFunc() { UE_LOG(LogTemp,Warning,TEXT(\"BindGlobalFunc\") }// DECLARE_DELEGATE(FTestDelegate); MainCharacter-&gt;TestBindStatic.BindStatic(&amp;TestGlobalFunc);BindUObject BindUObject는 UObject를 상속받는 클래스의 함수를 바인딩할 수 있다. 만약 UObject를 상속받지 않는 (non-UObject)클래스의 함수를 사용하고 싶다면 BindRaw 함수를 사용해야 한다. // DECLARE_DELEGATE(FTestDelegate); // UObjectvoid ATestActor::ClassFunc() { UE_LOG(LogTemp,Warning,TEXT(\"BindClassFunc\") }MainCharacter-&gt;TestBindClassFunc.BindUObject(this,&amp;ATestActor::ClassFunc);// non-UObjectvoid Myclass::MyFunc() { ... }MainCharacter-&gt;TestBindClassFunc.BindRaw(this,&amp;Myclass::MyFunc);BindLambda BindLambda는 람다 함수를 바인딩할 수 있다.// DECLARE_DELEGATE(FTestDelegate); MainCharacter-&gt;TestBindLambda.BindLambda( [] () {UE_LOG(LogTemp,Warning,TEXT(\"BindLambda\"))} );DELEGATE_RetVal Delegate_RetVal은 바인딩한 함수의 반환 타입을 저장해서 사용할 수 있다.FVector Loc = MainCharacter-&gt;GetActorLocation();// DECLARE_DELEGATE_RetVal(FVector, FTestRetVal);MainCharacter-&gt;TestRetVal.BindLambda([Loc]() {return Loc;} ); RetVal 타입의 반환값을 따로 받아 사용할 수 있다.FVector Loc = TestRetVal.Execute();UE_LOG(LogTemp,Warning,TEXT(\"%f %f %f\"), Loc.X,Loc.Y,Loc.Z);DELEGATE_&lt;Num&gt;Param DELEGATE_&lt;Num&gt;Param는 인자 수와 인자 타입이 동일한 함수를 바인딩할 수 있다. Num에 따라 인자 수가 정해지고, 작성하는 타입이 곧 인자의 타입이다 void ATestActor::ClassFuncOneParam(int num) { ... }// DECLARE_DELEGATE_OneParam(FTestOneParam, int)MainCharacter-&gt;TestOneParam.BindUObject(this,&amp;ATestActor::ClassFuncOneParam); Execute 함수를 호출할 때 인자를 전달해서 사용할 수 있다.if(TestOneParam.IsBound()) { TestOneParam.Execute(123456); }결과" }, { "title": "Sync Content Browser To Asset", "url": "/posts/Sync-Content-Browser-To-Asset/", "categories": "unreal, Editor", "tags": "unreal", "date": "2023-09-19 00:00:00 +0900", "snippet": "Sync Content Browser To Asset SListView에서 어떤 에셋을 클릭하면 해당 에셋이 있는 경로로 가려는 방식으로 만들려 한다. 먼저 SListView의 함수 중에서 OnMouseButtonClicked이라는 델리게이트 함수를 추가해서 List에서 Asset을 클릭하면 함수가 호출되게 만들 수 있다. TSharedRef&lt;SListView&lt;TSharedPtr&lt;FAssetData&gt;&gt;&gt; SAdvanceDeletionTab::ConstructAssetListView(){\tConstructedAssetListView = SNew(SListView&lt;TSharedPtr&lt;FAssetData&gt;&gt;)\t.ItemHeight(24.f)\t\t.ListItemsSource(&amp;DisplayedAssetsData)\t.OnGenerateRow(this,&amp;SAdvanceDeletionTab::OnGenerateRowForList)\t.OnMouseButtonClick(this,&amp;SAdvanceDeletionTab::OnRowWidgetMouseButtonClicked); // 이부분 추가\treturn ConstructedAssetListView.ToSharedRef(); } 그 이후에 UEditorAssetLibrary::SyncBrowserToObjects 함수를 이용해서 Content Brower에서 함수의 매개변수로 들어오는 Asset의 경로값으로 이동하게 만들 수 있다.void SAdvanceDeletionTab::OnRowWidgetMouseButtonClicked(TSharedPtr&lt;FAssetData&gt; ClickedData){ FSuperManagerModule&amp; SuperManagerModule = FModuleManager::LoadModuleChecked&lt;FSuperManagerModule&gt;(TEXT(\"SuperManager\"));\tSuperManagerModule.SyncCBToClickedAssetForAssetList(ClickedData-&gt;GetSoftObjectPath().ToString());}// 모듈void FSuperManagerModule::SyncCBToClickedAssetForAssetList(const FString&amp; AssetPathToSync){\tTArray&lt;FString&gt; AssetsPathToSync;\tAssetsPathToSync.Add(AssetPathToSync);\t\tUEditorAssetLibrary::SyncBrowserToObjects(AssetsPathToSync);}" }, { "title": "Listing Assets With Same Name", "url": "/posts/Listing-Assets-With-Same-Name/", "categories": "unreal, Editor", "tags": "unreal", "date": "2023-09-18 00:00:00 +0900", "snippet": "Listing Assets With Same Name 커스텀 에디터를 열면 경로가 다르면서 같은 이름을 가진 에셋이 있을 수 있다. 이러한 에셋들을 처리하기 위해 ComboBox에 추가한다. #define ListSameName TEXT(\"List Assets With Same Name\")void SAdvanceDeletionTab::Construct(const FArguments&amp; InArgs){ ... \tComboBoxSourceItems.Add(MakeShared&lt;FString&gt;(ListSameName)); ...} 그리고 Combo를 선택할 때 호출되는 함수에서 ListSameName 콤보를 선택하면 같은 이름의 에셋들을 목록으로 가져와야 하므로 따로 List에 담는 함수를 호출한다. List에 담을 때 TMultiMap을 사용한다. TMultiMap은 MultiMap과 다르게 다수의 동일한 키 저장을 지원한다. MultiMap에 이미 존재하는 키를 추가하면 기존의 것이 새로운 것으로 대체되지만,TMultiMap은 이미 존재하는 키가 있다고 하더라도 같은 키로 새롭게 추가한다. 아래에서 사용된 MultiFind 함수는 매개변수의 Key값에 맞는 모든 Value를 TArray에 저장하는 함수 void SAdvanceDeletionTab::OnComboSelectionChanged(TSharedPtr&lt;FString&gt; SelectedOption, ESelectInfo::Type InSelectInfo){ FSuperManagerModule&amp; SuperManagerModule = FModuleManager::LoadModuleChecked&lt;FSuperManagerModule&gt;(TEXT(\"SuperManager\")); if(*SelectedOption.Get() == ListALL) { ... } else if(*SelectedOption.Get() == ListUnused) { ... }\telse if(*SelectedOption.Get() == ListSameName)\t{\t\t// List out all assets with same name\t\tSuperManagerModule.ListSameNameAssetsForAssetList(StoredAssetsData,DisplayedAssetsData);\t\tRefreshAssetListView();\t}}void FSuperManagerModule::ListSameNameAssetsForAssetList(const TArray&lt;TSharedPtr&lt;FAssetData&gt;&gt;&amp; AssetsDataToFilter,\tTArray&lt;TSharedPtr&lt;FAssetData&gt;&gt;&amp; OutSameNameAssetsData){\tOutSameNameAssetsData.Empty();\t//Multimap for supporing finding assets with same name\tTMultiMap&lt;FString,TSharedPtr&lt;FAssetData&gt;&gt; AssetsInfoMultiMap;\tfor(const TSharedPtr&lt;FAssetData&gt;&amp; DataSharedPtr : AssetsDataToFilter)\t{ // 선택한 폴더에 있는 모든 에셋을 AssetsInfoMultiMap에 저장\t\tAssetsInfoMultiMap.Emplace(DataSharedPtr-&gt;AssetName.ToString(),DataSharedPtr);\t}\tfor(const TSharedPtr&lt;FAssetData&gt;&amp; DataSharedPtr : AssetsDataToFilter)\t{ // 지역 변수를 생성해서 AssetsInfoMultiMap에 저장했던 에셋들 중 // 같은 이름의 에셋들을 MultiFind로 찾아내고 TArray에 저장한다.\t\tTArray&lt;TSharedPtr&lt;FAssetData&gt;&gt; OutAssetsData;\t\tAssetsInfoMultiMap.MultiFind(DataSharedPtr-&gt;AssetName.ToString(),OutAssetsData);\t\tif(OutAssetsData.Num() &lt;= 1) continue; // 다수의 Key,Value가 아니라면 continue\t\tfor(const TSharedPtr&lt;FAssetData&gt;&amp; SameNameData : OutAssetsData)\t\t{\t\t\tif(SameNameData.IsValid())\t\t\t{ // OutAssetsData에는 하나의 Key에 여러 Value가 존재할텐데 // 여러번 호출되는 Key값에 대해 하나만 들어가도록 AddUnique함수 호출\t\t\t\tOutSameNameAssetsData.AddUnique(SameNameData);\t\t\t}\t\t}\t}}사진 기존 폴더 (/Content/Blueprint) 새 폴더 (/Content/Blueprint/NewFolder) 에 같은 이름(BP_Test) 블루프린트를 추가 Listing Asset With Same Name Combo 열기삭제 위 작업들은 커스텀 에디터에 중복된 이름 에셋들을 모아놓는 작업이고 이제는 Delete 버튼을 누르면 삭제되도록 만들어야 한다.FReply SAdvanceDeletionTab::OnDeleteButtonClicked(TSharedPtr&lt;FAssetData&gt; ClickedAssetData){ // ...\tif(BAssetDeleted)\t{ // ... if(DisplayedAssetsData.Contains(ClickedAssetData)) { DisplayedAssetsData.Remove(ClickedAssetData); } }" }, { "title": "Listing Unused Assets", "url": "/posts/Listing-Unused-Assets/", "categories": "unreal, Editor", "tags": "unreal", "date": "2023-09-16 00:00:00 +0900", "snippet": "Listing Unused Assets 이전 장에 만들었던 SComboBox로 선택하는 Combo에 맞게 필터링을 하는 작업을 하려고 한다. 먼저, 사용하지 않는 에셋들을 필터로 추려내기 위해 저장할 배열을 선언한다. // Slate 클래스 헤더파일에 선언TArray&lt;TSharedPtr&lt;FAssetData&gt;&gt; DisplayedAssetsData; SListView는 이 배열을 사용해야 하므로 ListItemsSource에 DisplayedAssetsData를 전달한다ConstructedAssetListView = SNew(SListView&lt;TSharedPtr&lt;FAssetData&gt;&gt;).ItemHeight(24.f)\t.ListItemsSource(&amp;DisplayedAssetsData).OnGenerateRow(this,&amp;SAdvanceDeletionTab::OnGenerateRowForList); Construct 함수에서는 DisplayedAssetsData에 StoredAssetsData를 그대로 저장하고 ComboBox에 추가할 Combo도 넣어준다.#define ListALL TEXT(\"List All Available Assets\")#define ListUnused TEXT(\"List Unused Assets\")void SAdvanceDeletionTab::Construct(const FArguments&amp; InArgs){\t// ... StoredAssetsData = InArgs._AssetsDataToStore; DisplayedAssetsData = StoredAssetsData;\tComboBoxSourceItems.Add(MakeShared&lt;FString&gt;(ListALL));\tComboBoxSourceItems.Add(MakeShared&lt;FString&gt;(ListUnused));\t// ...} 그리고 Combo를 선택할 때 호출되는 함수인 OnComboSelectedChanged 함수에서 선택되는 Combo(FString)에 따라 작업한다void SAdvanceDeletionTab::OnComboSelectionChanged(TSharedPtr&lt;FString&gt; SelectedOption, ESelectInfo::Type InSelectInfo){\tDebugHeader::Print(*SelectedOption.Get(),FColor::Cyan);\tComboDisplayTextBlock-&gt;SetText(FText::FromString(*SelectedOption.Get()));\tFSuperManagerModule&amp; SuperManagerModule = FModuleManager::LoadModuleChecked&lt;FSuperManagerModule&gt;(TEXT(\"SuperManager\"));\t// Pass data for our module to filter based on the selected option\tif(*SelectedOption.Get() == ListALL)\t{\t\t// List all stored asset data\t\tDisplayedAssetsData = StoredAssetsData;\t\tRefreshAssetListView();\t\t\t}\telse if(*SelectedOption.Get() == ListUnused)\t{\t\t// List all unused assets\t\tSuperManagerModule.ListUnusedAssetsForAssetList(StoredAssetsData,DisplayedAssetsData);\t\tRefreshAssetListView();\t}} AssetList를 필터링하는 함수는 모듈에서 작성할 것이므로 모듈에서 함수를 만든다.void FSuperManagerModule::ListUnusedAssetsForAssetList(const TArray&lt;TSharedPtr&lt;FAssetData&gt;&gt;&amp; AssetsDataToFilter,\tTArray&lt;TSharedPtr&lt;FAssetData&gt;&gt;&amp; OutUnusedAssetsData){ // 초기화\tOutUnusedAssetsData.Empty();\t// 선택된 폴더의 에셋들을 저장하는 배열인 StoredAssetData에서 // 사용하지 않는 에셋을 저장하는 배열인 DisplayedAssetData에게 넘겨준다.\tfor(const TSharedPtr&lt;FAssetData&gt;&amp; DataSharedPtr : AssetsDataToFilter)\t{\t\tTArray&lt;FString&gt; AssetReferencers = \t\tUEditorAssetLibrary::FindPackageReferencersForAsset(DataSharedPtr-&gt;ObjectPath.ToString());\t\tif(AssetReferencers.Num() == 0)\t\t{\t\t\tOutUnusedAssetsData.Add(DataSharedPtr);\t\t}\t}} 그리고 UnusedAsset Combo를 선택하게 되면 그에 맞는 List를 보여주는데 여기서도 Delete 작업을 할 수 있게 해야하므로 Delete버튼을 클릭하면 호출되는 함수에 가서 그에 맞게 작업해야 한다.FReply SAdvanceDeletionTab::OnDeleteAllButtonClicked(){ // ... for(const TSharedPtr&lt;FAssetData&gt;&amp; DeletedData : AssetsDataToDeleteArray) { // Updating the stored assets data if(StoredAssetsData.Contains(DeletedData)) { StoredAssetsData.Remove(DeletedData); } if(DisplayedAssetsData.Contains(DeletedData)) { DisplayedAssetsData.Remove(DeletedData); } } // ...} Delete 작업을 진행했다면, Redirector도 고쳐야 하는데 OnDeleteAllButtonClicked 에서 호출해도 되지만, 메뉴 엔트리에서 버튼을 클릭할 때 호출되도록 이 함수에서 호출한다.void FSuperManagerModule::OnAdvanceDeletionButtonClicked(){\tFixupRedirectors();\t\tFGlobalTabmanager::Get()-&gt;TryInvokeTab(FName(\"AdvanceDeletion\"));}사진 List All Available Assets를 선택했을 때 List Unused Assets를 선택했을 때 BP_Used는 사용되고 있어 리스트에 뜨지 않지만, BP_Test는 사용되고 있지 않아 List에 뜬다. " }, { "title": "SComboBox", "url": "/posts/SComboBox/", "categories": "unreal, Editor", "tags": "unreal", "date": "2023-09-14 00:00:00 +0900", "snippet": "SComboBox SComboBox는 SListView와 마찬가지로 타입이 TSharedPtr 아니면 UObject*이여야만 작동한다. 함수들은 아래 코드 주석에 작성. 헤더파일// ComboBox 생성 함수TSharedRef&lt;SComboBox&lt;TSharedPtr&lt;FString&gt;&gt;&gt; ConstructComboBox();// ComboBox에서 Combo로 사용될 리소스TArray&lt;TSharedPtr&lt;FString&gt;&gt; ComboBoxSourceItems;// SourceItem을 Combo로 추가하는 함수TSharedRef&lt;SWidget&gt; OnGenerateComboContent(TSharedPtr&lt;FString&gt; SourceItem);// 다른 Combo를 선택할 때 호출되는 함수void OnComboSelectionChanged(TSharedPtr&lt;FString&gt; SelectedOption, ESelectInfo::Type InSelectInfo);// 현재 선택되고 있는 Combo를 보여줄 TextBlockTSharedPtr&lt;STextBlock&gt; ComboDisplayTextBlock;소스파일void SAdvanceDeletionTab::Construct(const FArguments&amp; InArgs){\tComboBoxSourceItems.Empty();\tComboBoxSourceItems.Add(MakeShared&lt;FString&gt;(TEXT(\"List All Available Assets\"))); // ... ChildSlot\t[ // ComboBox 추가\t\t+SVerticalBox::Slot()\t\t.AutoHeight()\t\t[\t\t\tSNew(SHorizontalBox)\t\t\t+SHorizontalBox::Slot()\t\t\t.AutoWidth()\t\t\t[\t\t\t\tConstructComboBox()\t\t\t]\t\t] ]}TSharedRef&lt;SComboBox&lt;TSharedPtr&lt;FString&gt;&gt;&gt; SAdvanceDeletionTab::ConstructComboBox(){\tTSharedRef&lt;SComboBox&lt;TSharedPtr&lt;FString&gt;&gt;&gt; ConstructedComboBox\t=SNew(SComboBox&lt;TSharedPtr&lt;FString&gt;&gt;) // ComboBox 생성\t.OptionsSource(&amp;ComboBoxSourceItems) // OnGenerateComboContent 함수에 사용할 인자\t.OnGenerateWidget(this, &amp;SAdvanceDeletionTab::OnGenerateComboContent) // Combo 추가\t.OnSelectionChanged(this,&amp;SAdvanceDeletionTab::OnComboSelectionChanged) // 다른 Combo 선택할 때 함수호출\t[\t\tSAssignNew(ComboDisplayTextBlock,STextBlock) // 현재 Combo를 보여주기 위한 코드\t\t.Text(FText::FromString(TEXT(\"List Assets Option\")))\t];\treturn ConstructedComboBox;}TSharedRef&lt;SWidget&gt; SAdvanceDeletionTab::OnGenerateComboContent(TSharedPtr&lt;FString&gt; SourceItem){\tTSharedRef&lt;STextBlock&gt; ConstructedComboText = SNew(STextBlock).\tText(FText::FromString(*SourceItem.Get()));\treturn ConstructedComboText;}void SAdvanceDeletionTab::OnComboSelectionChanged(TSharedPtr&lt;FString&gt; SelectedOption, ESelectInfo::Type InSelectInfo){\tComboDisplayTextBlock-&gt;SetText(FText::FromString(*SelectedOption.Get()));}사진 좌측 상단에 Combox 생성" }, { "title": "DeleteAll && SelectButton And DeselectButton", "url": "/posts/DeleteAll-&&-SelectButton-And-DeselectButton/", "categories": "unreal, Editor", "tags": "unreal", "date": "2023-09-14 00:00:00 +0900", "snippet": "Create button Construct 함수에서 만들어서 ChildSlot에 추가한다.void SAdvanceDeletionTab::Construct(const FArguments&amp; InArgs){ // ...\tChildSlot\t[\t\t+SVerticalBox::Slot()\t\t.AutoHeight()\t\t[\t\t\tSNew(SHorizontalBox) // DeleteAllbutton 추가\t\t\t+SHorizontalBox::Slot()\t\t\t.FillWidth(10.f)\t\t\t.Padding(5.f)\t\t\t[\t\t\t\tConstructDeleteAllButton()\t\t\t] // SelectAllButton 추가\t\t\t+SHorizontalBox::Slot()\t\t\t.FillWidth(10.f)\t\t\t.Padding(5.f)\t\t\t[\t\t\t\tConstructSelectAllButton()\t\t\t] // DeselectAllButton 추가\t\t\t+SHorizontalBox::Slot()\t\t\t.FillWidth(10.f)\t\t\t.Padding(5.f)\t\t\t[\t\t\t\tConstructDeselectAllButton()\t\t\t]\t\t]\t];}// 나머지 버튼도 다음과 같이 작성, OnClicked에 바인딩된 함수와 TEXT만 다르다.TSharedRef&lt;SButton&gt; SAdvanceDeletionTab::ConstructDeleteAllButton(){\tTSharedRef&lt;SButton&gt; DeleteButton = SNew(SButton)\t.ContentPadding(FMargin(5.f))\t.OnClicked(this,&amp;SAdvanceDeletionTab::OnDeleteAllButtonClicked); // SetContent는 TSharedRef&lt;SWidget&gt;을 받아 자식 슬롯으로 넣는 함수\tDeleteButton-&gt;SetContent(ConstructTextForTabButtons(TEXT(\"Delete All\")));\treturn DeleteButton;}TSharedRef&lt;STextBlock&gt; SAdvanceDeletionTab::ConstructTextForTabButtons(const FString&amp; TextContent){\tFSlateFontInfo ButtonTextFont = GetEmbossedTextFont();\tButtonTextFont.Size = 15;\t\tTSharedRef&lt;STextBlock&gt; ConstructedTextBlock = SNew(STextBlock)\t.Text(FText::FromString(TextContent))\t.Font(ButtonTextFont)\t.Justification(ETextJustify::Center);\treturn ConstructedTextBlock;} 하단에 3개의 버튼 생성DeleteAllButtonClicked 에셋들을 따로 선택하기 위해 체크박스 함수에서 선택된 에셋들을 배열에 따로 저장한다.void SAdvanceDeletionTab::OnCheckBoxStateChanged(ECheckBoxState NewState, TSharedPtr&lt;FAssetData&gt; AssetData){\tswitch (NewState)\t{\tcase ECheckBoxState::Unchecked:\t\tif(AssetsDataToDeleteArray.Contains(AssetData))\t\t{\t\t\tAssetsDataToDeleteArray.Remove(AssetData);\t\t}\t\tbreak;\tcase ECheckBoxState::Checked:\t\tAssetsDataToDeleteArray.AddUnique(AssetData);\t\tbreak;\t}} Delete All 버튼에 바인딩된 함수 CheckBox 함수에서 선택된 에셋들을 AssetsDataToDeleteArray 변수에 저장했는데 이 변수를 모듈에게 보내서 삭제 함수를 호출한다. FReply SAdvanceDeletionTab::OnDeleteAllButtonClicked(){ // 따로 지역변수로 저장\tTArray&lt;FAssetData&gt; AssetDataToDelete;\tfor(const TSharedPtr&lt;FAssetData&gt;&amp; Data : AssetsDataToDeleteArray)\t{\t\tAssetDataToDelete.Add(*Data.Get());\t}\tFSuperManagerModule&amp; SuperManagerModule = FModuleManager::LoadModuleChecked&lt;FSuperManagerModule&gt;(TEXT(\"SuperManager\")); // 모듈에게 데이터를 전송하고 모듈에서 삭제 함수 호출\tconst bool bAssetsDeleted = SuperManagerModule.DeleteMultipleAssetsForAssetList(AssetDataToDelete);\tif(bAssetsDeleted)\t{\t\tfor(const TSharedPtr&lt;FAssetData&gt;&amp; DeletedData : AssetsDataToDeleteArray)\t\t{ // 이전에 저장했던 에셋 배열에서 삭제한 에셋을 삭제\t\t\tif(StoredAssetsData.Contains(DeletedData))\t\t\t{\t\t\t\tStoredAssetsData.Remove(DeletedData);\t\t\t}\t\t}\t\tRefreshAssetListView();\t}\t\treturn FReply::Handled();} 모듈 삭제함수bool FSuperManagerModule::DeleteMultipleAssetsForAssetList(const TArray&lt;FAssetData&gt;&amp; AssetsToDelete){\tif(ObjectTools::DeleteAssets(AssetsToDelete) &gt; 0)\t{\t\treturn true;\t}\treturn false;} 선택된 에셋들에 대해서 ObjectTools::DeleteAssets가 호출됨Select All Button And Deselect Button 모든 체크박스에 대해 check 상태로 만들어야 하기 때문에 CheckBox들을 저장한 배열을 만들어서 저장한다.// TArray&lt;TSharedRef&lt;SCheckBox&gt;&gt; CheckBoxesArray;TSharedRef&lt;SCheckBox&gt; SAdvanceDeletionTab::ConstructCheckBox(const TSharedPtr&lt;FAssetData&gt;&amp; AssetDataToDisplay){ TSharedRef&lt;SCheckBox&gt; ConstructedCheckBox = // ... (SCheckBox 생성) // 생성한 체크박스들을 저장\tCheckBoxesArray.Add(ConstructedCheckBox);\treturn ConstructedCheckBox;} 그런 다음, CheckBox 배열을 반복문으로 순회해서 Check이나 Uncheck로 만든다. DeselectButtonClicked 함수는 아래 함수에서 !CheckBox-&gt;IsChecked() 에서 CheckBox-&gt;IsChecked()로 변경하면 된다. FReply SAdvanceDeletionTab::OnSelectAllButtonClicked(){\tif(CheckBoxesArray.Num() == 0) return FReply::Handled();\tfor(const TSharedRef&lt;SCheckBox&gt;&amp; CheckBox : CheckBoxesArray)\t{\t\tif(!CheckBox-&gt;IsChecked())\t\t{\t\t\t// 체크박스의 상태를 반대로 만드는 함수\t\t\tCheckBox-&gt;ToggleCheckedState();\t\t\t\t\t\t}\t}\t\treturn FReply::Handled();}Refresh DeleteAll 에서 체크된 에셋데이터 배열인 AssetsDataToDeleteArray 이나 Select &amp;&amp; Deselect 에서 모든 체크박스의 배열인 CheckBoxesArray 변수들도 Refresh할 때 같이 Empty()를 호출해서 초기화해야 한다.void SAdvanceDeletionTab::RefreshAssetListView(){\tCheckBoxesArray.Empty();\tAssetsDataToDeleteArray.Empty();\t\tif(ConstructedAssetListView.IsValid())\t{\t\tConstructedAssetListView-&gt;RebuildList();\t}}" }, { "title": "Delete Single && Refresh SListView", "url": "/posts/Delete-Single-&&-Refresh-SListView/", "categories": "unreal, Editor", "tags": "unreal", "date": "2023-09-13 00:00:00 +0900", "snippet": "Delete Single Asset 이전 장에서 만들었던 SButton으로 해당 에셋을 ObjectTools::DeleteAssets() 함// 모듈bool FSuperManagerModule::DeleteSingleAssetForAssetList(const FAssetData&amp; AssetDataToDelete){\tTArray&lt;FAssetData&gt; AssetDataForDeletion;\tAssetDataForDeletion.Add(AssetDataToDelete);\t\tif(ObjectTools::DeleteAssets(AssetDataForDeletion) &gt; 0)\t{\t\treturn true;\t}\treturn false;}// 슬레이트FReply SAdvanceDeletionTab::OnDeleteButtonClicked(TSharedPtr&lt;FAssetData&gt; ClickedAssetData){\t// 모듈 불러오기\tFSuperManagerModule&amp; SuperManagerModule = \tFModuleManager::LoadModuleChecked&lt;FSuperManagerModule&gt;(TEXT(\"SuperManager\"));\t// 모듈에게 에셋 삭제 요청 // 여기서 ObjectTools::DeleteAssets()를 쓸 수 있지만 관리적인 측면에서 모듈에서 실행하도록 만듦\tconst bool BAssetDeleted = SuperManagerModule.DeleteSingleAssetForAssetList(*ClickedAssetData.Get());\tif(BAssetDeleted)\t{\t\t// Updating the list source items\t\tif(StoredAssetsData.Contains(ClickedAssetData))\t\t{\t\t\tStoredAssetsData.Remove(ClickedAssetData);\t\t}\t\t// Refresh the list\t\tRefreshAssetListView();\t}\t \treturn FReply::Handled();\t}Refresh 커스텀 에디터에서 삭제버튼을 눌러 해당 에셋을 삭제한다고 해도 커스텀 에디터에서는 Refresh하지 않아 그대로인 상태로 있기 때문에 SListView를 Refresh를 해줘야 한다 이 때 사용하는 함수가 SListView의 RebuildList()이다. // Refresh 함수void SAdvanceDeletionTab::RefreshAssetListView(){\tif(ConstructedAssetListView.IsValid())\t{\t\tConstructedAssetListView-&gt;RebuildList();\t}}사진 삭제 버튼 누르면 ObjectTools::DeleteAssets 함수 호출이 됨 지우고 나서 Refresh되어서 삭제된 에셋이 리스트에 없음" }, { "title": "SButton", "url": "/posts/SButton/", "categories": "unreal, Editor", "tags": "unreal", "date": "2023-09-11 00:00:00 +0900", "snippet": " Slate에서 Button을 만드려면 SButton으로 만들어야 한다. SButton에서는 OnClicked라는 델리게이트를 사용해서 버튼을 클릭했을 때 호출되는 함수를 지정할 수 있다. // SButton.h/** Called when the button is clicked */SLATE_EVENT( FOnClicked, OnClicked ) 버튼 관련 함수TSharedRef&lt;SButton&gt; SAdvanceDeletionTab::ConstructButtonForRowWidget(const TSharedPtr&lt;FAssetData&gt;&amp; AssetDataToDisplay){\tTSharedRef&lt;SButton&gt; ConstructedButton = SNew(SButton)\t.Text(FText::FromString(TEXT(\"Delete\")))\t.OnClicked(this,&amp;SAdvanceDeletionTab::OnDeleteButtonClicked, AssetDataToDisplay);\treturn ConstructedButton;}FReply SAdvanceDeletionTab::OnDeleteButtonClicked(TSharedPtr&lt;FAssetData&gt; ClickedAssetData){\tDebugHeader::Print(ClickedAssetData-&gt;AssetName.ToString() + TEXT(\" is clicked\"), FColor::Green);\treturn FReply::Handled();\t} Delete 버튼이 생기고 눌렀을 때 AssetName + is clicked 문구가 뜸 체크박스 - 에셋 클래스 이름 - 에셋 이름 - 버튼 " }, { "title": "getline EOF", "url": "/posts/getline-EOF/", "categories": "코딩테스트", "tags": "coding test", "date": "2023-09-10 00:00:00 +0900", "snippet": " 문제에는 보통 어느 정도 입력을 받을지에 대한 변수가 존재하지만, 없을 때도 있다. 그래서 다음과 같이 EOF(End Of File)이 들어오기 전까지 계속 입력받을 수 있는 형태가 있다. while(getline(cin, str)) { string tmp; cin &gt;&gt; tmp; // ... } 기본적으로 EOF가 들어오기 전까지는 계속 입력을 받지만, 윈도우에서는 Ctrl+Z를 눌러 EOF를 전달하여 while문이 종료된다." }, { "title": "SCheckBox", "url": "/posts/SCheckBox/", "categories": "unreal, Editor", "tags": "unreal", "date": "2023-09-10 00:00:00 +0900", "snippet": "SCheckBox Slate 위젯에 CheckBox를 사용할 수 있는데 OnCheckStateChanged() 이벤트를 사용한다. 이벤트는 델리게이트와 같은 기능을 하지만, 델리게이트와 달리 이벤트는 전역으로 선언할 수 없어 외부말고 클래스 내부에 선언해야 하는 키워드. // SCheckBox.h/** Called when the checked state has changed */SLATE_EVENT( FOnCheckStateChanged, OnCheckStateChanged ) 아래는 체크박스 관련 함수들TSharedRef&lt;SCheckBox&gt; SAdvanceDeletionTab::ConstructCheckBox(const TSharedPtr&lt;FAssetData&gt;&amp; AssetDataToDisplay){\tTSharedRef&lt;SCheckBox&gt; ConstructedCheckBox =\tSNew(SCheckBox) // 체크박스 생성\t.Type(ESlateCheckBoxType::CheckBox) // 체크박스 타입\t.OnCheckStateChanged(this,&amp;SAdvanceDeletionTab::OnCheckBoxStateChanged,AssetDataToDisplay) \t\t// 체크할 때 델리게이트\t.Visibility(EVisibility::Visible); // 가시성\treturn ConstructedCheckBox;}// 체크박스 상태가 변할 때 호출되는 함수void SAdvanceDeletionTab::OnCheckBoxStateChanged(ECheckBoxState NewState, TSharedPtr&lt;FAssetData&gt; AssetData){\tswitch (NewState)\t{\t\tcase ECheckBoxState::Unchecked: // 체크 해제\t\t\tDebugHeader::Print(AssetData-&gt;AssetName.ToString() + TEXT(\"is unchecked\"), FColor::Red);\t\t\tbreak;\t\tcase ECheckBoxState::Checked: // 체크\t\t\tDebugHeader::Print(AssetData-&gt;AssetName.ToString() + TEXT(\"is checked\"), FColor::Green);\t\t\tbreak;\t}} ECheckBoxState로 체크 박스에 대한 상태를 확인 후, switch에서 값에 맞게 처리사진 체크 체크 후 해제" }, { "title": "Setup Title", "url": "/posts/Setup-Title/", "categories": "unreal, Editor", "tags": "unreal", "date": "2023-09-09 00:00:00 +0900", "snippet": "Title Text Slate Widget을 처음 만들면 기본적으로 슬롯이 하나밖에 없어 하나의 텍스트(위젯 클래스)밖에 넣지 못한다. 위젯 블루프린트 에디터에서 계층구조에서 루트에 있는 노드에게 텍스트 블럭을 두 개 이상 넣지 못하는 것과 동일 그래서 다음과 같이 슬롯을을 추가해서 다른 위젯을 추가할 수 있다. void SAdvanceDeletionTab::Construct(const FArguments&amp; InArgs){\tbCanSupportFocus = true; // FontStyle\tFSlateFontInfo TitleTextFont = FCoreStyle::Get().GetFontStyle(FName(\"EmbossedText\"));\tTitleTextFont.Size = 30; // 크기\t\t\t// 기존에는 한 슬롯밖에 없어 하나의 텍스트블럭만 넣을 수 있기 때문에 // 다른 위젯인 VerticalBox를 통해 여러 개의 슬롯으로 여러 개의 Text Block을 넣을 수 있다.\tChildSlot\t[\t\t// 메인 Vertical Box\t\tSNew(SVerticalBox)\t\t// 제목 텍스트를 위한 첫 번째 Vertical Box 추가\t\t+SVerticalBox::Slot()\t\t.AutoHeight()\t\t[ // SNew의 함수들은 참조로 반환하기 때문에 도트 연산자로 함수를 계속 호출이 가능\t\t\tSNew(STextBlock)\t\t\t.Text(FText::FromString(TEXT(\"Advance Deletion\")))\t\t\t.Font(TitleTextFont)\t\t\t.Justification(ETextJustify::Center)\t\t\t.ColorAndOpacity(FColor::White)\t\t]\t];} Text 함수는 Text값을 의미 Font는 위에서 선언한 FontStyle을 의미 Jusstification은 위치를 의미 (Left,Center,Right) ColorAndOpacity는 색깔을 의미 사진 Advance Deletion 이 중앙에 생긴 모습" }, { "title": "SListView", "url": "/posts/SListView/", "categories": "unreal, Editor", "tags": "unreal", "date": "2023-09-09 00:00:00 +0900", "snippet": "SListView Slate에서 List를 만들기 위해 사용하는 것이 SListView이다. SListView는 아이템 데이터 배열을 찾고 이 아이템들에 대해 시각적으로 표현한다. SListView는 타입이 TSharedPtr 아니면 UObject*이여야만 작동한다. 그래서 SListView에 사용할 TSharedPtr 배열과 필요한 델리게이트 함수를 생성한다 class SAdvanceDeletionTab : public SCompoundWidget{\tSLATE_BEGIN_ARGS(SAdvanceDeletionTab) {} // TArray&lt;TSharedPtr &lt;FAssetData&gt; &gt; 타입을 받기 위한 선언\tSLATE_ARGUMENT(TArray&lt;TSharedPtr &lt;FAssetData&gt; &gt; ,AssetsDataToStore)\t\tSLATE_END_ARGS() ... private:\tTArray&lt;TSharedPtr&lt;FAssetData&gt;&gt; StoredAssetsData; // SListView에 필요한 함수 TSharedRef&lt;ITableRow&gt; OnGenerateRowForList(TSharedPtr&lt;FAssetData&gt; AssetDataToDisplay,\tconst TSharedRef&lt;STableViewBase&gt;&amp; OnwerTable);};에셋 데이터 배열 받아오는 함수 그러고 나서 모듈 파일에서 에셋 데이터 배열을 받아오는 함수를 작성해서 받아온다. 이 함수의 반환값을 SLATE_ARGUMENT로 보내서 Slate 클래스에서 사용함 TSharedRef&lt;SDockTab&gt; FSuperManagerModule::OnSpawnAdvanceDeletionTab(const FSpawnTabArgs&amp; SpawnTabArgs){\treturn SNew(SDockTab).TabRole(ETabRole::NomadTab)\t[ // SAdvanceDeletionTab 클래스에 전달 \tSNew(SAdvanceDeletionTab)\t\t.AssetsDataToStore(GetAllAssetDataUnderSelectedFolder())\t];}TArray&lt;TSharedPtr&lt;FAssetData&gt;&gt; FSuperManagerModule::GetAllAssetDataUnderSelectedFolder(){\tTArray&lt;TSharedPtr&lt;FAssetData&gt;&gt; AvailableAssetsData;\tTArray&lt;FString&gt; AssetsPathNames = UEditorAssetLibrary::ListAssets(FolderPathSelected[0]); for(const FString&amp; AssetPathName : AssetsPathNames) { // 지우면 안되는 최상위 폴더는 삭제 X if(AssetPathName.Contains(TEXT(\"Developers\")) || AssetPathName.Contains(TEXT(\"Collections\")) || AssetPathName.Contains(TEXT(\"__ExternalActors__\")) || AssetPathName.Contains(TEXT(\"__ExternalObjects__\"))) { continue; } if(!UEditorAssetLibrary::DoesAssetExist(AssetPathName)) continue; const FAssetData Data = UEditorAssetLibrary::FindAssetData(AssetPathName); AvailableAssetsData.Add(MakeShared&lt;FAssetData&gt;(Data)); }\treturn AvailableAssetsData;}에셋 데이터를 목록(행)으로 등록 그다음 받아온 에셋 데이터를 Slate 클래스의 Construct 함수에서 Slot으로 추가한다. FKey와 관련된 Input Event에 대해 컴파일 오류가 난다면 build.cs파일에서 InputCore를 넣어주면 된다 행으로 추가할 때는 OnGenerateRow 함수를 사용하면 된다. void SAdvanceDeletionTab::Construct(const FArguments&amp; InArgs){\tbCanSupportFocus = true;\t // SLATE_ARGUMENT으로 받아온 에셋 데이터 배열\tStoredAssetsData = InArgs._AssetsDataToStore;\t +SVerticalBox::Slot() .VAlign(VAlign_Fill) [ SNew(SScrollBox) +SScrollBox::Slot() [ ConstructAssetListView(); // ListView 생성하는 함수 ] ]}TSharedRef&lt;SListView&lt;TSharedPtr&lt;FAssetData&gt;&gt;&gt; SAdvanceDeletionTab::ConstructAssetListView(){ // TSharedPtr&lt;SListView&lt;TSharedPtr&lt;FAssetData&gt;&gt;&gt; ConstructedAssetListView\tConstructedAssetListView = SNew(SListView&lt;TSharedPtr&lt;FAssetData&gt;&gt;)\t.ItemHeight(24.f)\t // 세로 길이\t.ListItemsSource(&amp;StoredAssetsData) // 에셋 데이터 배열\t.OnGenerateRow(this,&amp;SAdvanceDeletionTab::OnGenerateRowForList); // 델리게이트\t// ToSharedRef는 TSharedPtr함수를 TSharedRef로 변환하는 함수\treturn ConstructedAssetListView.ToSharedRef(); }// 각 행에 대해 무언가 추가할 때 사용TSharedRef&lt;ITableRow&gt; SAdvanceDeletionTab::OnGenerateRowForList( TSharedPtr&lt;FAssetData&gt; AssetDataToDisplay, const TSharedRef&lt;STableViewBase&gt;&amp; OwnerTable){\tconst FString DisplayAssetName = AssetDataToDisplay-&gt;AssetName.ToString();\tTSharedRef&lt;STableRow&lt;TSharedPtr&lt;FAssetData&gt;&gt;&gt; ListViewRowWidget =\tSNew(STableRow&lt;TSharedPtr&lt;FAssetData&gt;&gt;, OwnerTable)\t[\t\tSNew(STextBlock)\t\t.Text(FText::FromString(DisplayAssetName))\t];\t\treturn ListViewRowWidget;}사진 Content를 우클릭하고 에디터를 열면 다음과 같이 뜬다." }, { "title": "Sending Data To Slate Widget", "url": "/posts/Sending-Data-To-Slate-Widget/", "categories": "unreal, Editor", "tags": "unreal", "date": "2023-09-08 00:00:00 +0900", "snippet": " Slate Widget에게 데이터를 보내기 위해서는 SLATE_ARGUMENT라는 매크로를 사용해야 한다. SLATE_BEGIN_ARGS와 SLATE_END_ARGS사이에 넣어야 함 SLATE_ARGUMENT( ArgType, ArgName ) 그러면 위젯이 생성될 때, ArgType타입에 대한 ArgName이 같이 생성된다.#pragma once#include \"Widgets/SCompoundWidget.h\"class SAdvanceDeletionTab : public SCompoundWidget{\tSLATE_BEGIN_ARGS(SAdvanceDeletionTab) {}\tSLATE_ARGUMENT(FString,TestString) // FString 인자를 가진 TestString 선언\t\tSLATE_END_ARGS()public:\tvoid Construct(const FArguments&amp; InArgs);\t}; 다음과 같이 만들면 다른 클래스에서 이 위젯 클래스에게 데이터를 보낼 때 사용할 수 있다.TSharedRef&lt;SDockTab&gt; FSuperManagerModule::OnSpawnAdvanceDeletionTab(const FSpawnTabArgs&amp; SpawnTabArgs){\treturn SNew(SDockTab).TabRole(ETabRole::NomadTab)\t[\t\tSNew(SAdvanceDeletionTab) \t// 괄호 안의 클래스 이름의 Slate 생성\t\t.TestString(TEXT(\"I am passing data\")) // SLATE_ARGUMENT으로 선언된 TestString에 값 전달\t];} SNew 키워드는 Slate 관련 클래스를 만들 때 사용한다. ex) SButton, SCheckBox … 여기서 대괄호 [] 는 하나의 슬롯을 의미한다. 받은 값 사용 Slate Widget 클래스 생성자의 매개변수 const FArguments&amp; InArgs에는 SLATE_ARGUMENT 매크로에서 사용했던 이름(TestString)과 _가 합쳐 _이름의 형태로 저장돼 있다.void SAdvanceDeletionTab::Construct(const FArguments&amp; InArgs){\tbCanSupportFocus = true; // ChildSlot은 Slate Widget의 기본 슬롯\tChildSlot\t[\t\t// SLATE_ARGUMENT에서 ArgName이 TestString이여서 _TestString으로 받아올 수 있음\t\tSNew(STextBlock)\t\t.Text(FText::FromString(InArgs._TestString))\t];}사진 i am passing data가 적힌 모습" }, { "title": "Spawn A Custom Editor Tab", "url": "/posts/Spawn-A-Custom-Editor-Tab/", "categories": "unreal, Editor", "tags": "unreal", "date": "2023-09-07 00:00:00 +0900", "snippet": "메뉴 생성 커스텀 에디터를 생성하려면 다음과 같이 SDockTab이라는 클래스를 생성해서 등록해야 한다.// hvoid RegisterAdvanceDeletionTab();TSharedRef&lt;SDockTab&gt; OnSpawnAdvanceDeletionTab(const FSpawnTabArgs&amp;);// cppvoid FSuperManagerModule::StartupModule(){\tInitCBMenuExtention();\tRegisterAdvanceDeletionTab(); // 등록}void FSuperManagerModule::RegisterAdvanceDeletionTab(){ // 등록하는 함수\tFGlobalTabmanager::Get()-&gt;RegisterNomadTabSpawner(FName(\"AdvanceDeletion\"),\t\tFOnSpawnTab::CreateRaw(this, &amp;OnSpawnAdvanceDeletionTab))\t.SetDisplayName(FText::FromString(TEXT(\"Advance Deletion\"))); // SetDisplayName은 이름 설정} FOnSpawnTab를 F12 눌러보면 TabManager.h 파일이 열리고 아래에 있는 델리게이트가 선언되어 있는데 이 델리게이트를 이용해서 생성해야 한다.// TabManager.hDECLARE_DELEGATE_RetVal_OneParam( TSharedRef&lt;SDockTab&gt;, FOnSpawnTab, const FSpawnTabArgs&amp; ); 위 델리게이트를 이용해서 아래 함수 선언TSharedRef&lt;SDockTab&gt; FSuperManagerModule::OnSpawnAdvanceDeletionTab(const FSpawnTabArgs&amp;){\treturn SNew(SDockTab).TabRole(ETabRole::NomadTab);}델리게이트 그리고 나서 커스텀 에디터 탭을 열기 위한 메뉴 엔트리를 하나 추가하고 TryInvokeTab 함수에서 RegisterNomadTabSpawner 함수에서 등록한 이름 FName(\"AdvanceDeletion\")을 이용하여 해당 에디터를 열 수 있다.// 메뉴 엔트리 추가void FSuperManagerModule::AddCBMenuEntry(FMenuBuilder&amp; MenuBuilder){ ... MenuBuilder.AddMenuEntry\t(\tFText::FromString(TEXT(\"Advance Deletion\")),\tFText::FromString(TEXT(\"List assets by specific condition in a tab for deleting\")),\tFSlateIcon(),\t\tFExecuteAction::CreateRaw(this,&amp;FSuperManagerModule::OnAdvanceDeletionButtonClicked)\t);}void FSuperManagerModule::OnAdvanceDeletionButtonClicked(){\t//RegisterNomadTabSpawner 함수에서 인자 FName으로 등록한 에디터를 연다\tFGlobalTabmanager::Get()-&gt;TryInvokeTab(FName(\"AdvanceDeletion\"));}사진 생성한 에디터 탭" }, { "title": "Slate", "url": "/posts/Slate/", "categories": "unreal, Editor", "tags": "unreal", "date": "2023-09-07 00:00:00 +0900", "snippet": "Slate 언리얼 엔진의 인터페이스로, 현재 언리얼에 들어가면 에디터에 있는 대부분의 것들이 Slate로 이뤄져 있다. ex) 에디터에서 클릭할 수 있는 대부분의 것들 Slate는 배우는데 어려운 이유가 있는데 3가지가 있다. 첫 번째로, 고유 구문(Unique Syntax)이 있다. // 예시// Spacer slot+SHorizontalBox::Slot().AuthWidth()[ SNew(SSpacer) .Size(FVector2D(200.f,0.f));]// Help text slot+SHorizontalBox::Slot().AutoWidth()[ | SNew(SHorizontalBox) +SHorizontalBox::Slot() .HAlign(HAlign_Fill) [ SNew(STextBlock) .Text(FText::FromString(TEXT(\"Special\"))) .AutoWrapText(true) .Justification(ETextJustify::Left) ]] 두 번째로는, 시각화하기 힘들다. 일일이 텍스트간 간격이나 테두리등을 코드로 배치해야 한다. 마지막으로는, 다른 모듈과 통신(communication)한다. 서로 다른 모듈을 통해 데이터를 파싱하기 때문에 신경써야할 부분이 많아진다. Slate Widget 클래스 생성 Slate Widget을 사용하기 위해 C++ 클래스에서 부모를 None으로 한 후 클래스 생성하고 모두 지운 다음 다음과 같이 설정한다.// AdvanceDeletionWidget.h#pragma once#include \"Widgets/SCompoundWidget.h\"class SAdvanceDeletionTab : public SCompoundWidget{ // SLATE_BEGIN_ARGS : 슬레이트(Slate) 위젯을 생성할 때 사용되는 매크로, 인자로는 클래스 이름 // 인디렉션(indirection, 포인터를 통한 변수 접근) 레이어를 추가하지 않고도 UI 제작을 가능하게 해준다. SLATE_BEGIN_ARGS(SAdvanceDeletionTab) {} // 여기에 SLATE_ARUGMENT 같은 SLATE 매크로를 사용 SLATE_END_ARGS() public: void Construct(const FArguments&amp; InArgs);};// AdvanceDeletionWidget.cpp#include \"SlateWidgets/AdvanceDeletionWidget.h\"void SAdvanceDeletionTab::Construct(const FArguments&amp; InArgs){\tbCanSupportFocus = true;}" }, { "title": "스마트 포인터", "url": "/posts/%EC%8A%A4%EB%A7%88%ED%8A%B8-%ED%8F%AC%EC%9D%B8%ED%84%B0/", "categories": "unreal, Basic", "tags": "unreal", "date": "2023-09-07 00:00:00 +0900", "snippet": "스마트 포인터 표준 C++에서는 new 키워드를 사용하면 힙에 메모리를 생성하고 포인터로 그 메모리를 받아와서 사용하고 delete 키워드로 지워줘야 메모리 누수가 발생하지 않는다. 스마트 포인터를 사용하면 위 과정을 자동으로 해주고 보통 shared_ptr 이나 unique_ptr을 사용하지만 언리얼에서는 다음과 같이 4 종류의 스마트 포인터를 지원한다. TSharedPtr TSharedRef TWeakPtr TUniquePtr TSharedPtr TSharedPtr 변수가 오브젝트의 포인터를 소유(own) Reference Counting을 통해 참조가 0이 되어야 삭제하고 그 이전에는 삭제하지 못하게 방지(prevent) TSharedPtr 변수는 Null이 될 수 있음 TSharedRef TSharedRef 변수가 오브젝트를 참조(own) TSharedRef 변수가 오브젝트가 삭제되는 것을 방지(prevent) 초기화할 때 유효한 오브젝트만 가능 그렇기 때문에 Slate를 다룰 때 반환값이 반드시 보장되어서 많이 사용함 TSharedPtr과 TSharedRef는 유사해서 TSharedPtr는 TSharedRef로 변환해서 사용해도 가능 TWeakPtr 참조하는 오브젝트를 소유(own)하지도 않고 오브젝트를 삭제로부터 방지(prevent)하지도 않음 TWeaPtr는 참조하는 오브젝트를 소유하지 않아 생명 주기와 관계없을 때 유용하다. 오브젝트를 사용하기 전에 오브젝트를 참조하고 있던 TWeakPtr로 살아있는지(삭제되었는지) 확인하기 좋다 개발할 때 스마트 포인터를 잘 보지 못한 이유 스마트 포인터는 UObject System에서 사용할 수 없기 때문 만약 Character 클래스를 TSharedPtr로 사용하려 한다면 컴파일 에러가 나거나 에디터가 충돌하여 종료된다. 이유는 UObject는 UObject만의 메모리 관리 시스템인 Garbage Collection을 사용하고 있기 때문이다. UPROPERTY() 을 사용해야 Garbage Colletion에서 관리 UPROPERTY()를 사용하지 못하는 경우에 스마트 포인터를 사용하는 것이 좋다. MakeShareable() , MakeShared() 스마트 포인터를 생성하는 방법에는 여러가지가 있다.// Raw PointerTSharedRef&lt;FExtender&gt; MenuExtender (new FExtender());// MakeShareableTSharedRef&lt;FExtender&gt; MenuExtender = MakeShareable(new FExtender());// MakeSharedconst FAssetData data = ...TShared&lt;FAssetData&gt; AssetDataSharedPtr = MakeShared&lt;FAssetData&gt;(Data); MakeShared는 새 오브젝트 인스턴스와 레퍼런스 컨트롤러를 한 메모리 블록에 할당하지만, 오브젝트가 public 생성자를 제공해야 한다 MakeShareable은 덜 효율적이지만 오브젝트의 생성자가 private이더라도 접근 가능하여 직접 생성하지 않은 오브젝트에 대한 소유권을 가질 수 있고, 오브젝트를 소멸시킬 경우에는 커스텀이 가능하다 " }, { "title": "Delete Empty Folders", "url": "/posts/Delete-Empty-Folders/", "categories": "unreal, Editor", "tags": "unreal", "date": "2023-09-06 00:00:00 +0900", "snippet": " Custom Menu Entry 장에서 사용했던 AddCBMenuEntry함수에 다른 Menu Entry를 넣어서 비어있는 폴더를 지울 버튼을 추가한다.// .hvoid OnDeleteEmptyFoldersButtonClicked(); // 비어있는 폴더를 삭제할 함수 추가// cppvoid FSuperManagerModule::AddCBMenuEntry(FMenuBuilder&amp; MenuBuilder){\t...\tMenuBuilder.AddMenuEntry\t(\tFText::FromString(TEXT(\"Delete Empty Folders\")),\tFText::FromString(TEXT(\"Safely delete all empty folders\")),\tFSlateIcon(),\t\tFExecuteAction::CreateRaw( this, &amp;SuperManagerModule::OnDeleteEmptyFoldersButtonClicked)\t);}언리얼에서 지원하는 함수 아래 함수들을 이용해서 폴더를 지우는 함수를 작성한다// EditorAssetLibrary.h// 해당 경로에 있는 에셋 목록을 가져오는 함수UFUNCTION(BlueprintCallable, Category = \"Editor Scripting | Asset\")static TArray&lt;FString&gt; ListAssets(const FString&amp; DirectoryPath, bool bRecursive = true, bool bIncludeFolder = false);// 컨텐츠 브라우저에 해당 경로가 존재하는지 확인하는 함수UFUNCTION(BlueprintCallable, Category = \"Editor Scripting | Asset\")static bool DoesDirectoryExist(const FString&amp; DirectoryPath);// 해당 경로에 에셋이 존재하는지 확인하는 함수UFUNCTION(BlueprintCallable, Category = \"Editor Scripting | Asset\")static bool DoesDirectoryHaveAssets(const FString&amp; DirectoryPath, bool bRecursive = true);폴더를 지우는 함수void FSuperManagerModule::OnDeleteEmptyFoldersButtonClicked(){\tFixupRedirectors();\t // 세 번째 매개변수가 true여야 folder도 포함한다.\tTArray&lt;FString&gt; FolderPathsArray = UEditorAssetLibrary::ListAssets(FolderPathSelected[0], true, true);\tuint32 Counter = 0;\tFString EmptyFolderPathsNames;\tTArray&lt;FString&gt; EmptyFoldersPathsArray;\tfor(const FString&amp; FolderPath : FolderPathsArray)\t{\t\tif(FolderPath.Contains(TEXT(\"Developers\")) ||\t\t\tFolderPath.Contains(TEXT(\"Collections\")) ||\t\t\tFolderPath.Contains(TEXT(\"__ExternalActors__\")) ||\t\t\tFolderPath.Contains(TEXT(\"__ExternalObjects__\")))\t\t{\t\t\tcontinue;\t\t}\t\tif(!UEditorAssetLibrary::DoesDirectoryExist(FolderPath)) continue;\t\tif(UEditorAssetLibrary::DoesDirectoryHaveAssets(FolderPath))\t\t{ // 메세지에 사용할 FString\t\t\tEmptyFolderPathsNames.Append(FolderPath);\t\t\tEmptyFolderPathsNames.Append(TEXT(\"\\n\")); // 삭제할 폴더 배열\t\t\tEmptyFoldersPathsArray.Add(FolderPath);\t\t}\t}\tif(EmptyFoldersPathsArray.Num() == 0) // 삭제할 폴더 없음\t{\t\tDebugHeader::ShowMsgDialog(EAppMsgType::Ok, TEXT(\"No empty folder found under selected folder\"),false);\t\treturn;\t}\tEAppReturnType::Type ConfirmResult =\tDebugHeader::ShowMsgDialog(EAppMsgType::OkCancel,TEXT(\"Empty folders found in:\\n\") + EmptyFolderPathsNames + TEXT(\"\\nWould you like to delete all?\"),false);\tif(ConfirmResult == EAppReturnType::Cancel) return; // 취소\tfor(const FString&amp; EmptyFolderPath : EmptyFoldersPathsArray)\t{ // DeleteDirectory 함수는 성공하면 true 실패하면 false를 반환한다. // 삼항 연산자로 반환값에 따라 알맞게 대처\t\tUEditorAssetLibrary::DeleteDirectory(EmptyFolderPath) ?\t\t\t++Counter :\t\t\tDebugHeader::Print(TEXT(\"Failed to delete \" + EmptyFolderPath),FColor::Red);\t}\tif(Counter &gt; 0)\t{\t\tDebugHeader::ShowNotifyInfo(TEXT(\"Successfully deleted \") + FString::FromInt(Counter) +TEXT(\"Folders\"));\t}}" }, { "title": "Search and Delete unused", "url": "/posts/Search-and-Delete-unused-Asset/", "categories": "unreal, Editor", "tags": "unreal", "date": "2023-09-04 00:00:00 +0900", "snippet": " Custom Menu Entry에서 사용했던 CustomCBMenuExtender 함수의 매개변수는 경로이므로 이 경로를 헤더 파일에 따로 저장하고 다음 함수에서 사용한다. 함수에서 보기 불필요한 메세지는 제외함 // TArray&lt;FString&gt; FolderPathSelectedvoid FSuperManagerModule::OnDeleteUnusedAssetbuttonClicked(){ // 한 번에 한 폴더만 하기 위해 1개 초과는 X\tif(FolderPathSelected.Num() &gt; 1) return; // ListAssets은 디렉토리 경로에서 찾은 모든 에셋 목록을 반환\tTArray&lt;FString&gt; AssetsPathNames = UEditorAssetLibrary::ListAssets(FolderPathSelected[0]);\tif(AssetsPathNames.Num() == 0) return;\tEAppReturnType::Type ConfirmResult = \t DebugHeader::ShowMsgDialog(EAppMsgType::YesNo, TEXT(\"~내용~\"),false); \tif(ConfirmResult == EAppReturnType::No) return;\tFixupRedirectors();\tTArray&lt;FAssetData&gt; UnusedAssetsDataArray;\tfor(const FString&amp; AssetPathName : AssetsPathNames)\t{\t\t// 지우면 안되는 최상위 폴더는 삭제 안되게 넘어간다.\t\tif(AssetPathName.Contains(TEXT(\"Developers\")) ||\t\t\tAssetPathName.Contains(TEXT(\"Collections\")) ||\t\t\tAssetPathName.Contains(TEXT(\"__ExternalActors__\")) ||\t\t\tAssetPathName.Contains(TEXT(\"__ExternalObjects__\")))\t\t{\t\t\tcontinue;\t\t}\t\t\t\tif(!UEditorAssetLibrary::DoesAssetExist(AssetPathName)) continue; // 해당 에셋이 참조되는지 확인\t\tTArray&lt;FString&gt; AssetReferencers = \t\tUEditorAssetLibrary::FindPackageReferencersForAsset(AssetPathName); // 에셋의 참조가 0이라면 따로 저장\t\tif(AssetReferencers.Num() == 0)\t\t{\t\t\tconst FAssetData UnusedAssetData = UEditorAssetLibrary::FindAssetData(AssetPathName);\t\t\tUnusedAssetsDataArray.Add(UnusedAssetData);\t\t}\t}\tif(UnusedAssetsDataArray.Num() &gt; 0) // 삭제\t{\t\tObjectTools::DeleteAssets(UnusedAssetsDataArray);\t}}" }, { "title": "Custom Menu Entry", "url": "/posts/Custom-Menu-Entry/", "categories": "unreal, Editor", "tags": "unreal", "date": "2023-09-03 00:00:00 +0900", "snippet": "Custom Menu Entry 델리게이트를 이용하여 에디터의 메뉴 엔트리에 버튼을 추가할 수 있다. build.cs 파일에서 \"ContentBrowser\"를 넣어줘야 하고 메뉴 엔트리는 플러그인 모듈에서 추가한다 모듈에서 진행하므로 모듈이 시작하면서 호출되는 함수인 StartModule에 InitCbMenuExtention에서 호출해야 한다. void FSuperManagerModule::StartupModule(){\tInitCBMenuExtention();} void FSuperManagerModule::InitCBMenuExtention(){ // 컨텐츠 브라우저 모듈을 가져온다,\tFContentBrowserModule&amp; ContentBrowserModule = \tFModuleManager::LoadModuleChecked&lt;FContentBrowserModule&gt;(TEXT(\"ContentBrowser\")); // 컨텐츠 브라우저의 모든 메뉴 확장 컨텍스트를 가져온다\tTArray&lt;FContentBrowserMenuExtender_SelectedPaths&gt;&amp; ContentBrowserModuleMenuExtenders = ContentBrowserModule.GetAllPathViewContextMenuExtenders();\t// 메뉴 엔트리에서 위치를 정할 델리게이트 추가\tContentBrowserModuleMenuExtenders.Add (FContentBrowserMenuExtender_SelectedPaths::CreateRaw\t\t (this,&amp;FSuperManagerModule::CustomCBMenuExtender));}TSharedRef&lt;FExtender&gt; FSuperManagerModule::CustomCBMenuExtender(const TArray&lt;FString&gt;&amp; SelecetedPaths){\tTSharedRef&lt;FExtender&gt; MenuExtender(new FExtender());\tif(SelecetedPaths.Num() &gt; 0)\t{\t\tMenuExtender-&gt;AddMenuExtension(FName(\"Delete\"), // 추가할 메뉴 엔트리 이름\t\tEExtensionHook::After, // 위치\t\tTSharedPtr&lt;FUICommandList&gt;(), // 단축키\t\tFMenuExtensionDelegate::CreateRaw (this,&amp;FSuperManagerModule::AddCBMenuEntry)); // 디테일을 위한 델리게이트\t}\t\treturn MenuExtender;}// 추가할 메뉴 엔트리void FSuperManagerModule::AddCBMenuEntry(FMenuBuilder&amp; MenuBuilder){\tMenuBuilder.AddMenuEntry\t(\t\tFText::FromString(TEXT(\"Delete UnUsed Assets\")),\t\t // 타이틀\t\tFText::FromString(TEXT(\"Safely delete all unused assets under folder\")),// 툴팁\t\tFSlateIcon(),\t // 아이콘\t\tFExecuteAction::CreateRaw \t(this,&amp;FSuperManagerModule::OnDeleteUnusedAssetbuttonClicked) // 실제로 호출되는 함수\t);} OnDeleteUnusedAssetbuttonClicked는 다음장에서 작성 다음과 같이 메뉴 엔트리에 추가된다 개발자 훅 UI 메뉴, 메뉴바 및 툴바를 확장할 수 있게 허용하는 개발자 훅을 위 사진같이 초록색 글자로 표시할 수 있다. 편집-&gt;에디터 설정에서 다음과 같이 검색한 후 체크해주고 에디터를 재시작하면 된다. " }, { "title": "Delete Unused Asset && Fixup Redirector", "url": "/posts/DeleteUnusedAsset/", "categories": "unreal, Editor", "tags": "unreal", "date": "2023-09-02 00:00:00 +0900", "snippet": "Delete Unused Asset 사용중이지 않은 에셋을 삭제하려면 일단 해당 에셋이 사용중인지 확인해야한다. 그럴때 사용하는 함수가 FindPackageReferencersForAsset읻다. // AssetPath 는 찾고자 하는 에셋 경로// bLoadAssetsToConfirm는 종속성을 확인하기 위해 에셋과 레퍼런스를 로드할지 결정UFUNCTION(BlueprintCallable, Category = \"Editor Scripting | Asset\")static TArray&lt;FString&gt; FindPackageReferencersForAsset( const FString&amp; AssetPath, bool bLoadAssetsToConfirm = false); 언리얼에는 종속성에 강 참조(Hard), 약 참조(Soft)가 있다. 강 참조(Hard)는 A오브젝트가 B오브젝트를 참조하고 있다면, A오브젝트 로드시 B 오브젝트도 로드하는 방식이다 약 참조(Soft)는 경로(Path)같은 문자열 형태의 간접 매커니즘을 통해 A오브젝트가 B오브젝트를 참조하게 만들어 로드하는 방식이다. #include \"ObjectTools.h\"// 소스파일void UQuickAssetAction::RemoveUnusedAssets(){ // 선택된 에셋 데이터 배열\tTArray&lt;FAssetData&gt; SelectedAssetsData = \t\t\tUEditorUtilityLibrary::GetSelectedAssetData();\t// 삭제할 에셋 데이터 배열\tTArray&lt;FAssetData&gt; UnusedAssetsData;\tFixupRedirectors();\t\tfor(const FAssetData&amp; SelecetedAssetData : SelectedAssetsData)\t{\t\tTArray&lt;FString&gt; AssetReferencers = UEditorAssetLibrary::FindPackageReferencersForAsset (SelecetedAssetData.GetSoftObjectPath().ToString());\t\tif(AssetReferencers.Num() == 0) // 에셋의 참조횟수가 0이라면\t\t{\t\t\tUnusedAssetsData.Add(SelecetedAssetData);\t\t}\t}\tif(UnusedAssetsData.Num() == 0) // 삭제할 에셋이 없다면 메세지 출력\t{\t\tShowMsgDialog(EAppMsgType::Ok,\t\t\t\tTEXT(\"No unused asset found among seleceted assets\"),\t\t\t\tfalse);\t\treturn;\t} // DeleteAssets 함수로 삭제 및 총 삭제한 개수를 리턴\tconst int32 NumOfAssetsDeleted = ObjectTools::DeleteAssets(UnusedAssetsData);\tif(NumOfAssetsDeleted == 0) return;\tShowNotifyInfo(TEXT(\"Successfully deleted \") + \t\t\t\tFString::FromInt(NumOfAssetsDeleted) +\t\t\t\tTEXT(\" unused assets\"));}Fixup Redirector Redirector는 이동된 애셋을 가리키던 레퍼런스를 현재 위치로 고쳐주는 오브젝트이다. 만약 에셋의 위치를 옮기거나 이름을 바꾸면 원래 있던 장소에 Redirector가 남는다. 그렇기 때문에 Redirector 오브젝트를 갱신하지 않으면 에셋을 이동한 후에 RemoveUnUsedAssets 함수를 호출해도 작동하지 않는다. 에디터에도 이 Redirector를 지원하지만, 매번 옮길때마다 에디터에서 이 함수를 호출하기에는 효율적이지 않아 C++로 작성해서 호출시키는 방식으로 만든다.#include \"AssetRegistry/AssetRegistryModule.h\"#include \"AssetToolsModule.h\"void UQuickAssetAction::FixupRedirectors(){\tTArray&lt;UObjectRedirector*&gt; RedirectorsToFixArray; // LoadModuleChecked로 AssetRegistry 모듈이 존재하는지 확인\tFAssetRegistryModule&amp; AssetRegistryModule = \t\tFModuleManager::Get().\t\tLoadModuleChecked&lt;FAssetRegistryModule&gt;(TEXT(\"AssetRegistry\"));\tFARFilter Filter;\tFilter.bRecursivePaths = true; // 하위 폴더의 접근 허용\tFilter.PackagePaths.Emplace(\"/Game\"); // 경로, (\"/Game\")은 컨텐츠 브라우저를 의미\tFilter.ClassPaths.Emplace(\"ObjectRedirector\"); // 가져올 클래스 이름\tTArray&lt;FAssetData&gt; OutRedirectors;\t // 필터에 해당하는 에셋 데이터를 전부 반환\tAssetRegistryModule.Get().GetAssets(Filter, OutRedirectors); \tfor(const FAssetData&amp; RedirectorData : OutRedirectors)\t{\t\tif(UObjectRedirector* RedirectorToFix = \t\t\t\tCast&lt;UObjectRedirector&gt;(RedirectorData.GetAsset()))\t\t{\t\t\tRedirectorsToFixArray.Add(RedirectorToFix);\t\t}\t}\tFAssetToolsModule&amp; AssetToolsModule = \tFModuleManager::LoadModuleChecked&lt;FAssetToolsModule&gt;(TEXT(\"AssetTools\")); // 고쳐야할 Redirector을 수정\tAssetToolsModule.Get().FixupReferencers(RedirectorsToFixArray);} AssetToolsModule을 사용하려면 build.cs 파일에서 “AssetTools”를 추가해야 한다." }, { "title": "Prefix to assets", "url": "/posts/Prefix-to-assets/", "categories": "unreal, Editor", "tags": "unreal", "date": "2023-09-01 00:00:00 +0900", "snippet": "Prefix to assets TMap을 이용해서 해당 블루프린트의 클래스를 알아내고, 그 클래스는 지정한 FString으로 시작하게 만드는 함수// 헤더파일private: TMap&lt;UClass*, FString&gt; PrefixMap = { {UBlueprint::StaticClass(), TEXT(\"BP_\")}, {UMaterial::StaticClass(),TEXT(\"M_\")}, {UNiagaraSystem::StaticClass(), TEXT(\"NS_\")}, //... 원하는 클래스들 추가 }public: UFUNCTION(CallInEditor) void AddPrefixes();// 함수void UQuickAssetAction::AddPrefixes(){ // 선택한 에셋들을 담은 배열\tTArray&lt;UObject*&gt; SelectedObjects = UEditorUtilityLibrary::GetSelectedAssets();\tuint32 Counter = 0;\t\tfor(UObject* SelectedObject : SelectedObjects)\t{\t\tif(!SelectedObject) continue; // 해당 클래스가 TMap에 있다면 Value에 해당하는 FString을 가져온다\t\tFString* PrefixFound = PrefixMap.Find(SelectedObject-&gt;GetClass());\t\t\t\tif(!PrefixFound || PrefixFound-&gt;IsEmpty())\t\t{\t\t\tPrint(TEXT(\"Failed to find prefix for class\") +\t\t\t\t\tSelectedObject-&gt;GetClass()-&gt;GetName(),\t\t\t\t\tFColor::Red);\t\t\tcontinue;\t\t}\t\tFString OldName = SelectedObject-&gt;GetName();\t\t// StartsWith는 특정 문자열로 시작하는지 확인하는 함수, 이미 수정된 에셋은 변경X\t\tif(OldName.StartsWith(*PrefixFound))\t\t{\t\t\tPrint(OldName + TEXT(\" already has prefix added\"), FColor::Red);\t\t\tcontinue;\t\t} // IsA는 템플릿인지 확인하는 함수, MaterialInstance라면 변경사항 추가 if(SelectedObject-&gt;IsA&lt;UMaterialInstanceConstant&gt;())\t\t{\t\t\tOldName.RemoveFromStart(TEXT(\"M_\"));\t\t\tOldName.RemoveFromEnd(TEXT(\"_Inst\"));\t\t}\t\tconst FString NewNameWithPrefix = *PrefixFound + OldName; // 선택된 에셋을 해당 이름으로 변경\t\tUEditorUtilityLibrary::RenameAsset(SelectedObject, NewNameWithPrefix);\t\t++Counter;\t} \tif(Counter &gt; 0)\t{\t\tShowNotifyInfo(TEXT(\"Successfully rename \" + FString::FromInt(Counter)));\t}} 에디터에서 해당 함수 호출전 호출후" }, { "title": "Custom Editor Message", "url": "/posts/Custom-Editor-Message/", "categories": "unreal, Editor", "tags": "unreal", "date": "2023-09-01 00:00:00 +0900", "snippet": "알림 메세지 언리얼에서 특정 행동을 하면 메세지가 나타내는데 다음과 같은 함수로 원하는 알림 메세지를 보낼 수 있다.#include \"Framework/Notifications/NotificationManager.h\"void ShowNotifyInfo(const FString&amp; Message){\tFNotificationInfo NotifyInfo(FText::FromString(Message));\tNotifyInfo.bUseLargeFont = true;\tNotifyInfo.FadeOutDuration = 7.f;\tFSlateNotificationManager::Get().AddNotification(NotifyInfo);}// 사용ShowNotifyInfo(TEXT(\"Successfully duplicated \" + FString::FromInt(Counter) + \"files\")); 그러면 다음과 같은 특정 메세지를 생성할 수 있다.창 메세지 아니면 다음과 같이 에디터에서 특정 행동에 따라 창을 띄워서 내용을 전달할 수 있다.static EAppReturnType::Type ShowMsgDialog(EAppMsgType::Type MsgType, const FString&amp; Message,bool bShowMsgAsWarning = true){\tif(bShowMsgAsWarning)\t{\t\tFText MessageTitle = FText::FromString(TEXT(\"Warning\"));\t\treturn FMessageDialog::Open(MsgType,FText::FromString(Message),&amp;MessageTitle);\t}\telse\t{\t\treturn FMessageDialog::Open(MsgType,FText::FromString(Message));\t}}단일 메세지를 띄울 때// 헤더UFUNCTION(CallInEditor)void ShowMsgOk();// 소스void UQuickAssetAction::ShowMsgOk(){\tShowMsgDialog(EAppMsgType::Ok,TEXT(\"Ok\"));}선택 메세지를 띄울 때// 헤더UFUNCTION(CallInEditor)void ShowMsgYesNo();// 소스void UQuickAssetAction::ShowMsgYesNo(){\tEAppReturnType::Type ReturnType =\tDebugHeader::ShowMsgDialog(EAppMsgType::YesNo,TEXT(\"YesNo\"));\tif(ReturnType == EAppReturnType::Yes)\t{\t\tDebugHeader::ShowMsgDialog(EAppMsgType::Ok,TEXT(\"Yes\"));\t}\telse if(ReturnType == EAppReturnType::No)\t{\t\tDebugHeader::ShowMsgDialog(EAppMsgType::Ok,TEXT(\"No\"));\t}} Yes나 No를 누르면 ShowMsgOk함수처럼 창이 뜨고 안에 내용이 누른 것에 따라 바뀐다." }, { "title": "Duplicate 함수", "url": "/posts/Duplicate-%ED%95%A8%EC%88%98/", "categories": "unreal, Editor", "tags": "unreal", "date": "2023-08-30 00:00:00 +0900", "snippet": "Scripting Libraries Scripting Library인 두 라이브러리를 사용해서 다음 함수를 사용하려 한다. UEditorUtilityLibrary UEditorAssetLibrary UEditorUtilityLibrary// Gets the set of currently selected assetsUFUNCTION(BlueprintCallable, Category = \"Development|Editor\")static TArray&lt;UObject*&gt; GetSelectedAssets();// Gets the set of currently selected assets dataUFUNCTION(BlueprintCallable, Category = \"Development|Editor\")static TArray&lt;FAssetData&gt; GetSelectedAssetData(); AssetData와 Asset의 차이점은 AssetData가 Asset보다 좀 더 많은 정보를 담고 있다.UEditorAssetLibraryUFUNCTION(BlueprintCallable, Category = \"Development|Editor\")static TArray&lt;FString&gt; ListAssets(const FString&amp; DirectoryPath, bool) EditorAssetLibrary를 이용하기 위해선 EditorScriptingUtilities모듈을 넣어야 한다.에디터 에디터에서 위 라이브러리를 이용하여 다음과 같은 함수를 만들어 한번에 여러개 복사하는 함수를 만들 수 있다.// 헤더파일UCLASS()class SUPERMANAGER_API UQuickAssetAction : public UAssetActionUtility{\tGENERATED_BODY()public:\tUFUNCTION(CallInEditor)\tvoid DuplicateAssets(int32 NumOfDuplicates);};// 소스파일void UQuickAssetAction::DuplicateAssets(int32 NumOfDuplicates){\tif(NumOfDuplicates &lt;= 0)\t{\t\treturn;\t}\tTArray&lt;FAssetData&gt; SelectedAssetsData = UEditorUtilityLibrary::GetSelectedAssetData();\tuint32 Counter = 0; // 복사되는 에셋 수\t\tfor(const FAssetData&amp; SelectedAssetData : SelectedAssetsData)\t{\t\tfor(int32 i = 0; i &lt; NumOfDuplicates; i++)\t\t{\t\t\tconst FString SourceAssetPath = \t\t\t\tSelectedAssetData.ObjectPath.ToString();\t// 해당 에셋 경로\t\t\tconst FString NewDuplicatedAssetName = \t\t\t\tSelectedAssetData.AssetName.ToString() + TEXT(\"_\") + FString::FromInt(i); // 복사한 에셋 이름 설정\t\t\tconst FString NewPathName = \t\t\t\tFPaths::Combine(SelectedAssetData.PackagePath.ToString(),NewDuplicatedAssetName); // 새로운 경로\t\t\tif(UEditorAssetLibrary::DuplicateAsset(SourceAssetPath,NewPathName)) // 복사\t\t\t{\t\t\t\tUEditorAssetLibrary::SaveAsset(NewPathName, false);\t// 저장\t\t\t\t++Counter;\t\t\t}\t\t}\t}} 에디터에서 다음과 같이 창이 뜨면 매개변수값을 넣어주고 확인을 누르면 다음과 같이 5개의 복사된 에셋이 생성된다." }, { "title": "AssetActionUtility", "url": "/posts/AssetActionUtility/", "categories": "unreal, Editor", "tags": "unreal", "date": "2023-08-30 00:00:00 +0900", "snippet": ".uplugin 현재 만들고 있는 툴을 플러그인으로 제작하기 위해 편집-&gt;플러그인-&gt;추가-&gt;공백을 누르고 이름을 작성한다. 그다음 IDE에서 해당 플러그인에 들어가 이름.uplugin에 들어가 다음과 같이 바꿔준다.\"Modules\": [ { \"Name\": \"SuperManager\", \"Type\": \"Editor\", \"LoadingPhase\": \"PreDefault\" }] Type은 모듈의 유형으로 이 플러그인의 모듈을 로드하기에 적합한 어플리케이션 유형을 결정한다. 에디터상에서만 작동시키기 위해 Editor로 작성 종류에는 https://docs.unrealengine.com/5.2/en-US/API/Runtime/Projects/EHostType__Type/ 에서 확인할 수 있다. LoadingPhase는 모듈이 언제 로딩되는지를 결정한다. 엔진이 초기화되기 이전에 로딩되기 위해 PreDefault를 사용한다. 종류는 https://docs.unrealengine.com/5.2/en-US/API/Runtime/Projects/ELoadingPhase__Type/ 에서 확인할 수 있다. AssetActionUtility 커스텀 에디터에서 Asset관련은 AssetActionUtility, Actor관련은 ActorActionUtility 클래스를 사용한다 지금은 에셋 커스텀 에디터를 위해 AssetActionUtility 클래스의 파생 클래스를 제작한다. 그런데 AssetActionUtility 클래스를 사용하기 위해선 모듈을 추가해야 한다. 플러그인의 .cs파일에 들어가 다음과 같이 추가한다. // System.IO.Path.GetFullPath(Target.RelativeEnginePath)는 엔진 경로를 의미PrivateIncludePaths.AddRange( new string[] { System.IO.Path.GetFullPath(Target.RelativeEnginePath) + \"/Source/Editor/Blutility/Private\" }); 그 다음 다음과 같이 추가하면 에디터에서 해당 옵션이 뜬다.// hUCLASS()class SUPERMANAGER_API UQuickAssetAction : public UAssetActionUtility{\tGENERATED_BODY()public:\tUFUNCTION(CallInEditor) // CallInEditor 속성을 사용해서 에디터에서 해당 함수를 사용\tvoid TestFunc();};// cppvoid UQuickAssetAction::TestFunc(){\tif(GEngine)\t{\t\tGEngine-&gt;AddOnScreenDebugMessage(-1, 8.f,FColor::Cyan, TEXT(\"Working\"));\t}} 에디터에 TestFunc를 추가" }, { "title": "Replication", "url": "/posts/Replication/", "categories": "unreal, multi", "tags": "unreal", "date": "2023-07-29 00:00:00 +0900", "snippet": "Replication 좌측은 서버, 우측은 클라이언트 클라이언트 캐릭터가 무기에 부딪힌 상황 void AWeapon::BeginPlay(){\tSuper::BeginPlay(); // OnSphereOverlap : 부딪히면 Text가 보이게 설정하는 함수\tAreaSphere-&gt;OnComponentBeginOverlap.AddDynamic(this, &amp;AWeapon::OnSphereOverlap);} 충돌할 때 Widget을 보이게 설정한 후, 클라이언트에서만 캐릭터가 충돌했지만 서버(에디터)까지 텍스트가 보여버린다 서버에서도 보이는 이유는 서버에서 Overlap Event가 발생하기 때문이다. 클라이언트로 변수를 복제해서 클라이언트에서만 보이게 하려면 다음과 같은 과정을 거쳐야 한다. 과정 첫 번쨰로, UPROPERTY의 Replicated 속성이 들어가야 한다. Replicated속성은 엔진에 의해 관리되고 복제되어야 함을 지정하는 역할 ReplicatedUsing으로 함수를 세팅하면 해당 변수가 복제될 때마다 세팅한 함수가 호출된다.UPROPERTY(ReplicatedUsing = OnRep_OverlaapingWeapon)class AWeapon* OverlappingWeapon;UFUNCTION()void OnRep_OverlappingWeapon();// c++void ABlasterCharacter::OnRep_OverlappingWeapon(){\tif(OverlappingWeapon)\t{\t\tOverlappingWeapon-&gt;ShowPickupWidget(true);\t}} 두 번쨰로, 생성자에 bReplicated값을 true로 설정해야 함` AWeapon::AWeapon(){ PrimaryActorTick.bCanEverTick = false; // bReplicates 값이 true여야만 다른 machine에서 복사될 수 있음 bReplicates = true; ...} 세 번째로, 가상함수 GetLifetimeReplicatedProps에서 복제할 변수를 등록해야 한다 변수를 등록하여 네트워크 상에서 자동으로 동기화한다.// 네트워크 상에서 복제되어야 하는 프로퍼티 목록을 엔진에 알려주는 역할void ABlasterCharacter::GetLifetimeReplicatedProps(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps) const{\tSuper::GetLifetimeReplicatedProps(OutLifetimeProps); // 기본적으로는 DOREPLIFETIME을 사용 // DOREPLIFETIME(클래스, 변수)\t// COND_OwnerOnly : 해당 변수가 소유자만 접근 가능하도록 지정\tDOREPLIFETIME_CONDITION(ABlasterCharacter,OverlappingWeapon,COND_OwnerOnly);}복제 후 서버에서 보이지 않고 클라이언트에서만 위젯이 보이게 되었다. 그런데 이러면 문제가 있는데 서버에서 접근하면 OnRep_OverlappingWeapon함수가 호출되지 않아 아무 반응이 없어 위젯이 뜨지 않는다. 서버에서는 처음 시작할때 생성되기 때문에 복제되지 않아 함수가 호출되지 않음 그래서 따로 함수로 적용시켜야 한다.// 이전void ABlasterCharacter::SetOverlappingWeapon(AWeapon* Weapon){\tOverlappingWeapon = Weapon;}// 이후void ABlasterCharacter::SetOverlappingWeapon(AWeapon* Weapon){ // 처음에 false로 설정 if(OverlappingWeapon)\t\tOverlappingWeapon-&gt;ShowPickupWidget(false);\tOverlappingWeapon = Weapon; // 로컬에서 컨트롤하는 서버라면\tif(IsLocallyControlled())\t\tif(OverlappingWeapon)\t\t\tOverlappingWeapon-&gt;ShowPickupWidget(true);}OnRep 함수의 매개변수 OnRep 함수에 매개변수에는 복제한 타입의 포인터(AWeapon*)를 가질 수 있다. 이 매개변수가 의미하는 것은 변수가 복제되기 이전 마지막 값을 의미한다. // 헤더파일UFUNCTION()void OnRep_OverlappingWeapon(AWeapon* LastWeapon);// 소스파일void ABlasterCharacter::OnRep_OverlappingWeapon(AWeapon* LastWeapon){\tif(OverlappingWeapon)\t{\t\tOverlappingWeapon-&gt;ShowPickupWidget(true);\t} if(LastWeapon) { LastWeapon-&gt;ShowPickupWidget(false); }}" }, { "title": "RPC", "url": "/posts/RPC/", "categories": "unreal, multi", "tags": "unreal", "date": "2023-07-29 00:00:00 +0900", "snippet": "RPC 로컬에서 호출되지만 다른 머신에서 원격 실행되는 함수를 의미한다 RPC를 사용하려면 UFUNCTION()에서 다음과 같이 키워드를 붙여주면 된다. ClientUFUCNTION(Client)void ClientRPCFunction(); 이 함수는 서버에서 호출되지만 클라이언트에서 실행된다.ServerUFUCNTION(Server)void ClientRPCFunction(); 이 함수는 클라이언트에서 호출되지만 서버에서 실행된다.NetMulticastUFUCNTION(NetMulticast)void ClientRPCFunction(); 서버에서 호출되지만 서버와 모든 클라이언트에서 실행된다. 클라이언트에서도 호출이 가능하지만 그 경우에는 로컬에서만 실행된다. InVoke 클라이언트나 서버에서 RPC가 호출되면 어떻게 작동하는지는 공식 문서에 나와 있다.예시 E키를 누르면 Combat이라는 ActorComponent에서 현재 충돌중인 Weapon을 장착하는 함수를 다음과 같이 만들었다고 한다.void ABlasterCharacter::EquipButtonPressed(){\tif(Combat)\t{ Combot-&gt;EquipWeapon(OverlappingWeapon); }} 서버와 클라이언트에서 각각 실행되면 서버에서는 장착되면 서버와 클라이언트 둘 다 보이지만,클라이언트에서 장착하면 서버에서는 해당 클라이언트가 장착되지 않게 보인다.서버에서 장착 서버캐릭터가 장착하면 클라이언트, 서버 둘 다 장착하는 모습클라이언트에서 장착 클라이언트 캐릭터가 장착하면 서버(에디터)에서는 클라이언트 캐릭터가 장착하지 못한 모습 서버에서만 Equip 함수가 실행되고 Client에서는 Equip 함수가 호출되지 않음 위와 같은 상황을 해결하려면 RPC를 사용해야 한다. 헤더파일 // 클라이언트에서 호출되지만 서버에서 실행되도록 하는 Server 키워드// 확실하게 실행되려면 Reliable 키워드 사용UFUNCTION(Server, Reliable)void ServerEquipButtonPressed(); 소스코드// RPC함수는 _Implementation가 뒤에 붙어야 한다.void ABlasterCharacter::ServerEquipButtonPressed_Implementation(){\tif(Combat)\t{\t\tCombat-&gt;EquipWeapon(OverlappingWeapon);\t}}void ABlasterCharacter::EquipButtonPressed(){\tif(Combat)\t{\t\t// 클라이언트, 서버 어디에서 실행하든 항상 서버에서 실행\t\tServerEquipButtonPressed();\t}}RPC 적용" }, { "title": "Travel", "url": "/posts/Travel/", "categories": "unreal, multi", "tags": "unreal", "date": "2023-07-18 00:00:00 +0900", "snippet": "TRAVEL 방식 게임 내에서 여러 개의 레벨 또는 맵을 연결하는 방법 Non-Seamless Travel와 Seamless Travel 두 가지 버전이 있다. GameMode 클래스에서 bUseSeamlessTravel이란 값으로 선택할 수 있다. Non-Seamless Travel 게임 플레이 중에 현재 레벨을 완전히 언로드한 후, 다른 레벨을 로드하여 이동하는 방식 클라이언트가 서버 연결을 끊고 같은 서버에 다시 재연결한다 맵을 로딩할 때, 서버와 처음 연결할 때, 게임이 끝나고 새롭게 시작할 때 모든 클라이언트한테 발생한다 Non-Seamless Travel은 주로 큰 규모의 레벨 간 전환이 필요한 경우나, 다른 맵으로의 이동이 필요한 경우에 사용된다 Seamless Travel 레벨 간 전환 시 로딩 화면 없이 자연스럽게 이동하는 방식 클라이언트가 서버와 연결을 끊을 필요가 없어 부드러운 환경이 제공된다 재연결 이슈도 피할 수 있다 서버를 찾지 못하거나 서버에 갑자기 유저가 많아져 유저가 재연결되지 않는것 등 변환 지도(Transition Map)를 사용한다 Transition Map은 플레이어가 한 장소에서 다른 장소로 이동할 때의 경로와 관련된 정보를 담고 있는 지도 맵이 언제든 로딩이 되어야 하기 때문에 다른 맵으로 이동할 때의 경로를 담고 있는 변환 지도를 이용한다. 만약 현재 맵에서 다른 맵으로 이동할 때 변환맵이 없다면 많은 비용이 소모된다 Seamless Travel은 주로 작은 규모의 레벨 간 전환, 다양한 지역 간의 이동 또는 게임 내의 퀘스트 진행을 위해 사용된다.멀티플레이어에서 Travel 호출 UWorld::ServerTravel과 APlayerController::ClientTravel이 있다.UWorld::ServerTravel 게임 서버에서 사용되는 메서드 ServerTravel을 호출하면 현재 게임 세션에서 다른 맵(레벨)으로 이동할 수 있다. 맵 전환: 서버가 다른 맵으로 이동하여 새로운 게임 세션을 시작하는 경우 사용 게임 모드 변경: 서버에서 특정 게임 모드로 전환하는 경우 사용 서버에서만 호출할 수 있으며, 클라이언트 측에서 직접 호출하면 작동하지 않는다. 따라서 서버 관리자 또는 서버 측 로직에서 호출되어야 한다. APlayerController::ClientTravel 게임 클라이언트에서 사용되는 메서드 ClientTravel을 호출하면 현재 클라이언트가 서버에서 제공하는 새로운 맵으로 이동한다. 로비 또는 매치메이킹: 클라이언트가 서버에서 호스팅되는 로비 또는 매치메이킹 시스템에 참가할 때 사용 게임 시작 및 종료: 클라이언트가 서버에서 게임 세션을 시작하거나 종료할 때 사용 클라이언트에서만 호출할 수 있으며, 서버 측에서 호출해도 클라이언트의 이동에는 영향을 미치지 않는다. 따라서 클라이언트 관리자 또는 클라이언트 측 로직에서 호출되어야 한다. 결론 ServerTravel은 서버에서 다른 맵으로 이동하는 데 사용되며, ClientTravel은 클라이언트에서 서버에서 제공하는 새로운 맵으로 이동하는 데 사용" }, { "title": "프로젝트-2", "url": "/posts/ENetRole/", "categories": "unreal, multi", "tags": "unreal", "date": "2023-07-18 00:00:00 +0900", "snippet": "NetworkRole 멀티플레이어에서 한 컴퓨터 안에 있는 캐릭터끼리 구분해서 서버인지 클라이언트인지를 구분할 수 있다. 어떤 캐릭터를 기준으로 할지를 ENetRole이라는 열거형으로 구분할 수 있다. Local은 자기 컴퓨터를 기준으로 Remote는 다른 컴퓨터를 기준으로 ENetRole를 부여한다고 생각하면 된다. 간단한 ENetRole 설명 ROLE_Authority : 서버에 존재하는 액터 ROLE_SimulatedProxy : 클라이언트에서 자기가 조종하지 않는 캐릭터를 의미 ROLE_AutonomousProxy : 클라이언트에서 자기가 조종하는 캐릭터를 의미 ROLE_None : 구분하지 않음 Local Role 로컬 플레이어에 대한 네트워크 역할을 정의한다.서버 서버에서는 모든 Actor가 Authority를 가진다. Authority값을 가짐으로써 Server인지 Client인지 구분한다. 클라이언트 클라이언트에서 자기가 조종하는 캐릭터는 AutonomousProxy이다. 자기가 조종하지 않는 캐릭터는 SimulatedProxy이다. Remote Role 네트워크 연결을 통해 원격 플레이어와 상호작용하는 액터(Actor)에 대한 역할을 정의한다. Remote Role은 서버에서는 클라이언트, 클라이언트에서는 서버의 ENetRole을 본다고 생각하면 된다. 서버클라이언트유용 컴퓨터가 조종하는 폰에 대해서만 적용 : IsLocallyControlled(); 서버에서만 실행 : HasAuthority() " }, { "title": "Steam Online Session", "url": "/posts/Steam-Online-Session/", "categories": "unreal, multi", "tags": "unreal", "date": "2023-07-16 00:00:00 +0900", "snippet": "프로젝트 생성 후 플러그인 세팅에디터 세팅 프로젝트 생성 후 사용할 플러그인을 프로젝트 폴더 안에 넣는다. 그다음 에디터에서 편집-&gt;플러그인을 클릭한다 그 후 멀티가 되는 프로젝트를 만들 예정이므로 OnlineSession을 찾는다. 각 버전에 맞게 설치해야됨. 여기서는 스팀 폴더 세팅 그 후 폴더에 가서 Config 폴더를 연다. 코드를 추가해야 하는데 OnlineSubsystem Steam버전으로 추가해야 하기 때문에 언리얼 공식문서에 가서 해당 코드를 복사해야 한다. https://docs.unrealengine.com/5.1/ko/online-subsystem-steam-interface-in-unreal-engine/ DefaultEngine.ini 처음에는 DefaultEngine.ini를 열어 밑의 코드를 복사하여 붙여넣기를 한다.DefaultGame.ini 그리고 DefaultGame.ini를 열어 맨 아래의 코드를 추가해야 한다 아래 부분을 추가해야 하는데 추가하지 않으면 자동적으로 최대 플레이어수가 16으로 고정된다.[/Script/Engine.GameSession]MaxPlayers=100 그 후 프로젝트의 Binaries와 Intermediate 폴더와 Plugins안에 있는 Binaries와 Intermediate 폴더를 지운 후 Visual Studio를 rebuild한다. 플러그인의 코드를 보기 위해선 콘텐츠 브라우저-&gt;세팅에서 플러그인 콘텐츠 표시를 클릭해야 한다. " }, { "title": "이벤트 기반 아키텍처 (Event-Driven Architecture)", "url": "/posts/%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EA%B8%B0%EB%B0%98-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-(Event-Driven-Architecture)/", "categories": "디자인 패턴, 아키텍처 패턴", "tags": "design pattern", "date": "2023-07-09 00:00:00 +0900", "snippet": "이벤트 기반 아키텍처 시스템 내에서 발생하는 이벤트(Event)의 생산(Production), 감지(Detection), 그리고 소비(Consumption)를 중심으로 소프트웨어를 구성하는 아키텍처 패턴 이 구조에서 각 컴포넌트들은 서로를 직접 호출하는 대신, 시스템의 상태 변화를 나타내는 ‘이벤트’를 발생시키거나, 특정 이벤트가 발생하기를 ‘구독’하고 기다린다. 이 모든 통신은 이벤트 버스(Event Bus) 또는 메시지 브로커(Message Broker)라는 중앙 채널을 통해 이루어진다. 이 패턴의 핵심 목표는 시스템을 구성하는 컴포넌트들을 극도로 분리(Decoupling)하는 것이다. 이벤트를 발생시키는 쪽(Producer)은 누가 그 이벤트를 받아서 처리하는지 전혀 알 필요가 없으며, 이벤트를 처리하는 쪽(Consumer) 또한 누가 그 이벤트를 발생시켰는지 알 필요가 없다.시나리오: 다양한 게임 시스템 연동하기 플레이어가 몬스터를 처치했을 때, 다음과 같은 여러 가지 일이 동시에 일어나야 한다고 가정하자. 퀘스트 시스템: ‘고블린 10마리 처치’ 퀘스트의 카운트를 1 증가시킨다. 업적 시스템: ‘첫 몬스터 사냥’ 업적을 달성 처리한다. UI 시스템: 화면의 킬 카운트를 갱신한다. 사운드 시스템: 몬스터의 비명소리와 함께 경험치 획득 효과음을 재생한다. 문제점: 모든 것을 아는 거대 객체 이벤트 기반 아키텍처가 없다면, 몬스터의 Die() 메서드는 이 모든 시스템을 직접 참조하고 호출해야 한다.// 안티 패턴: 몬스터가 너무 많은 책임을 짐class Monster {private: QuestSystem* quest_system; AchievementSystem* achievement_system; UISystem* ui_system; SoundSystem* sound_system;public: void Die() { // ... 죽는 로직 ... // 몬스터가 다른 모든 시스템을 직접 호출한다. quest_system-&gt;UpdateKillCount(this-&gt;type); achievement_system-&gt;CheckFirstKillAchievement(); ui_system-&gt;UpdateKillCounter(); sound_system-&gt;Play(\"monster_death.wav\"); // 만약 '길드 시스템'에 몬스터 처치 공지가 추가된다면? // 이 클래스를 또 수정해야 한다! }}; 이 코드는 Monster 클래스가 퀘스트, 업적, UI, 사운드 등 자신과 직접 관련 없는 수많은 시스템에 대해 알아야 하는 강한 결합 상태를 만든다. 이는 시스템을 수정하거나 확장하기 매우 어려운 구조다.해결책: 이벤트로 시스템들 분리하기 이벤트 기반 아키텍처는 이 문제를 이벤트와 이벤트 버스를 통해 해결한다.1. 이벤트(Event) 정의 먼저, 시스템 내에서 발생할 수 있는 의미 있는 사건들을 간단한 데이터 구조체로 정의한다#include &lt;string&gt;using namespace std;// 몬스터가 죽었을 때 발생하는 이벤트struct MonsterKilledEvent { string monster_type; int experience_yield;};// 플레이어가 아이템을 획득했을 때 발생하는 이벤트struct ItemPickedUpEvent { string item_id; int quantity;}; 이벤트 객체는 오직 사건에 대한 ‘정보’만 담을 뿐, 어떤 로직도 가지지 않는다.2. 이벤트 버스 (Event Bus) - 중앙 채널 모든 이벤트의 발행(Publish)과 구독(Subscribe)을 중개하는 중앙 통로다. 이는 매개자(Mediator) 패턴과 옵저버(Observer) 패턴의 조합으로 구현될 수 있다.#include &lt;functional&gt;#include &lt;map&gt;#include &lt;vector&gt;// 간단한 개념의 이벤트 버스class EventBus {public: // 이벤트 타입별로 구독자(콜백 함수) 목록을 가짐 map&lt;string, vector&lt;function&lt;void(void*)&gt;&gt;&gt; subscribers; // 특정 이벤트에 대한 구독을 신청 template &lt;typename T_Event&gt; void Subscribe(function&lt;void(T_Event*)&gt; callback) { subscribers[typeid(T_Event).name()].push_back( // 타입을 안전하게 변환하는 래퍼 람다 [callback](void* event_data){ callback(static_cast&lt;T_Event*&gt;(event_data)); } ); } // 이벤트를 발행하여 모든 구독자에게 알림 template &lt;typename T_Event&gt; void Publish(T_Event* event) { string type_name = typeid(T_Event).name(); if (subscribers.count(type_name)) { for (auto&amp; callback : subscribers[type_name]) { callback(event); } } }}; 실제 프로덕션 환경에서는 Boost.Signals2나 직접 구현한 더 정교한 타입 안전 시그널/슬롯 시스템을 사용한다.3. 생산자(Producer)와 소비자(Consumer) 구현 이제 각 시스템은 다른 시스템을 직접 참조하는 대신, 이벤트 버스와만 상호작용한다.// 이벤트 생산자: 몬스터는 죽을 때 이벤트를 발행만 할 뿐, 누가 듣는지는 모른다.class Monster { EventBus&amp; bus;public: Monster(EventBus&amp; bus) : bus(bus) {} void Die() { // ... MonsterKilledEvent event = {\"Goblin\", 10}; bus.Publish(&amp;event); }};// 이벤트 소비자 1: 퀘스트 시스템은 '몬스터 사망' 이벤트를 구독한다.class QuestSystem {public: QuestSystem(EventBus&amp; bus) { bus.Subscribe&lt;MonsterKilledEvent&gt;([this](MonsterKilledEvent* e){ OnMonsterKilled(e); }); } void OnMonsterKilled(MonsterKilledEvent* event) { if (event-&gt;monster_type == \"Goblin\") { cout &lt;&lt; \"[퀘스트 시스템] 고블린 처치 횟수 +1\" &lt;&lt; endl; } }};// 이벤트 소비자 2: 업적 시스템도 같은 이벤트를 구독한다.class AchievementSystem {public: AchievementSystem(EventBus&amp; bus) { bus.Subscribe&lt;MonsterKilledEvent&gt;([this](MonsterKilledEvent* e){ cout &lt;&lt; \"[업적 시스템] '첫 사냥' 업적 달성!\" &lt;&lt; endl; }); }};4. 전체적인 흐름 Monster가 죽으면 MonsterKilledEvent를 이벤트 버스에 발행한다. 이벤트 버스는 이 이벤트를 구독하고 있던 QuestSystem과 AchievementSystem에 전달하고, 각 시스템은 전달받은 이벤트 데이터를 기반으로 자신만의 로직을 독립적으로 수행한다. 모든 컴포넌트가 완벽하게 분리되었다. 나중에 ‘길드 시스템’이 몬스터 처치 공지를 띄워야 한다면, 그저 MonsterKilledEvent를 구독하는 GuildSystem 클래스 하나만 추가하면 될 뿐, Monster나 다른 시스템의 코드는 전혀 건드릴 필요가 없다.요약 이벤트 기반 아키텍처는 이벤트의 흐름을 통해 시스템의 각 부분을 제어하고 통신하는 아키텍처 스타일이다. 이벤트 생산자(Producer)와 이벤트 소비자(Consumer)는 이벤트 버스(Event Bus)를 통해서만 상호작용하며, 서로의 존재를 전혀 알지 못한다.이를 통해 시스템 컴포넌트 간의 결합도를 최소화(Extremely Decoupled)할 수 있다. 장점 극도의 유연성과 확장성: 새로운 기능(소비자)을 추가할 때, 기존 코드를 전혀 수정하지 않고 새로운 구독자를 이벤트 버스에 등록하기만 하면 된다. 비동기 처리 용이: 이벤트를 큐(Queue)에 넣고 나중에 처리하는 방식으로 쉽게 확장할 수 있어, 시스템의 응답성과 처리량을 높일 수 있다. (예: 많은 로그를 한 번에 파일에 쓰는 작업) 향상된 복원력: 특정 소비자 컴포넌트가 실패하더라도, 이벤트를 발행하는 생산자나 다른 소비자에게는 영향을 주지 않는다. 독립적인 개발 및 배포: 각 컴포넌트(마이크로서비스 아키텍처에서 특히 중요)를 독립적으로 개발, 테스트, 배포할 수 있다. 이벤트 기반 아키텍처는 복잡한 상호작용을 가진 현대적인 대규모 어플리케이션이나 게임에서, 시스템을 유연하고 확장 가능하게 유지하기 위한 핵심적인 패러다임이다. " }, { "title": "Online Subsystem", "url": "/posts/Online-Subsystem/", "categories": "unreal, multi", "tags": "unreal", "date": "2023-07-09 00:00:00 +0900", "snippet": "로컬(Local) IP와 공개(Public) Ip 동일한 로컬 네트워크에 연결된 컴퓨터의 게임 인스턴스에 연결했었지만, 로컬 네트워크에 없는 플레이어와 연결하려 한다. 로컬 IP 주소는 Internal IP 주소라고도 불리며, 로컬 네트워크 라우터에 의해 컴퓨터에 할당된다. 192.168로 시작하는 IP 주소면, 192.168.1.1 , 192.168.1.2 이런식으로 할당된다. 대부분의 네트워크 라우터는 기기들에게 다른 IP 주소를 할당하며 어떤 기기에 연결되었는지에 따라 IP 주소가 바뀔 수 있다. 이 IP 주소들은 네트워크 안에 있는 다른 컴퓨터에게만 보인다. 이 로컬 네트워크는 외부로부터 연결할 수 없다 로컬 컴퓨터는 이더넷 케이블이나 와이파이로 라우터와 연결되어 있다. 라우터는 ISP(Internet Service Provider)와 연결되어 있다. ISP는 라우터에 External Public IP 주소를 할당한다. External Public IP 주소는 인터넷의 다른 IP에게 노출된다. 인터넷에 들어오는 모든 정보는 Public IP 주소나 External IP 주소로 이동한 다음 Local 혹은 Internal IP 주소로 들어온다 결국 같은 로컬 네트워크를 사용하는 컴퓨터끼리는 연결이 쉽지만 아닌 컴퓨터들은 Public IP 주소를 이용하여 접속해야 한다. 그런데 알려주지 않는 한 Public IP 주소를 알 수 없기 때문에 이상적이지 않다. 보통 비디오게임에 로그인하면 게임 자체가 다른 플레이어와 매칭시켜준다. 게임이 IP 주소를 찾는 방법 Dedicated-Server 서버가 Dedicated-Server인 경우, 로그인하면 IP 주소 목록을 갖고 있는 서버 중 하나에 접속하여 매칭한다. 그러나 Dedicated-Server은 돈과 시간이 많이 든다. Listen-Server 한 유저가 Server 역할로 시작한다면, 다른 유저들은 이 Server에 접속한다. 다른 유저들이 이 Server의 IP 주소를 알아내서 접속해야 한다. 게임 로그인은 특정 서버에 신호를 전송하여 로그인한 다른 플레이어와 연결해 주는데, 이러한 서버를 호스팅하는 서비스를 이용하여 다른 플레이어와 연결된다. Online-SubSystem 언리얼 엔진은 Online-Subsystem이라는 기능을 제공하는데 다른 유저들의 IP 주소 없이도 로그인할 수 있게 도와준다. 멀티 플레이어 게임을 언리얼 엔진으로 만들면 게임 세션을 관리하고 유저들을 연결하는 온라인 서비스에 접속해서 함께 플레이할 수 있다. 온라인 서비스에는 스팀, XBox Live, 페이스북 등 있다 게임이 이러한 온라인 서비스중 하나에 연결되고 온라인 서비스은 유저간의 연결을 처리하기 위한 고유한 코드가 설정되어 있다. 스팀에는 유저를 연결하고 친구 목록을 작성하는 고유 코드가 있다. 언리얼에서는 온라인 서비스마다 다르게 작성될 수 있는 코드인 Single Code Base 를 제시한다. Code Base를 이용하여 어떤 온라인 서비스에 연결되었냐에 따라 알맞게 세부사항을 처리한다. Single Code Base로 크로스 서비스의 모든 기능을 담당하는 것을 ABSTRACTION LAYER(추상 계층)이라고 한다. 즉, Online-SubSystem은 온라인 서비스 기능을 공통된 방식으로 액세스할 수 있는 방법을 제공한다. 어떤 서비스를 선택하든 추상 계층으로만 작업하기에 상관없다. " }, { "title": "계층형 아키텍처 (Layered Architecture)", "url": "/posts/%EA%B3%84%EC%B8%B5%ED%98%95-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-(Layered-Architecture)/", "categories": "디자인 패턴, 아키텍처 패턴", "tags": "design pattern", "date": "2023-07-08 00:00:00 +0900", "snippet": "계층형 아키텍처 (Layered Architecture) 시스템의 구성 요소들을 서로 다른 계층(Layer)으로 분리하여 구성하는 가장 보편적인 아키텍처 패턴 각 계층은 특정 역할과 책임에만 집중하며, 정해진 규칙에 따라 인접한 계층과만 상호작용한다. 이 패턴의 핵심 목표는 관심사의 분리(Separation of Concerns)다. 예를 들어, 화면에 보이는 UI 로직과 실제 게임 규칙 로직, 그리고 데이터를 저장하는 로직을 뒤섞는 대신, 각각을 별개의 층으로 분리하여 코드의 재사용성과 유지보수성을 높이는 것이다. 가장 일반적인 형태는 3계층 아키텍처(3-Tier Architecture)다. 프레젠테이션 계층 (Presentation Layer): 사용자에게 보여지는 부분. (UI, 렌더링) 비즈니스 로직 계층 (Business Logic Layer): 시스템의 핵심 규칙과 로직. (게임 규칙, 상태 관리) 데이터 접근 계층 (Data Access Layer): 데이터의 저장과 조회. (파일 저장/불러오기, 데이터베이스) 시나리오: 간단한 RPG 게임의 구조 플레이어의 정보를 관리하고, 아이템을 획득하며, 게임을 저장하는 간단한 RPG 게임을 만든다고 가정하자.문제점: 스파게티 코드 (Spaghetti Code) 계층 구분이 없다면, 모든 코드가 한 곳에 뒤섞이기 쉽다.// 안티 패턴: 모든 로직이 한 클래스에 섞여있음class Monster {public: void Die() { // 게임 규칙 로직 player.experience += 100; player.gold += 50; // 프레젠테이션(UI) 로직 ShowDeathAnimation(); UpdateQuestUI(\"몬스터 처치: 1/10\"); // 데이터 접근 로직 // 파일에 플레이어 데이터를 직접 쓴다. ofstream file(\"savegame.dat\"); file &lt;&lt; player.experience &lt;&lt; \",\" &lt;&lt; player.gold; }}; 이런 코드는 몬스터가 죽는 로직을 바꾸고 싶을 뿐인데, UI나 파일 저장 방식까지 신경 써야 한다. 테스트는 거의 불가능하며, 코드를 재사용하거나 확장하는 것은 재앙에 가깝다.해결책: 역할에 따른 계층 분리 이 문제를 해결하기 위해, 게임 시스템을 3개의 계층으로 명확하게 나눈다.1. 프레젠테이션 계층 (Presentation Layer) 이 계층은 오직 보여주고 입력받는 역할만 책임진다. 게임이 내부적으로 어떻게 동작하는지는 전혀 알지 못한다.// Presentation Layerclass GameUI {private: GameLogic&amp; game; // 핵심 로직 계층에 대한 참조만 가짐public: GameUI(GameLogic&amp; logic) : game(logic) {} void Render() { // game 객체로부터 데이터를 '요청'하여 화면에 그린다. cout &lt;&lt; \"플레이어 HP: \" &lt;&lt; game.GetPlayerHealth() &lt;&lt; endl; } void OnAttackButtonPressed() { // 사용자 입력을 핵심 로직 계층으로 '전달'할 뿐이다. game.ExecutePlayerAttack(); }}; GameUI는 GameLogic을 호출할 수는 있지만, GameLogic이 GameUI를 직접 호출하는 일은 절대 없다.2. 비즈니스 로직 계층 (Game Logic Layer) 게임의 모든 규칙과 핵심 로직을 담당한다. 이 계층은 게임의 ‘두뇌’다. UI가 버튼으로 만들어졌는지, 데이터가 파일에 저장되는지 알 필요가 없다.// Business Logic Layerclass GameLogic {private: DataAccess&amp; data; // 데이터 접근 계층에 대한 참조 Player player;public: GameLogic(DataAccess&amp; data_layer) : data(data_layer) {} void ExecutePlayerAttack() { // 게임 규칙을 처리한다. Monster* target = FindClosestMonster(); if (target) { player.Attack(target); } } void SaveGame() { // 데이터 저장이 필요할 때 데이터 접근 계층에 '요청'한다. data.SavePlayerData(player.GetData()); } void LoadGame() { PlayerData loaded_data = data.LoadPlayerData(); player.ApplyData(loaded_data); } int GetPlayerHealth() const { return player.GetHealth(); }}; GameLogic은 상위 계층인 Presentation 계층에 대해 전혀 모르며, 하위 계층인 Data Access 계층의 인터페이스에만 의존한다.3. 데이터 접근 계층 (Data Access Layer) 이 계층의 유일한 책임은 데이터를 저장하고 불러오는 것이다. 이 데이터가 게임 캐릭터의 정보인지, 설정 값인지조차 알 필요가 없다.// Data Access Layerclass DataAccess {public: void SavePlayerData(const PlayerData&amp; data) { // 데이터를 파일이나 DB에 쓰는 로직에만 집중한다. cout &lt;&lt; \"데이터를 파일에 저장합니다...\" &lt;&lt; endl; // ofstream file(\"save.json\"); // file &lt;&lt; ConvertToJson(data); } PlayerData LoadPlayerData() { cout &lt;&lt; \"파일에서 데이터를 불러옵니다...\" &lt;&lt; endl; // ... return {}; }};계층 간 상호작용 규칙 이 구조의 핵심 규칙은 의존성의 방향이 단방향으로만 흐른다는 것이다. Presentation → Game Logic → Data Access 상위 계층은 바로 아래 하위 계층에만 의존할 수 있다. 하위 계층은 절대로 상위 계층에 대해 알거나 참조해서는 안 된다. 이 ‘엄격한’ 규칙 덕분에 각 계층은 독립적인 부품처럼 교체하거나 테스트할 수 있게 된다. 예를 들어, 게임 저장 방식을 JSON에서 데이터베이스로 바꾸고 싶다면 DataAccess 계층만 수정하면 되며, 다른 계층은 전혀 영향을 받지 않는다.요약 계층형 아키텍처는 시스템을 논리적인 계층(Layer)으로 나누어, 각 계층이 특정 책임만 수행하도록 하는 패턴이다. 가장 중요한 원칙은 단방향 의존성이다. 상위 계층은 하위 계층에 의존할 수 있지만, 그 반대는 허용되지 않는다. 이를 통해 시스템의 각 부분이 독립적으로 개발, 테스트, 수정될 수 있게 되어 코드의 결합도는 낮아지고(Loose Coupling), 응집도는 높아진다(High Cohesion). 장점 유지보수성: 특정 계층의 수정이 다른 계층에 미치는 영향을 최소화하여 유지보수가 용이하다. 테스트 용이성: 각 계층을 독립적으로 테스트할 수 있다. 예를 들어, GameLogic을 테스트할 때 실제 DB 대신 가짜 DataAccess 객체를 주입할 수 있다. 재사용성 및 확장성: 각 계층은 독립적인 모듈이므로 다른 프로젝트에서 재사용하기 쉽고, 새로운 기능을 추가할 때도 해당 계층에만 집중하면 된다. 분업 용이: 팀을 나누어 프론트엔드(프레젠테이션) 개발자와 백엔드(로직, 데이터) 개발자가 각자의 계층을 병렬로 개발할 수 있다. 대부분의 소프트웨어 시스템은 명시적으로든 암묵적으로든 이 계층형 아키텍처를 기반으로 설계된다. 이는 복잡한 시스템을 체계적으로 구성하는 가장 기본적이고 강력한 방법 중 하나다. " }, { "title": "멀티 플레이어 테스트", "url": "/posts/%EB%A9%80%ED%8B%B0%ED%94%8C%EB%A0%88%EC%9D%B4%EC%96%B4-%ED%85%8C%EC%8A%A4%ED%8A%B8/", "categories": "unreal, multi", "tags": "unreal", "date": "2023-07-08 00:00:00 +0900", "snippet": "에디터에서 멀티플레이어 테스트하기 프로젝트를 생성하고 Play 가장 우측에 점모양 버튼을 눌러 가장 밑에 있에 멀티플레이어 관련 옵션이 있다.사진 플레이어의 수는 1부터 4까지 가능하고 클라이언트 안에 수만큼 생성된다. 넷 모드는 총 3가지 옵션이 있다. Play Standalone Play As Listen Server Play As Client Play Standalone Dedicated-Server를 생성하지 않고 독립적으로 실행Play As Listen Server Listen-Server로 실행 이 클라이언트가 서버 역할도 함 클라이언트 수에 따라 인스턴스를 추가한다. Shift + F1으로 다른 클라이언트로 변경한다. Play As Client Dedicated-Server를 실행한다. 생성한 Dedicated-Server에 연결할 클라이언트로 실행한다. 사진을 보면 Listen-Server와 달리 다른 클라이언트의 타이틀이 Client-1이 아닌 Client-2로 시작하는데 서버 역할을 하는 인스턴스가 따로 생성되기 때문이다. 위의 넷모드는 혼자서 멀티플레이어를 테스트하기 편한 환경이다. 다른 컴퓨터에 프로젝트를 패키지로 보내 테스트하기 위해서는 Lan을 연결해야 한다. Lan Connection Lan은 Local Area Network의 줄임말이다. 여러 대의 컴퓨터가 연결된 단일(Single) 라우터가 있다고 가정한다. 각 컴퓨터에는 자체 Local IP 주소가 있고 모두 같은 라우터에 연결되어 있어 Local IP 주소를 통해 같은 네트워크안의 다른 컴퓨터에 접속이 가능하다 맵 생성과 블루프린트 File -&gt; NewLevel로 새로운 레벨을 생성하고 File -&gt; Save Current Level을 통해 Lobby란 이름으로 저장한다.// 사진 이후에 Blueprint에서 1번 키로 Open Level 함수를 이용하여 새로운 레벨을 연다 Open Level 함수 Level Name은 열 맵의 이름 Absolute은 레벨의 옵션들을 Reset할지 선택하는 변수 Options travel URL로 사용할 옵션의 이름으로,위에선 listen으로 작성하여 Listen-Server로 열도록 설정했다. // C++ 버전// Character.h UFUNCTION(BlueprintCallable)void OpenLobby(); // Lobby 열기UFUNCTION(BlueprintCallable)void CallOpenLevel(const FString&amp; Address); // Level 열기UFUNCTION(BlueprintCallable)void CallClientTravel(const FString&amp; Address);// Character.cpp void AMenuSystemCharacter::OpenLobby(){ UWorld* World = GetWorld(); // Wolrd 객체 얻기 if(World) { // 3개의 인자로,첫 번째는 Level의 파일 경로를 얻어야한다 // 에디터에서 해당 Level을 우클릭하여 Copy File Path를 눌러 얻어올 수 있다. // C:/ ~ /Content까지 '/Game' 로 상대경로로 바꿀 수 있다 // 이후에 ? + 옵션(listen)으로 지정할 수 있다. World-&gt;ServerTravel(\"/Game/ThirdPerson/Maps/Lobby?listen\"); }}void AMenuSystemCharacter::CallOpenLevel(const FString&amp; Address){ // 해당 레벨 열기 UGameplayStatics::OpenLevel(this,*Address);}void AMenuSystemCharacter::CallClientTravel(const FString&amp; Address){ // PlayerController 얻기 APlayerController* PlayerController = GetGameInstance()-&gt;GetFirstLocalPlayerController(); if(PlayerController) { // ETravelType은 다른 레벨로 갈 때 유형 PlayerController-&gt;ClientTravel(Address, ETravelType::TRAVEL_Absolute); }} 2번 키는 콘솔 커맨드를 이용하여 Command에 Open + 127.0.0.1(IPv4 주소)를 작성하여 해당 컴퓨터의 IP 주소를 이용하여 접속하도록 설정한다.// C++ 버전// PlayerController 버전UGameplayStatics::GetPlayerController(this ,0)-&gt;ConsoleCommand(TEXT(\"Open 127.0.0.1\"));// GEngine 버전GEngine-&gt;Exec( GetWorld(), TEXT(\"Open 127.0.0.1\") ); Listen-Server를 열고 있는 클라이언트에서 1번을 눌러 Listen-Server 맵을 열고 다른 컴퓨터에서 이 프로젝트의 패키지를 실행한 후 2번을 눌러 접속할 수 있다." }, { "title": "방문자 패턴", "url": "/posts/%EB%B0%A9%EB%AC%B8%EC%9E%90-%ED%8C%A8%ED%84%B4/", "categories": "디자인 패턴, 행태 패턴", "tags": "design pattern", "date": "2023-07-07 00:00:00 +0900", "snippet": "방문자 패턴 실제 데이터 구조(객체들의 집합)와, 그 구조를 순회하며 수행할 처리 로직(알고리즘)을 분리하는 행위 디자인 패턴 이 패턴을 사용하면, 데이터 구조를 변경하지 않고도 새로운 연산(기능)을 쉽게 추가할 수 있다. ‘방문자(Visitor)’라는 객체가 데이터 구조의 각 요소를 ‘방문’하면서, 각 요소에 맞는 특정 작업을 수행하는 방식이다. 게임 씬(Scene)에 존재하는 다양한 오브젝트들을 JSON, XML 등 여러 포맷으로 저장하는 기능을 추가해야 할 때, 각 오브젝트 클래스에 SaveToJson(), SaveToXml() 같은 메서드를 일일이 추가하는 대신, JsonVisitor, XmlVisitor를 만들어 이 문제를 깔끔하게 해결할 수 있다.시나리오: 게임 씬(Scene)을 다양한 포맷으로 저장하기 게임 씬은 여러 종류의 노드(Node)들이 트리 구조(씬 그래프)를 이루고 있다고 가정하자. TransformNode: 다른 노드들을 자식으로 가질 수 있는 그룹 노드. 위치, 회전, 크기 정보를 가진다. MeshNode: 3D 모델을 나타내는 말단 노드(Leaf). LightNode: 광원을 나타내는 말단 노드. 이 씬 그래프 구조는 안정적이어서 거의 변하지 않지만, 앞으로 이 씬을 JSON, XML, 혹은 커스텀 바이너리 포맷 등 다양한 방식으로 저장하는 기능이 계속 추가될 예정이다. 문제점: 침습적 방식의 한계 가장 단순한 방법은 ISceneNode 인터페이스에 SaveToJson(), SaveToXml() 같은 가상 함수를 추가하고, 모든 하위 클래스에서 이를 구현하는 것이다.// 안티 패턴: 새로운 기능이 추가될 때마다 모든 클래스를 수정해야 한다.class ISceneNode {public: virtual void SaveToJson() = 0; virtual void SaveToXml() = 0; // ... 새로운 저장 포맷이 추가될 때마다 여기에 메서드가 늘어난다.}; 이 방식은 개방-폐쇄 원칙(OCP)을 위배한다. 새로운 저장 기능이 하나 추가될 때마다 ISceneNode를 포함한 모든 노드 클래스의 코드를 수정해야 한다. 또한 각 노드 클래스가 렌더링, 물리, 저장 등 너무 많은 책임을 지게 되어 단일 책임 원칙(SRP)도 위배한다.해결책: 방문자 패턴 도입 방문자 패턴은 이중 디스패치(Double Dispatch)라는 기법을 활용하여 이 문제를 해결한다. 이중 디스패치란, 프로그램의 실제 동작이 두 객체의 런타임 타입에 따라 결정되게 하는 것이다.1. 방문자(Visitor) 인터페이스 정의 먼저, 씬 그래프의 각 노드 타입을 ‘방문’할 수 있는 메서드를 가진 INodeVisitor 인터페이스를 정의한다.#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;// 전방 선언class TransformNode;class MeshNode;class LightNode;// 방문자 인터페이스: 방문할 모든 노드 타입에 대한 Visit 메서드를 정의한다.class INodeVisitor {public: virtual ~INodeVisitor() = default; virtual void Visit(TransformNode&amp; node) = 0; virtual void Visit(MeshNode&amp; node) = 0; virtual void Visit(LightNode&amp; node) = 0;};2. 데이터 구조에 Accept 메서드 추가 이제 각 노드 클래스가 방문자를 ‘받아들일’ 수 있도록 Accept 메서드를 추가한다. 이것이 이중 디스패치의 첫 번째 단계다.// 데이터 구조의 기본 인터페이스class ISceneNode {public: virtual ~ISceneNode() = default; // 모든 노드는 방문자를 받아들여야 한다. virtual void Accept(INodeVisitor&amp; visitor) = 0;};class MeshNode : public ISceneNode {public: // MeshNode는 방문자에게 \"나는 MeshNode야\"라고 알리며 자신을 전달한다. void Accept(INodeVisitor&amp; visitor) override { visitor.Visit(*this); // 이중 디스패치의 두 번째 단계 }};class TransformNode : public ISceneNode { /* ... */ void Accept(INodeVisitor&amp; visitor) override { visitor.Visit(*this); }};class LightNode : public ISceneNode { /* ... */ void Accept(INodeVisitor&amp; visitor) override { visitor.Visit(*this); }}; node-&gt;Accept(visitor)가 호출되면, 먼저 node의 실제 타입에 따라 올바른 Accept 메서드가 호출된다(첫 번째 디스패치). 그리고 그 Accept 메서드 안에서 visitor.Visit(*this)가 호출되는데, 이때 *this의 타입은 컴파일 타임에 확정되므로, INodeVisitor에 오버로딩된 Visit 메서드 중 정확한 타입의 것이 호출된다(두 번째 디스패치).3. 구체적인 방문자(Concrete Visitor) 구현 이제 새로운 ‘저장’ 기능을 별도의 방문자 클래스로 구현한다. ISceneNode 계층의 코드는 전혀 건드릴 필요가 없다.// 구체적인 방문자: JSON으로 저장하는 로직을 담당한다.class JsonSaveVisitor : public INodeVisitor {private: string json_output;public: void Visit(TransformNode&amp; node) override { json_output += \"{ \\\"type\\\": \\\"Transform\\\", \\\"children\\\": [\"; // 자식 노드들을 재귀적으로 방문한다. for (auto&amp; child : node.children) { child-&gt;Accept(*this); } json_output += \"] }\"; } void Visit(MeshNode&amp; node) override { json_output += \"{ \\\"type\\\": \\\"Mesh\\\", \\\"path\\\": \\\"\" + node.meshPath + \"\\\" }\"; } void Visit(LightNode&amp; node) override { json_output += \"{ \\\"type\\\": \\\"Light\\\", \\\"intensity\\\": \" + to_string(node.intensity) + \" }\"; } string GetResult() const { return json_output; }};4. 클라이언트 코드에서의 활용 클라이언트는 원하는 방문자 객체를 생성하고, 씬 그래프의 루트 노드에 전달하기만 하면 된다.int main() { // 1. 씬 그래프를 구성한다. auto scene_root = make_unique&lt;TransformNode&gt;(); scene_root-&gt;Add(make_unique&lt;MeshNode&gt;(\"player.obj\")); scene_root-&gt;Add(make_unique&lt;LightNode&gt;(1.5f)); // 2. JSON 저장 방문자를 생성하고 실행한다. JsonSaveVisitor json_visitor; scene_root-&gt;Accept(json_visitor); cout &lt;&lt; \"JSON 저장 결과: \" &lt;&lt; json_visitor.GetResult() &lt;&lt; endl; // 만약 XML 저장이 필요하다면? // XmlSaveVisitor xml_visitor; // scene_root-&gt;Accept(xml_visitor); // -&gt; 오직 새로운 방문자 클래스만 추가하면 된다!}현대적 대안: std::variant와 std::visit C++17 이상에서는 std::variant를 사용하여 방문자 패턴을 더 안전하고 간결하게 구현할 수 있다. variant는 타입 안전한 union으로, 정해진 타입 목록 중 하나를 저장할 수 있다.#include &lt;variant&gt;// 1. 상속 대신 variant로 노드 타입을 정의한다.using SceneNode = variant&lt;TransformNode, MeshNode, LightNode&gt;;// 2. 방문자는 각 타입에 대한 operator() 오버로드를 가진다.struct SaveVisitor { void operator()(const TransformNode&amp; node) { /* ... */ } void operator()(const MeshNode&amp; node) { /* ... */ } void operator()(const LightNode&amp; node) { /* ... */ }};int main() { SceneNode node = MeshNode{\"enemy.obj\"}; // 3. std::visit가 알아서 node의 현재 타입에 맞는 operator()를 호출해준다. std::visit(SaveVisitor{}, node);} 이 방식은 Accept 메서드를 추가하기 위해 데이터 구조를 수정할 필요가 없고, 컴파일 타임에 모든 타입을 처리하는지 검사할 수 있어 더 안전하다. 하지만 variant에 새로운 타입을 추가하는 것은 여전히 모든 방문자를 수정해야 하는 번거로움이 있다.요약 방문자 패턴은 데이터 구조와 이를 처리하는 알고리즘(연산)을 분리하는 강력한 패턴이다. 이 패턴을 사용하면, 기존 데이터 구조의 코드를 변경하지 않고도 새로운 연산을 쉽게 추가할 수 있다 (개방-폐쇄 원칙). 구성 요소: Element: 데이터 구조의 각 요소. 방문자를 받아들이는 Accept 메서드를 가진다. Visitor: 데이터 구조의 각 요소를 방문하는 Visit 메서드를 정의한 인터페이스. ConcreteVisitor: Visitor 인터페이스를 구현하여 실제 연산을 수행하는 클래스. 단점: 데이터 구조에 새로운 Element 타입을 추가하기가 어렵다. 새로운 요소가 추가되면 모든 Visitor 인터페이스와 구현체를 수정해야 하기 때문이다. 따라서 데이터 구조는 안정적이지만, 수행할 연산이 자주 변경되거나 추가될 때 가장 효과적이다." }, { "title": "멀티 플레이어 개념", "url": "/posts/%EB%A9%80%ED%8B%B0-%ED%94%8C%EB%A0%88%EC%9D%B4%EC%96%B4-%EA%B0%9C%EB%85%90/", "categories": "unreal, multi", "tags": "unreal", "date": "2023-07-06 00:00:00 +0900", "snippet": "싱글 플레이어 싱글 플레이어 게임은 한 컴퓨터에서 실행되는 하나의 게임 세션으로 구성된다. 한 컴퓨터에서 여러 입력 장치와 화면 분할로 게임을 구성할 순 있지만 이 유형에는 인터넷이 필요치 않다. 그리고 네트워크를 통해 다른 컴퓨터에서 실행되는 게임의 다른 인스턴스에게 정보를 전달할 필요가 없다. 이러한 유형을 로컬 멀티플레이어라고 한다. 멀티 플레이어 멀티 플레이어 게임은 두 개 이상의 인스턴스가 서로 다른 컴퓨터에서 실행된다. 두 플레이어가 게임 내 상황을 변경하기 위한 입력을 사용하기 때문에 최소 두 개의 게임 인스턴스가 별도의 컴퓨터에서 실행된다. 간단히 말해, 서로 다른 컴퓨터로 각자의 캐릭터를 조종하기 위한 입력을 의미 이때, 입력에 의해 변경된 정보는 게임 내의 다른 인스턴스(다른 컴퓨터)에게 전송되어야 한다. 1번 캐릭터가 움직이면 2번 컴퓨터에서 1번 캐릭터가 움직여야 한다. 게임 세션의 시스템 종류 게임 세션 간 정보 공유 시스템을 구축하는 방법은 여러가지가 있다. Peer-To-Peer Client-Server Peer-To-Peer 중앙 서버 없이 플레이어들 사이에 직접 통신을 수행하는 방식 가장 간단한 방법이면서 가장 구현하기 쉬운 시스템이다. 다른 인스턴스에게 정보를 보내주는 방식이다. 1번 플레이어가 움직이면 그 외 나머지 플레이어에게 1번 플레이어의 움직임 데이터를 전송 그런데 이러한 방식은 플레이어가 많으면 많을수록 효율이 떨어진다. 예를 들어 n명의 플레이어가 있다면, 한 플레이어가 나머지 n-1명의 플레이어에게 전송하는데 나머지도 이 행위를 반복하므로 총 (n-1)*n번 전송한다. Peer-To-Peer의 또 다른 문제점은 게임의 공식 버전(authoritative version)이 없다. 플레이어가 캐릭터를 움직이면, 해당 플레이어의 기기 버전은 다른 기기에서 실행중인 게임의 버전과 달라지며, 그 정보가 네트워크를 통해 다른 기기에서 실행 중인 게임을 업데이트하는데 시간이 걸리낟. 그러다 보니 어떤 게임 인스턴스을 기준으로 하는지 알 수 없게 된다. Client-Server 서버는 하나의 기기로만 설정되고, 나머지 기기는 클라이언트로 설정된다. 그리고 클라이언트는 서버와만 대화한다 즉, 클라이언트끼리는 정보를 주고 받을 수 없고 서버와만 정보를 송수신할 만큼 정도의 대역폭이 필요하다. 서버는 권위적인(authoritative) 역할이지만, 항상 그런 것은 아니다. 위의 말뜻은 서버는 권한은 많지만 서버의 버전을 올바른 버전으로 기준을 잡는다. 클라이언트가 서버에게 데이터를 보내면, 서버는 데이터가 올바른지 확인 후, 모든 클라이언트에게 데이터를 보내 업데이트를 한다. 이때 서버에서 클라이언트들에게 데이터를 보내는 것을 복제(replication)이라고 한다. 클라이언트 서버 모델 구현하는 방법 클라이언트 서버 모델을 구현하는 방법은 아래와 같이 있다. Listen-Server Dedicated-Server Authoritative Client-Server Listen-Server 클라이언트 중 하나가 서버 역할 서버 역할을 하는 플레이어가 게임을 하면,그래픽을 렌더링 하면서 기기들은 서버 역할을 하는 플레이어를 기준으로 업데이트를 진행한다. 서버 역할을 하는 플레이어는 서버에 요청할 필요가 없어 이점이 있다. 클라이언트 플레이어들은 서버에 요청을 보내고 데이터가 복제되기를 기다려야 한다. 소규모 게임에서는 미미하지만, 규모가 커질수록 데이터 복제에 시간과 비용이 커져 Dedicated-Server가 필요하게 됐다. Dedicated-Server 렌더링과 사용자 입력 처리를 전혀 하지 않고, 순전히 클라이언트의 연결을 받는 세션을 처리만 하는 역할 Dedicated-Server에서는 서버 기기의 버전을 기준으로 시뮬레이션을 처리하며 대규모 멀티플레이어 클라이언트를 복제할 수 있다. Authoritative Client-Server 언리얼 엔진은 Authoritative Client-Server를 사용한다 한 컴퓨터는 서버로 동작하고 다른 컴퓨터들은 클라이언트로 연결된다. 서버 버전은 권위적인 역할을 하며 항상 올바른 버전으로 여겨진다. 싱글 플레이어 게임에서 언리얼 엔진은 클라이언트와 서버가 같은 Client-Server 모델을 사용한다" }, { "title": "템플릿 메서드", "url": "/posts/%ED%85%9C%ED%94%8C%EB%A6%BF-%EB%A9%94%EC%84%9C%EB%93%9C-%ED%8C%A8%ED%84%B4/", "categories": "디자인 패턴, 행태 패턴", "tags": "design pattern", "date": "2023-07-05 00:00:00 +0900", "snippet": "템플릿 메서드 패턴 알고리즘의 뼈대(skeleton)를 상위 클래스에 정의하고, 알고리즘의 특정 단계들을 하위 클래스에서 재정의할 수 있도록 하는 행위 디자인 패턴 즉, 전체적인 알고리즘의 구조는 상위 클래스에서 결정하지만, 세부적인 내용은 하위 클래스가 구현하도록 책임을 위임하는 방식이다. 이를 통해 코드의 중복을 줄이고, 일관된 프로세스 내에서 다양한 변형을 쉽게 만들 수 있다.전략 패턴과의 차이점 이 패턴은 전략 패턴과 매우 유사하지만, 결정적인 차이가 있다. 전략 패턴: 구성(Composition)을 사용한다. 객체가 다른 ‘전략 객체’를 멤버로 포함하여 행동을 위임한다. 런타임에 전략을 교체할 수 있다. 템플릿 메서드 패턴: 상속(Inheritance)을 사용한다. 하위 클래스가 상위 클래스의 특정 메서드를 오버라이딩(overriding)하여 행동을 구체화한다. 행동은 컴파일 타임에 결정된다. 시나리오: 게임 캐릭터의 스킬(Ability) 시스템 구축 게임 캐릭터가 사용하는 다양한 스킬(“파이어볼”, “치유”, “강타”)을 구현해야 한다고 가정하자. 모든 스킬은 다음과 같은 공통된 실행 흐름을 가진다. 스킬을 사용할 수 있는지 확인한다 (쿨타임, 마나 등) 필요한 자원(마나, 기력 등)을 소모한다. 고유한 스킬 효과를 발동시킨다. (이 부분만 스킬마다 다르다!) 스킬의 쿨타임을 시작시킨다. 문제점: 보일러플레이트 코드의 중복 템플릿 메서드 패턴이 없다면, 모든 스킬 클래스마다 쿨타임 및 자원 소모를 확인하는 코드를 복사-붙여넣기 해야 한다.// 안티 패턴: 모든 스킬 클래스에 중복 코드가 발생class Fireball {public: void Execute() { if (cooldown &gt; 0) return; if (player.mana &lt; 20) return; player.mana -= 20; // --- 실제 파이어볼 효과 --- cout &lt;&lt; \"파이어볼 발사!\" &lt;&lt; endl; // ------------------------- cooldown = 5.0f; }};class Heal {public: void Execute() { if (cooldown &gt; 0) return; if (player.mana &lt; 30) return; player.mana -= 30; // --- 실제 치유 효과 --- cout &lt;&lt; \"체력 회복!\" &lt;&lt; endl; // ----------------------- cooldown = 10.0f; }}; 이 방식은 코드 중복이 심하고, 만약 공통 로직(예: 자원 소모 방식)이 변경되면 모든 스킬 클래스를 일일이 수정해야 하는 유지보수 악몽을 초래한다.템플릿 메서드 패턴 구현 이 문제를 해결하기 위해, 모든 스킬의 공통된 뼈대를 Ability라는 추상 상위 클래스에 정의한다.1. 추상 클래스(Abstract Class) 정의 Ability 클래스는 스킬 실행의 전체적인 흐름을 담는 템플릿 메서드(Execute)와, 하위 클래스가 구현해야 할 추상 단계(ApplyEffect)를 정의한다.#include &lt;iostream&gt;using namespace std;// 추상 클래스: 스킬의 공통적인 뼈대를 정의한다.class Ability {public: // 이것이 '템플릿 메서드'다. 알고리즘의 뼈대는 변경할 수 없다 (non-virtual). void Execute() { // 1. 공통 단계: 쿨타임 및 자원 확인 if (!isReady()) { cout &lt;&lt; \"[시스템] 스킬을 사용할 수 없습니다.\" &lt;&lt; endl; return; } // 2. 공통 단계: 자원 소모 ConsumeResources(); // 3. 변하는 단계: 실제 효과 적용 (하위 클래스에 위임) ApplyEffect(); // 4. 공통 단계: 쿨타임 시작 StartCooldown(); } virtual ~Ability() = default;protected: // 하위 클래스에서 재정의할 수 있는 '단계'들 (protected) virtual bool isReady() { /* 기본 쿨타임/자원 검사 로직 */ return true; } virtual void ConsumeResources() { /* 기본 자원 소모 로직 */ } virtual void StartCooldown() { /* 기본 쿨타임 설정 로직 */ } // 하위 클래스가 '반드시' 구현해야 하는 순수 가상 함수 virtual void ApplyEffect() = 0;}; Execute() 메서드가 바로 템플릿 메서드다. 이 메서드는 알고리즘의 전체 구조를 정의하며, 그 안에서 ApplyEffect()와 같은 추상 메서드를 호출하여 세부 내용을 하위 클래스에게 맡긴다.2. 구체적인 클래스(Concrete Class) 구현 이제 각 스킬은 Ability를 상속받고, 자신만의 고유한 ApplyEffect() 로직만 구현하면 된다.// 구체적인 클래스 1: 파이어볼class FireballAbility : public Ability {protected: void ApplyEffect() override { cout &lt;&lt; \"==&gt; 파이어볼이 맹렬한 불길과 함께 날아갑니다!\" &lt;&lt; endl; } // 필요하다면, 더 많은 자원을 소모하도록 재정의할 수도 있다. void ConsumeResources() override { cout &lt;&lt; \"(마나 30 소모)\" &lt;&lt; endl; }};// 구체적인 클래스 2: 치유class HealAbility : public Ability {protected: void ApplyEffect() override { cout &lt;&lt; \"==&gt; 부드러운 빛이 아군을 감싸며 체력을 회복시킵니다!\" &lt;&lt; endl; } void ConsumeResources() override { cout &lt;&lt; \"(마나 50 소모)\" &lt;&lt; endl; }}; FireballAbility와 HealAbility는 쿨타임이나 자원 확인 같은 공통 로직에 대해 전혀 신경 쓸 필요가 없다. 오직 자신의 핵심 역할인 ApplyEffect에만 집중하면 된다.3. 클라이언트 코드에서의 활용 클라이언트는 어떤 스킬이든 Ability 타입으로 다룰 수 있으며, Execute()를 호출하기만 하면 된다.#include &lt;vector&gt;#include &lt;memory&gt;int main() { vector&lt;unique_ptr&lt;Ability&gt;&gt; skill_bar; skill_bar.push_back(make_unique&lt;FireballAbility&gt;()); skill_bar.push_back(make_unique&lt;HealAbility&gt;()); cout &lt;&lt; \"1번 스킬 사용:\" &lt;&lt; endl; skill_bar[0]-&gt;Execute(); // 파이어볼 실행 cout &lt;&lt; \"\\n2번 스킬 사용:\" &lt;&lt; endl; skill_bar[1]-&gt;Execute(); // 치유 실행} 클라이언트는 Execute()를 호출할 뿐, 그 안에서 어떤 복잡한 단계들이 어떤 순서로 실행되는지는 알 필요가 없다. 모든 것은 Ability 베이스 클래스가 정의한 ‘템플릿’을 따른다.요약 템플릿 메서드 패턴은 상속을 기반으로, 알고리즘의 뼈대는 상위 클래스에, 세부 내용은 하위 클래스에 정의하는 방식이다. 상위 클래스의 템플릿 메서드는 알고리즘의 전체 구조를 제어하며, 이 구조는 하위 클래스에서 변경할 수 없다. 하위 클래스는 템플릿 메서드가 호출하는 특정 단계(primitive operations)들을 오버라이딩하여 알고리즘을 커스터마이징한다. 하위 클래스에서 반드시 구현해야 하는 단계는 순수 가상 함수로, 선택적으로 구현할 수 있는 단계는 가상 함수(hook)로 제공할 수 있다. 이 패턴은 여러 클래스에 걸쳐 나타나는 코드 중복을 효과적으로 제거하고, 프레임워크나 라이브러리에서 전체적인 작업 흐름을 정의하고 사용자가 특정 부분만 채워 넣도록 유도할 때 매우 유용하다. " }, { "title": "Camera와 SpringArm", "url": "/posts/Camera-%EC%99%80-SpringArm/", "categories": "unreal, Basic", "tags": "unreal", "date": "2023-07-05 00:00:00 +0900", "snippet": "Camera 플레이어의 시점을 나타내기 위해 사용되는 것으로, CameraComponent로 만들어 사용한다. 카메라의 기본 설정으로는 Projection Mode와 FOV가 있다. Projection Mode Projection Mode는 카메라의 타입을 나타낸다. Perspective는 원근 투영으로, 원근법을 살려서 물체의 거리에 따라 크기를 조절한다. 카메라 Orthographic은 직교 투영으로, 원근감없이 수직에서 내려보는 듯하게 투영한다. 미니맵, 설계도 FOV 시야각을 나타내는 용어로, Field Of View의 줄임말이다. 이 값의 크기는 카메라의 시야 범위를 결정한다 FOV 값이 클수록 시야가 커지고,작을수록 시야가 작아진다. SprignArm Pawn에 붙이는 Camera를 위한 컴포넌트로, Camera의 위치를 조절하기 위한 컴포넌트로 생각하면 된다. SpringArm의 장점 카메라의 위치, 길이, 회전 속도, 충돌 처리 방식, 흔들림 등을 조절할 수 있다. 만약 스프링암에 연결된 Camera와 Pawn 사이에 오브젝트가 충돌된다면 SpringArm이 충돌된 오브젝트 앞까지 이동한다. SpringArm에 붙어있는 기능으로, Target Arm Length으로 SpringArm에 붙어있는 카메라와 Pawn사이의 거리를 조절할 수 있다. Target Arm Length는 카메라로 확대하거나 축소할 때 사용한다. 코드// Character.hUPROPERTY(VisibleAnywhere, Category = \"Camera\")UCameraComponent* ViewCamera;UPROPERTY(VisibleAnywhere, Category = \"Camera\")USpringArmComponent* CameraBoom;// Character.cpp#include \"Camera/CameraComponent.h\"#include \"GameFramework/SpringArmComponent.h\"APlayerCharacter::APlayerCharacter(){ ... // CreateDefaultSubobject&lt;Type&gt; 함수로 Component 생성 // 인자에 TEXT를 넣어 이름을 부여할 수 있다. CameraBoom = CreateDefaultSubobject&lt;USpringArmComponent&gt;(TEXT(\"CameraBoom\")); // RootComponent는 상위 컴포넌트로, World에 있는 Actor의 Transform값을 가진다. // 다른 하위 컴포넌트는 RootComponent에 상대적인 위치값을 가진다. CameraBoom-&gt;SetupAttachment(GetRootComponent()); // SpringArm의 끝에 있는 카메라와 Pawn의 거리 CameraBoom-&gt;TargetArmLength = CameraDist; // Pawn의 회전값을 SpringArm에도 적용시킨다. CameraBoom-&gt;bUsePawnControlRotation = true; ViewCamera = CreateDefaultSubobject&lt;UCameraComponent&gt;(TEXT(\"ViewCamera\")); // 카메라는 RootComponent가 아닌 SpringArm의 위치값에 따라 상대적이여야 하므로 // RootComponent가 아닌 SpringArm에 부착시킨다. ViewCamera-&gt;SetupAttachment(CameraBoom);}" }, { "title": "Enhanced Input", "url": "/posts/Enhanced-Input/", "categories": "unreal, Basic", "tags": "unreal", "date": "2023-07-04 00:00:00 +0900", "snippet": "Enhanced Input Enhanced Input은 언리얼 엔진5에서 기존의 Input 기능 대신 새로 나온 Input 기능시작하기 먼저 언리얼 엔진 버전에 따라 플러그인의 설치가 다르다. 만약 안되어 있다면 편집 -&gt; 플러그인으로 가서 다음 사진과 같이 체크버튼을 눌러야 한다. 그러고 나서 에디터창에서 다시 편집 -&gt; 프로젝트 세팅으로 가서 다음과 같이 엔진 카테고리에서 입력으로 들어가고 Default Classes를 찾아 다음과 같이 변경해야 한다.핵심 컨셉 Enhanced Input의 시스템에서 4가지 메인 컨셉이 있다. 입력 액션 입력 액션 컨텍스트 입력 모디파이어 입력 트리거 입력 액션(Input Action) 입력 액션은 해당 키를 눌렀을 때 사용할 함수를 할당하기 위해 사용한다. 입력 액션의 값 타입에는 Digital(bool),Axis1D(float), Axis2D(Vector2D) ,Axis3D(Vector3D)가 있다. 값 타입은 해당 입력 액션을 키를 눌러 입력했을 때 반환하는 값의 타입으로, 괄호 안에 있는 타입으로 사용된다. 예를 들어, 버튼처럼 사용하려면 Digital(bool)을 사용하고 방향키(WASD)나 조이스틱같은 입력 장치를 사용할 때는 Axis2D(Vector2D)를 사용한다. Axis2D의 좌표값은 -1 ~ 1 사이의 실수값으로 나타나고 수평과 수직방향 값으로 사용된다. X축 값은 왼쪽으로 이동하면 -1, 오른쪽으로 이동하면 1에 가까워지고 Y축 값은 아래로 이동하면 -1, 위로 이동하면 1에 가까워진다. 아무것도 누르지 않는다면 X축 Y축 둘 다 0으로 나타난다. 입력 맵핑 컨텍스트(Input Mapping Context) 입력 맵핑 컨텍스트(Input Mapping Context)는 사용자의 입력을 입력 액션으로 매핑한다. 컨텍스트는 사용자별로 추가하거나 삭제할 수 있고 우선순위를 지정할 수 있다. 향상된 입력 로컬 플레이어 서브시스템(Enhanced Input Local Player Subsystem)을 통해 하나 이상의 컨텍스트를 로컬 플레이어에게 적용하고 우선 순위를 지정해 동일한 입력을 사용하고자 하는 여러 액션 사이의 충돌을 처리할 수 있다. 입력 트리거 상태(Input Trigger State) 입력 트리거 상태는 입력 이벤트가 발생한 순간에 대한 상태를 나타낸다. enum class인 ETriggerEvent에 멤버로 있으며, 입력 액션이 바인딩된 입력 트리거에 충족하면 입력 액션이 활성화된다. - None은 아무것도 누르지 않은 상태1. Triggered : 아래와 같은 상태로 변할 때(None -&gt; Triggered, Ongoing -&gt; Triggered, Triggered -&gt; Triggered)1. Started : 키를 누른 그 프레임에 발동(None -&gt; Ongoing, None -&gt; Triggered)1. Ongoing : 누르고 있던 키를 계속 누를 때(Ongoing -&gt; Ongoing)1. Completed : 누르고 있던 키를 뗐을 때(Ongoing -&gt; None)1. Canceled : 트리거 상태가 끝났을 때(Triggered -&gt; None)입력 모디파이어(Input Modifier) 입력 액션에 추가적인 특성을 부여하여 다양한 상호작용을 가능하게 해주는 기능 모디파이어에서 주로 사용하는 것은 Negate과 스위즐 입력 축 값이 있다. 스위즐 입력 축 값으로 입력 값을 Y축 값으로 변경할 수 있다. Negate을 이용하여 해당 입력의 부정(+면 -)값을 얻을 수 있다. C++에서 mapping context를 플레이어에 추가하는 코드 C++ 코드에서 플레이어가 Enhanced Input을 사용하기 위해서는 사전 작업이 필요하다. Actor 클래스에서도 되지만, 해당 Actor의 PlayerController 클래스에서도 할 수 있다. // 플레이어로 사용할 캐릭터의 BeginPlayvoid APlayerCharacter::BeginPlay(){\t// Call the base class \tSuper::BeginPlay();\t//Add Input Mapping Context\tif (APlayerController* PlayerController = Cast&lt;APlayerController&gt;(Controller))\t{\t\tif (UEnhancedInputLocalPlayerSubsystem* Subsystem =\t\t ULocalPlayer::GetSubsystem&lt;UEnhancedInputLocalPlayerSubsystem&gt;\t\t \t\t\t\t\t\t\t\t(PlayerController-&gt;GetLocalPlayer()))\t\t{\t\t\tSubsystem-&gt;AddMappingContext(DefaultMappingContext, 0);\t\t}\t}}C++에서 입력 액션 바인딩 UEnhancedInputComponent의 변수와 BindAction 함수를 이용하여 입력 액션을 바인딩한다. FInputActionValue으로 입력 값을 받아와 템플릿 함수인 Get을 이용하여 값을 변경하여 사용한다. 매개 변수의 순서는 바인딩할 입력 액션, 트리거 이벤트, 바인딩할 객체, 바인딩할 함수이다. // 가상 함수인 SetupPlayerInputComponent을 이용한다.void APlayerCharacter::SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent){\tif (UEnhancedInputComponent* EnhancedInputComponent = CastChecked&lt;UEnhancedInputComponent&gt;(PlayerInputComponent)) {\t\t// 점프\t\tEnhancedInputComponent-&gt;BindAction(JumpAction, ETriggerEvent::Triggered,\t\t\t\t\t\t\t\t\t\t\tthis, &amp;ACharacter::Jump);\t\tEnhancedInputComponent-&gt;BindAction(JumpAction, ETriggerEvent::Completed,\t\t\t\t\t\t\t\t\t\t\tthis,&amp;ACharacter::StopJumping);\t\t//Moving\t\tEnhancedInputComponent-&gt;BindAction(MoveAction, ETriggerEvent::Triggered,\t\t\t\t\t\t\t\t\t\t\tthis, &amp;APlayerCharacter::Move);\t\t//Looking\t\tEnhancedInputComponent-&gt;BindAction(LookAction, ETriggerEvent::Triggered,\t\t\t\t\t\t\t\t\t\t\tthis, &amp;APlayerCharacter::Look);\t}}// AddMovementInput는 캐릭터의 이동을 조작하는 데 사용하는 함수void APlayerCharacter::Move(const FInputActionValue&amp; Value){\t// input is a Vector2D\tFVector2D MovementVector = Value.Get&lt;FVector2D&gt;();\tif (Controller != nullptr)\t{\t\t// find out which way is forward\t\tconst FRotator Rotation = Controller-&gt;GetControlRotation();\t\tconst FRotator YawRotation(0, Rotation.Yaw, 0);\t\t// get forward vector\t\tconst FVector ForwardDirection = \t\t\t\tFRotationMatrix(YawRotation).GetUnitAxis(EAxis::X);\t\t\t// get right vector \t\tconst FVector RightDirection = \t\t\t\tFRotationMatrix(YawRotation).GetUnitAxis(EAxis::Y);\t\t// add movement \t\tAddMovementInput(ForwardDirection, MovementVector.Y);\t\tAddMovementInput(RightDirection, MovementVector.X);\t}}// AddControllerYawInput \t함수는 캐릭터의 수평 회전(Yaw)을 조작// AddControllerPitchInput \t함수는 캐릭터의 수직 회전(Pitch)을 조작void APlayerCharacter::Look(const FInputActionValue&amp; Value){\t// input is a Vector2D\tFVector2D LookAxisVector = Value.Get&lt;FVector2D&gt;();\tif (Controller != nullptr)\t{\t\t// add yaw and pitch input to controller\t\tAddControllerYawInput(LookAxisVector.X);\t\tAddControllerPitchInput(LookAxisVector.Y);\t}}" }, { "title": "전략 패턴", "url": "/posts/%EC%A0%84%EB%9E%B5-%ED%8C%A8%ED%84%B4/", "categories": "디자인 패턴, 행태 패턴", "tags": "design pattern", "date": "2023-07-02 00:00:00 +0900", "snippet": "전략 패턴 유사한 행동(알고리즘)들을 별개의 클래스로 캡슐화하고, 이들을 동적으로 교체할 수 있도록 만드는 행위 디자인 패턴 어떤 작업을 수행하는 방법(전략)이 여러 가지일 때, 각 방법을 독립적인 ‘전략 객체’로 정의한다. 그리고 이 전략들을 사용하는 ‘컨텍스트(Context)’ 객체는 구체적인 전략의 내용을 알 필요 없이, 추상적인 인터페이스를 통해 전략을 실행한다. 이를 통해 클라이언트(컨텍스트)의 코드를 전혀 변경하지 않고도, 런타임에 행동(알고리즘)을 자유롭게 바꾸거나 새로운 행동을 추가할 수 있다.시나리오: 다양한 길 찾기(Pathfinding) 알고리즘 사용하기 게임 속 AI 유닛이 맵 상에서 특정 목적지까지 이동하는 길 찾기 기능을 구현해야 한다. 길 찾기에는 여러 알고리즘이 있으며, 각각 장단점이 있다. A* (에이스타) 알고리즘: 최적의 최단 경로를 보장하지만, 계산량이 많아 다소 느릴 수 있다. Dijkstra (다익스트라) 알고리즘: 특정 지점에서 다른 모든 지점까지의 최단 경로를 계산할 때 유용하다. Greedy Best-First Search: 매우 빠르지만, 최단 경로를 보장하지는 않는다. 상황에 따라 AI가 다른 길 찾기 전략을 사용하게 하고 싶다. 예를 들어, 전투 중에는 정확한 최단 경로를 위해 A*를 사용하고, 평시의 장거리 이동에는 속도가 빠른 Greedy 알고리즘을 사용하고 싶다.문제점: 거대한 조건문 전략 패턴이 없다면, AIAgent 클래스의 FindPath() 메서드 내부는 거대한 if-else 또는 switch 문으로 가득 차게 된다.// 안티 패턴: 모든 알고리즘 로직이 하나의 클래스에 얽혀있음class AIAgent {private: PathfindingAlgorithm current_algorithm;public: Path FindPath(Point start, Point end) { if (current_algorithm == A_STAR) { // A* 알고리즘 로직 ... } else if (current_algorithm == DIJKSTRA) { // 다익스트라 알고리즘 로직 ... } else if (current_algorithm == GREEDY) { // Greedy 알고리즘 로직 ... } // 새로운 알고리즘을 추가하려면 이 함수를 계속 수정해야 한다. }}; 이 코드는 새로운 알고리즘을 추가하거나 기존 알고리즘을 수정할 때마다 AIAgent 클래스를 직접 건드려야 한다. 이는 개방-폐쇄 원칙(OCP)에 위배되며, 코드를 복잡하고 경직되게 만든다.동적 전략 (Dynamic Strategy) 런타임에 알고리즘을 교체할 수 있는 고전적인 전략 패턴 구현 방식이다.1. 전략(Strategy) 인터페이스 정의 모든 길 찾기 알고리즘이 따라야 할 공통 인터페이스를 정의한다.#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;// 모든 길 찾기 전략이 구현해야 할 공통 인터페이스class IPathfindingStrategy {public: virtual ~IPathfindingStrategy() = default; virtual vector&lt;Point&gt; FindPath(Point start, Point end) const = 0;};2. 구체적인 전략(Concrete Strategy) 구현 각 알고리즘을 이 인터페이스를 구현하는 별도의 클래스로 캡슐화한다.// A* 알고리즘 전략class AStarStrategy : public IPathfindingStrategy {public: vector&lt;Point&gt; FindPath(Point start, Point end) const override { cout &lt;&lt; \"A* 알고리즘으로 최단 경로를 탐색합니다.\" &lt;&lt; endl; // ... 실제 A* 로직 ... return {}; // 실제 경로 반환 }};// Greedy 알고리즘 전략class GreedyStrategy : public IPathfindingStrategy {public: vector&lt;Point&gt; FindPath(Point start, Point end) const override { cout &lt;&lt; \"Greedy 알고리즘으로 빠른 경로를 탐색합니다.\" &lt;&lt; endl; // ... 실제 Greedy 로직 ... return {}; }};3. 컨텍스트(Context) 구현 AIAgent는 이제 길 찾기 알고리즘의 구체적인 내용을 알지 못한다. 단지 IPathfindingStrategy 인터페이스를 통해 전략을 실행할 뿐이다.#include &lt;memory&gt;// 컨텍스트: 전략을 사용하는 주체class AIAgent {private: unique_ptr&lt;IPathfindingStrategy&gt; path_strategy;public: // 생성 시 기본 전략을 설정하거나, 외부에서 주입받을 수 있다. AIAgent() : path_strategy(make_unique&lt;AStarStrategy&gt;()) {} // 런타임에 전략을 교체하는 메서드 void SetStrategy(unique_ptr&lt;IPathfindingStrategy&gt; new_strategy) { path_strategy = move(new_strategy); } void PlanMove(Point destination) { cout &lt;&lt; \"\\n목적지까지의 이동 계획 수립 시작...\" &lt;&lt; endl; // 실제 길 찾기는 현재 설정된 전략 객체에 위임한다. auto path = path_strategy-&gt;FindPath(GetCurrentPosition(), destination); // ... 계산된 경로를 따라 이동 ... } Point GetCurrentPosition() const { return {}; }};4. 클라이언트 코드에서의 활용 이제 AI의 상태에 따라 동적으로 길 찾기 전략을 변경할 수 있다.int main() { AIAgent agent; // 평시에는 빠른 Greedy 전략 사용 agent.SetStrategy(make_unique&lt;GreedyStrategy&gt;()); agent.PlanMove({100, 200}); // 전투 상황이 되면 정확한 A* 전략으로 변경 agent.SetStrategy(make_unique&lt;AStarStrategy&gt;()); agent.PlanMove({50, 60});} AIAgent의 코드를 전혀 수정하지 않고도, 새로운 길 찾기 알고리즘을 추가(새로운 IPathfindingStrategy 구현)하거나 런타임에 교체할 수 있게 되었다.정적 전략 (Static Strategy) 런타임에 전략을 변경할 필요가 없고, 컴파일 타임에 전략이 고정되는 경우 C++ 템플릿을 이용한 정적 전략을 사용할 수 있다. 이 방식은 가상 함수 호출에 따른 오버헤드가 없어 성능상 이점이 있다.1. 템플릿 기반 컨텍스트 구현 AIAgent를 템플릿 클래스로 만들고, 전략 타입을 템플릿 인자로 받는다.template &lt;typename T_Strategy&gt;class AIAgent_Static {private: T_Strategy path_strategy; // 전략 객체를 포인터가 아닌 멤버로 직접 가짐public: void PlanMove(Point destination) { cout &lt;&lt; \"\\n(정적 전략) 목적지까지의 이동 계획 수립...\" &lt;&lt; endl; auto path = path_strategy.FindPath(GetCurrentPosition(), destination); } Point GetCurrentPosition() const { return {}; }};2. 클라이언트 코드에서의 활용 사용할 전략에 따라 서로 다른 타입의 AIAgent_Static 객체를 생성해야 한다.int main() { // A* 전략을 사용하는 전투 유닛 타입 AIAgent_Static&lt;AStarStrategy&gt; combat_unit; combat_unit.PlanMove({50, 60}); // Greedy 전략을 사용하는 민간인 유닛 타입 AIAgent_Static&lt;GreedyStrategy&gt; civilian_unit; civilian_unit.PlanMove({100, 200}); // combat_unit.SetStrategy(...) // 런타임에 전략 교체 불가} 이 방식은 런타임 유연성은 없지만, 전략이 고정된 객체에 대해서는 더 높은 성능을 제공할 수 있다.요약 전략 패턴은 행동(알고리즘)을 독립적인 클래스로 캡슐화하여, 이들을 사용하는 클라이언트와 분리하는 패턴이다. 동적 전략: 실행 중에 객체의 행동을 자유롭게 교체할 수 있어 유연성이 높다. 정적 전략: 컴파일 타임에 행동이 결정되며, 가상 함수 오버헤드가 없어 성능에 유리하다. 이 패턴을 사용하면 거대한 조건문을 제거하고 개방-폐쇄 원칙(OCP)을 준수할 수 있다. 즉, 새로운 전략(행동)을 추가할 때 기존 코드를 수정할 필요가 없다. 게임 개발에서 AI의 행동 패턴, 정렬 방식, 렌더링 기법, 공격 패턴 등 동일한 목적에 대해 여러 가지 방법(전략)이 존재할 때, 전략 패턴은 코드를 유연하고 확장 가능하게 만드는 매우 효과적인 도구다. " }, { "title": "Actor && Pawn && Character", "url": "/posts/Actor-&&-Pawn-&&-Character/", "categories": "unreal, Basic", "tags": "unreal", "date": "2023-07-01 00:00:00 +0900", "snippet": "Actor 레벨에 배치할 수 있는 오브젝트이며 어떤 의미로는 컴포넌트라는 타입의 오브젝트들을 담는 컨테이너라고 생각하면 된다. 기본적으로 이동, 회전, 스케일과 같은 3D Transform을 지원한다 Actor 클래스의 인스턴스를 생성하기 위해서는 SpawnActor 템플릿을 사용 주요 Component UActorComponent : 기본 컴포넌트. 특정 액터와 연결되어 사용하지만 월드에는 존재하는 형태는 아니다 USceneComponent : Transform을 갖고 있는 Actor Component. Scene Component는 계층형 방식으로 Attach가 가능하다 UPrimitiveComponent : Mesh,Particle 같은 그래픽 표현이 있는 Scene Component, Physics나 Collision도 있다. Root Component : Root역할을 하는 Component. Actor의 위치,스케일,회전은 Root SceneComponent에서 가져온다. Pawn 플레이어나 AI 가 제어할 수 있는 모든 Actor의 Base 클래스 플레이어나 AI 개체의 시각적인 모습 뿐만 아니라, 콜리전이나 기타 물리적 반응과 같은 측면에서 월드와의 상호작용 방식도 Pawn 이 규정한다 Controller ` Pawn (폰) 또는 Character (캐릭터)처럼 Pawn에서 파생된 클래스를 빙의(possess)하여 그 동작을 제어할 수 있는, 눈에 보이지는 않는 액터` 기본적으로 컨트롤러와 폰에는 1:1 대응 관계인 즉, 컨트롤러는 단 하나의 폰만 제어한다. 제어중인 폰에 발생하는 다수의 이벤트에 대한 알림을 받아서 그 이벤트에 대해 반응하여, 해당 이벤트를 가로채고 폰의 기본 동작을 대체하는 동작을 구현할 수 있는 기회를 얻습니다. 컨트롤러는 주어진 폰보다 먼저 틱을 시켜 인풋 처리와 폰 이동 사이의 지연시간을 최소화하는 것이 가능합니다. Character 걸어다닐 수 있는 능력을 지닌 특수 유형의 Pawn CharacterMovementComponent, CapsuleComponent,SkeletalMeshComponent 의 추가를 통해 월드에서 걷기, 달리기, 점프, 비행, 수영 등이 가능한 직립 플레이어를 표현하기 위해 디자인된 Pawn이다. SkeletalMeshComponent 고급 애니메이션을 위해 스켈레톤 Mesh를 사용CapsuleComponent 이동 Collision에 사용하기 위한 컴포넌트 CharacterMovementComponent 에서 사용되는 복잡한 Geomerty 계산은 이 Capsule 모양의 컴포넌트를 통해서 계산한다. CharacterMovementComponent Avatar가 걷기, 달리기, 점프, 낙하, 수영 등으로 이동할 때 Rigid body Physics를 사용하지 않아도 된다. CharacterMovementComponent 에 설정할 수 있는 프로퍼티에는 낙하와 걷기의 마찰력, 공기와 물과 땅을 가로지르는 이동 속력, 부력, 중력 스케일, 캐릭터가 피직스 오브젝트에 행사할 수 있는 물리력 등에 대한 값이 포함된다. CharacterMovementComponent 는 애니메이션으로부터 오는 루트 모션 파라미터도 포함하며, 피직스로 사용할 수 있도록 이미 월드 스페이스에서 트랜스된다. " }, { "title": "상태 패턴", "url": "/posts/%EC%83%81%ED%83%9C-%ED%8C%A8%ED%84%B4/", "categories": "디자인 패턴, 행태 패턴", "tags": "design pattern", "date": "2023-06-29 00:00:00 +0900", "snippet": "상태 패턴 객체의 내부 상태(State)가 바뀜에 따라, 객체의 행동(Behavior)이 마치 클래스가 바뀐 것처럼 달라지게 하는 행위 디자인 패턴 if-else나 switch 문으로 상태에 따른 모든 행동을 분기 처리하는 복잡한 조건문을 피하고, 상태 자체를 객체로 캡슐화하는 것이 이 패턴의 핵심이다. 객체는 현재 자신의 상태를 나타내는 ‘상태 객체’를 참조하며, 실제 행동은 이 상태 객체에 위임한다. 게임 개발에서는 캐릭터나 몬스터의 AI, 플레이어의 조작 상태(서있기, 달리기, 점프 등), 게임의 국면(메뉴, 플레이 중, 게임 오버) 등을 관리하는 상태 머신(Finite State Machine, FSM)을 구현할 때 이 패턴이 핵심적인 역할을 한다.시나리오: 간단한 몬스터 AI 구현하기 순찰(Patrol), 추격(Chase), 공격(Attack) 세 가지 상태를 가지는 간단한 몬스터 AI를 구현해야 한다. 순찰: 평소에는 정해진 경로를 따라 순찰한다. 추격: 플레이어가 일정 거리 안에 들어오면 플레이어를 쫓아간다. 공격: 플레이어가 공격 범위 안에 들어오면 공격한다. 문제점: 복잡한 조건문 상태 패턴이 없다면, Monster의 Update() 메서드는 수많은 if-else 문으로 가득 차게 된다.// 안티 패턴: 모든 상태 로직이 하나의 메서드에 얽혀있음void Monster::Update() { float distance_to_player = GetDistanceToPlayer(); if (distance_to_player &gt; SIGHT_RANGE) { // 순찰 로직... } else if (distance_to_player &gt; ATTACK_RANGE) { // 추격 로직... // 만약 체력이 20% 이하면 도망가는 로직 추가? if (health &lt; 0.2f) ... } else { // 공격 로직... } // ... 새로운 상태 '도망'이 추가되면 이 코드는 더욱 끔찍해진다.} 이 코드는 새로운 상태가 추가되거나 상태 전환 조건이 복잡해질수록 가독성과 유지보수성이 급격히 떨어진다.해결책 1: 간단한 상태 머신 (Enum과 Switch문) 게임 개발 현장에서 가장 흔히 사용되는 간단한 상태 머신 구현 방식이다.1. 상태(State)와 몬스터(Context) 정의 먼저 몬스터가 가질 수 있는 상태들을 enum class로 명확하게 정의한다.#include &lt;iostream&gt;using namespace std;enum class AIState { Patrolling, Chasing, Attacking};class Monster {private: AIState current_state = AIState::Patrolling; // 각 상태에 해당하는 행동 메서드 void UpdatePatrol() { cout &lt;&lt; \"[순찰] 어슬렁거린다.\" &lt;&lt; endl; // 플레이어가 시야에 들어오면 추격 상태로 전환 if (IsPlayerInSight()) { cout &lt;&lt; \"플레이어 발견! 추격 시작!\" &lt;&lt; endl; current_state = AIState::Chasing; } } void UpdateChase() { cout &lt;&lt; \"[추격] 플레이어를 향해 달려간다.\" &lt;&lt; endl; // 플레이어가 공격 범위에 들어오면 공격 상태로 전환 if (IsPlayerInAttackRange()) { cout &lt;&lt; \"공격 범위에 들어왔다! 공격!\" &lt;&lt; endl; current_state = AIState::Attacking; } // 플레이어가 시야에서 벗어나면 순찰 상태로 복귀 else if (!IsPlayerInSight()) { cout &lt;&lt; \"플레이어를 놓쳤다. 순찰로 복귀.\" &lt;&lt; endl; current_state = AIState::Patrolling; } } void UpdateAttack() { /* 공격 로직 및 상태 전환 */ }public: void Update() { // 현재 상태에 따라 적절한 행동 메서드를 호출 switch (current_state) { case AIState::Patrolling: UpdatePatrol(); break; case AIState::Chasing: UpdateChase(); break; case AIState::Attacking: UpdateAttack(); break; } } // 예시를 위한 더미 함수 bool IsPlayerInSight() { /* ... */ return true; } bool IsPlayerInAttackRange() { /* ... */ return false; }}; Update() 메서드는 더 이상 복잡한 조건문 대신, 현재 상태(current_state)에 따라 적절한 Update…() 메서드를 호출하는 깔끔한 switch문으로 바뀐다. 상태에 따른 행동과 상태 전환 로직이 각 Update…() 메서드 안에 캡슐화되어 이전보다 훨씬 구조화된 코드가 되었다.해결책 2: 클래스 기반 상태 패턴 (GoF 방식) 상태가 더 복잡해지고, 각 상태가 고유한 데이터와 복잡한 로직을 가져야 할 때는 각 상태를 별도의 클래스로 만드는 것이 더 효과적이다. 이것이 디자인 패턴의 교과서(GoF)에서 제안하는 방식이다.1. 상태(State) 인터페이스와 구체적인 상태 클래스 정의 모든 상태 클래스가 구현해야 할 공통 인터페이스 IState를 정의한다.#include &lt;memory&gt;class Monster; // 전방 선언// 상태의 공통 인터페이스class IState {public: virtual ~IState() = default; // 이 상태에 진입할 때 호출될 메서드 virtual void Enter(Monster&amp; monster) {} // 매 프레임 실행될 메서드 virtual void Execute(Monster&amp; monster) = 0; // 이 상태를 떠날 때 호출될 메서드 virtual void Exit(Monster&amp; monster) {}}; 이제 각 AI 상태를 이 인터페이스를 구현하는 별도의 클래스로 만든다.// 구체적인 상태 클래스들class PatrolState : public IState {public: void Execute(Monster&amp; monster) override { cout &lt;&lt; \"[순찰] 어슬렁거린다.\" &lt;&lt; endl; if (monster.IsPlayerInSight()) { // 몬스터에게 상태를 변경하라고 요청한다. monster.ChangeState(make_unique&lt;ChaseState&gt;()); } }};class ChaseState : public IState {public: void Enter(Monster&amp; monster) override { cout &lt;&lt; \"플레이어 발견! 추격 시작!\" &lt;&lt; endl; } void Execute(Monster&amp; monster) override { cout &lt;&lt; \"[추격] 플레이어를 향해 달려간다.\" &lt;&lt; endl; if (!monster.IsPlayerInSight()) { monster.ChangeState(make_unique&lt;PatrolState&gt;()); } }}; 컨텍스트(Context) 클래스 수정 Monster 클래스는 이제 상태를 나타내는 enum 대신, 현재 상태 객체에 대한 포인터를 가진다.// 컨텍스트 클래스: 현재 상태를 관리하고, 행동을 상태 객체에 위임한다.class Monster {private: unique_ptr&lt;IState&gt; current_state;public: Monster() { // 초기 상태를 설정한다. current_state = make_unique&lt;PatrolState&gt;(); current_state-&gt;Enter(*this); } void ChangeState(unique_ptr&lt;IState&gt; new_state) { current_state-&gt;Exit(*this); current_state = move(new_state); current_state-&gt;Enter(*this); } void Update() { // 모든 행동을 현재 상태 객체에 위임한다. current_state-&gt;Execute(*this); } // 더미 함수 bool IsPlayerInSight() { return true; }}; 이제 Monster의 Update() 메서드는 current_state-&gt;Execute(*this); 단 한 줄로 극도로 단순해졌다. 모든 복잡한 로직은 각 …State 클래스 내부로 완전히 캡슐화되었다. 새로운 상태 ‘도망(FleeState)’을 추가하고 싶다면, IState를 상속받는 FleeState 클래스 하나만 새로 만들면 되며, 기존 코드는 전혀 수정할 필요가 없다. 이는 개방-폐쇄 원칙(OCP)을 잘 따르는 구조다.요약 상태 패턴은 객체가 자신의 내부 상태에 따라 행동을 바꾸도록 하는 패턴으로, 복잡한 조건 분기문을 효과적으로 대체한다. enum과 switch를 이용한 간단한 상태 머신: 구현이 쉽고 직관적이어서 간단한 상태 관리에 매우 효과적이다. 하지만 상태가 많아지고 복잡해지면 관리하기 어려워질 수 있다. 클래스 기반의 상태 패턴: 각 상태를 별도의 클래스로 캡슐화하여, 상태별 행동과 데이터를 완벽하게 분리한다. 이는 복잡한 상태를 가진 객체를 설계할 때 확장성과 유지보수성을 크게 향상시킨다. 어떤 방식을 선택할지는 시스템의 복잡도에 따라 다르지만, 두 방식 모두 상태에 따른 객체의 행동을 체계적으로 구성하여 코드의 품질을 높이는 강력한 도구다. " }, { "title": "관찰자 패턴", "url": "/posts/%EA%B4%80%EC%B0%B0%EC%9E%90-%ED%8C%A8%ED%84%B4/", "categories": "디자인 패턴, 행태 패턴", "tags": "design pattern", "date": "2023-06-25 00:00:00 +0900", "snippet": "옵저버 패턴 한 객체(주체, Subject)의 상태가 변할 때, 그 객체에 의존하는 다른 객체들(옵저버, Observer)에게 변화를 자동으로 알려주고 업데이트하는 행위 디자인 패턴 이는 ‘일대다(one-to-many)’ 의존 관계를 정의하는 가장 대표적인 방법이다. 주체는 자신을 관찰하는 옵저버가 누구인지, 몇 명인지 알 필요 없이 그저 “나의 상태가 변했다!”고 방송(broadcast)만 하면 된다. 그러면 이 방송을 ‘구독’하고 있던 모든 옵저버가 각자 알아서 필요한 동작을 수행한다. 이 패턴의 핵심 목표는 주체와 옵저버 간의 결합도를 낮추는 것이다. 이를 통해 시스템을 유연하고 확장 가능하게 만들 수 있다. 유튜브 채널을 ‘구독’하면 새 영상이 올라올 때마다 알림이 오는 것이 바로 이 패턴의 완벽한 실생활 예시다.시나리오: 플레이어 체력과 UI 연동하기 게임에서 플레이어의 체력이 변할 때마다 화면의 체력 바(Health Bar) UI가 실시간으로 갱신되어야 한다고 가정해보자.1. 주체(Subject) 정의 상태 변화가 일어나는 주체는 Player 클래스다. Player는 자신의 체력(health)을 멤버 변수로 가진다.#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Player {private: int health;public: Player() : health(100) {} void TakeDamage(int damage) { health -= damage; if (health &lt; 0) health = 0; cout &lt;&lt; \"[Player] 데미지를 입었습니다! 현재 체력: \" &lt;&lt; health &lt;&lt; endl; // 체력이 변경되었음을 '누군가'에게 알려야 한다. } int GetHealth() const { return health; }};2. 문제점: 강한 결합 가장 단순한 방법은 Player가 HealthBarUI 객체를 직접 참조하여 Update 메서드를 호출하는 것이다.// 안티 패턴: 주체와 옵저버의 강한 결합class Player {private: HealthBarUI* healthBar; // UI 객체를 직접 참조public: void TakeDamage(int damage) { health -= damage; // ... // UI의 업데이트 메서드를 직접 호출한다. healthBar-&gt;UpdateDisplay(health); }}; 이 방식은 Player라는 핵심 게임 로직이 HealthBarUI라는 UI의 구체적인 구현에 강하게 결합(Tightly Coupled)되게 만든다. 만약 체력이 변할 때 사운드도 재생해야 하고, 화면에 붉은색 이펙트도 띄워야 한다면? Player 클래스는 SoundSystem, ScreenEffectSystem 등 온갖 다른 시스템들을 직접 참조해야 하고, 코드는 금세 스파게티처럼 엉망이 될 것이다.해결책: 옵저버 패턴으로 분리하기 옵저버 패턴은 이 문제를 깔끔하게 해결한다. C++에는 내장된 이벤트 시스템이 없으므로, Boost.Signals2와 같은 검증된 라이브러리를 사용하는 것이 일반적이고 효과적이다. 이 라이브러리는 시그널(Signal)과 슬롯(Slot) 개념을 제공한다. 시그널(Signal): 주체가 발생시키는 이벤트. “상태가 변했다!”는 방송 채널이다. 슬롯(Slot): 시그널에 연결(connect)되는 함수. 이벤트가 발생했을 때 실행될 콜백 함수다. 1. 주체(Subject)에 시그널 추가하기 Player 클래스에 체력이 변경되었음을 알리는 OnHealthChanged 시그널을 추가한다.#include &lt;boost/signals2.hpp&gt;class Player {private: int health;public: // 시그널 정의: int 타입(현재 체력)을 인자로 받는 이벤트를 발생시킨다. boost::signals2::signal&lt;void(int)&gt; OnHealthChanged; Player() : health(100) {} void TakeDamage(int damage) { health -= damage; if (health &lt; 0) health = 0; cout &lt;&lt; \"[Player] 데미지를 입었습니다! 현재 체력: \" &lt;&lt; health &lt;&lt; endl; // 체력이 변경되었음을 시그널을 통해 방송한다. // 누가 이 방송을 듣는지는 전혀 신경 쓰지 않는다. OnHealthChanged(health); } int GetHealth() const { return health; }};2. 옵저버(Observer)가 시그널을 구독하기 이제 Player의 상태 변화에 반응해야 하는 옵저버들을 구현한다. 이들은 Player를 직접 아는 대신, Player의 시그널에 자신의 함수(슬롯)를 연결(구독)하기만 하면 된다.// 옵저버 1: 체력 바 UIclass HealthBarUI {public: // 생성 시, 관찰할 Player의 시그널에 자신의 멤버 함수를 연결(구독)한다. HealthBarUI(Player&amp; player) { player.OnHealthChanged.connect( [this](int newHealth) { this-&gt;UpdateDisplay(newHealth); } ); } void UpdateDisplay(int health) { cout &lt;&lt; \"[HealthBar UI] 체력 바 갱신 -&gt; \" &lt;&lt; health &lt;&lt; \"%\" &lt;&lt; endl; }};// 옵저버 2: 사운드 시스템class SoundSystem {public: SoundSystem(Player&amp; player) { player.OnHealthChanged.connect( [](int newHealth) { // 체력이 50 미만이면 경고음 재생 if (newHealth &lt; 50) { cout &lt;&lt; \"[Sound System] 위험! 경고음 재생!\" &lt;&lt; endl; } } ); }};3. 전체적인 흐름 이제 모든 컴포넌트는 서로를 모른 채, 오직 Player의 OnHealthChanged 시그널을 통해 상호작용한다.int main() { Player player; // 옵저버들을 생성한다. 생성자에서 자동으로 player의 이벤트를 구독한다. HealthBarUI healthBar(player); SoundSystem soundSystem(player); cout &lt;&lt; \"--- 게임 시작 ---\" &lt;&lt; endl; player.TakeDamage(20); // player는 단지 TakeDamage를 호출할 뿐이다. cout &lt;&lt; endl; player.TakeDamage(40);}실행 결과--- 게임 시작 ---[Player] 데미지를 입었습니다! 현재 체력: 80[HealthBar UI] 체력 바 갱신 -&gt; 80%[Player] 데미지를 입었습니다! 현재 체력: 40[HealthBar UI] 체력 바 갱신 -&gt; 40%[Sound System] 위험! 경고음 재생! Player는 HealthBarUI나 SoundSystem의 존재를 전혀 알지 못하지만, 이들은 Player의 상태 변화에 완벽하게 반응한다. 이것이 옵저버 패턴을 통한 느슨한 결합(Loose Coupling)의 힘이다.고급 주제: 스레드 안정성과 수신 해제 std::vector&lt;IObserver*&gt;와 같은 방식으로 옵저버 패턴을 직접 구현하면 스레드 안정성이나 재진입성(옵저버가 알림을 받는 도중 스스로를 구독 해제하는 문제) 등 까다로운 문제에 직면하게 된다. Boost.Signals2와 같은 라이브러리는 이러한 문제들을 내부적으로 처리해준다. 스레드 안전성: 여러 스레드에서 동시에 시그널에 연결하거나 이벤트를 발생시켜도 안전하게 동작한다. 자동 수신 해제: connect 메서드는 connection 객체를 반환한다. 이 객체를 저장해두었다가 connection.disconnect()를 호출하면 안전하게 구독을 해제할 수 있다. 옵저버 객체가 소멸될 때 이 connection 객체도 함께 소멸되게 하면, 죽은 객체에 대한 알림 전송을 자동으로 방지할 수 있다. 요약 옵저버 패턴은 한 객체(주체)의 상태 변화를 여러 다른 객체(옵저버)들에게 알리기 위한 구독 메커니즘을 제공한다. 이 패턴의 핵심은 주체와 옵저버 간의 결합도를 낮추는 것이다. 주체는 옵저버의 구체적인 내용을 알 필요 없고, 옵저버들은 주체에 영향을 주지 않고 자유롭게 추가되거나 제거될 수 있다. C++에서는 Boost.Signals2와 같은 시그널/슬롯 라이브러리를 활용하면 스레드 안정성 등 복잡한 문제를 고려하지 않고도 강력한 옵저버 패턴을 쉽게 구현할 수 있다. 옵저버 패턴은 UI와 데이터 모델의 동기화, 게임 내 각종 이벤트 시스템, 로그 시스템 등 “어떤 일이 발생했을 때, 여러 곳에 알려야 한다”는 요구사항이 있는 거의 모든 곳에서 사용되는 필수적인 디자인 패턴이다. " }, { "title": "언리얼 프레임워크", "url": "/posts/%EC%96%B8%EB%A6%AC%EC%96%BC-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC/", "categories": "unreal, Basic", "tags": "unreal", "date": "2023-06-25 00:00:00 +0900", "snippet": "언리얼의 게임 루프 기본적인 게임 프로그램은 시작하면 초기화 작업을 하고 플레이어가 플레이할 때 동안 실행된다.// 기본적인 게임 프로그램 방식int main(){ init(); // 초기화 while(!g_exit_requested) // 종료전까지 Loop { // 매 프레임마다 실행 poll_input(); // 입력 update(); // 업데이트 render(); // 렌더링 } shutdown(); // 종료} 하지만 언리얼엔진은 코드에서 직접적으로 GameLoop를 다루지 못한다. 개발자들은 언리얼 엔진 코드에서 main 함수로 시작하지 않고, GameMode의 하위 클래스를 정의해서 가상함수를 오버라이딩해서 시작한다. 그리고 액터나 컴포넌트 클래스의 BeginPlay나 Tick 함수같은 가상함수를 다뤄서 자기 자신의 Logic에 추가할 수 있다 // 언리얼 엔진의 AGameModeBase 클래스class ENGINE_API AGameModeBase : public AInfo{\tGENERATED_UCLASS_BODY()public: // 게임 초기화 함수 // InitGame event는 다른 함수보다 먼저 호출된다. virtual void InitGame(const FString&amp; MapName, const FString&amp; Options, FString&amp; ErrorMessage); ...}; 언리얼 엔진은 소스코드를 제공하고, 그 소스 코드는 여러 방향으로 확장되기 좋게 작성되었다. 심지어 초보자라면, 언리얼 엔진의 프레임워크를 클래스들로 적절하게 이해할 수 있다. GameMode, GameState, PlayerController, Pawn, PlayerState 등등 언리얼 엔진 코드의 main함수(Winmain)를 찾아가면 게임코드가 실제로 실행되는 코드 진입점(entry point)을 찾기 힘들다. 다양한 플랫폼이나, 다양한 빌드를 지원하기 위한 복잡한 컴파일이나, 쓰레드등 여러가지를 객체 지향의 추상화로 빌드된 “game loop”가 이것들을 관리한다 #include \"LaunchEngineLoop.h\"//전역 변수FEngineLoop GEngineLoop; // Game Loop를 담당하는 클래스bool GIsRequestingExit = false; // 끝났는지 체크/*GuardedMain는 게임의 진입점(entry point) 역할을 하는 함수 - 역할1. 엔진 초기화 : 게임 엔진의 서브시스템 및 모듈 초기화, 설정 파일 로드2. 커맨드 라인 인수 처리 : 명령어로 엔진 설정 반영(게임 설정 추가한다거나 등)3. 메인 루프 관리 : 게임 엔진의 로직을 관리하고 프레임을 업데이트 루프를 실행하면서 입력 처리,물리 시뮬레이션,그래픽 렌더링 등 수행4. 에러 처리 : 예외 처리와 에러 로깅을 담당 예외나 오류를 처리하고, 필요하면 로그에 기록하여 디버깅에 도움을 줌*/int32 GuardedMain(const TCHAR* CmdLine){ // 엔진 모듈을 Load하고 early 초기화 실행 int32 ErrorLevel = GEngineLoop.PreInit(CmdLine); if(ErrorLevel != 0 || GIsRequestingExit) { return ErrorLevel; } // UEngine을 만들고 초기화, late 초기화 실행, 게임 시작 ErrorLevel = GEngineLoop.Init(); // 매 프레임마다 실행 : 렌더링 시작, 엔진 tick 함수 실행, RHI 업데이트 // RHI : 렌더링 API 의 인터페이스로, 그래픽 프로그래밍에 있어 또 하나의 핵심 모듈 while(!GIsRequestingExit) { GEngineLoop.Tick(); }} PreInit에서 대부분의 모듈을 로딩한다. 몇몇 모듈은 필수적이고, 몇몇은 특정 플랫폼이나 특정 상황을 위한 모듈등이 있다. 모듈 시스템이 이러한 모듈들을 관리하고 개발자가 필요한 구성(configuration)만 로딩할 수 있다. PreInit Engine Loop이 시작해서 PreInit 단계에서는 하위(low-level) 모듈을 로드하고 필수 시스템과 필수 타입들이 정의된다. 그러고 나서 프로젝트나 플러그인에 있는 모듈이 로드한다. 그 후에 대부분의 상위 모듈을 로드한다. 모듈이 로드될 때 모듈에서 정의된 클래스들을 UObject로 엔진에 등록한다. Reflection System이 이 클래스들을 알 수 있게 만든다. 등록한 각각의 클래스들을 CDO(class default object)로도 생성한다. CDO는 클래스의 기본 상태(default state)를 기록(record)한 것으로, 상속을 위한 프로토타입으로 사용 커스텀 클래스(Actor,GameMode등)를 만들면서 클래스 앞에 UCLASS()를 붙이면 Engine Loop가 그 클래스들의 기본 객체(default intance)로 할당한다. 즉, 언리얼 엔진은 이 클래스들의 생성자들로 CDO를 만든다. 언리얼 엔진의 생성자는 특정 객체를 수정하는 것이 목적이 아닌 CDO를 위한 초기화 작업 함수 그래서 언리얼 엔진에서는 게임과 관련된 코드를 생성자에서 초기화하지 않고 보통 Init이나 BeginPlay를 이용한다. 모듈의 모든 클래스들을 등록한 후 모듈의 StartupModule()이라는 함수가 모듈의 라이프사이클과 관련된 초기화 작업을 수행하기 위해 사용되며 그에 매칭되는 ShutdownModule() 함수를 제공한다.결론 PreInit 단계에서는 엔진에 필요한 프로젝트,플러그인,모듈등을 로드하고 그 안의 클래스들을 등록하여 하위(low-level) 시스템에서 초기화된다. PreInit() 단계가 끝나면 Init() 단계로 넘어간다. Init Engine Loop의 Init 함수는 비교적 간단하다. 간단하게 표현하자면, UEngine이라는 클래스에게 처리를 넘긴다고 볼 수 있다. 들어가기에 앞서, 소문자로 이루어진 engine이라는 단어는 일반적으로 직접 작성하지 않은 코드들로 이루어진 실행 프로그램(the executable)를 의미하고대문자가 들어간 Engine이라는 단어는 UEngine의 객체를 의미한다. UEditorEngine이나 UGameEngine 등등.. // 실제로 소스 코드를 보면 훨씬 길고 예외처리나 매크로등 많다..int32 FEngineLoop::Init(){ // Load the UGameEngine class that`s specified in the Engine config file // GameEngine에서 사용할 클래스를 알아내기 위헤 Engine config file를 체크함 FString GameEngineClassName;\tGConfig-&gt;GetString(TEXT(\"/Script/Engine.Engine\"), TEXT(\"GameEngine\"), GameEngineClassName, GEngineIni);\tEngineClass = StaticLoadClass(UGameEngine::StaticClass(), nullptr, *GameEngineClassName); // Create a new UGameEngine and enshrine it as the global UEngine object // UGameEngine을 생성하고 전역 변수인 UEngine 객체에 저장(enshirne:안치하다) GEngine = NewObject&lt;UEngine&gt;(GetTransientPackage(), EngineClass); // Initialize the engine : this creates UGameInstance and UGameViewportClient // 엔진 초기화 작업 GEngine-&gt;ParseCommandline(); GEngine-&gt;Init(this);\t// Call init callbacks // 전역 델리게이트로 엔진이 초기화됐음을 알림\tFCoreDelegates::OnPostEngineInit.Broadcast(); // Load all the post-engine init modules // late loading으로 구성된 프로젝트나 플러그인,모듈을 로딩 IProjectManager::Get().LoadModulesForProject(ELoadingPhase::PostEngineInit);IPluginManager::Get().LoadModulesForEnabledPlugins(ELoadingPhase::PostEngineInit); // 게임 시작 GEngine-&gt;Start(); GIsRunning = true; // 전역변수 FCoreDelegates::OnFEngineLoopInitComplete.Broadcast(); return 0;}URL Engine은 클라이언트로 연결할 서버 주소 혹은 로드할 맵의 이름을 나타내는 URL를 찾을(Browse) 수 있다. URL은 거기에다가 다른 인자들을 가지고 있다. 이러한 URL들을 빌드하거나 커맨드 라인에 입력하면 서버에 접속하거나 맵을 로드할 수 있다. Init(Engine-Object 생성) Engine은 맵을 로드하기전에 초기화하고 중요한 객체들(UGameInstance, UGameViewportClient, LocalPlayer등)를 생성한다.void UGameEngine::Init(IEngineLoop* InEngineLoop){ UEngine::Init(InEngineLoop); // Create a UGameInstance using the class specified by project config FSoftClassPath GameInstanceClassName = GetDefault&lt;UGameMapsSetting&gt;()-&gt;GameInstanceClass; UClass* GameInstance = LoadObject&lt;UClass&gt;(nullptr, *GameInstanceClassName.ToString()); GameInstance = NewObject&lt;UGameInstance&gt;(this, GameInstanceClass); // Create FWorldContext and dummy UWorld; initialize subsystems GameInstance-&gt;InitializeStandalone(); // Create a UGameViewportClient and initialize it UGameViewportClient* ViewportClient = NewObject&lt;UGameViewportClient&gt;(this, GameViewportClientClass); ViewportClient-&gt;Init(*GameInstance-&gt;GetWorldContext(), GameInstance); GameViewport = ViewportClient; GameInstance-&gt;GetWorldContext()-&gt;GameViewport = ViewportClient; CreateGameViewport(ViewportClient); //Create a ULocalPlayer and associate it with the viewport client FString Error; ViewportClient-&gt;SetupInitialLocalPlayer(Error); UGameViewportClient::OnViewportCreated().Broadcast(); // Done; now we`re ready to load PostEngineInit modules and start the game UE_LOG(LogInit, Display, TEXT(\"Game Engine Initialized.\")); bIsInitialized = true;} LocalPlayer는 스크린 앞에 앉아있는 유저를 의미 ViewportClient는 스크린 그자체를 의미 ViewportClient는 기본적으로 렌더링을 위한 상위(high-level) 인터페이스로 오디오,입력 시스템등 유저와 엔진 사이의 인터페이스 UGameInstance 클래스는 4.4버전부터 추가된 것으로, UGameEngine에서 분리되어 이전에 엔진에서 처리하던 프로젝트의 특정 기능(일부)를 처리하기 위한 클래스이다.LoadMap(Game-Object 생성) 위와 같이 엔진이 초기화되고 나서 UGameInstance, UGameViewportClient, ULocalPlayer을 생성하고 나서 게임이 시작할 준비가 됐다. 그리고 나서 UEngine::LoadMap 함수가 호출하면 다음과 같은 과정이 발생한다. ULevel, AActor, UActorComponent등을 포함하고 있는 UWorld를 생성 그 후에 게임 프레임워크의 핵심 actor인 AGameModeBase, AGameSession, AGameStateBase, AGameNetworkManager, APlayerController, APlayerState, APawn를 새로 생성한다. Engine Object와 Game Object의 차이점 중 핵심 요소(key factor)는 life-time이다. Engine Object들은 맵이 로드되기 전에 로드하고, Game Object들은 맵이 로드된 후에 로드한다. Game Object들은 맵이 있을 때만 존재하고 만약 새로운 맵이 로드하거나 다른 서버에 연결한다면 현재 맵에 있는 Game Object들은 파괴되고 UWorld는 삭제(clean)된다. bool UEngine::LoadMap(FWorldContext&amp; WorldContext, FURL URL, class UPendingNetGame* Pending, FString&amp; Error){ // Let any interested parties know that the current world is about to be unloaded // 맵의 변화에 관해 델리게이트 호출 FCoreUObjectDelegates::PreLoadMap.BroadCast(URL.map); /* Omitted : - Destroy player-controlled Pawns and PlayerControllers - Route the EndPlay event to all actors - Clean up the world, destroy all actors */ // Cache the current time so we can report total duration post-load double StartTime = FPlatformTime::Seconds(); // Notify the GameInstance of the map change in case it wants load assets WorldContext.OwningGameInstance-&gt;PreloadContentForURL(URL); // Load our persistent level`s map package and get the top-level UWorld UPackage* WorldPackage = LoadPackage(nullptr, *URL.Map, LOAD_None); UWorld* NewWorld = UWorld::FindWorldInPackage(WorldPackage); // Give the world a reference to the GameInstance NewWorld-&gt;SetGameInstance(WorldContext.OwningGameInstance); GWorld = NewWorld; // Take the raw, just-loaded UWorld and get it ready for gameplay WorldContext.SetCurrentWorld(NewWorld); WorldContext.World()-&gt;WorldType = WorldContext.WorldType; WorldContext.World()-&gt;AddToRoot(); WorldContext.World()-&gt;InitWorld(); // AI,Physics,navigation,audio WorldContext.World()-&gt;SetGameMode(URL); // Load any per-map packages and make sure \"always loaded\" sub-levels are fully loaded const FName Tag = WorldContext.World()-&gt;PersistentLevel-&gt;GetOutermost()-&gt;GetName(); LoadPackagesFully(WorldContext.World(), FULLYLOAD_Map, Tag); WorldContext.World()-&gt;FlushLevelStreaming(EFlushLevelStreamingType::Visibility); // Register components, then initialize all actors and their components { FRegisterComponentContext Context(WorldContext.World()); WorldContext.World()-&gt;InitializeActorsForPlay(URL, true, &amp;Context); Context.Process(); } // Spawn play actor (i.e. PlayerControllers) for all active local players for(auto It = WorldContext.OwningGameInstance-&gt;GetLocalPlayerIterator(); It; ++IT) { FString Error2; (*It)-&gt;SpawnPlayActor(URL.ToString(1), Error2, WorldContext.World()); } // Route the BeginPlay event to indicate that all actors are present and initialized WorldContext.World()-&gt;BeginPlay(); // Fire another delegate to let listeners know that the map change is done FCoreUObjectDelegates::PostLoadMapWithWorld.Broadcast(WorldContext.World()); // Report how it took to load the map, and notify the GameInstance as well double StopTime = FPlatformTime::Seconds(); UE_LOG(LogLoad, Log, TEXT(\"Took %f seconds to LoadMap(%s)\"), StopTime - StartTime, *URL.Map); WorldContext.OwningGameInstance-&gt;LoadComplete(StopTime - StartTime, *URL.Map); return true;} UWorldContext는 Engine 초기화 중, GameInstance가 생성되면서 만들어진다. UWorldContext는 현재 로드된 맵을 추적(keep track)하는 영구적인 오브젝트 아무것도 로드되지 않았을 때, GameInstance는 원하는 에셋을 미리 로드할 수 있지만, 기본적으로는 혼자선 아무것도 하지 않는다. PreloadContentForURL() 함수 에디터에는 메모리에 로드된 UWorld가 있고 그 밑에 Actor와 ActorComponent를 담고있는 ULevel이 있다. 맵을 저장할 때에는 World,Level,Actor 모두 포함하여 map Package인 UPackage에 직렬화(serialized)하고 디스크에 umap 포맷으로 저장된다. 그래서 이렇게 만든 umap 파일로 로드할 수 있다. LoadPackage() 함수 그 다음 GameInstance의 참조를 UWorld 객체에 주고 전역 변수인 GWorld에 초기화한다. SetGameInstance() 함수 그리고 UWorld는 WorldContext에 들어가고(install) World에 대한 설정을 한다. SetGameMode() 함수에서 AGameModeBase 액터를 World에 생성시킨다. 일단 GameMode가 나타나면(exist), 항상 로드되어 있는 모든 서브레벨(any always-loaded sublevels are loaded in)이 레퍼런스 에셋과 함께 나타난다. 그 다음에 InitializeActorsForPlay 이 함수는 현재 World에 필요한 Actor와 Component를 가져온다. World는 모든 Actor를 가져오는 걸 여러가지 루프로 진행하는데,아래와 같다. // PersistentLevel는 게임 월드의 모든 다른 요소를 포함하는 가장 상위 레벨.// 게임 시작부터 끝까지 존재하며, 게임 플레이중 지속적으로 로드되어 있다.// 액터/레벨 디자인,게임 로직,이벤트 처리에 대한 정보/ 다른 서브 레벨등 여러가지 포함하고 있다.void UWorld::InitializeActorsForPlay(const FURL&amp; InURL, bool bResetTime, FRegisterComponentText* Context){ // Register all actor components in the persistent level only. Note that in actual fact, // actors loaded from sublevels have their components registered during FlushLevelStreaming, just before this point. PersistentLevel-&gt;UpdateLevelComponents(false, Context); // Set bActorsInitialized so that future actors will be initialized on spawn bActorInitialized = true; // Initialize the game mode : this spawns an AGameSession AuthorityGameMode-&gt;InitGame(FPaths::GetBaseFilename(InURL.Map), ParseOptions(InURL), Error); // Route InitializeComponents (and PreInit/PostInit) to all actors, level-by-level for(ULevel* Level : Levels) { Level-&gt;RouteActorInitialize(); } // Fire both a member delegate and global/static delegate FActorsInitializedParams OnActorInitParams(this, bResetTime); OnActorsInitialzed.Broadcast(OnActorInitParams); FWorldDelegates::OnWorldInitializedActors.Broadcast(OnActorInitParams);}첫 번째 루프(UpdateLevelComponents) 첫번째 루프인 UpdateLevelComponents() 함수에서 RegisterComponentWithWorld() 함수로 모든 컴포넌트를 등록한다 컴포넌트를 등록 후에 FPrimitiveSceneProxy를 생성하고 FScene에 등록한다.// ActorComponentvoid UActorComponent::RegisterComponentWithWorld(UWorld* InWorld, FRegisterComponentContext* Context){ // 로드된 World 포인터를 받아옴 WorldPrivate = InWorld; if(!bRegisted) { OnRegister(); // 등록 } ...}두 번째 루프(AuthorityGameMode-&gt;InitGame) 모든 컴포넌트를 등록 후에는 AuthorityGameMode의 InitGame에서 GameSession을 생성한다.// AuthorityGameMode-&gt;InitGame(...);void AGameModeBase::InitGame(const FString&amp; MapName, const FString&amp; Options, FString&amp; ErrorMessage){ // Save the options (parsed from the URL) for future use OptionString = Options; // Spawn a GameSession actor, giving us an interface to the online session FActorSpawnParameters SpawnInfo; SpawnInfo.Instigator = GetInstigator(); SpawnInfo.ObjectFlags |= RF_Transient; GameSession = GetWorld()-&gt;SpanwActor&lt;AGameSession&gt;(GetGameSessionClass(), SpawnInfo); GameSession-&gt;InitOptions(Options); // Fire a global delegate to allow any arbitrary engine/project/plugin code to respond to InitGame FGameModeEvents::GameModeInitializedEvent.Broadcast(this);}세 번째 루프(RouteActorInitialize) GameSession을 생성하고 나서 또 다른 루프인 Level-&gt;RouteActorInitialize() 함수로 각 레벨의 모든 액터를 초기화한다. 이 루프에서는 PreInit~,Init~,Post~ 총 3번 초기화하는 함수가 있다. // Level-&gt;RouteActorInitialize();void ULevel::RouteActorInitialize(){ // PreInitializeComponents는 컴포넌트가 등록은 됐지만, 컴포넌트가 초기화하기 전에 호출되어 초기화하는 함수 // 여기서 GameModeBase 클래스도 PreInit 함수를 호출해서 GameState클래스를 스폰하고 World에 등록한다. // 그 다음 GameState를 초기화하기 전에 GameNetworkManager를 스폰 for(AActor* Actor : Actors) { Actor-&gt;PreInitializeComponents(); } for(AActor* Actor : Actors) { Actor-&gt;InitializeComponents(); Actor-&gt;PostInitializeComponents(); }}세 번째 루프 - 1.PreInitializeComponent GameMode 클래스도 PreInitializeComponent() 함수에서 초기화한다. 초기화하면서 GameState를 만들고 World에 등록하면서 GameNetworkManager를 스폰 // GameMode 클래스의 초기화 함수void AGameModeBase::PreInitializeComponents(){ Super::PreInitializeComponents(); ... FActorSpawnParamters SpawnInfo; ... GameState = World-&gt;SpawnActor&lt;AGameStateBase&gt;(GameStateClass, SpawnInfo); // 월드에 등록 World-&gt;SetGameState(GameState); GameState-&gt;AuthorityGameMode = this; // 네트워크 게임이라면 AGameNetworkManager 스폰 AWorldSettings* WorldSettings = World-&gt;GetWorldSettings(); World-&gt;NetworkManager = World-&gt;SpawnActor&lt;AGameNetworkManager&gt;(WorldSettings-&gt;GameNetworkManagerClass, SpawnInfo); // GameState 초기화 InitGameState();}세 번째 루프 - 2.InitializeComponent InitializeComponent() 함수에서는 두 가지를 확인한다. Component의 bAutoActivate을 확인하고 true면 Activate Component의 bWantsInitializeComponent를 확인하고 true면 Initialize void AActor::InitializeComponents(){ TInlineComponentArray&lt;UActorComponent*&gt; Components; GetComponents(Components); for (UActorComponent* ActorComp : Components) { if(ActorComp-&gt;bAutoActivate &amp;&amp; !ActorComp-&gt;IsActive()) { ActorComp-&gt;Activate(true); } if(ActorComp-&gt;bWantsInitializeComponent &amp;&amp; !ActorComp-&gt;HasBeenInitialized()) { ActorComp-&gt;InitializeComponent(); } }}세 번째 루프 - 3.PostInitializeComponent 게임이 시작할 때 액터의 초기화를 위한 코드를 넣는 곳루프가 끝나고 루프가 끝나면 게임에서 액터들의 설정을 전반적으로 관리하기 위한 오브젝트들이 존재한다. AGameModeBase, AGameSession, AGameNetworkManager, AGameStateBase AGameModeBase는 게임의 규칙을 정의하는 클래스로, 게임플레이의 핵심이되는 대부분의 액터들을 스폰한다. 게임 플레이중 일어나는 모든 일에 대해 권한(ultimate authority)이 있으며, 서버에만 존재한다(SERVER-ONLY). AGameSession과 AGameNetworkManager는 서버에만 존재한다(SERVER-ONLY). AGameNetworkManager는 movement prediction과 cheat detection과 같은 것들로 구성되어 있다. 온라인 게임에서 AGameSession은 온라인 서비스(ex:Steam)에서 인터페이스로 사용되거나 로그인 요청하는데 사용된다 AGameStateBase는 서버에서 생성되고 오직 서버만이 바꿀수 있다. 그리고 모든 클라이언트에 복사된다. Player(클라이언트)한테 필요한 게임 관련 데이터들을 저장하는데 사용된다. Player 스폰(SpawnPlayActor function) LoadMap이 끝나고 나서는 Player을 생성한다. 모든 LocalPlayer를 GameInstance로 하나씩만 생성한다. LocalPlayer는 SpawnPlayActor() 함수로 호출된다 PlayActor는 PlayerController와 호환되는 액터이다. bool ULocalPlayer::SpawnPlayActor(const FString&amp; URL, FString&amp; OutError, UWorld* InWorld){ // We`re local to the server, so we need to make our own URL to accompany our login attempt FURL PlayerURL(nullptr, *URL, TARVEL_Absolute); // Get a player name : this will be the public name from the online service, if available FString PlayerName = GetNickname(); if(PlayerName.Len() &gt; 0) { PlayerURL.AddOption(*FString::Printf(TEXT(\"Name=%s\"), *PlayerName)); } // Custom ULocalPlayer subclasses can specify additional login options via GetGameLoginOptions FString GameUrlOptions = GetGameLoginOptions(); if(GameUrlOptions.Len() &gt; 0) { PlayerURL.AddOption(*FString::Printf(TEXT(\"%s\"), *GameUrlOptions)); } // Net ID: typically a big arbitrary number that uniquely identifies the player across the network FUniqueNetIdRepl UniqueId(GetPreferredUniqueNetId()); // Defer to the UWorld to Spawn a PlayerController actor const int32 NetPlayerIndex = GEngine-&gt;GetGamePlayers(InWorld).Find(this); // SpawnPlayActor 함수를 통해 PlayerController를 스폰한다. PlayerController = InWorld-&gt;SpawnPlayActor( this, ROLE_SimulatedProxy, PlayerURL, UniqueId, OutError, NetPlayerIndex);} ULocalPlayer는 엔진에서 말하는 플레이어를 의미하고 APlayerController는 게임 월드에서 말하는 플레이어를 의미한다. UPlayer ULocalPlayer는 좀 더 Player base class에 전문(specialization)인 클래스이다. 또 다른 Player class인 NetConnection은 원격 프로세스(remote process)로부터 연결된 플레이어 클래스이다. Player가 게임에 참가하기 위해서는 local이든 remote든 로그인 과정을 거쳐야 한다. 로그인 과정(SpawnPlayActor)// SpawnPlayActor 함수APlayerController* UWorld::SpawnPlayActor( UPlayer* NewPlayer, ENetRole RemoteRole, const FURL&amp; InURL, const FUniqueNetIdRepl&amp; Uniqued, FString&amp; Error, uint8 InNetPlayerIndex){ // Call the GameMode`s login function, which actually spawns the APlayerController APlayerController* NewPlayerController = GetAuthGameMode()-&gt;Login( NewPlayer, RemoteRole, *InURL.Portal, ParseOptions(InURL), UniqueId, Error); // Initialize the PlayerController for network replication NewPlayerController-&gt;NetPlayerIndex = InNetPlayerIndex; NewPlayerController-&gt;SetRole(ROLE_Authority); NewPlayerController-&gt;SetReplicates(RemoteRole != ROLE_None); if(RemoteRole == ROLE_AutonomousProxy) { NewPlayerController-&gt;SetAutonomousProxy(true); } // Associate the PlayerController with the Player NewPlayerController-&gt;SetPlayer(NewPlayer); // Finally, call the GameMode`s PostLogin function, which spawns and possesses a Pawn GetAuthGameMode()-&gt;PostLogin(NewPlayerController); return NewPlayerController;}// AGameModeBase 클래스에 있는 함수들virtual void GameWelcomPlayer(UNetConnection* Connection, FString&amp; RedirectURL);virtual void PreLogin(const FString&amp; Options,const FString&amp; Address, const FUniqueNetIdRepl&amp; UniqueId, FString&amp; ErrorMessage);virtual APlayerController* Login( UPlayer* NewPlayer, ENetRole InRemoteRole, const FString&amp; Portal,const FString&amp; Options, const FUniqueNetIdRepl&amp; UniqueId, FString&amp; ErrorMessage);virtual void PostLogin( APlayerController* NewPlayerController);virtual void Logout(AController* Exiting); PreLogin() 함수에서는 remote에 연결을 시도한다. 로그인 요청을 거절하거나 승인한다. Player가 Local이거나 PreLogin() 함수에서 로그인 요청을 승인하면 Login() 함수가 호출된다.// Login 함수APlayerController* AGameModeBase::Login(UPlayer* NewPlayer, ENetRole InRemoteRole, const FString&amp; Portal, const FString&amp; Options, const FUniqueNetIdRepl&amp; UniqueId, FString&amp; ErrorMessage){ // Allow the GameSession to approve or reject the login request\tErrorMessage = GameSession-&gt;ApproveLogin(Options);\tif (!ErrorMessage.IsEmpty())\t{\t\treturn nullptr;\t} // Spawn the PlayerController\tAPlayerController* const NewPlayerController = SpawnPlayerController(InRemoteRole, Options);\tif (NewPlayerController == nullptr)\t{\t\tErrorMessage = FString::Printf(TEXT(\"Failed to spawn player controller\"));\t\treturn nullptr;\t}\t// Call InitNewPlayer, which lets us act on the options passed in via the URL\tErrorMessage = InitNewPlayer(NewPlayerController, UniqueId, Options, Portal);\tif (!ErrorMessage.IsEmpty())\t{\t\tNewPlayerController-&gt;Destroy();\t\treturn nullptr;\t}\treturn NewPlayerController;} 위 Login() 함수에서는 PlayerController Actor를 스폰하고 World에 반환한다. PlayerController Actor는 스폰되면서 초기화되고, 초기화하면서 PostInitializeComponents() 함수를 호출한다.void APlayerController::PostInitializeComponents(){\tSuper::PostInitializeComponents();\tif ( IsValid(this) &amp;&amp; (GetNetMode() != NM_Client) )\t{\t\t// create a new player replication info\t\tInitPlayerState();\t}\tSpawnPlayerCameraManager();\tResetCameraMode(); \tif ( GetNetMode() == NM_Client )\t{\t\tSpawnDefaultHUD();\t}\tAddCheats();\tbPlayerIsWaiting = true;\tStateName = NAME_Spectating; // Don't use ChangeState, because we want to defer spawning the SpectatorPawn until the Player is received}* InitPlayerState() 함수// PostInitializeComponents() 함수에서 호출하고 PlayerState actor를 스폰한다.void AController::InitPlayerState(){ FActorSpawnParameters SpawnInfo; SpawnInfo.Owner = this; SpawnInfo.Instigator = GetInstigator(); SpawnInfo.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AlwaysSpawn; SpawnInfo.ObjectFlags |= RF_Transient;\t// We never want player states to save into a map const AGameModeBase* GameMode = World-&gt;GetAuthGameMode(); PlayerState = GetWorld()-&gt;SpawnActor&lt;APlayerState&gt;( GameMode-&gt;PlayerStateClass, SpawnInfo); )}void APlayerState::PostInitializeComponents(){ Super::PostInitializeComponents(); AGameStateBase* GameState = GetWorld()-&gt;GetGameState(); if(GameState != nullptr) { GameState-&gt;AddPlayerState(this); }} APlayerController와 APlayerState는 GameMode에서 약간 다르지만 비슷하다.1. AGameModeBase -&gt; Server-Only2. APlayerController -&gt; Server-Authoritative, Replicated only to Owning Client3. AGameStateBase -&gt; Server-Authoritative, Replicated only to All Clients4. APlayerState -&gt; Server-Authoritative, Replicated only to All Clients SpawnPlayActor() 함수와 PostLogin() 함수// SpawnPlayActor() 함수APlayerController* UWorld::SpawnPlayActor(UPlayer* NewPlayer, ENetRole RemoteRole, const FURL&amp; InURL, const FUniqueNetIdRepl&amp; UniqueId, FString&amp; Error, uint8 InNetPlayerIndex){\tif (AGameModeBase* const GameMode = GetAuthGameMode())\t{\t\t// Call the GameMode`s Login function, which actually spawns the APlayerController\t\tAPlayerController* const NewPlayerController = GameMode-&gt;Login(NewPlayer, RemoteRole, *InURL.Portal, Options, UniqueId, Error);\t\t// Initialize the PlayerController for network replication\t\tNewPlayerController-&gt;NetPlayerIndex = InNetPlayerIndex;\t\tNewPlayerController-&gt;SetRole(ROLE_Authority);\t\tNewPlayerController-&gt;SetReplicates(RemoteRole != ROLE_None);\t\tif (RemoteRole == ROLE_AutonomousProxy)\t\t{\t\t\tNewPlayerController-&gt;SetAutonomousProxy(true);\t\t} // Associate the PlayerController with the UPlayer\t\tNewPlayerController-&gt;SetPlayer(NewPlayer); // Finally, call the GameMode`s PostLogin function, which spawns and possesses a Pawn\t\tGameMode-&gt;PostLogin(NewPlayerController);\t\treturn NewPlayerController;\t}\treturn nullptr;}// AGameModeBase`s PostLogin() 함수void AGameModeBase::PostLogin(APlayerController* NewPlayer){\t// Common setup for HUD, voice chat, Matinee (legacy), etc\tGenericPlayerInitialization(NewPlayer);\t// Let the GameSession know that this player is fully logged in\tif (GameSession)\t{\t\tGameSession-&gt;PostLogin(NewPlayer);\t} // Fire Blueprint event : this is the first place where RPCs can be called\tK2_PostLogin(NewPlayer); FGameModeEvents::GameModePostLoginEvent.Broadcast(this, NewPlayer);\t// Now that initialization is done, try to spawn the player's pawn and start match\tHandleStartingNewPlayer(NewPlayer);} 일단 APlayerController가 스폰되면, World는 네트워킹을 위해 완전히 초기화되며 플레이어 오브젝트와 연결한다. 플레이어와 연결하고 나면, PostLogin 함수에서 플레이어가 참가하기 위한 것들을 설정한다. HandleStartingNewPlayer() 함수에서 새로운 플레이어(APlayerController)를 위해 GameMode가 폰을 생성한다 Pawn은 Controller가 소유(possess)할 수 있는 특별한 유형의 액터이다. PlayerController은 Base Controller Class를 전문화(specialization)한 클래스이다. Base Controller Class의 또 다른 하위 클래스인 AIController는 NPC(non-player character)가 사용하는 클래스이다. 위 구조는 언리얼에서 오랫동안 사용한 구조로, 자율적으로 움직이게 하는 액터는 AIController를 사용하고 사람이 입력해서 사용하려는 액터는 PlayerController를 사용한다. 즉, AController은 Actor를 구동하는 intelligence이고 APawn은 월드에서 나타나는 액터로 이해하면 된다. 언리얼 프레임워크는 관전자(spectators)를 지원한다.void AGameModeBase::HandleStartingNewPlayer_Implementation(APlayerController* NewPlayer){\t// If players should start as spectators, leave them in the spectator state\tif (!bStartPlayersAsSpectators &amp;&amp; !MustSpectate(NewPlayer) &amp;&amp; PlayerCanRestart(NewPlayer))\t{\t\t// Otherwise spawn their pawn immediately\t\tRestartPlayer(NewPlayer);\t}} PlayerState는 Player를 관전할 수 있도록 만들수 있고 혹은 GameMode가 Player를 초기에 관전자로 시작하도록 바꿀 수 있다. 게임모드의 경우 GameMode는 Pawn을 스폰하지 않는 대신에 PlayerController가 SpectatorPawn을 대신 World안에서 자유 시점인 상태로 스폰한다. void AGameModeBase::RestartPlayer(AController* NewPlayer){ // Find a PlayerStart actor, and use its transform (with no pitch/roll) for the pawn AActor* StartSpot = FindPlayerStart(NewPlayer); const FRotator StartRotation(0.0f, StartSpot-&gt;GetActorRotation().Yaw, 0.0f); const FVector StartLocation = StartSpot-&gt;GetActorLocation(); const FTransform SpawnTransform(StartRotation, StartLocation); // Get the Pawn class to use for this player; typically Default PawnClass UClass* PawnClass = GetDefaultPawnClassForController(NewPlayer); // Spawn a new Pawn using that class FActorSpawnParameters SpawnInfo; SpawnInfo.Instigator = GetInstigator(); SpawnInfo.ObjectFlags |= RF_Transient; APawn* NewPawn = GetWorld()-&gt;SpawnActor&lt;APawn&gt;(PawnClass, SpawnTransform, SpawnInfo); // Associate the Pawn with the Controller (before Possess) NewPlayer-&gt;SetPawn(NewPawn); // Let the PlayerStart actor know that it was used InitStartSpot(StartSpot, Newplayer); // Possess the Pawn, init control rotation, call SetPlayerDefaults FinishRestartPlayer(NewPlayer, StartRotation);} 만약 멀티플레이어 게임에서 조종하는 Pawn이 Destroy되기 전까지 PlayerController는 남아있는 상태다. 플레이어가 리스폰될 때, 게임에서 새로운 Pawn을 스폰해야 한다. 이 때를 위한 함수가 위 코드의 RestartPlayer() 함수이다. PlayerController가 새롭게 생성되는 Pawn을 찾고 게임 플레이어 컨트롤러(PlayerController)와 연결된 기본 폰 클래스를 결정하고 생성한다. 기본적으로 GameMode는 맵에 배치된 PlayerStart Actor를 살펴보고 그 중 하나를 찾는다. 하지만 이러한 모든 동작은 자체 GameMode Class에서 재정의하고 커스터마이징할 수 있다. Pawn이 생성되고 나면, PlayerController를 설정하고 PlayerController은 그 Pawn을 소유(possess)한다. // Route the BeginPlay event to indicate that all actors are present and initializedWorldContext.World()-&gt;BeginPlay();// Fire another delegate to let listeners know that the map change is doneFCoreUObjectDelegates::PostLoadMapWithWorld.Broadcast(WorldContext.World());// Report how it took to load the map, and notify the GameInstance as welldouble StopTime = FPlatformTime::Seconds();UE_LOG(LogLoad, Log, TEXT(\"Took %f seconds to LoadMap(%s)\"), StopTime - StartTime, *URL.Map);WorldContext.OwningGameInstance-&gt;LoadComplete(StopTime - StartTime, *URL.Map);return true;// UWorld`s BeginPlayvoid UWorld::BeginPlay(){ AGameModeBase* GameMode = GetAuthGameMode(); if(GameMode) { GameMode-&gt;StartPlay(); } OnWorldBeginPlay.Broadcast();}// AGameModeBase`s StartPlayvoid AGameModeBase::StartPlay(){ GameState-&gt;HandleBeginPlay();}// AGameState`s HandleBeginPlayvoid AGameStateBase::HandleBeginPlay(){ bReplicatedHasBegunPlay = true; GetWorldSettings()-&gt;NotifyBeginPlay(); GetWorldSettings()-&gt;NotifyMatchStarted();}// AWorldSetting::NotifyBeginPlayvoid AWorldSetting::NotifyBeginPlay(){ UWorld* World = GetWorld(); if(!World-&gt;bBegunPlay) { for(FActorIterator It(World); It; ++It) { const bool bFromLevelLoad = true; It-&gt;DistpatchBeginPlay(bFromLevelLoad); } World-&gt;bBegunPlay = true; }} LoadMap 코드로 돌아와서, World 객체에서 BeginPlay를 실행하고 그 안에서 GameMode가 StartPlay() 함수를 실행한다. StartPlay() 함수안에서는 GameState의 HandleBeginPlay() 함수를 호출하고 이 안에서 WAWorldSetting의 NotifyBeginPlay에서는 모든 액터의 BeginPlay를 실행한다. DispatchBeginPlay() 함수에서 액터의 BeginPlay 시작 보고 작성한 유튜브https://www.youtube.com/watch?v=IaU2Hue-ApI 위 영상은 언리얼 4.26버전이고 언리얼 5.0 이상에서는 좀 다르다. 얼추 비슷한 부분이 많다 " }, { "title": "Null 객체", "url": "/posts/Null-%EA%B0%9D%EC%B2%B4/", "categories": "디자인 패턴, 행태 패턴", "tags": "design pattern", "date": "2023-06-22 00:00:00 +0900", "snippet": "널 객체 패턴 아무런 동작도 하지 않는 ‘널(Null) 객체’를 사용하여, if (object != nullptr) 과 같은 널 포인터 검사 코드를 피하는 행위 디자인 패턴 어떤 클래스가 다른 객체(의존성)를 필요로 할 때, 때로는 그 의존성이 ‘없음’ 상태일 수 있다. 이 경우 nullptr를 전달하면, 의존성을 사용하는 모든 코드 위치에서 널 포인터 예외(crash)를 막기 위한 검사 코드를 일일이 넣어줘야 한다. 널 객체 패턴은 실제 객체와 동일한 인터페이스를 가지면서도 아무런 동작도 하지 않는 객체를 만들어, nullptr 대신 이 ‘안전한 빈 껍데기’ 객체를 전달하는 방식이다. 이를 통해 클라이언트 코드는 의존성이 실제로 존재하는지 여부를 신경 쓸 필요 없이 코드를 작성할 수 있다.시나리오: 사운드 시스템 끄고 켜기 게임 캐릭터가 공격할 때마다 공격 효과음을 재생하는 시스템을 구현해야 한다.1. 의존성 인터페이스(IAudioSystem) 정의 먼저, 모든 오디오 시스템이 따를 공통 인터페이스를 정의한다.#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;// 오디오 시스템의 공통 인터페이스class IAudioSystem {public: virtual ~IAudioSystem() = default; virtual void PlaySound(const string&amp; sound_id) = 0;};2. 클라이언트(Player) 클래스 정의 Player 클래스는 생성자를 통해 IAudioSystem 구현체를 주입받고, 공격 시 사운드를 재생한다.#include &lt;memory&gt;// 클라이언트: IAudioSystem에 의존한다.class Player {private: IAudioSystem&amp; audio;public: Player(IAudioSystem&amp; audio_system) : audio(audio_system) {} void Attack() { cout &lt;&lt; \"플레이어가 공격합니다!\" &lt;&lt; endl; // 오디오 시스템을 직접 호출 audio.PlaySound(\"sword_swing.wav\"); }};3. 문제 상황: 사운드 기능이 필요 없을 때 게임 설정에서 사용자가 사운드를 끄거나, 테스트를 위해, 또는 사운드 기능이 없는 전용 서버 환경에서는 오디오 시스템이 필요 없다. 이때 Player 객체를 어떻게 생성해야 할까? nullptr를 전달하는 것은 불가능하거나 위험하다. Player의 Attack 메서드 안에서 audio.PlaySound(…)를 호출하는 순간 프로그램은 비정상 종료될 것이다. 이를 막기 위해 Player 코드 안에 if (audio != nullptr) 같은 검사 코드를 넣는 것은 코드를 지저분하게 만들고, Player에게 불필요한 책임을 지게 한다.해결책: NullAudioSystem 도입 이 문제에 대한 가장 우아한 해결책이 바로 널 객체(Null Object)를 만드는 것이다.1. 널 객체(Null Object) 구현 IAudioSystem 인터페이스를 구현하되, 모든 메서드의 본문을 비워둔다. 즉, ‘아무것도 하지 않는’ 객체를 만든다.// 널 객체: IAudioSystem 인터페이스를 따르지만 아무 동작도 하지 않는다.class NullAudioSystem : public IAudioSystem {public: void PlaySound(const string&amp; sound_id) override { // 이 메서드는 호출되어도 아무 일도 일어나지 않는다. }};2. 널 객체의 활용 이제 게임 설정에 따라 실제 오디오 시스템 또는 널 오디오 시스템을 주입할 수 있다.// 실제 오디오 시스템 구현class SDLAudioSystem : public IAudioSystem {public: void PlaySound(const string&amp; sound_id) override { cout &lt;&lt; \"[SDL 오디오] \" &lt;&lt; sound_id &lt;&lt; \" 재생!\" &lt;&lt; endl; }};int main() { bool sound_enabled = false; // 게임 설정에서 사운드를 껐다고 가정 unique_ptr&lt;IAudioSystem&gt; audio_system; if (sound_enabled) { audio_system = make_unique&lt;SDLAudioSystem&gt;(); } else { // 사운드가 꺼져있으면, Null 객체를 주입한다. audio_system = make_unique&lt;NullAudioSystem&gt;(); } // Player는 주입된 객체가 진짜인지 가짜인지 전혀 신경 쓸 필요가 없다. Player player(*audio_system); player.Attack(); // 크래시 없이 안전하게 실행된다.} Player 클래스는 단 한 줄의 수정도 없이, 그리고 if 문 하나 없이, 사운드 기능이 있거나 없는 두 가지 상황 모두에서 완벽하게 동작한다. 이것이 널 객체 패턴의 핵심적인 장점이다.nullptr는 Null 객체가 아니다 중요한 점은, nullptr와 널 객체는 근본적으로 다르다는 것이다. nullptr는 '객체가 존재하지 않음'을 의미한다. nullptr에 대해 메서드를 호출하려고 시도하면 런타임 에러(크래시)가 발생한다. 널 객체는 '존재하지만 아무 동작도 하지 않는 객체'다. 널 객체는 유효한 인터페이스를 가지고 있으므로, 메서드를 안전하게 호출할 수 있다. 더 나은 설계: 프록시를 이용한 암묵적 Null 객체 위 예제에서도 게임 설정에 따라 if-else로 객체를 생성하는 부분이 남아있다. 프록시 패턴을 응용하면 이 부분마저 숨겨서 클라이언트 코드를 더욱 단순화할 수 있다.// 프록시 역할을 하는 클래스class OptionalAudioSystem : public IAudioSystem {private: shared_ptr&lt;IAudioSystem&gt; real_audio_system; // 실제 오디오 시스템을 가리키는 포인터public: // 생성 시 실제 시스템을 받거나, nullptr을 받을 수도 있다. OptionalAudioSystem(shared_ptr&lt;IAudioSystem&gt; real_system) : real_audio_system(real_system) {} void PlaySound(const string&amp; sound_id) override { // 프록시 내부에서 널 검사를 수행한다. if (real_audio_system) { real_audio_system-&gt;PlaySound(sound_id); } }}; 이제 Player는 생성 시 shared_ptr를 받고, 이를 항상 OptionalAudioSystem 프록시로 감싸서 사용한다.class Player {private: unique_ptr&lt;IAudioSystem&gt; audio_proxy;public: Player(shared_ptr&lt;IAudioSystem&gt; audio) { // 주입된 포인터(nullptr일 수도 있음)를 안전한 프록시로 감싼다. this-&gt;audio_proxy = make_unique&lt;OptionalAudioSystem&gt;(audio); } void Attack() { // 이제 Player는 널 검사에 대해 완전히 신경 쓸 필요가 없다. audio_proxy-&gt;PlaySound(\"sword_swing.wav\"); }};int main() { // 사운드 비활성화: 그냥 nullptr을 전달한다. Player player_no_sound(nullptr); player_no_sound.Attack(); // 안전하게 실행됨 // 사운드 활성화 Player player_with_sound(make_shared&lt;SDLAudioSystem&gt;()); player_with_sound.Attack(); // 정상적으로 소리 재생} 이 방식은 널 검사의 책임을 클라이언트(Player)가 아닌 프록시 객체에 위임하여, 클라이언트 코드를 궁극적으로 단순하게 만든다.요약 널 객체 패턴은 아무 동작도 하지 않는 ‘기본’ 객체를 사용하여, if (object != nullptr)와 같은 조건문을 제거하는 패턴이다. 널 객체는 실제 객체와 동일한 인터페이스를 구현하므로, 클라이언트는 둘을 구분하지 않고 다형적으로 사용할 수 있다. 이를 통해 클라이언트 코드의 복잡성을 줄이고, 널 포인터 역참조로 인한 런타임 에러를 원천적으로 방지할 수 있다. 이 패턴은 선택적인 의존성이나 비활성화될 수 있는 기능을 다룰 때 매우 유용하며, 코드를 더 깨끗하고 견고하게 만들어준다. " }, { "title": "메멘토 패턴", "url": "/posts/%EB%A9%94%EB%A9%98%ED%86%A0-%ED%8C%A8%ED%84%B4/", "categories": "디자인 패턴, 행태 패턴", "tags": "design pattern", "date": "2023-06-19 00:00:00 +0900", "snippet": "메멘토 패턴 객체의 캡슐화(Encapsulation)를 깨뜨리지 않으면서, 그 객체의 내부 상태를 스냅샷처럼 저장하여 나중에 이 상태로 복원할 수 있게 만드는 행위 디자인 패턴 ‘메멘토’는 ‘기억해야 할 것’ 또는 ‘기념품’을 뜻하는 라틴어다. 이름처럼, 이 패턴은 특정 시점의 상태를 ‘메멘토’라는 객체에 담아 보관해두었다가, 필요할 때 그 ‘기념품’을 이용해 과거의 상태로 되돌아가는 기능을 구현하는 데 사용된다. 게임에서 흔히 볼 수 있는 ‘저장/불러오기’, ‘체크포인트’, ‘실행 취소(Undo)’ 기능이 바로 이 메멘토 패턴의 대표적인 활용 사례다.시나리오: 턴제 전략 게임의 ‘한 수 무르기’ 턴제 전략 게임에서 플레이어가 유닛을 움직인 후, 그 수를 무르고 싶을 때 사용하는 ‘한 수 무르기(Undo)’ 기능을 구현해야 한다고 가정하자.1. 상태를 가진 원본 객체 (Originator) 정의 먼저, 게임 보드의 상태를 관리하는 GameBoard 클래스를 정의한다. 이 클래스는 모든 유닛의 위치와 같은 게임의 현재 상태를 가지고 있다.#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;// 유닛의 상태 (간단하게 위치만 저장)struct UnitState { int x, y;};// 원본 객체: 게임 보드의 상태를 책임진다.class GameBoard {private: map&lt;string, UnitState&gt; unit_positions;public: void SetUnitPosition(const string&amp; unitId, int x, int y) { unit_positions[unitId] = {x, y}; } // ...}; 플레이어가 유닛을 움직이면 unit_positions 맵의 데이터가 변경된다. 이 변경을 어떻게 기록하고 이전 상태로 되돌릴 수 있을까? GameBoard의 private 멤버인 unit_positions를 외부에 노출하지 않으면서 말이다.메멘토 패턴 구현 이 패턴은 세 가지 핵심 역할로 구성된다. 오리지네이터 (Originator): 상태를 저장하고 복원할 원본 객체 (GameBoard). 메멘토 (Memento): 오리지네이터의 내부 상태 스냅샷을 저장하는 객체. 오리지네이터 외에는 그 내용을 알 수 없다. 커맨더 (Caretaker): 메멘토 객체를 보관하고 관리하지만, 그 내용은 들여다보지 않는다. 1. 메멘토 (Memento) 클래스 정의 메멘토는 GameBoard의 상태(unit_positions)를 저장한다. 중요한 점은, 모든 멤버가 private이고 GameBoard를 friend로 선언하여 오직 GameBoard만이 메멘토의 내부 상태에 접근할 수 있도록 하는 것이다.// 메멘토: GameBoard의 상태 스냅샷을 저장한다.class BoardMemento {private: // 생성자도 private으로 만들어 GameBoard만 생성할 수 있게 한다. BoardMemento(const map&lt;string, UnitState&gt;&amp; state) : saved_state(state) {} map&lt;string, UnitState&gt; saved_state; // GameBoard 클래스에게만 내부 접근을 허용한다. friend class GameBoard;}; 이 구조 덕분에 GameBoard의 캡슐화가 완벽하게 유지된다.2. 오리지네이터 (Originator) 수정 GameBoard에 상태를 저장하고 복원하는 메서드를 추가한다.#include &lt;memory&gt;class GameBoard {private: map&lt;string, UnitState&gt; unit_positions;public: // ... SetUnitPosition 등 기존 메서드 ... // 현재 상태를 메멘토 객체로 만들어 반환한다. unique_ptr&lt;BoardMemento&gt; CreateMemento() const { // new를 직접 호출하는 대신, private 생성자를 호출할 수 있다. return make_unique&lt;BoardMemento&gt;(unit_positions); } // 메멘토로부터 상태를 복원한다. void Restore(const BoardMemento&amp; memento) { this-&gt;unit_positions = memento.saved_state; }};3. 커맨더 (Caretaker) 구현 커맨더는 메멘토들을 저장하고 관리하는 역할을 한다. 여기서는 TurnHistory 클래스가 그 역할을 맡는다.#include &lt;vector&gt;// 커맨더: 메멘토들을 보관하고 관리한다.class TurnHistory {private: vector&lt;unique_ptr&lt;BoardMemento&gt;&gt; history;public: void Save(GameBoard&amp; board) { // 보드로부터 메멘토를 받아 히스토리에 저장한다. history.push_back(board.CreateMemento()); } void Undo(GameBoard&amp; board) { if (history.empty()) { cout &lt;&lt; \"더 이상 되돌릴 수 없습니다.\" &lt;&lt; endl; return; } // 가장 마지막 메멘토를 꺼내서 보드 상태를 복원한다. board.Restore(*history.back()); history.pop_back(); }}; TurnHistory는 BoardMemento의 내용이 무엇인지 전혀 알지 못한다. 그저 ‘보관’했다가 ‘전달’할 뿐이다.4. 전체적인 흐름 이제 이들을 조합하여 ‘한 수 무르기’ 기능을 완성할 수 있다.int main() { GameBoard board; TurnHistory history; // 턴 시작: 초기 상태 설정 및 저장 board.SetUnitPosition(\"Player1\", 10, 10); history.Save(board); cout &lt;&lt; \"턴 시작. Player1 위치: (10, 10)\" &lt;&lt; endl; // 플레이어가 유닛을 이동시킨다. board.SetUnitPosition(\"Player1\", 12, 15); cout &lt;&lt; \"Player1 이동. 현재 위치: (12, 15)\" &lt;&lt; endl; // 플레이어가 '한 수 무르기'를 선택한다. cout &lt;&lt; \"\\n'한 수 무르기' 실행...\" &lt;&lt; endl; history.Undo(board); cout &lt;&lt; \"복원된 Player1 위치: (10, 10)\" &lt;&lt; endl;}Undo/Redo 확장 메멘토 패턴을 이용하면 완전한 Undo/Redo 시스템도 쉽게 구현할 수 있다. 이때는 오리지네이터가 직접 커맨더의 역할을 겸하는 경우가 많다.// 오리지네이터가 커맨더 역할을 겸하는 예class GameBoardWithUndo {private: int balance; // 간단한 상태 예시 vector&lt;shared_ptr&lt;Memento&gt;&gt; changes; // 메멘토 히스토리 int current_state_index; // 현재 상태를 가리키는 인덱스public: // ... 생성자에서 초기 상태를 changes에 추가 ... void Deposit(int amount) { balance += amount; auto m = make_shared&lt;Memento&gt;(balance); changes.push_back(m); current_state_index = changes.size() - 1; } void Undo() { if (current_state_index &gt; 0) { --current_state_index; balance = changes[current_state_index]-&gt;balance; } } void Redo() { if (current_state_index + 1 &lt; changes.size()) { ++current_state_index; balance = changes[current_state_index]-&gt;balance; } }}; 이 방식은 current_state_index를 앞뒤로 움직이며 상태를 되돌리거나 다시 실행한다.요약 메멘토 패턴은 객체의 내부 상태를 외부로 캡슐화하여, 나중에 해당 상태로 쉽게 복원할 수 있도록 하는 패턴이다. 구성 요소: 오리지네이터 (Originator): 상태를 가진 원본 객체. 메멘토를 생성하고, 메멘토로부터 상태를 복원할 책임이 있다. 메멘토 (Memento): 오리지네이터의 상태 스냅샷. 오리지네이터 외에는 누구도 그 내용을 들여다볼 수 없어야 한다(캡슐화). 커맨더 (Caretaker): 메멘토를 보관하고 관리하지만, 그 내용을 알지 못한다. 이 패턴은 객체의 캡슐화를 훼손하지 않으면서 상태 저장/복원 기능을 구현하는 가장 좋은 방법이다. 게임 개발에서는 저장/불러오기, 체크포인트 시스템, 그리고 특히 강력한 Undo/Redo 기능을 구현할 때 메멘토 패턴이 핵심적인 역할을 한다. " }, { "title": "매개자 패턴", "url": "/posts/%EB%A7%A4%EA%B0%9C%EC%9E%90-%ED%8C%A8%ED%84%B4/", "categories": "디자인 패턴, 행태 패턴", "tags": "design pattern", "date": "2023-06-15 00:00:00 +0900", "snippet": "매개자 패턴 여러 객체들(동료, Colleagues) 간의 복잡한 상호작용을 중재자(Mediator)라는 단일 객체에 캡슐화하는 행위 디자인 패턴 객체들이 서로 직접 참조하고 호출하는 거미줄 같은 구조(spaghetti code) 대신, 모든 통신은 중재자를 통해서만 이루어진다. 이를 통해 객체들은 서로의 존재를 알 필요가 없어지며, 시스템의 결합도(Coupling)가 크게 낮아진다. 게임 개발에서 여러 UI 요소들이 서로 상호작용하거나, 다양한 게임 시스템들이 특정 이벤트에 반응해야 할 때, 이 패턴은 코드의 구조를 매우 깔끔하고 유지보수하기 쉽게 만들어준다.시나리오: 복잡한 UI 화면의 상호작용 관리 게임의 메인 메뉴 화면을 만든다고 가정해보자. 이 화면에는 다음과 같은 UI 요소(위젯)들이 있다. 플레이어 이름을 입력하는 텍스트 필드(TextField) ‘하드 모드’를 활성화하는 체크박스(Checkbox) 게임을 시작하는 버튼(Button) 요구사항은 다음과 같다: “시작 버튼을 누르면, 텍스트 필드에 이름이 입력되어 있을 때만 하드 모드 활성화 여부를 확인하고 게임을 시작한다.” 문제점: 위젯 간의 직접적인 참조 매개자 패턴이 없다면, 각 위젯은 다른 위젯을 직접 참조해야 할 수 있다.// 안티 패턴: 위젯들이 서로 강하게 결합됨class StartButton {private: // 시작 버튼이 텍스트 필드와 체크박스를 직접 알아야 한다. PlayerNameTextField* nameField; HardModeCheckbox* hardModeCheck;public: void OnClick() { if (!nameField-&gt;GetText().empty()) { bool isHard = hardModeCheck-&gt;IsChecked(); // ... 이름과 난이도로 게임 시작 로직 호출 ... } }}; 이 방식은 StartButton이 다른 두 위젯의 구체적인 타입에 의존하게 만든다. 만약 PlayerNameTextField가 다른 종류의 위젯으로 교체된다면 StartButton의 코드도 수정해야 한다. 위젯이 늘어날수록 의존 관계는 걷잡을 수 없이 복잡해진다.해결책: UIPanel 매개자 도입 이 문제를 해결하기 위해, 모든 위젯들의 상호작용을 중재하는 UIPanel 매개자를 도입한다.1. 동료(Colleague)와 매개자(Mediator) 인터페이스 정의 먼저 위젯과 패널이 소통할 기본적인 규약을 정의한다.#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class IWidget; // 전방 선언// 매개자 인터페이스: 위젯으로부터 알림을 받는다.class IMediator {public: virtual ~IMediator() = default; virtual void OnWidgetChanged(IWidget* widget) = 0;};// 동료(위젯)의 기본 클래스class IWidget {protected: IMediator* mediator;public: IWidget(IMediator* med) : mediator(med) {} virtual ~IWidget() = default; // 자신의 상태가 바뀌면 매개자에게 알린다. void Changed() { mediator-&gt;OnWidgetChanged(this); }};2. 구체적인 동료(Concrete Colleague) 구현 이제 각 위젯은 자신의 로직에만 집중하고, 변화가 생기면 매개자에게 Changed()를 호출하여 알리기만 한다.class Button : public IWidget {public: Button(IMediator* med) : IWidget(med) {} void Click() { cout &lt;&lt; \"Button: 클릭됨. 매개자에게 알림.\" &lt;&lt; endl; Changed(); }};class Checkbox : public IWidget {public: bool isChecked = false; Checkbox(IMediator* med) : IWidget(med) {} void SetChecked(bool checked) { isChecked = checked; cout &lt;&lt; \"Checkbox: 상태 변경됨. 매개자에게 알림.\" &lt;&lt; endl; Changed(); }};3. 구체적인 매개자(Concrete Mediator) 구현 UIPanel은 모든 위젯을 소유하고, 위젯으로부터 알림이 오면 중앙에서 모든 상호작용을 조율한다.// 매개자 구현: 모든 위젯을 소유하고 상호작용을 제어한다.class UIPanel : public IMediator {private: unique_ptr&lt;Button&gt; startButton; unique_ptr&lt;Checkbox&gt; hardModeCheckbox; // ... 다른 위젯들 ...public: UIPanel() { // 매개자가 위젯들을 생성하고, 자기 자신을 주입한다. startButton = make_unique&lt;Button&gt;(this); hardModeCheckbox = make_unique&lt;Checkbox&gt;(this); } // 위젯으로부터 알림이 오면, 여기서 모든 로직을 처리한다. void OnWidgetChanged(IWidget* widget) override { // 만약 변경을 알린 위젯이 시작 버튼이라면 if (widget == startButton.get()) { cout &lt;&lt; \"매개자: 시작 버튼 클릭을 감지함. 다른 위젯들의 상태를 확인합니다.\" &lt;&lt; endl; bool isHard = hardModeCheckbox-&gt;isChecked; // ... 게임 시작 로직 실행 ... cout &lt;&lt; \"매개자: 게임을 \" &lt;&lt; (isHard ? \"하드 모드\" : \"일반 모드\") &lt;&lt; \"로 시작합니다!\" &lt;&lt; endl; } } // 테스트를 위한 위젯 접근자 Button* GetStartButton() { return startButton.get(); } Checkbox* GetHardModeCheckbox() { return hardModeCheckbox.get(); }}; 이제 Button은 Checkbox의 존재를 전혀 모른다. 단지 매개자인 UIPanel에 “나 눌렸어!”라고 알릴 뿐이다. 그러면 UIPanel이 알아서 다른 위젯들의 상태를 확인하고 다음 동작을 결정한다. 모든 복잡한 의존성이 매개자 안으로 캡슐화되었다.더 나은 접근법: 이벤트 브로커 (Event Broker) 매개자 패턴의 더 발전된 형태는 이벤트 브로커 또는 이벤트 버스(Event Bus) 모델이다. 이는 옵저버 패턴과 결합하여 훨씬 더 유연한 구조를 만든다.1. 이벤트 브로커 정의 게임 내 모든 이벤트를 중계하는 전역적인 허브를 만든다. Boost.Signals2나 직접 구현한 시그널/슬롯 시스템을 사용할 수 있다.#include &lt;boost/signals2.hpp&gt;// 이벤트 정보를 담는 구조체 (다형성을 위해 상속 구조 사용 가능)struct PlayerDiedEvent { string killerName; };struct ItemPickedUpEvent { string itemName; };// 이벤트 브로커 (매개자)class GameEventBus {public: boost::signals2::signal&lt;void(PlayerDiedEvent)&gt; onPlayerDied; boost::signals2::signal&lt;void(ItemPickedUpEvent)&gt; onItemPickedUp;};2. 분리된 시스템들 (동료) 이제 각 게임 시스템은 서로를 전혀 모른 채, 오직 GameEventBus에만 의존하여 이벤트를 발행(publish)하거나 구독(subscribe)한다.// 퀘스트 시스템class QuestSystem {public: QuestSystem(GameEventBus&amp; bus) { // '전설의 검'을 줍는 이벤트가 발생하면 퀘스트를 완료 처리한다. bus.onItemPickedUp.connect([&amp;](ItemPickedUpEvent e) { if (e.itemName == \"Legendary Sword\") { cout &lt;&lt; \"[퀘스트 시스템]: '전설의 검 찾기' 퀘스트 완료!\" &lt;&lt; endl; } }); }};// 사운드 시스템class SoundSystem {public: SoundSystem(GameEventBus&amp; bus) { // 아이템을 줍는 이벤트가 발생하면 효과음을 재생한다. bus.onItemPickedUp.connect([&amp;](ItemPickedUpEvent e) { cout &lt;&lt; \"[사운드 시스템]: 아이템 획득 효과음 재생!\" &lt;&lt; endl; }); }};// 플레이어class Player { GameEventBus&amp; bus;public: Player(GameEventBus&amp; bus) : bus(bus) {} void PickUpItem(const string&amp; itemName) { cout &lt;&lt; \"\\n플레이어가 \" &lt;&lt; itemName &lt;&lt; \"을(를) 주웠다.\" &lt;&lt; endl; // 플레이어는 이벤트를 발행하기만 할 뿐, 누가 이 이벤트를 받는지 모른다. bus.onItemPickedUp(ItemPickedUpEvent{itemName}); }}; 플레이어가 아이템을 주우면, Player는 그저 GameEventBus에 “아이템 주웠다”는 신호를 보낸다. 그러면 이 신호를 구독하고 있던 QuestSystem과 SoundSystem이 각자 알아서 자신의 할 일을 처리한다. 세 시스템은 서로의 존재를 전혀 모른 채 완벽하게 분리되어 동작한다.요약 매개자 패턴은 객체 간의 복잡한 상호작용을 중앙의 중재자 객체에 위임하여, 객체들 간의 직접적인 참조를 없애는 패턴이다. 이를 통해 객체 간의 결합도를 낮추고, 각 객체는 자신의 책임에만 집중할 수 있게 되어 재사용성이 높아진다. 이벤트 브로커 방식은 매개자 패턴의 더 발전된 형태로, 시그널/슬롯 메커니즘을 이용해 시스템을 극도로 유연하고 확장 가능하게 만든다. 복잡한 상호작용이 필요한 UI 시스템, 여러 게임 시스템에 걸쳐 영향을 주는 이벤트 처리 등에서 매개자 패턴은 코드의 구조를 단순하고 명확하게 유지하는 데 매우 효과적인 해결책이다. " }, { "title": "반복자 패턴", "url": "/posts/%EB%B0%98%EB%B3%B5%EC%9E%90-%ED%8C%A8%ED%84%B4/", "categories": "디자인 패턴, 행태 패턴", "tags": "design pattern", "date": "2023-06-13 00:00:00 +0900", "snippet": "반복자 패턴 컬렉션(배열, 리스트, 트리 등)의 내부 구조를 외부에 노출하지 않으면서, 그 요소들을 순차적으로 접근할 수 있는 방법을 제공하는 행위 디자인 패턴 for 루프를 사용해 std::vector의 모든 요소를 출력하는 것이 바로 이 패턴의 가장 흔한 예다. 반복자 패턴의 핵심은, 데이터 구조가 어떻게 생겼는지(배열인지, 연결 리스트인지 등)와 상관없이 클라이언트가 동일한 방식(begin, end, ++, *)으로 컬렉션의 요소를 순회할 수 있도록 하는 것이다.C++ 표준 라이브러리의 반복자 C++ 개발자들은 이미 반복자 패턴을 매일 사용하고 있다. 게임 캐릭터의 인벤토리를 예로 들어보자.#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Item { string name; };int main() { vector&lt;Item&gt; inventory = { {\"Sword\"}, {\"Shield\"}, {\"Health Potion\"} }; // 1. begin()으로 첫 번째 요소를 가리키는 반복자를 얻는다. vector&lt;Item&gt;::iterator it = inventory.begin(); // 2. operator* (역참조)로 반복자가 가리키는 요소의 값에 접근한다. cout &lt;&lt; \"첫 번째 아이템: \" &lt;&lt; (*it).name &lt;&lt; endl; // 출력: Sword // 3. operator++ 로 다음 요소로 이동한다. ++it; cout &lt;&lt; \"두 번째 아이템: \" &lt;&lt; it-&gt;name &lt;&lt; endl; // 포인터처럼 -&gt; 연산자도 사용 가능. 출력: Shield // 4. end()는 마지막 요소 '다음'을 가리키며, 순회의 종료 조건으로 사용된다. cout &lt;&lt; \"\\n--- 전체 인벤토리 순회 ---\" &lt;&lt; endl; for (auto iter = inventory.begin(); iter != inventory.end(); ++iter) { cout &lt;&lt; iter-&gt;name &lt;&lt; endl; }} std::vector가 내부적으로 데이터를 어떻게 저장하는지 전혀 몰라도, 우리는 begin(), end(), ++, * 라는 표준화된 인터페이스를 통해 모든 요소에 접근할 수 있다. 이것이 반복자 패턴의 본질이다. C++의 범위 기반 for 루프는 이 과정을 더욱 단순화한 문법적 설탕(syntactic sugar)이다// 범위 기반 for 루프는 내부적으로 반복자를 사용한다.for (const auto&amp; item : inventory) { cout &lt;&lt; item.name &lt;&lt; endl;}커스텀 반복자: 게임 씬 그래프 순회하기 반복자 패턴의 진정한 힘은 vector와 같은 선형 구조뿐만 아니라, 트리와 같은 복잡한 비선형 자료구조를 순회할 때 드러난다. 게임 엔진의 씬 그래프(Scene Graph)는 모든 게임 오브젝트를 부모-자식 관계의 트리 구조로 관리한다. 이 씬 그래프의 모든 오브젝트를 특정 순서(예: 깊이 우선 탐색, DFS)로 순회하고 싶다면 어떻게 해야 할까?1. 데이터 구조(Component) 정의 먼저 GameObject 클래스를 정의한다. 각 GameObject는 자식들을 가질 수 있다.#include &lt;memory&gt;class GameObject {public: string name; vector&lt;unique_ptr&lt;GameObject&gt;&gt; children; GameObject(const string&amp; name) : name(name) {} void AddChild(unique_ptr&lt;GameObject&gt; child) { children.push_back(move(child)); }};2. 커스텀 반복자(Custom Iterator) 구현 깊이 우선 탐색(DFS)을 수행하는 DFSIterator를 직접 구현해 보자. 재귀적인 DFS 알고리즘을 비재귀적인 operator++로 구현하려면, 방문할 노드들을 저장할 스택이 필요하다.// 깊이 우선 탐색을 위한 커스텀 반복자class DFSIterator {private: GameObject* current; stack&lt;GameObject*&gt; nodes_to_visit;public: explicit DFSIterator(GameObject* start_node) : current(start_node) {} // 역참조 연산자 GameObject&amp; operator*() const { return *current; } GameObject* operator-&gt;() const { return current; } // 다음 노드로 이동 (핵심 로직) DFSIterator&amp; operator++() { // 현재 노드의 자식들을 역순으로 스택에 넣는다 (그래야 첫째 자식부터 방문). for (auto it = current-&gt;children.rbegin(); it != current-&gt;children.rend(); ++it) { nodes_to_visit.push(it-&gt;get()); } // 스택에서 다음 방문할 노드를 꺼낸다. if (!nodes_to_visit.empty()) { current = nodes_to_visit.top(); nodes_to_visit.pop(); } else { current = nullptr; // 순회 종료 } return *this; } // 비교 연산자 bool operator!=(const DFSIterator&amp; other) const { return current != other.current; }}; 이 operator++ 구현은 복잡하고, 원래의 재귀적인 DFS 알고리즘과는 모습이 사뭇 다르다. 가독성이 떨어지고 버그가 발생하기 쉽다.3. begin() / end() 메서드 제공 GameObject 클래스에 이 반복자를 사용할 수 있는 진입점을 제공한다.class GameObject { // ...public: DFSIterator begin() { // 생성 시점의 this가 첫 번째 current가 됨 // ++ 호출 시 자식들이 스택에 쌓이고 첫 번째 자식이 다음 current가 됨 return DFSIterator(this); } DFSIterator end() { // 순회가 끝나면 current는 nullptr가 되므로, end()는 nullptr를 가리키는 반복자와 비교한다. return DFSIterator(nullptr); }}; 이제 클라이언트는 씬 그래프의 내부 구조를 몰라도, for 루프 하나로 모든 GameObject를 깊이 우선으로 순회할 수 있다.// 사용 예시GameObject scene_root(\"SceneRoot\");// ... 씬 그래프 구성 ...for (auto&amp; object : scene_root) { cout &lt;&lt; \"Updating: \" &lt;&lt; object.name &lt;&lt; endl;}더 나은 방법: 코루틴(Coroutine)을 이용한 순회 앞서 구현한 스택 기반의 operator++는 복잡하고 비직관적이다. C++20에 도입된 코루틴(Coroutine)을 사용하면 이 문제를 매우 우아하게 해결할 수 있다. 코루틴은 함수의 실행을 중간에 멈추고 값을 반환한 뒤, 나중에 그 지점부터 실행을 재개하는 기능을 제공한다.#include &lt;coroutine&gt;#include &lt;experimental/generator&gt; // 컴파일러에 따라 구현이 다를 수 있음// 코루틴을 이용한 재귀적 DFS 생성기(Generator)experimental::generator&lt;GameObject*&gt; GetNodesDFS(GameObject* node) { if (!node) co_return; co_yield node; // 1. 현재 노드를 반환하고 여기서 잠시 멈춘다. for (const auto&amp; child : node-&gt;children) { // 2. 자식 노드에 대한 재귀 호출 결과를 다시 그대로 반환한다. for (auto* child_node : GetNodesDFS(child.get())) { co_yield child_node; } }} 이 GetNodesDFS 함수는 재귀적인 DFS 알고리즘의 모습과 거의 동일하여 매우 직관적이고 가독성이 높다. 스택을 수동으로 관리할 필요도 없다.// 코루틴 사용 예시GameObject scene_root(\"SceneRoot\");// ... 씬 그래프 구성 ...for (auto* object_ptr : GetNodesDFS(&amp;scene_root)) { cout &lt;&lt; \"Updating with coroutine: \" &lt;&lt; object_ptr-&gt;name &lt;&lt; endl;}요약 반복자 패턴은 컬렉션의 내부 구현을 숨긴 채, 요소에 순차적으로 접근하는 표준화된 방법을 제공한다. for (auto&amp; element : collection) 형태의 범위 기반 for 루프는 C++에서 반복자 패턴을 가장 편리하게 사용하는 방법이다. vector 같은 선형 구조뿐만 아니라, 트리와 같은 복잡한 자료구조에 대한 커스텀 반복자를 직접 구현할 수 있다. 전통적인 커스텀 반복자 구현은 복잡할 수 있지만, C++20 코루틴과 같은 현대적인 기능을 활용하면 훨씬 간결하고 가독성 높은 순회 로직을 작성할 수 있다. " }, { "title": "인터프리터 패턴", "url": "/posts/%EC%9D%B8%ED%84%B0%ED%94%84%EB%A6%AC%ED%84%B0-%ED%8C%A8%ED%84%B4/", "categories": "디자인 패턴, 행태 패턴", "tags": "design pattern", "date": "2023-06-08 00:00:00 +0900", "snippet": "인터프리터 패턴 특정 ‘언어’에 대한 문법을 정의하고, 그 언어로 작성된 문장을 해석(interpret)하는 해석기를 제공하는 행위 디자인 패턴 쉽게 말해, 우리가 직접 정의한 간단한 규칙이나 언어를 이해하고 실행하는 엔진을 만드는 방법이다. 게임 개발에서는 NPC의 행동을 정의하는 간단한 스크립트, 퀘스트의 완료 조건, 아이템의 효과 설명 등을 파싱하고 실행하는 데 이 패턴을 활용할 수 있다. 이 패턴은 보통 다음의 두 단계를 거쳐 구현된다. 1.렉싱(Lexing): 입력된 텍스트를 의미 있는 최소 단위인 ‘토큰(Token)’으로 분해한다. 2.파싱(Parsing): 토큰들의 나열을 분석하여, 실행 가능한 구조(보통 트리 형태)로 변환한다. 시나리오 : 간단한 NPC 행동 스크립트 만들기 게임 디자이너나 기획자가 코드를 직접 수정하지 않고, 간단한 텍스트 스크립트로 NPC의 행동을 제어하게 하고 싶다고 가정하자. 우리가 만들 ‘언어’는 다음과 같다.# NPC 'Guard'를 (100, 50) 좌표로 이동시킨다.MOVE Guard 100 50# 'Guard'가 \"멈춰!\" 라고 말하게 한다.SAY Guard \"멈춰!\"# 2.5초간 기다린다.WAIT 2.5 이 스크립트를 읽고, 해석하고, 실제 게임 상에서 NPC를 움직이게 하는 인터프리터를 만들어 보자.1단계: 렉싱 - 스크립트를 토큰으로 분해하기 렉싱(Lexing)은 날것의 문자열을 문법적으로 의미 있는 조각들, 즉 토큰(Token)으로 나누는 과정이다. 먼저 우리 언어에 필요한 토큰의 종류를 정의한다. #include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;struct Token { // 우리 언어의 토큰 타입 정의 enum Type { KEYWORD, // MOVE, SAY, WAIT 같은 명령어 키워드 IDENTIFIER, // Guard 같은 NPC 이름 NUMBER, // 100, 50, 2.5 같은 숫자 STRING, // \"멈춰!\" 같은 문자열 UNKNOWN // 알 수 없는 토큰 } type; string text; // 토큰의 원본 텍스트 Token(Type type, const string&amp; text) : type(type), text(text) {}}; 이제 문자열을 입력받아 vector&lt;Token&gt;을 반환하는 간단한 Lexer 함수를 만든다.// 간단한 렉서 함수vector&lt;Token&gt; Lex(const string&amp; input) { vector&lt;Token&gt; tokens; // ... 실제 렉서는 공백, 따옴표 등을 정교하게 처리해야 하지만 여기서는 개념만 표현한다. // 예: \"MOVE Guard 100 50\" -&gt; {KEYWORD, \"MOVE\"}, {IDENTIFIER, \"Guard\"}, {NUMBER, \"100\"}, {NUMBER, \"50\"} // ... return tokens;} 렉싱이 완료되면, MOVE Guard 100 50 이라는 문자열은 [{KEYWORD, \"MOVE\"}, {IDENTIFIER, \"Guard\"}, {NUMBER, \"100\"}, {NUMBER, \"50\"}] 와 같은 토큰의 스트림으로 변환된다.2단계: 파싱 - 토큰을 실행 가능한 구조로 변환하기 파싱(Parsing)은 렉서가 생성한 토큰 스트림을 읽어, 문법 규칙에 따라 의미 있는 구조로 만드는 과정이다. 여기서는 각 스크립트 명령어를 실행 가능한 커맨드(Command) 객체로 변환한다.1. 모든 커맨드가 따를 공통 인터페이스(Abstract Expression) 정의 이는 인터프리터 패턴의 ‘추상 표현식’에 해당하며, 여기서는 커맨드 패턴을 함께 활용한다.// 모든 스크립트 커맨드의 기본 인터페이스class ICommand {public: virtual ~ICommand() = default; virtual void Execute() = 0;};2. 구체적인 커맨드(Concrete Expression) 구현 각각의 스크립트 명령어에 해당하는 구체적인 커맨드 클래스를 만든다.#include &lt;memory&gt;// MOVE 커맨드class MoveCommand : public ICommand {private: string targetNpc; float x, y;public: MoveCommand(const string&amp; target, float x, float y) : targetNpc(target), x(x), y(y) {} void Execute() override { cout &lt;&lt; targetNpc &lt;&lt; \"를 좌표 (\" &lt;&lt; x &lt;&lt; \", \" &lt;&lt; y &lt;&lt; \")로 이동시킵니다.\" &lt;&lt; endl; }};// SAY 커맨드class SayCommand : public ICommand {private: string targetNpc; string message;public: SayCommand(const string&amp; target, const string&amp; msg) : targetNpc(target), message(msg) {} void Execute() override { cout &lt;&lt; targetNpc &lt;&lt; \"가 말합니다: \" &lt;&lt; message &lt;&lt; endl; }};// WAIT 커맨드class WaitCommand : public ICommand {private: float duration;public: WaitCommand(float seconds) : duration(seconds) {} void Execute() override { cout &lt;&lt; duration &lt;&lt; \"초 동안 기다립니다...\" &lt;&lt; endl; }};3. 파서(Parser) 구현 파서는 토큰 리스트를 받아, 이를 분석하여 ICommand 객체의 리스트로 변환한다.// 간단한 파서 클래스class Parser {public: vector&lt;unique_ptr&lt;ICommand&gt;&gt; Parse(const vector&lt;Token&gt;&amp; tokens) { vector&lt;unique_ptr&lt;ICommand&gt;&gt; commands; for (size_t i = 0; i &lt; tokens.size(); ) { const Token&amp; current = tokens[i]; if (current.type == Token::KEYWORD) { if (current.text == \"MOVE\" &amp;&amp; (i + 3) &lt; tokens.size()) { // MOVE 키워드를 만나면, 뒤따르는 토큰 3개를 이용해 MoveCommand를 생성 const string&amp; target = tokens[i+1].text; float x = stof(tokens[i+2].text); float y = stof(tokens[i+3].text); commands.push_back(make_unique&lt;MoveCommand&gt;(target, x, y)); i += 4; // 토큰 4개를 소비했으므로 인덱스 점프 } else if (current.text == \"SAY\" &amp;&amp; (i + 2) &lt; tokens.size()) { const string&amp; target = tokens[i+1].text; const string&amp; message = tokens[i+2].text; commands.push_back(make_unique&lt;SayCommand&gt;(target, message)); i += 3; } // ... WAIT 등 다른 명령어에 대한 파싱 로직 ... else { // 잘못된 문법 i++; } } else { i++; } } return commands; }};3단계: 해석 및 실행 (Interpretation &amp; Execution) 이제 모든 조각이 모였다. 스크립트를 렉싱하고, 파싱하여, 최종적으로 실행하는 클라이언트 코드를 작성할 수 있다.// 클라이언트 코드 (예: ScriptRunner)int main() { string script = \"MOVE Guard 100 50 SAY Guard \\\"멈춰!\\\"\"; // 1. 렉싱 (문자열 -&gt; 토큰 리스트) vector&lt;Token&gt; tokens = Lex(script); // 실제 Lex 함수는 구현 필요 // 2. 파싱 (토큰 리스트 -&gt; 커맨드 리스트) Parser parser; vector&lt;unique_ptr&lt;ICommand&gt;&gt; commands = parser.Parse(tokens); // 3. 해석 및 실행 (커맨드 실행) cout &lt;&lt; \"--- 스크립트 실행 시작 ---\" &lt;&lt; endl; for (const auto&amp; command : commands) { command-&gt;Execute(); } cout &lt;&lt; \"--- 스크립트 실행 완료 ---\" &lt;&lt; endl;} 이 과정을 통해, 우리는 텍스트 스크립트를 ‘해석’하여 실제 게임 내 동작으로 변환하는 간단한 인터프리터를 완성했다. 새로운 명령어(예: ATTACK)를 추가하고 싶다면, Token enum, ICommand 구현체, 그리고 Parser의 로직에 해당 규칙만 추가하면 된다.요약 인터프리터 패턴은 텍스트 기반의 언어나 규칙을 해석하고 실행하는 방법을 제공한다. 일반적으로 렉싱(문자열을 토큰으로 분해)과 파싱(토큰을 실행 가능한 구조로 변환)의 단계를 거친다. 파싱된 결과는 종종 추상 구문 트리(AST)나, 위 예제처럼 커맨드 객체의 리스트 형태로 표현된다. 이 패턴은 언어가 비교적 단순하고, 문법을 쉽게 확장할 수 있어야 할 때 유용하다. 복잡한 언어(C++, Python 등)를 위한 인터프리터나 컴파일러를 직접 만드는 것은 매우 어려운 일이며, 보통 ANTLR이나 Bison/Flex 같은 전문적인 파서 생성 도구를 사용한다. 하지만 게임 내에서 간단한 스크립팅, 룰 엔진, 데이터 정의 언어 등을 구현할 때 인터프리터 패턴의 기본 원리를 이해하고 적용하면 매우 유연하고 강력한 시스템을 구축할 수 있다." }, { "title": "커맨드 패턴", "url": "/posts/%EC%BB%A4%EB%A7%A8%EB%93%9C-%ED%8C%A8%ED%84%B4/", "categories": "디자인 패턴, 행태 패턴", "tags": "design pattern", "date": "2023-06-05 00:00:00 +0900", "snippet": "커맨드 패턴 player.Jump()처럼 객체의 메서드를 직접 호출하는 대신, ‘점프하라’는 요청(request) 또는 명령(command) 자체를 하나의 객체로 캡슐화하는 것이 커맨드 패턴(Command Pattern)의 핵심이다. 이렇게 요청을 객체로 만들면 어떤 장점이 있을까? 명령을 변수처럼 저장하거나, 큐에 쌓아두고 순서대로 실행하거나, 로그로 남기거나, 심지어 ‘실행 취소(Undo)’하는 것까지 가능해진다. 커맨드 패턴은 요청을 호출하는 객체(Invoker)**와 **요청을 실제로 수행하는 객체(Receiver)를 분리하여, 시스템의 유연성을 크게 향상시키는 행위 디자인 패턴이다. 시나리오: 유연한 플레이어 입력 시스템 만들기 게임에서 플레이어의 키보드 입력을 처리하는 상황을 생각해보자. W, A, S, D 키로 캐릭터를 움직이고, Space 바로 점프하게 만들어야 한다.1. 수신자(Receiver) 정의 먼저, 실제 동작을 수행할 GameActor 클래스를 정의한다.#include &lt;iostream&gt;using namespace std;// 실제 동작을 수행하는 수신자class GameActor {public: void Jump() { cout &lt;&lt; \"점프!\" &lt;&lt; endl; } void Fire() { cout &lt;&lt; \"발사!\" &lt;&lt; endl; } void Move(float x, float y) { cout &lt;&lt; \"이동: (\" &lt;&lt; x &lt;&lt; \", \" &lt;&lt; y &lt;&lt; \")\" &lt;&lt; endl; }};2. 문제점: 경직된 if-else 구조 커맨드 패턴이 없다면, 입력 처리 로직은 보통 거대한 if-else 또는 switch 문으로 구현된다.// 안티 패턴: 입력과 액션이 강하게 결합됨void HandleInput(GameActor&amp; actor) { if (IsKeyPressed(KeyCode::SPACE)) { actor.Jump(); } else if (IsKeyPressed(KeyCode::CONTROL)) { actor.Fire(); } // ... 키가 늘어날수록 복잡해짐} 이 코드는 키보드와 GameActor의 동작이 강하게 결합되어 있다. 키 바인딩을 바꾸거나, 게임패드를 지원하거나, AI가 캐릭터를 조종하게 하려면 이 코드를 전부 수정해야 한다. 매우 비효율적이고 확장성이 떨어진다.커맨드 패턴 구현 이 문제를 해결하기 위해, 각 행동을 ‘커맨드 객체’로 캡슐화한다.1. Command 인터페이스 정의 모든 커맨드 객체가 따를 공통 인터페이스를 정의한다.// 모든 커맨드의 기본 인터페이스class ICommand {public: virtual ~ICommand() = default; virtual void Execute(GameActor&amp; actor) = 0;};2. 구체적인 커맨드(Concrete Command) 구현 이제 각 행동을 별도의 커맨드 클래스로 구현한다.#include &lt;memory&gt;class JumpCommand : public ICommand {public: void Execute(GameActor&amp; actor) override { actor.Jump(); }};class FireCommand : public ICommand {public: void Execute(GameActor&amp; actor) override { actor.Fire(); }};class MoveCommand : public ICommand {private: float x, y;public: MoveCommand(float x, float y) : x(x), y(y) {} void Execute(GameActor&amp; actor) override { actor.Move(x, y); }};3. 호출자(Invoker) 구현 InputHandler는 이제 어떤 키가 눌렸을 때 어떤 커맨드를 실행할지만을 책임진다.#include &lt;map&gt;// 키 입력을 받아 커맨드를 실행시키는 호출자class InputHandler {private: map&lt;KeyCode, unique_ptr&lt;ICommand&gt;&gt; keyBindings;public: InputHandler() { // 게임 시작 시 키 바인딩 설정 keyBindings[KeyCode::SPACE] = make_unique&lt;JumpCommand&gt;(); keyBindings[KeyCode::CONTROL] = make_unique&lt;FireCommand&gt;(); keyBindings[KeyCode::W] = make_unique&lt;MoveCommand&gt;(0, 1); keyBindings[KeyCode::S] = make_unique&lt;MoveCommand&gt;(0, -1); // ... } // 입력을 처리하여 해당하는 커맨드를 실행 ICommand* HandleInput() { for (auto const&amp; [key, command] : keyBindings) { if (IsKeyPressed(key)) { return command.get(); // 실행할 커맨드를 반환 } } return nullptr; }};4. 개선된 게임 루프 이제 게임 루프는 매우 간결해진다.int main() { GameActor player; InputHandler inputHandler; while (true) { // 게임 루프 ICommand* command = inputHandler.HandleInput(); if (command) { command-&gt;Execute(player); } }} 이제 키 바인딩을 바꾸려면 InputHandler의 생성자만 수정하면 된다. AI를 만들고 싶다면, InputHandler와 똑같이 커맨드 객체를 생성하여 Execute를 호출하기만 하면 된다. 입력 소스와 캐릭터의 실제 행동이 완벽하게 분리되었다.실행 취소(Undo) 기능 추가하기 커맨드 패턴의 가장 강력한 활용 사례 중 하나는 ‘실행 취소’ 기능이다. 턴제 전략 게임에서 유닛을 움직였다가 취소하는 상황을 생각해보자.1. Command 인터페이스에 Undo 메서드를 추가한다.class ICommand {public: virtual ~ICommand() = default; virtual void Execute(GameActor&amp; actor) = 0; virtual void Undo(GameActor&amp; actor) = 0;};2.MoveCommand를 Undo가 가능하도록 수정한다. Undo를 하려면 ‘이전 상태’를 알아야 한다. 따라서 MoveCommand는 이동한 거리를 기억해야 한다.class MoveCommand : public ICommand {private: float dx, dy; // 이동한 거리public: MoveCommand(float x, float y) : dx(x), dy(y) {} void Execute(GameActor&amp; actor) override { actor.Move(dx, dy); } void Undo(GameActor&amp; actor) override { // 정반대 방향으로 이동하여 원상복구 actor.Move(-dx, -dy); }};3. 커맨드 기록(Command History) 관리 실행된 커맨드들을 스택(stack)에 저장해두고, ‘실행 취소’ 요청이 오면 스택에서 가장 마지막 커맨드를 꺼내 Undo를 호출한다.#include &lt;vector&gt;vector&lt;unique_ptr&lt;ICommand&gt;&gt; commandHistory;void ExecuteAndStore(unique_ptr&lt;ICommand&gt; command, GameActor&amp; actor) { command-&gt;Execute(actor); commandHistory.push_back(move(command));}void UndoLastCommand(GameActor&amp; actor) { if (!commandHistory.empty()) { commandHistory.back()-&gt;Undo(actor); commandHistory.pop_back(); }} 이제 ExecuteAndStore와 UndoLastCommand 함수를 이용해 무한한 실행 취소/다시 실행(Redo) 기능을 구현할 수 있다.요약 커맨드 패턴은 ‘무엇’을 할 것인지(커맨드 객체)와 ‘누가’ 할 것인지(수신자 객체)를 분리하여, ‘언제’, ‘어떻게’ 할 것인지(호출자 객체)를 자유롭게 결정할 수 있게 한다. 구성 요소: Command: 모든 커맨드의 공통 인터페이스. (ICommand) ConcreteCommand: 실제 요청을 캡슐화한 객체. (JumpCommand, MoveCommand) Receiver: 요청을 실제로 수행하는 객체. (GameActor) Invoker: 커맨드를 실행시키는 객체. (InputHandler) 장점 요청자와 수행자의 분리: 두 객체 간의 결합도를 낮춰 시스템을 유연하게 만든다. 커맨드의 객체화: 커맨드를 큐에 저장(액션 시퀀싱), 로그로 기록(리플레이), 네트워크로 전송하는 등 다양하게 활용할 수 있다. Undo/Redo 기능 구현: 커맨드에 Undo 로직을 추가하여 실행 취소/다시 실행 기능을 쉽게 구현할 수 있다. 확장성: 새로운 커맨드를 추가할 때 기존 코드를 수정할 필요 없이 새로운 ICommand 구현체만 만들면 된다. 이 패턴은 플레이어 입력 처리, AI 행동 결정, UI 버튼 이벤트, 매크로 및 리플레이 시스템, 턴제 게임의 행동 이력 관리 등 게임 개발의 수많은 영역에서 핵심적인 역할을 한다. " }, { "title": "책임 사슬 패턴", "url": "/posts/%EC%B1%85%EC%9E%84-%EC%82%AC%EC%8A%AC-%ED%8C%A8%ED%84%B4/", "categories": "디자인 패턴, 행태 패턴", "tags": "design pattern", "date": "2023-06-02 00:00:00 +0900", "snippet": "책임 사슬 패턴 요청을 처리할 수 있는 객체들의 사슬(chain)을 만들어, 요청이 처리될 때까지 이 사슬을 따라 객체들이 차례대로 요청을 확인하게 만드는 행위 디자인 패턴이다. 요청을 보낸 객체(Sender)는 어떤 객체가 그 요청을 처리할지 알 필요가 없다. 요청은 사슬의 첫 번째 객체에게 전달되고, 해당 객체는 요청을 처리하거나, 처리하지 못할 경우 사슬의 다음 객체에게 요청을 넘긴다. 이 과정을 요청이 처리되거나 사슬의 끝에 도달할 때까지 반복한다. 이 패턴의 핵심 목표는 요청을 보내는 쪽과 요청을 처리하는 쪽의 결합도를 낮추는 것이다. 이를 통해 여러 객체에게 요청을 처리할 기회를 유연하게 제공할 수 있다.시나리오: 게임 캐릭터의 버프와 디버프 시스템 게임 캐릭터가 다양한 버프(buff)와 디버프(debuff) 효과를 받는 시스템을 구현해야 한다. 예를 들어, ‘공격력 2배’ 버프와 ‘방어력 증가’ 버프가 동시에 적용될 수 있어야 하고, 특정 저주에 걸리면 모든 버프 효과가 무시되어야 한다. 먼저, 기본적인 Creature 클래스를 정의한다.#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;struct Creature{ string name; int attack, defense; Creature(const string&amp; name, int attack, int defense) : name(name), attack(attack), defense(defense) {} friend ostream&amp; operator&lt;&lt;(ostream&amp; os, const Creature&amp; obj) { return os &lt;&lt; \"Name: \" &lt;&lt; obj.name &lt;&lt; \", Attack: \" &lt;&lt; obj.attack &lt;&lt; \", Defense: \" &lt;&lt; obj.defense; }}; 이 Creature의 능력치를 어떻게 동적으로, 그리고 여러 효과를 중첩하여 변경할 수 있을까?방법 1: 포인터 체인 (The Pointer Chain) 가장 고전적이고 단순한 책임 사슬 구현은 처리기(Handler)들을 연결 리스트(linked list) 형태로 구성하는 것이다.1. 처리기(Handler) 기본 클래스 정의 모든 능력치 변경 효과(Modifier)의 기반이 될 추상 클래스를 정의한다.// 모든 능력치 변경 효과의 기본 클래스 (처리기의 기본 인터페이스)class CreatureModifier {protected: Creature&amp; creature; CreatureModifier* next = nullptr; // 사슬의 다음 처리기를 가리키는 포인터public: explicit CreatureModifier(Creature&amp; creature) : creature(creature) {} // 사슬에 새로운 처리기를 추가하는 메서드 void Add(CreatureModifier* modifier) { if (next) { next-&gt;Add(modifier); } else { next = modifier; } } // 요청을 처리하는 가상 함수. 기본적으로 다음 처리기에게 요청을 넘긴다. virtual void Handle() { if (next) { next-&gt;Handle(); } }};2. 구체적인 처리기(Concrete Handler) 구현 이제 실제 버프 효과들을 구현한다. 각 효과는 자신의 로직을 수행한 후, 명시적으로 다음 처리기를 호출해야 한다.// 공격력을 2배로 만드는 처리기class DoubleAttackModifier : public CreatureModifier {public: explicit DoubleAttackModifier(Creature&amp; creature) : CreatureModifier(creature) {} void Handle() override { creature.attack *= 2; // 다음 처리기에게 요청 전달 CreatureModifier::Handle(); }};// 방어력을 1 증가시키는 처리기class IncreaseDefenseModifier : public CreatureModifier {public: explicit IncreaseDefenseModifier(Creature&amp; creature) : CreatureModifier(creature) {} void Handle() override { creature.defense += 1; // 다음 처리기에게 요청 전달 CreatureModifier::Handle(); }};// 모든 보너스를 막는 처리기 (사슬을 끊는 역할)class NoBonusesModifier : public CreatureModifier {public: explicit NoBonusesModifier(Creature&amp; creature) : CreatureModifier(creature) {} void Handle() override { // 아무것도 하지 않고, 다음 처리기를 호출하지도 않는다. // 여기서 사슬이 중단된다. }};3. 사용법 및 한계 클라이언트 코드에서 이 처리기들을 수동으로 연결하여 사슬을 구성하고 실행한다.int main() { Creature goblin{\"Goblin\", 1, 1}; CreatureModifier root{goblin}; // 사슬의 시작점 DoubleAttackModifier double_attack{goblin}; IncreaseDefenseModifier increase_defense{goblin}; root.Add(&amp;double_attack); root.Add(&amp;increase_defense); cout &lt;&lt; \"적용 전: \" &lt;&lt; goblin &lt;&lt; endl; root.Handle(); // 사슬 전체를 실행 cout &lt;&lt; \"적용 후: \" &lt;&lt; goblin &lt;&lt; endl;} 이 방식은 책임 사슬의 기본 개념을 잘 보여주지만, 몇 가지 한계가 있다. 능력치 변경이 영구적이다. 버프가 사라졌을 때 원래 값으로 되돌리기 어렵다. 사슬의 중간에 있는 효과를 제거하거나 순서를 바꾸는 것이 복잡하다. 모든 처리기가 Creature의 내부 상태를 직접 수정하므로, 결합도가 여전히 높다. 방법 2: 브로커 체인 (The Broker Chain) 더 유연하고 강력한 방법은 이벤트 브로커(Event Broker) 또는 중재자(Mediator)를 사용하는 것이다. 이는 옵저버 패턴과 중재자 패턴을 결합한 형태다.1. 이벤트 브로커와 질의(Query) 객체 정의 모든 능력치 ‘조회’ 요청을 중계하는 중앙 허브(Game)와, 요청의 내용을 담는 Query 객체를 정의한다.#include &lt;boost/signals2.hpp&gt; // C#의 event와 유사한 시그널/슬롯 라이브러리struct Query { string creature_name; enum class Argument { attack, defense } argument; int&amp; result; // 조회 결과를 담을 참조};// 이벤트 브로커 역할을 하는 중재자struct Game { boost::signals2::signal&lt;void(Query&amp;)&gt; queries;};2. ‘똑똑한’ Creature 클래스 재정의 Creature는 이제 자신의 능력치를 직접 반환하지 않는다. 대신, 이벤트 브로커에게 “내 최종 공격력은 몇인가요?”라고 질의(Query)한다.class Creature {private: Game&amp; game; int base_attack, base_defense;public: string name; // ... 생성자 ... int GetAttack() { Query q{name, Query::Argument::attack, base_attack}; game.queries(q); // 브로커에게 질의를 보낸다. return q.result; // 모든 버프가 적용된 최종 결과를 받는다. } // ... GetDefense()도 유사하게 구현 ...};3. RAII를 이용한 스코프 기반 처리기 이제 능력치 변경 효과들은 Creature를 직접 수정하는 대신, Game의 queries 시그널을 ‘구독’한다. 그리고 자신의 수명이 다하면 자동으로 구독을 ‘해지’한다(RAII 패턴).// RAII를 활용한 스코프 기반 처리기class CreatureModifier {protected: Game&amp; game; Creature&amp; creature;public: CreatureModifier(Game&amp; game, Creature&amp; creature) : game(game), creature(creature) {} virtual ~CreatureModifier() = default;};class DoubleAttackModifier : public CreatureModifier { boost::signals2::connection conn; // 시그널 연결을 관리하는 커넥션 객체public: DoubleAttackModifier(Game&amp; game, Creature&amp; creature) : CreatureModifier(game, creature) { // 생성 시, queries 시그널에 처리 로직(람다)을 연결한다. conn = game.queries.connect([&amp;](Query&amp; q) { if (q.creature_name == creature.name &amp;&amp; q.argument == Query::Argument::attack) { q.result *= 2; } }); } // 소멸 시, conn 객체가 자동으로 파괴되면서 시그널 연결이 해제된다. ~DoubleAttackModifier() { conn.disconnect(); }}; 이 처리기는 Creature의 상태를 직접 바꾸지 않는다. 단지 Game을 통해 전달되는 Query의 result 값만 수정할 뿐이다.4. 사용법 및 장점 이제 버프 적용이 매우 직관적이고 안전해진다.int main() { Game game; Creature goblin{game, \"Goblin\", 2, 2}; cout &lt;&lt; goblin &lt;&lt; endl; // 공격력 2 { // 이 스코프 안에서만 DoubleAttackModifier가 활성화된다. DoubleAttackModifier dam{game, goblin}; cout &lt;&lt; goblin &lt;&lt; endl; // GetAttack() 호출 시 버프가 적용되어 공격력 4 } cout &lt;&lt; goblin &lt;&lt; endl; // 스코프를 벗어나 modifier가 파괴되었으므로 공격력 2} 이 방식은 버프/디버프가 일시적이고, 여러 효과가 서로를 모른 채 독립적으로 적용되며, 적용 순서에 크게 구애받지 않는 게임 시스템을 구축하는 데 매우 효과적이다.요약 책임 사슬 패턴은 요청을 보내는 객체와 이를 처리하는 객체들 간의 결합도를 낮추는 데 목적이 있다. 포인터 체인은 가장 기본적인 구현으로, 처리 순서가 명확한 파이프라인 구조에 적합하다. 브로커 체인은 중재자와 옵저버 패턴을 결합한 고급 구현으로, 여러 처리기가 독립적으로, 그리고 일시적으로 요청에 영향을 미치는 동적인 시스템(예: 게임의 버프 시스템)에 매우 강력한 해결책을 제공한다. 이 패턴을 통해 각 처리기는 자신의 책임에만 집중할 수 있게 되어 단일 책임 원칙(SRP)을 만족시키고, 새로운 처리기를 추가하거나 순서를 변경하는 것이 자유로워져 시스템의 유연성과 확장성을 크게 향상시킬 수 있다. " }, { "title": "프록시 패턴", "url": "/posts/%ED%94%84%EB%A1%9D%EC%8B%9C-%ED%8C%A8%ED%84%B4/", "categories": "디자인 패턴, 구조 패턴", "tags": "design pattern", "date": "2023-05-29 00:00:00 +0900", "snippet": "프록시 프록시(Proxy)는 ‘대리인’을 의미한다. 프록시 패턴은 어떤 객체에 대한 접근을 제어하기 위해, 그 객체를 대신하는 대리 객체를 제공하는 구조 패턴이다. 이 대리 객체는 실제 객체와 동일한 인터페이스를 가지므로, 클라이언트는 자신이 실제 객체를 사용하는지 프록시를 사용하는지 전혀 알 필요 없이 동일한 방식으로 코드를 작성할 수 있다. 프록시는 실제 객체에 대한 요청을 중간에서 가로채, 접근 제어, 비용이 큰 연산의 지연(lazy initialization), 로깅, 원격 통신 등 다양한 부가 작업을 수행한 뒤 실제 객체에 요청을 전달한다. 데코레이터 패턴이 객체에 새로운 ‘기능’을 추가하는 데 중점을 둔다면, 프록시 패턴은 객체로의 ‘접근’을 제어하고 관리하는 데 중점을 둔다.가상 프록시(Virtual Proxy): 무거운 리소스의 지연 로딩 게임 개발에서 프록시 패턴이 가장 유용하게 쓰이는 대표적인 사례는 지연 로딩(Lazy Loading)이다.문제 상황: 긴 로딩 시간과 메모리 낭비 게임 레벨을 시작할 때, 해당 레벨에 필요한 모든 텍스처, 3D 모델, 사운드 등 무거운 리소스를 한꺼번에 로딩한다고 가정해보자.// 실제 텍스처 클래스class Texture {private: string filePath; vector&lt;char&gt; textureData; // 매우 큰 텍스처 데이터public: // 생성자는 매우 비싼 연산이다 (파일 I/O, GPU 업로드). Texture(const string&amp; path) : filePath(path) { cout &lt;&lt; \"'\" &lt;&lt; path &lt;&lt; \"' 에서 텍스처를 로딩합니다... (무거운 작업)\" &lt;&lt; endl; // ... 파일 시스템에서 이미지 데이터를 읽어 textureData에 저장 ... } void Draw() const { cout &lt;&lt; \"'\" &lt;&lt; filePath &lt;&lt; \"' 텍스처를 화면에 그립니다.\" &lt;&lt; endl; }};// 게임 로딩 시 모든 텍스처를 한 번에 생성vector&lt;Texture&gt; textures;textures.emplace_back(\"player.png\");textures.emplace_back(\"enemy.png\");textures.emplace_back(\"boss_monster.png\"); // 아직 보이지도 않는데 미리 로딩textures.emplace_back(\"background.png\");// ... 수백 개의 텍스처 ... 이 방식은 레벨 로딩 시간을 매우 길게 만들고, 당장 사용하지도 않는 리소스까지 메모리에 올려 심각한 메모리 낭비를 유발한다.해결책: 가상 프록시를 이용한 지연 로딩 이 문제를 해결하기 위해 가상 프록시를 도입한다. 이 프록시는 실제 Texture 객체가 필요한 시점까지 생성을 미루는 역할을 한다.1. 공통 인터페이스 정의 먼저, 실제 객체와 프록시가 모두 따를 공통 인터페이스를 정의한다.// 텍스처의 공통 인터페이스class ITexture {public: virtual ~ITexture() = default; virtual void Draw() const = 0;};// 실제 Texture 클래스가 이 인터페이스를 구현하도록 수정class Texture : public ITexture { /* ... 이전과 동일 ... */ };2. 가상 프록시 클래스 구현 TextureProxy는 실제 Texture와 동일한 ITexture 인터페이스를 구현하지만, 생성자는 매우 가볍다.#include &lt;memory&gt;// 실제 Texture 객체를 대리하는 가상 프록시class TextureProxy : public ITexture {private: string filePath; // 파일 경로만 가볍게 저장한다. mutable unique_ptr&lt;Texture&gt; realTexture = nullptr; // 실제 객체에 대한 포인터public: TextureProxy(const string&amp; path) : filePath(path) {} // Draw 메서드가 호출되는 '순간'에 실제 객체를 생성한다. void Draw() const override { // 실제 객체가 아직 생성되지 않았다면, 지금 생성한다. if (realTexture == nullptr) { realTexture = make_unique&lt;Texture&gt;(filePath); } // 실제 객체에 요청을 위임한다. realTexture-&gt;Draw(); }};3. 클라이언트 코드에서의 투명한 사용 이제 클라이언트(렌더링 시스템)는 ITexture 인터페이스에만 의존하므로, 실제 Texture와 TextureProxy를 구분 없이 사용할 수 있다.#include &lt;vector&gt;int main() { cout &lt;&lt; \"--- 레벨 로딩 시작 ---\" &lt;&lt; endl; vector&lt;unique_ptr&lt;ITexture&gt;&gt; sceneTextures; // 프록시 생성은 파일 경로만 저장하므로 매우 빠르다. sceneTextures.push_back(make_unique&lt;TextureProxy&gt;(\"player.png\")); sceneTextures.push_back(make_unique&lt;TextureProxy&gt;(\"enemy.png\")); sceneTextures.push_back(make_unique&lt;TextureProxy&gt;(\"boss_monster.png\")); sceneTextures.push_back(make_unique&lt;TextureProxy&gt;(\"background.png\")); cout &lt;&lt; \"--- 레벨 로딩 완료 (매우 빠름) ---\" &lt;&lt; endl &lt;&lt; endl; // --- 게임 렌더링 루프 --- cout &lt;&lt; \"화면에 보이는 객체만 렌더링합니다...\" &lt;&lt; endl; // 플레이어와 배경만 화면에 보인다고 가정 sceneTextures[0]-&gt;Draw(); // 이때 'player.png'가 실제로 로딩된다. sceneTextures[3]-&gt;Draw(); // 이때 'background.png'가 실제로 로딩된다. // 'boss_monster.png'는 Draw()가 호출되지 않았으므로 아직 메모리에 로딩되지 않았다.} 이처럼 가상 프록시는 객체의 생성을 실제로 필요한 시점까지 지연시켜, 초기화 성능을 최적화하고 메모리 사용을 효율적으로 관리한다.프록시 패턴의 다른 활용 프록시 패턴은 지연 로딩 외에도 다양한 목적으로 활용된다.보호 프록시 (Protection Proxy) 객체에 대한 접근을 제어하는 역할을 한다. 특정 조건을 만족하는 클라이언트만 실제 객체의 메서드를 호출할 수 있도록 허용한다. 게임 개발 예시: GameCommandConsole이라는 치트 콘솔이 있다고 가정하자. 일반 유저는 Help, Quit 같은 기본 명령어만 사용할 수 있어야 하고, 개발자만 GiveItem, GodMode 같은 강력한 명령어를 사용할 수 있어야 한다. ConsoleProxy를 만들어, ExecuteCommand 요청이 들어왔을 때 사용자의 권한을 먼저 확인하고, 권한이 없으면 요청을 차단하고, 권한이 있으면 실제 GameCommandConsole 객체에 요청을 전달할 수 있다.원격 프록시 (Remote Proxy) 다른 주소 공간(예: 다른 프로세스, 다른 서버)에 있는 객체를 로컬에 있는 것처럼 사용할 수 있게 해주는 대리인이다. 게임 개발 예시: 온라인 게임에서 플레이어의 인벤토리는 서버에 저장된다. 클라이언트 코드에서 server.SendPacket(MoveItem, …) 같은 저수준 네트워크 코드를 직접 다루는 것은 복잡하다. 대신, 클라이언트에 InventoryProxy를 둔다. 클라이언트 코드가 inventoryProxy-&gt;MoveItem(slotA, slotB)를 호출하면, 프록시 내부에서는 이 요청을 네트워크 패킷으로 변환하여 서버에 전송하고 응답을 기다린다. 클라이언트 입장에서는 마치 로컬에 있는 인벤토리를 다루는 것처럼 코드를 작성할 수 있다.요약 프록시 패턴은 실제 객체를 대신하는 대리 객체를 통해, 원래 객체로의 접근을 제어하고 다양한 부가 기능을 수행하는 패턴이다. 프록시는 실제 객체와 동일한 인터페이스를 구현하므로, 클라이언트는 둘을 구분하지 않고 투명하게 사용할 수 있다.주요 용도 및 장점 지연 초기화 (가상 프록시): 생성 비용이 큰 객체의 생성을 필요한 시점까지 미뤄 성능을 최적화한다. 접근 제어 (보호 프록시): 특정 조건에 따라 객체에 대한 접근 권한을 제어하여 보안을 강화한다. 원격 통신 추상화 (원격 프록시): 네트워크의 복잡성을 숨겨, 원격 객체를 로컬 객체처럼 다룰 수 있게 한다. 로깅 및 캐싱: 실제 객체에 대한 요청 앞뒤로 로그를 남기거나, 자주 사용되는 요청의 결과를 캐싱하여 성능을 향상시킬 수 있다. 프록시 패턴은 실제 객체의 코드를 변경하지 않으면서도 그 객체의 생명주기와 접근 방식을 유연하게 제어할 수 있는 강력한 구조적 패턴이다. " }, { "title": "문자열을 진수로 바꾸는 함수", "url": "/posts/%EB%AC%B8%EC%9E%90%EC%97%B4%EC%9D%84-%EC%A7%84%EC%88%98%EB%A1%9C-%EB%B0%94%EA%BE%B8%EB%8A%94-%ED%95%A8%EC%88%98/", "categories": "코딩테스트", "tags": "coding test", "date": "2023-05-27 00:00:00 +0900", "snippet": "문자열을 진수로 바꾸는 함수long strtol(const char* str,char **str_end, int base);// str : NULL로 종결되는 수식을 포함하는 문자열의 포인터// str_end : 변환이 멈춰진 문자열의 포인터, 멈춰진 문자열의 주소값이 들어가 있다.// base : 변환될 문자열의 기수(2,8,10,16진수 선택 ) 2~36진수까지 가능예시#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main(void){char* ch = (char*)\"145\"; //145 저장long value = strtol(ch, NULL, 16); // 16진수로 계산// 두 번째 인수에는 다음 정수를 저장할 포인터가 필요없으므로 NULLcout &lt;&lt; value &lt;&lt; endl;// 두 번째 인수 NULL 은 여러 개의 정수로 된 문자열을 변환할 때 사용// 두 번째 인수에는 이전 숫자의 끝 부분을 저장한다.// 공백을 기준으로 정수를 나눔char src[100] = \"123 af 16 1001\";char* pos = NULL;long value1 = 0, value2 = 0, value3 = 0, value4 = 0;value1 = strtol(src, &amp;pos, 10); //10진수로 계산 value2 = strtol(pos, &amp;pos, 16); //16진수로 계산value3 = strtol(pos, &amp;pos, 8); //8진수로 계산value4 = strtol(pos, &amp;pos, 2); //2진수로 계산printf(\"%d %d %d %d\\n\", value1, value2, value3, value4);return 0;}" }, { "title": "공백문자 포함해서 입력받기", "url": "/posts/%EA%B3%B5%EB%B0%B1%EB%AC%B8%EC%9E%90-%ED%8F%AC%ED%95%A8%ED%95%B4%EC%84%9C-%EC%9E%85%EB%A0%A5%EB%B0%9B%EA%B8%B0/", "categories": "코딩테스트", "tags": "coding test", "date": "2023-05-27 00:00:00 +0900", "snippet": "getline cin이나 scanf 함수를 사용하면 공백문자를 입력받는 순간 거기서 끊어져 버린다. getline을 이용하여 공백문자까지 포함할 수 있다. // char 배열 버전char input[100];cin.getline(input, 100, '\\n'); // 배열, 배열 크기, 문자의 끝을 구분하는 문자// string 버전string s;getline(cin, s); // 두 번째 인수에 저장할 string 타입 변수scanf_s scanf_s 함수에서 마지막 문자열을 지정하는 []를 이용해도 공백문자를 받을 수 있다.#include &lt;iostream&gt;using namespace::std;int main(void){\tchar str[100]; // [^문자]는 문자가 나오기 전까지 모든 문자열을 입력받는다. // 여기서 문자 : \\n이므로 엔터키를 받기 전까지 입력받음\tscanf_s(\" %[^\\n]s\", str,sizeof(str));\tprintf(\"%s\", str); // 입력 : abc abc // 결과 : abc abc}// 추가int main(void){\tchar str[100]; // [문자]는 해당 문자 이외의 값이 나오기 전까지 모든 문자열을 받는다.\tscanf_s(\" %[abc]s\", str,sizeof(str));\tprintf(\"%s\", str); // 입력 abcdabc // 결과 abc}" }, { "title": "플라이웨이트 패턴", "url": "/posts/%ED%94%8C%EB%9D%BC%EC%9D%B4%EC%9B%A8%EC%9D%B4%ED%8A%B8-%ED%8C%A8%ED%84%B4/", "categories": "디자인 패턴, 구조 패턴", "tags": "design pattern", "date": "2023-05-25 00:00:00 +0900", "snippet": "플라이웨이트 패턴 원래 권투의 체급 중 가장 가벼운 체급을 의미한다. 플라이웨이트 패턴은 이름처럼 대량의 객체들을 '가볍게' 만들기 위한 구조 패턴이다. 수많은 객체 사이에 공통적으로 사용될 수 있는 데이터를 공유하여, 메모리 사용량을 획기적으로 줄이는 것을 목적으로 한다. 오픈월드 게임에 수만 그루의 나무를 배치하는 상황을 생각해보자. 모든 나무 객체가 저마다의 3D 모델(메시, 텍스처 등) 데이터를 가지고 있다면 엄청난 메모리를 소모할 것이다. 하지만 대부분의 ‘떡갈나무’는 사실상 동일한 모델을 사용한다. 플라이웨이트 패턴은 바로 이 점에 착안한다. 무거운 데이터(모델)는 한 번만 로드하여 공유하고, 각 나무 객체는 자신의 고유한 정보(위치, 크기, 각도 등)만 ‘가볍게’ 가지도록 하는 것이다.시나리오: 거대한 숲 렌더링하기 오픈월드 게임에 수천, 수만 그루의 나무가 있는 숲을 구현해야 한다.1. 문제점: 무거운 객체의 대량 생성 가장 단순하고 직관적인 방법은 나무에 필요한 모든 데이터를 담은 Tree 클래스를 만들고, 필요한 만큼 인스턴스를 생성하는 것이다.// 안티 패턴: 모든 데이터를 포함하는 무거운 객체class HeavyTree {private: // 각 인스턴스가 고유한 모델 데이터를 가진다고 가정 vector&lt;float&gt; mesh_vertices; // 수만 개의 정점 데이터 (무거움) vector&lt;char&gt; texture_data; // 고해상도 텍스처 데이터 (매우 무거움) // ... 기타 재질(Material) 정보 ... // 각 나무의 고유한 상태 Matrix4x4 transform; // 위치, 회전, 크기};// 숲을 생성vector&lt;HeavyTree&gt; forest;for (int i = 0; i &lt; 10000; ++i) { forest.emplace_back(/* ... */);} 이 방식은 나무 10,000그루를 생성할 때, 무거운 mesh_vertices와 texture_data를 10,000번 복제하여 메모리에 올린다. 이는 수 기가바이트(GB)의 메모리를 순식간에 소모하며, 현실적으로 불가능한 접근 방식이다.해결책: 플라이웨이트 패턴으로 데이터 공유하기 플라이웨이트 패턴은 객체의 상태를 두 가지로 분리한다. 본질적 상태 (Intrinsic State): 여러 객체에서 공유 가능한 불변의 데이터. (예: 나무의 3D 모델, 텍스처, 기본 재질) 외재적 상태 (Extrinsic State): 각 객체마다 고유해야 하는 데이터. (예: 나무의 위치, 크기, 회전, 체력) 1. 플라이웨이트(Flyweight) 클래스 정의 먼저, 공유할 본질적 상태를 담는 TreeModel 클래스를 정의한다. 이 객체는 매우 무겁지만, 종류별로 단 한 번만 생성될 것이다.#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;memory&gt;#include &lt;map&gt;using namespace std;// 플라이웨이트 클래스: 공유되는 무거운 데이터를 담는다.class TreeModel {private: string mesh; // 3D 모델 데이터 (단순화된 표현) string texture; // 텍스처 데이터 (단순화된 표현)public: TreeModel(const string&amp; mesh, const string&amp; texture) : mesh(mesh), texture(texture) { cout &lt;&lt; mesh &lt;&lt; \" 모델 로딩 완료 (무거운 작업).\" &lt;&lt; endl; } void Render(const Matrix4x4&amp; transform) const { // 이 모델을 주어진 transform 위치에 렌더링한다. cout &lt;&lt; mesh &lt;&lt; \"을(를) 렌더링합니다.\" &lt;&lt; endl; }};2. 플라이웨이트 팩토리(Flyweight Factory) 구현 TreeModel 객체의 생성을 관리하고, 이미 생성된 모델은 재사용하도록 보장하는 팩토리를 만든다.// TreeModel의 생성을 관리하고 공유를 보장하는 팩토리class TreeModelFactory {private: map&lt;string, shared_ptr&lt;TreeModel&gt;&gt; models;public: shared_ptr&lt;TreeModel&gt; GetModel(const string&amp; modelName) { if (models.find(modelName) == models.end()) { // 캐시에 없으면 새로 생성하여 저장 if (modelName == \"Oak\") { models[modelName] = make_shared&lt;TreeModel&gt;(\"OakTree.obj\", \"OakTexture.png\"); } else if (modelName == \"Pine\") { models[modelName] = make_shared&lt;TreeModel&gt;(\"PineTree.obj\", \"PineTexture.png\"); } } return models[modelName]; }};3. 컨텍스트(Context) 클래스 정의 이제 실제 나무 객체는 고유한 외재적 상태와 플라이웨이트 객체에 대한 참조만 가진다. 이 객체는 매우 ‘가볍다’.// 각 나무 인스턴스를 나타내는 가벼운 '컨텍스트' 클래스class Tree {private: // 외재적(고유) 상태 Matrix4x4 transform; // 위치, 회전, 크기 // 본질적(공유) 상태에 대한 참조 shared_ptr&lt;TreeModel&gt; model;public: Tree(shared_ptr&lt;TreeModel&gt; model, const Matrix4x4&amp; transform) : model(model), transform(transform) {} void Render() const { // 렌더링 요청이 오면, 실제 작업은 공유 모델(플라이웨이트)에 위임한다. model-&gt;Render(this-&gt;transform); }};4. 숲 생성 및 렌더링 이제 10,000그루의 나무를 효율적으로 생성하고 렌더링할 수 있다.int main() { TreeModelFactory factory; vector&lt;Tree&gt; forest; cout &lt;&lt; \"--- 숲 생성 시작 ---\" &lt;&lt; endl; for (int i = 0; i &lt; 5000; ++i) { // 'Oak' 모델은 최초 한 번만 로딩되고 계속 공유된다. shared_ptr&lt;TreeModel&gt; oakModel = factory.GetModel(\"Oak\"); forest.emplace_back(oakModel, Matrix4x4::RandomTransform()); } for (int i = 0; i &lt; 5000; ++i) { // 'Pine' 모델도 최초 한 번만 로딩되고 계속 공유된다. shared_ptr&lt;TreeModel&gt; pineModel = factory.GetModel(\"Pine\"); forest.emplace_back(pineModel, Matrix4x4::RandomTransform()); } cout &lt;&lt; \"--- 숲 생성 완료 ---\" &lt;&lt; endl &lt;&lt; endl; // 렌더링 cout &lt;&lt; \"--- 렌더링 시작 ---\" &lt;&lt; endl; for (const auto&amp; tree : forest) { tree.Render(); // 각 나무는 자신의 위치에 공유된 모델을 그린다. }} 결과적으로, 무거운 TreeModel 객체는 ‘떡갈나무’와 ‘소나무’ 단 두 개만 메모리에 존재하고, forest 벡터에는 10,000개의 가벼운 Tree 객체(transform 정보와 포인터)만 저장된다. 이는 엄청난 메모리 절약으로 이어진다. GPU에서 이와 유사한 기법을 인스턴스드 렌더링(Instanced Rendering)이라 부른다.요약 플라이웨이트 패턴은 대량의 유사 객체를 효율적으로 지원하기 위해 데이터 공유를 통해 메모리 사용량을 최소화하는 패턴이다. 객체의 상태를 여러 객체가 공유할 수 있는 본질적 상태(Intrinsic State, 플라이웨이트)와, 각 객체마다 고유해야 하는 외재적 상태(Extrinsic State, 컨텍스트)로 분리하는 것이 핵심이다. 플라이웨이트 팩토리는 플라이웨이트 객체의 생성을 관리하며, 이미 존재하는 객체의 재사용을 보장한다.장점 메모리 효율성: 패턴의 주된 목적으로, 공유를 통해 시스템의 전체 메모리 사용량을 크게 줄인다. 성능 향상: 메모리 사용량이 줄어들면 CPU 캐시 효율이 높아지고, 객체 생성 및 관리 비용이 감소하여 전반적인 성능이 향상될 수 있다. 상태의 중앙 관리: 공유되는 본질적 상태가 팩토리를 통해 중앙에서 관리되므로 데이터 일관성을 유지하기 용이하다. 게임에서 타일맵, 파티클 시스템, 군중, 총알 등 대량의 유사 객체를 처리해야 하는 거의 모든 상황에서 플라이웨이트 패턴은 필수적인 최적화 기법이다. " }, { "title": "퍼사드 패턴", "url": "/posts/%ED%8D%BC%EC%82%AC%EB%93%9C-%ED%8C%A8%ED%84%B4/", "categories": "디자인 패턴, 구조 패턴", "tags": "design pattern", "date": "2023-05-21 00:00:00 +0900", "snippet": "퍼사드 패턴 프랑스어로 ‘건물의 정면’을 의미한다. 건물의 복잡한 내부 구조(배관, 전기, 골조 등)와 상관없이, 우리는 깔끔한 정면(출입구)을 통해 건물에 쉽게 드나들 수 있다. 퍼사드 패턴은 이와 동일한 개념을 소프트웨어 설계에 적용한 것이다. 복잡하게 얽혀있는 여러 서브시스템(subsystems)의 기능들을 한데 묶어, 사용하기 쉬운 단일 인터페이스를 제공하는 구조 패턴이다. 클라이언트는 복잡한 내부 동작을 전혀 알 필요 없이, 퍼사드가 제공하는 간결한 API만을 호출하여 원하는 기능을 수행할 수 있다.시나리오: 복잡한 마법(Spell) 시전 과정 게임에서 플레이어가 ‘파이어볼’ 마법 하나를 시전하는 과정을 생각해보자. 이 간단해 보이는 동작 뒤에는 수많은 서브시스템의 협력이 필요하다.1. 관련된 서브시스템들 하나의 마법을 구현하기 위해 다음과 같은 여러 독립적인 시스템이 관여한다. AnimationSystem: 캐릭터의 마법 시전 애니메이션을 재생한다. ParticleSystem: 파이어볼의 불꽃, 폭발 효과 등 파티클을 생성하고 관리한다. SoundSystem: 마법 시전 소리, 폭발음 등 효과음을 재생한다. EffectSystem: 적에게 ‘화상’과 같은 상태 이상 효과를 적용한다. PhysicsSystem: 발사된 파이어볼의 충돌을 감지한다. 2. 문제점: 서브시스템에 대한 직접적인 의존 퍼사드 패턴이 없다면, ‘파이어볼’을 시전하는 코드는 다음과 같이 매우 복잡하고 지저분해진다.// 안티 패턴: 클라이언트가 모든 서브시스템을 직접 제어void Player::CastFireball(Target* target){ // 1. 애니메이션 재생 animationSystem-&gt;Play(\"Cast_Fire_Anim\", this); // 2. 사운드 재생 soundSystem-&gt;Play(\"fireball_cast.wav\", this-&gt;GetPosition()); // 3. 파티클 생성 particleSystem-&gt;Emit(\"fireball_projectile.effect\", this-&gt;GetHandPosition(), target-&gt;GetPosition()); // 4. 충돌 감지 및 결과 처리 if (physicsSystem-&gt;CheckHit(projectile, target)) { // 5. 적중 시 추가 효과 soundSystem-&gt;Play(\"explosion.wav\", target-&gt;GetPosition()); particleSystem-&gt;Emit(\"explosion.effect\", target-&gt;GetPosition()); effectSystem-&gt;ApplyEffect(\"Burning\", target, 10.0f); // 10초간 화상 target-&gt;TakeDamage(50); } // ...} 이 코드는 다음과 같은 심각한 문제를 가진다. 높은 복잡도: 마법 하나를 구현하는 데 너무 많은 코드가 필요하고, 로직을 파악하기 어렵다. 강한 결합: Player 클래스가 5개의 다른 서브시스템에 직접적으로 의존한다. 만약 ParticleSystem의 API가 변경되면, Player 코드를 포함한 모든 마법 시전 코드를 수정해야 한다. 중복 코드: ‘아이스 볼트’ 마법을 만들려면, 이 복잡한 코드를 거의 그대로 복사-붙여넣기 해야 한다. 해결책: MagicSystem 퍼사드 도입 이 문제에 대한 해결책은, 이 모든 서브시스템들을 관장하는 MagicSystem이라는 퍼사드를 만드는 것이다.1. 퍼사드 클래스 구현 MagicSystem은 내부에 필요한 모든 서브시스템에 대한 참조를 가지고, 이들을 조율(orchestration)하는 역할을 담당한다.#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;// -- 개념적인 서브시스템들 (실제 구현은 생략) --class AnimationSystem { public: void Play(const string&amp; anim) { /*...*/ } };class SoundSystem { public: void Play(const string&amp; sound) { /*...*/ } };class ParticleSystem { public: void Emit(const string&amp; effect) { /*...*/ } };class EffectSystem { public: void Apply(const string&amp; effect) { /*...*/ } };// ...// 마법 시전에 필요한 모든 데이터를 담는 구조체struct SpellData { string castAnimation; string castSound; string projectileParticle; string hitEffect;};// 퍼사드 클래스class MagicSystem {private: // 퍼사드는 내부에 복잡한 서브시스템들을 포함한다. AnimationSystem animSystem; SoundSystem soundSystem; ParticleSystem particleSystem; EffectSystem effectSystem; map&lt;string, SpellData&gt; spellbook; // 사용 가능한 마법 데이터public: MagicSystem() { // 게임 시작 시, 마법 데이터를 로드한다고 가정 spellbook[\"Fireball\"] = {\"Cast_Fire\", \"fireball.wav\", \"fire_p.effect\", \"Burning\"}; spellbook[\"IceBolt\"] = {\"Cast_Ice\", \"ice.wav\", \"ice_p.effect\", \"Frozen\"}; } // 클라이언트에게 제공되는 단순화된 인터페이스 void CastSpell(const string&amp; spellName) { cout &lt;&lt; \"--- Casting \" &lt;&lt; spellName &lt;&lt; \" ---\" &lt;&lt; endl; // 0. 시전하려는 마법 데이터 조회 auto data = spellbook.find(spellName); if (data == spellbook.end()) { cout &lt;&lt; \"Unknown spell!\" &lt;&lt; endl; return; } const SpellData&amp; spellData = data-&gt;second; // 1. 퍼사드 내부에서 복잡한 서브시스템들을 순서대로 호출하고 조율한다. animSystem.Play(spellData.castAnimation); soundSystem.Play(spellData.castSound); particleSystem.Emit(spellData.projectileParticle); // ... 충돌 감지 후 ... effectSystem.Apply(spellData.hitEffect); cout &lt;&lt; \"--------------------\" &lt;&lt; endl; }};2. 퍼사드를 통한 클라이언트 코드 개선 이제 Player 코드는 매우 간결하고 명확해진다.// 개선된 클라이언트 코드class Player {private: MagicSystem&amp; magic; // 퍼사드에 대한 참조만 가짐public: Player(MagicSystem&amp; magicSystem) : magic(magicSystem) {} void CastFireball() { // 복잡한 과정은 모두 퍼사드에 위임한다. magic.CastSpell(\"Fireball\"); } void CastIceBolt() { magic.CastSpell(\"IceBolt\"); }};// --- 게임의 메인 로직 ---int main() { MagicSystem magicSystem; // 퍼사드 객체 생성 Player player(magicSystem); player.CastFireball(); player.CastIceBolt();} 이제 Player 클래스는 MagicSystem의 존재만 알면 될 뿐, 그 뒤에 얼마나 많은 시스템이 어떻게 움직이는지 전혀 신경 쓸 필요가 없다. 마법 시전 로직이 변경되면 MagicSystem 퍼사드 내부만 수정하면 되므로, 클라이언트 코드는 영향을 받지 않는다.요약 퍼사드 패턴은 복잡한 서브시스템에 대한 단순하고 통합된 창구(인터페이스)를 제공하는 패턴이다. 클라이언트는 퍼사드 객체와만 상호작용하므로, 서브시스템 간의 복잡한 의존 관계로부터 완벽하게 분리된다.장점 복잡성 감소: 클라이언트는 복잡한 내부 구현을 알 필요 없이 간단한 메서드 호출만으로 원하는 기능을 사용할 수 있다. 결합도 감소: 클라이언트와 서브시스템 간의 결합도를 낮춘다. 서브시스템의 내부 코드가 변경되거나 교체되어도, 퍼사드의 인터페이스만 동일하다면 클라이언트 코드는 수정할 필요가 없다. 가독성 및 유지보수성 향상: 관련 기능들이 퍼사드에 모여있으므로 코드를 이해하기 쉽고, 수정이 필요할 때 한 곳만 집중하면 되므로 유지보수가 용이하다. 계층화된 시스템 구축: 퍼사드를 이용해 시스템을 여러 계층으로 나눌 수 있다. 각 서브시스템은 독립적으로 개발하고, 퍼사드를 통해 상위 계층에 필요한 기능만 노출할 수 있다. 라이브러리나 프레임워크를 설계할 때, 또는 여러 하위 시스템을 조율하여 특정 기능을 제공해야 할 때 퍼사드 패턴은 코드를 훨씬 깔끔하고 견고하게 만들어주는 필수적인 도구다. " }, { "title": "가비지 컬렉터", "url": "/posts/%EA%B0%80%EB%B9%84%EC%A7%80-%EC%BB%AC%EB%A0%89%ED%84%B0/", "categories": "unreal, 용어", "tags": "unreal", "date": "2023-05-19 00:00:00 +0900", "snippet": "가비지 컬렉터 언리얼 엔진의 가비지 컬렉터는 메모리 관리를 자동화하는 시스템으로, 사용되지 않는 객체들을 자동으로 식별하고 제거하여 메모리 누수를 방지 UObject 기반의 객체들을 관리 기능 자동 메모리 관리: 언리얼 엔진의 가비지 컬렉터는 객체가 더 이상 참조되지 않으면 이를 자동으로 감지하고, 메모리에서 해제. 이를 통해 개발자는 객체 생명주기를 수동으로 관리할 필요 없이 안전하게 메모리를 관리 루트 세트 관리: 가비지 컬렉터는 ‘루트 세트’로 불리는 참조 집합을 기반으로 객체를 추적합니다. 루트 세트에 포함된 객체는 수동으로 관리되며, 이들로부터 연결된 객체들이 메모리에 유지됩니다. 주기적 실행: 가비지 컬렉터는 주기적으로 실행되며, 각 실행 시 사용되지 않는 객체들을 수집하여 메모리를 해제합니다.작동방식 가비지 컬렉터는 Mark and Sweep 방식으로 동작 마크 단계: 루트 세트에서 시작하여 모든 참조된 객체들을 탐색하고, 사용 중인 객체를 ‘마크’ 스윕 단계: 마크되지 않은 객체들은 메모리에서 제거. 이 과정에서, 객체가 가비지 컬렉션에 포함되면 해당 객체에 대한 포인터는 null로 설정되며, 이후에 이를 사용하려고 하면 오류가 발생 장점 메모리 누수 방지: 가비지 컬렉터는 사용되지 않는 객체를 자동으로 제거하여 메모리 누수를 방지합니다. 이는 특히 대규모 프로젝트에서 중요한 기능입니다. 개발 효율성 향상: 가비지 컬렉터 덕분에 개발자는 객체의 생명주기를 일일이 관리하지 않아도 되므로, 코드 유지보수가 용이해지고 개발 효율성이 높아집니다. 안전성: 메모리 관리를 자동화하여 수동 메모리 관리로 인한 잠재적인 오류를 줄입니다. 알면 좋은점 UPROPERTY 사용: 가비지 컬렉터는 UPROPERTY 매크로를 통해 객체를 추적합니다. 객체를 안전하게 관리하려면, 클래스 멤버 변수에 UPROPERTY를 사용하여 가비지 컬렉터가 해당 객체를 추적할 수 있도록 해야 합니다. TWeakObjectPtr 사용: 객체의 생존 여부를 확인해야 하지만 가비지 컬렉터에 의해 제거되지 않도록 하려면, TWeakObjectPtr을 사용하는 것이 좋습니다. 수동 가비지 컬렉션: 특정 상황에서 필요할 때, ForceGarbageCollection() 함수를 사용하여 가비지 컬렉션을 강제로 실행할 수 있습니다. " }, { "title": "UPARAM", "url": "/posts/UPARAM/", "categories": "unreal, 용어", "tags": "unreal", "date": "2023-05-19 00:00:00 +0900", "snippet": "UPARAM 언리얼 엔진에서 함수 매개변수의 동작을 변경하거나 메타데이터를 추가하기 위해 사용되는 매크로 이 매크로는 주로 함수가 블루프린트에 노출될 때 특정 매개변수의 동작을 제어하는 데 사용기능 UPARAM은 함수 매개변수가 블루프린트에서 어떻게 나타나는지를 제어하는 데 중요한 역할 예를 들어, 매개변수를 입력 또는 출력 핀으로 지정하거나, 표시 이름을 변경하는 등의 기능을 제공 종류 및 예시refUFUNCTION(BlueprintCallable)void ModifySomeArray(UPARAM(ref) TArray&lt;bool&gt;&amp; BooleanArray); 이 지정자는 매개변수를 참조(Reference)로 전달할 때 사용되며, 블루프린트에서 해당 매개변수를 출력 핀으로 노출하지 않고 입력 핀으로 유지 기본적으로, 참조로 전달된 매개변수는 블루프린트에서 출력 핀으로 나타나지만, UPARAM(ref)를 사용하면 이를 입력 핀으로 변경 DisplayNameUFUNCTION(BlueprintCallable)void AnalyzeVector(UPARAM(DisplayName=\"Input Vector\") FVector&amp; InVector); 블루프린트에서 특정 매개변수의 이름을 사용자 정의 C++ 변수명과는 다른 이름을 블루프린트에 표시하고자 할 때 유용 AdvancedDisplayUFUNCTION(BlueprintCallable, meta=(AdvancedDisplay = 1))void ShowMessage(FString Message, FLinearColor TextColor = FLinearColor(1.f, 0.f, 0.f), float TimeToDisplay = 5.f); 블루프린트 노드에서 매개변수가 기본적으로 숨겨지도록 하며, 사용자가 확장하여 볼 수 있도록 설정 주로 선택적이거나 자주 사용되지 않는 매개변수에 사용." }, { "title": "ini파일", "url": "/posts/Targetcs%ED%8C%8C%EC%9D%BC/", "categories": "unreal, 용어", "tags": "unreal", "date": "2023-05-18 00:00:00 +0900", "snippet": "Target.cs 파일 언리얼 엔진의 빌드 프로세스에서 특정 타겟(예: 게임, 에디터, 서버 등)에 대해 필요한 설정을 정의하는 C# 스크립트 이 파일은 주로 Unreal Build Tool(UBT)에 의해 사용되며, 빌드할 타겟의 타입, 모듈 목록, 빌드 환경 설정 등을 지정. 기능 타겟 타입 지정: Target.cs 파일은 게임, 에디터, 서버, 클라이언트 등 빌드할 타겟의 타입을 지정합니다. 이를 통해 서로 다른 환경에서 서로 다른 빌드 설정을 사용할 수 있습니다. 모듈 설정: 타겟 빌드에 포함될 모듈들을 지정할 수 있습니다. 예를 들어, 특정 타겟에서만 필요한 모듈을 빌드에 포함시키는 식으로 빌드 최적화가 가능합니다. 빌드 설정 지정: Target.cs 파일은 빌드의 기본 설정, 컴파일러 옵션, 포함 경로 등 다양한 빌드 설정을 정의합니다. 이를 통해 각 타겟에 맞춘 빌드를 생성할 수 있습 장점 다중 타겟 지원: 하나의 프로젝트에서 여러 빌드 타겟을 관리할 수 있도록 하여, 게임, 에디터, 서버, 클라이언트 등의 빌드를 개별적으로 설정할 수 있습니다. 유연한 빌드 프로세스: 빌드 환경을 쉽게 변경하고 확장할 수 있습니다. 예를 들어, 특정 플랫폼에 맞춘 빌드 설정을 할 때 유용합니다. 플랫폼별 설정 관리: 각 플랫폼에 대한 빌드 설정을 분리하여 관리할 수 있어, 다양한 플랫폼을 지원하는 게임 개발에 적합합니다. 사용자 정의 Target.cs 파일 만드는 방법 1.프로젝트 소스 폴더에 파일 생성 프로젝트의 Source 폴더에 새로운 Target.cs 파일을 생성합니다. 2.기존 타겟 클래스에서 상속: 사용자 정의 타겟 파일에서 기본 타겟 클래스를 상속받아 새로운 타겟을 정의 using UnrealBuildTool;using System.Collections.Generic;public class ProjectName_EOSTarget : ProjectNameTarget{ public ProjectName_EOSTarget(TargetInfo Target) : base(Target) { // 추가 설정 CustomConfig = \"EOS\"; }} 3.빌드 설정 수정 필요한 경우, 사용자 정의 타겟에 대해 특정 설정을 덮어쓰거나 추가 플랫폼별 또는 기능별 구분 여러 타겟을 생성하여 각기 다른 설정을 적용할 수 있습니다. 예를 들어, EOS(에픽 온라인 서비스)와 스팀(Steam)을 개별적으로 타겟팅하는 설정을 각각 만들 수 있다 " }, { "title": "ini파일", "url": "/posts/ini%ED%8C%8C%EC%9D%BC/", "categories": "unreal, 용어", "tags": "unreal", "date": "2023-05-17 00:00:00 +0900", "snippet": " 언리얼 엔진에서 .ini 파일은 게임 설정을 저장하고 관리하는 데 중요한 역할을 한다. 주로 게임의 구성, 기본값, 사용자 설정 등을 저장하며, 엔진과 프로젝트의 다양한 측면에서 사용된다.ini 파일 .ini 파일은 기본적으로 키-값 쌍으로 데이터를 저장하는 텍스트 파일 이러한 파일들은 섹션으로 구분되며, 각 섹션은 대괄호 [ ]로 감싸진 이름으로 시작합니다. 예시[Core.System]Paths=../../../Engine/ContentPaths=../../../MyProject/Content[/Script/Engine.RendererSettings]r.DefaultFeature.Bloom=Truer.DefaultFeature.AntiAliasing=2 [SectionName] : 섹션 이름을 정의. 엔진이나 게임에서 특정 설정 그룹을 의미 Key=Value : 섹션 내에서 설정 값을 정의. 각각의 키는 특정 설정을 나타내고, 해당 키에 대해 값을 지정 기본 .ini 파일 종류 DefaultEngine.ini: 엔진 설정을 저장합니다. 렌더링, 물리 엔진, 오디오 등과 같은 시스템 레벨 설정이 포함됩니다. DefaultGame.ini: 게임 관련 기본 설정을 정의합니다. 주로 게임 플레이와 관련된 설정이 여기에 저장됩니다. DefaultInput.ini: 입력 설정을 정의합니다. 키보드, 마우스, 컨트롤러 입력 매핑이 여기에 포함됩니다. DefaultEditor.ini: 에디터에서 사용하는 설정을 정의합니다. 에디터의 인터페이스와 관련된 사용자 정의 설정을 포함합니다. C++에서 .ini 파일 읽기 및 쓰기읽기 GConfig 객체를 사용하여 .ini 파일을 쉽게 읽을 수 있다FString MyValue;GConfig-&gt;GetString( TEXT(\"/Script/Engine.RendererSettings\"), TEXT(\"r.DefaultFeature.Bloom\"), MyValue, GGameIni); 위 코드에서 GGameIni는 DefaultGame.ini 파일을 참조합니다. 특정 섹션과 키를 지정하여 해당 값을 가져올 수 있다.쓰기 GConfig 객체를 사용하여 설정 값을 업데이트하거나 새로 추가할 수 있다.GConfig-&gt;SetString( TEXT(\"/Script/Engine.RendererSettings\"), TEXT(\"r.DefaultFeature.Bloom\"), TEXT(\"False\"), GGameIni);GConfig-&gt;Flush(false, GGameIni); Flush는 변경 사항을 디스크에 저장하는 역할을 한다.C++ 코드에서 .ini 파일 사용 클래스에 UCLASS 매크로와 함께 Config 메타 키워드를 사용하면, 해당 클래스의 멤버 변수를 .ini 파일과 연동할 수 있다.UCLASS(config=Game)class MYGAME_API UMyClass : public UObject{ GENERATED_BODY()public: UPROPERTY(Config) int32 MyConfigValue;}; 위 예제에서 MyConfigValue는 DefaultGame.ini 파일에 저장되고, 게임이 시작될 때 자동으로 해당 값을 로드한다.사용자 정의 .ini 파일 필요에 따라 사용자 정의 .ini 파일을 생성할 수 있다. 이 파일은 프로젝트 폴더나 엔진 설정 폴더에 위치시킬 수 있으며, 이를 통해 추가적인 설정을 관리할 수 있다.FString MyCustomIniPath = FPaths::ProjectConfigDir() + TEXT(\"MyCustomConfig.ini\");GConfig-&gt;SetString( TEXT(\"MyCustomSection\"), TEXT(\"MyKey\"), TEXT(\"MyValue\"), MyCustomIniPath);GConfig-&gt;Flush(false, MyCustomIniPath);" }, { "title": "UCLASS", "url": "/posts/UCLASS/", "categories": "unreal, 용어", "tags": "unreal", "date": "2023-05-16 00:00:00 +0900", "snippet": "UCLASS 언리얼 엔진에서 C++ 클래스를 언리얼 엔진의 Reflection System에 통합하기 위해 사용하는 매크로기능 Reflection System 통합: UCLASS는 C++ 클래스를 언리얼 엔진의 Reflection System에 등록하여, 클래스의 속성, 메서드, 상속 관계 등을 엔진 내부에서 관리할 수 있게 합니다. 블루프린트 및 에디터 통합: UCLASS로 정의된 클래스는 블루프린트에서 사용 가능하며, 에디터에서 해당 클래스의 인스턴스를 생성하거나 속성을 편집할 수 있습니다. 네트워크 복제: UCLASS를 사용하면 클래스가 네트워크 게임에서 올바르게 복제되고 동기화될 수 있도록 설정할 수 있습니다. 장점 유연한 개발 환경: UCLASS는 언리얼 엔진의 모든 기능과 호환되므로, 복잡한 게임 로직을 쉽게 구현할 수 있습니다. 강력한 데이터 관리: Reflection System과의 통합 덕분에 클래스와 그 속성들을 런타임에 동적으로 관리할 수 있습니다. 에디터 통합성: 클래스와 속성들이 에디터에 노출되므로, 개발자들이 비주얼 에디터를 통해 게임 콘텐츠를 직관적으로 구성할 수 있습니다. Meta 키워드BlueprintableUCLASS(Blueprintable) 클래스가 블루프린트에서 파생될 수 있도록 합니다. 이를 통해 C++로 작성된 클래스를 기반으로 블루프린트에서 새로운 클래스를 생성할 수 있습니다.BlueprintTypeUCLASS(BlueprintType) 클래스가 블루프린트에서 변수 타입으로 사용될 수 있도록 합니다. 이 옵션을 통해 블루프린트에서 해당 클래스를 변수 타입으로 사용할 수 있습니다.NotBlueprintableUCLASS(NotBlueprintable) 클래스가 블루프린트에서 파생될 수 없도록 합니다.AbstractUCLASS(Abstract) 추상 클래스로 정의하여, 이 클래스 자체로는 인스턴스화할 수 없도록 합니다. 다른 클래스가 상속받아 사용할 수 있습니다.ConfigUCLASS(Config) 클래스의 특정 설정이 구성 파일(.ini)에서 로드되도록 지정합니다. 예를 들어, Config=Game은 게임 관련 설정을 해당 클래스에 적용하는 것입니다.TransientUCLASS(Transient) 클래스가 저장되지 않도록 합니다 주로 런타임 동안만 유지되어야 하는 임시 데이터에 사용됩니다.MinimalAPIUCLASS(MinimalAPI) 클래스가 엔진 또는 모듈 외부에 노출되지 않도록 하면서도, 최소한의 API를 제공하는 경우에 사용됩니다.PlaceableUCLASS(Placeable) 에디터에서 이 클래스를 액터로 배치할 수 있도록 허용합니다 이 옵션이 없으면 클래스가 에디터에서 배치되지 않습니다.NotPlaceableUCLASS(NotPlaceable) 클래스가 에디터에서 배치될 수 없도록 지정합니다. 주로 서브 클래스로만 사용되거나, 독립적으로 사용되지 않아야 하는 클래스에 적용됩니다.DefaultToInstancedUCLASS(DefaultToInstanced) 클래스가 항상 인스턴스화되어야 함을 지정합니다 이는 여러 오브젝트가 동일한 서브오브젝트를 공유하지 않도록 보장하는 데 유용합니다.AutoCollapseCategoriesUCLASS(AutoCollapseCategories = \"Rendering, Physics\") 에디터에서 특정 카테고리를 기본적으로 접히도록 설정합니다 이를 통해, 자주 사용하지 않는 카테고리나 세부 정보를 기본적으로 숨겨둘 수 있습니다HideCategoriesUCLASS(HideCategories = (\"Input\", \"Collision\")) 에디터의 디테일 패널에서 특정 카테고리를 숨기도록 설정합니다. 불필요한 카테고리나 사용자가 볼 필요가 없는 설정을 숨길 때 유용합니다.ShowCategoriesUCLASS(ShowCategories = (\"Rendering\", \"Physics\")) 기본적으로 숨겨진 카테고리를 디테일 패널에 표시하도록 설정합니다. 반대로 특정 카테고리를 항상 표시하고자 할 때 사용됩니다.CollapseCategoriesUCLASS(CollapseCategories) 모든 카테고리를 기본적으로 접히도록 설정합니다. 이 옵션을 사용하면, 디테일 패널이 처음 열릴 때 모든 카테고리가 접힌 상태로 표시됩니다.SparseClassDataTypesUCLASS(SparseClassDataTypes) 클래스가 사용하는 “희소 클래스 데이터 타입”을 지정합니다. 이 메타 데이터는 엔진의 메모리 최적화와 관련된 고급 기능으로, 메모리 효율성을 높이기 위해 데이터 타입을 분리하는 데 사용됩니다.WithinUCLASS(Within = \"MyOuterClass\") 특정 클래스 안에서만 사용할 수 있는 클래스를 지정합니다. 이 키워드를 통해 해당 클래스가 특정 컨텍스트에서만 인스턴스화되도록 할 수 있습니다.CustomConstructorUCLASS(CustomConstructor) 기본 생성자가 아닌 사용자 정의 생성자를 사용하도록 지정합니다. 이를 통해, 클래스가 생성될 때 사용자 정의 로직을 실행할 수 있습니다.ConversionRootUCLASS(ConversionRoot) 클래스가 언리얼 엔진의 복제 시스템에서 루트로 간주되도록 지정합니다. 주로 엔진의 고급 복제 기능과 관련된 클래스를 정의할 때 사용됩니다DefaultConfigUCLASS(DefaultConfig) 클래스의 기본 설정이 .ini 파일에서 로드되도록 지정합니다. 이 옵션은 게임 설정이나 전역적인 설정을 처리하는 클래스에서 주로 사용됩니다.AdvancedClassDisplay 클래스가 “Advanced” 카테고리에 표시되도록 지정합니다. 이 키워드는 주로 기본적으로 잘 사용되지 않는 클래스나 고급 사용자를 대상으로 하는 클래스를 숨기고 싶을 때 유용합니다." }, { "title": "UENUM", "url": "/posts/UENUM/", "categories": "unreal, 용어", "tags": "unreal", "date": "2023-05-15 00:00:00 +0900", "snippet": "UENUM 매크로는 C++의 열거형(enum)을 언리얼 엔진의 Reflection System에 통합하여 블루프린트, 에디터 등에서 사용 가능하게 합니다.TEnumAsByte 열거형 값을 바이트 단위로 저장하는 템플릿 클래스장점 메모리 효율성: TEnumAsByte는 열거형 값을 1바이트 크기로 저장하므로, 메모리를 절약할 수 있습니다. 특히 열거형이 256개 이하의 값만을 가지는 경우, 메모리 사용을 최소화할 수 있어 효율적입니다. 네트워크 전송: 열거형 데이터를 네트워크로 전송할 때, TEnumAsByte를 사용하면 데이터 전송량을 줄일 수 있어 네트워크 성능이 향상됩니다. C++ 호환성: TEnumAsByte는 타입 안정성을 제공하면서도, C++의 열거형을 바이트 단위로 취급할 수 있게 해줍니다. 이는 특히 C++ 템플릿이나 함수 인자 전달 시 유용합니다. 작동방식 TEnumAsByte는 열거형 값을 내부적으로 uint8 타입으로 저장합니다. 이로 인해 저장 공간이 1바이트로 고정되며, 메모리 사용을 최적화할 수 있습니다. " }, { "title": "USTRUCT", "url": "/posts/USTRUCT/", "categories": "unreal, 용어", "tags": "unreal", "date": "2023-05-14 00:00:00 +0900", "snippet": "USTRUCT 언리얼 엔진에서 C++ 구조체를 반사(reflection) 시스템에 등록하고, 이를 통해 블루프린트, 에디터, 네트워크 복제 등 다양한 엔진 기능에서 사용할 수 있게 하는 매크로기능 Reflection System 통합: USTRUCT 매크로는 구조체를 언리얼 엔진의 Reflection System에 등록합니다. 이를 통해 구조체의 속성들이 블루프린트에서 사용 가능해지며, 에디터에서 편집할 수 있습니다. 데이터 저장 및 관리: USTRUCT는 주로 데이터 그룹을 관리하고 저장하는 데 사용됩니다. 예를 들어, 캐릭터의 상태, 게임 설정 등을 구조체로 묶어 관리할 수 있습니다. 블루프린트와의 통합: BlueprintType이라는 메타 옵션을 사용하면 구조체가 블루프린트에서 사용할 수 있는 타입으로 등록됩니다. 이를 통해 구조체 데이터를 블루프린트 노드로 활용할 수 있습니다. 네트워크 복제: USTRUCT는 네트워크 복제 시스템과도 호환되며, 구조체에 담긴 데이터가 네트워크를 통해 올바르게 동기화될 수 있도록 돕습니다. 동작 방식 생성 및 초기화: USTRUCT 매크로로 선언된 구조체는 GENERATED_USTRUCT_BODY 매크로를 통해 기본 생성자, 소멸자, 그리고 Reflection System에 필요한 초기화 코드를 자동으로 생성합니다. 속성 선언: 구조체 내부에 선언된 변수들은 UPROPERTY 매크로를 통해 추가 설정이 가능하며, 이를 통해 변수의 가시성, 편집 가능성 등을 설정할 수 있습니다. 장점 유연성: USTRUCT를 사용하여 데이터의 그룹화 및 관리가 용이합니다. 복잡한 데이터 세트를 간단히 관리할 수 있습니다. 엔진 통합성: USTRUCT를 사용하면 데이터가 언리얼 엔진의 다양한 시스템과 자동으로 통합되며, 이를 통해 게임 개발 시 효율성을 높일 수 있습니다. 편리한 데이터 접근: Reflection System과의 통합 덕분에, 데이터에 대한 접근이 간편해지며, 런타임 시 데이터의 수정 및 관리가 용이해집니다. 키워드BlueprintType 구조체를 블루프린트에서 사용할 수 있도록 등록Blueprintable 해당 구조체를 블루프린트에서 기반으로 삼아 다른 블루프린트 클래스를 생성할 수 있게 합니다.Immutable 구조체의 값을 변경할 수 없도록 설정합니다. 이 옵션은 주로 데이터의 불변성을 보장해야 하는 상황에서 사용됩니다." }, { "title": "UFUNCTION", "url": "/posts/UFUNCTION/", "categories": "unreal, 용어", "tags": "unreal", "date": "2023-05-13 00:00:00 +0900", "snippet": "UFUNCTION 함수와 같이 사용하는 리플렉션 매크로로, 매크로의 인자에 값을 넣어 여러가지 방면으로 사용할 수 있다.BlueprintCallableUFUNCTION(BlueprintCallable) 함수를 블루프린트에서 호출 가능하도록 만드는 매크로 블루프린트에서 재정의하지 못함 BlueprintPureUPROPERTY(BlueprintPure) 함수가 “순수 함수”임을 나타내며, 즉, 함수가 내부 상태를 변경하지 않고 입력값만을 기반으로 출력을 생성한다는 것을 의미BlueprintImplementableEventUPROPERTY(BlueprintImplementableEvent) C++에서 함수의 틀만 정의하고, 실제 구현은 블루프린트에서 하도록 설정BlueprintNativeEventUPROPERTY(BlueprintNativeEvent)void Func();virtual void Func_Implementation(); C++에서 기본 구현을 제공하지만, 블루프린트에서 해당 함수를 오버라이드 Server/Client/NetMulticastUFUNCTION(Server)UFUNCTION(Client)UFUNCTION(NetMulticast) 함수가 네트워크에서 실행될 때 어느 쪽에서 실행되는지를 결정Reliable/UnreliableUFUNCTION(Server, Reliable)UFUNCTION(Server, Unreliable) 네트워크 함수 호출의 신뢰성을 설정 Reliable은 반드시 전달되어야 하는 중요한 호출에 사용되고, Unreliable은 일부 누락이 허용되는 호출에 사용 WithValidationUFUNCTION(Server, Reliable, WithValidation) 네트워크 함수에서 서버로의 호출이 유효한지 확인하는 추가 검증 함수가 필요할 때 사용 이 옵션을 사용하면 _Validate라는 이름의 함수를 정의하여, 해당 함수가 실행되기 전에 검증 가능 ExecUFUNCTION(Exec) 콘솔 명령어로 함수를 실행 주로 디버깅이나 개발 도구에서 사용 CallInEditorUFUNCTION(CallInEditor) 함수가 에디터에서 호출될 수 있음CategoryUFUNCTION(BlueprintCallable, Category = \"Movement\") 카테고리BlueprintAuthorityOnlyUFUNCTION(BlueprintCallable, BlueprintAuthorityOnly, Category = \"Networking\") 블루프린트에서 서버 권한이 있을 때만 호출할 수 있는 함수를 정의 주로 서버에서만 실행되어야 하는 함수에 사용 BlueprintCosmeticUFUNCTION(BlueprintCosmetic, Category = \"UI\") 함수가 클라이언트에서만 실행될 수 있음을 표시 서버에서 호출되지 않고, 클라이언트 측에서만 필요한 그래픽 처리 등의 작업에 사용 NetReliableUFUNCTION(NetReliable, Server, WithValidation) 네트워크 관련 함수가 항상 신뢰할 수 있는 방식으로 전송되도록 지정 중요한 데이터 전송이나 명령에 대해 사용되며, 패킷이 반드시 도달해야 하는 상황에 사용 CustomThunkUFUNCTION(CustomThunk) 함수가 스크립트에서 호출될 때, 커스텀 스텁(Thunk)을 사용하도록 지정 복잡한 블루프린트 기능이나 특수한 동작이 필요한 경우 사용 SealedEventUFUNCTION(BlueprintCallable, SealedEvent, Category = \"Security\") 블루프린트에서 이 함수를 오버라이드할 수 없도록 막을 때 사용DisplayNameUFUNCTION(BlueprintCallable, DisplayName = \"Calculate Damage\") 블루프린트 에디터에서 함수의 이름을 지정UnsafeDuringActorConstructionUFUNCTION(UnsafeDuringActorConstruction) 액터가 생성되는 동안 호출되는 것이 안전하지 않은 함수를 지정 액터가 생성 중일 때 특정 작업을 방지하고자 할 때 사용(액터 생성 중 실행되면 안 되는 함수에 사용) BlueprintInternalUseOnlyUFUNCTION(BlueprintInternalUseOnly) 블루프린트에서 내부적으로만 사용되도록 제한 외부에서 접근하지 못하도록 하여, 블루프린트 논리의 무결성을 보호 루프린트 내부 논리에서만 사용되도록 제한할 때 사용 " }, { "title": "데코레이터 패턴", "url": "/posts/%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-%ED%8C%A8%ED%84%B4/", "categories": "디자인 패턴, 구조 패턴", "tags": "design pattern", "date": "2023-05-12 00:00:00 +0900", "snippet": "데코레이터 패턴 다른 사람이 작성한 클래스나 외부 라이브러리에 새로운 기능을 추가해야 하는 상황을 생각해보자. 원본 코드를 직접 수정하는 것은 불가능하거나 바람직하지 않다. 가장 먼저 떠오르는 방법은 상속이지만, 상속은 항상 최선의 선택이 아니다. 특히 추가하려는 기능이 여러 종류일 때, 상속은 클래스의 폭발적인 증가를 야기한다. 예를 들어, 기본 캐릭터에 ‘검 장착’, ‘갑옷 장착’ 기능을 상속으로 추가하면 CharacterWithSword, CharacterWithArmor가 필요하고, 둘 다 장착한 CharacterWithSwordAndArmor 클래스까지 만들어야 한다. 새로운 기능이 하나 추가될 때마다 조합의 수는 기하급수적으로 늘어난다. 기존 객체의 코드를 전혀 수정하지 않으면서, 런타임에 동적으로 새로운 책임과 기능을 덧씌울 수 있는 우아한 해결책을 제공한다. 이는 개방-폐쇄 원칙(Open-Closed Principle)을 완벽하게 준수하는 방법이다시나리오: 아이템으로 캐릭터 능력치 강화하기 게임 캐릭터가 아이템을 장착할 때마다 능력치가 변하는 시스템을 만들어야 한다.1. 기본 컴포넌트(Base Component) 정의 모든 캐릭터가 가져야 할 기본 인터페이스를 정의한다. 여기서는 공격력과 방어력을 반환하는 메서드를 가진다.// 모든 캐릭터의 기본 인터페이스class ICharacter {public: virtual ~ICharacter() = default; virtual int GetAttackPower() const = 0; virtual int GetDefense() const = 0;};2. 구체적인 컴포넌트(Concrete Component) 구현 기본 인터페이스를 구현한 순수한 플레이어 객체다. 아무 아이템도 장착하지 않은 상태의 기본 능력치를 가진다.#include &lt;iostream&gt;using namespace std;// 기본 플레이어 클래스class Player : public ICharacter {public: int GetAttackPower() const override { return 10; } // 기본 공격력 10 int GetDefense() const override { return 5; } // 기본 방어력 5}; 문제: 이 Player 객체에 ‘강철 검(+5 공격력)’과 ‘철 갑옷(+15 방어력)’의 효과를 어떻게 적용할 것인가?동적 데코레이터: 런타임에 기능 덧씌우기 이것이 고전적인 데코레이터 패턴의 구현 방식이다. 핵심은 상속과 구성을 함께 사용하는 것이다. 데코레이터는 꾸며줄 대상과 같은 타입(IS A)이면서, 동시에 꾸며줄 대상의 인스턴스를 멤버로 포함(HAS A)한다.1. 기본 데코레이터 클래스 정의 모든 데코레이터의 공통적인 구조를 담은 추상 클래스를 만든다. 이 클래스는 ICharacter를 상속받고, 내부에 ICharacter 포인터를 가져 요청을 전달하는 역할을 한다.#include &lt;memory&gt;// 기본 데코레이터: 요청을 다른 객체로 전달하는 역할class CharacterDecorator : public ICharacter {protected: unique_ptr&lt;ICharacter&gt; decoratedCharacter; // 감싸고 있는(꾸며줄) 캐릭터public: CharacterDecorator(unique_ptr&lt;ICharacter&gt; character) : decoratedCharacter(move(character)) {} // 데코레이터는 기본적으로 요청을 내부 객체에 그대로 전달한다. int GetAttackPower() const override { return decoratedCharacter-&gt;GetAttackPower(); } int GetDefense() const override { return decoratedCharacter-&gt;GetDefense(); }};2. 구체적인 데코레이터(Concrete Decorator) 구현 이제 실제 기능을 덧씌우는 구체적인 데코레이터를 만든다.// 검을 장착했을 때의 데코레이터class SwordDecorator : public CharacterDecorator {public: SwordDecorator(unique_ptr&lt;ICharacter&gt; character) : CharacterDecorator(move(character)) {} // 공격력 요청이 오면, 내부 객체의 결과에 5를 더해서 반환한다. int GetAttackPower() const override { return CharacterDecorator::GetAttackPower() + 5; // 새로운 기능 추가! }};// 갑옷을 장착했을 때의 데코레이터class ArmorDecorator : public CharacterDecorator {public: ArmorDecorator(unique_ptr&lt;ICharacter&gt; character) : CharacterDecorator(move(character)) {} // 방어력 요청이 오면, 내부 객체의 결과에 15를 더해서 반환한다. int GetDefense() const override { return CharacterDecorator::GetDefense() + 15; // 새로운 기능 추가! }};3. 데코레이터 겹쳐 사용하기 (Stacking) 이 데코레이터들은 마치 양파껍질처럼 객체를 여러 겹으로 감쌀 수 있다.int main() { // 1. 순수한 플레이어 객체 생성 unique_ptr&lt;ICharacter&gt; player = make_unique&lt;Player&gt;(); cout &lt;&lt; \"기본 공격력: \" &lt;&lt; player-&gt;GetAttackPower() &lt;&lt; endl; // 10 // 2. 검을 장착 (Player 객체를 SwordDecorator로 감싼다) player = make_unique&lt;SwordDecorator&gt;(move(player)); cout &lt;&lt; \"검 장착 후 공격력: \" &lt;&lt; player-&gt;GetAttackPower() &lt;&lt; endl; // 10 + 5 = 15 // 3. 갑옷을 추가로 장착 (이미 검으로 장식된 player를 ArmorDecorator로 감싼다) player = make_unique&lt;ArmorDecorator&gt;(move(player)); cout &lt;&lt; \"갑옷 추가 장착 후 방어력: \" &lt;&lt; player-&gt;GetDefense() &lt;&lt; endl; // 5 + 15 = 20 cout &lt;&lt; \"갑옷 추가 장착 후 공격력: \" &lt;&lt; player-&gt;GetAttackPower() &lt;&lt; endl; // 15 (그대로 전달됨)} GetDefense() 요청이 들어오면 ArmorDecorator는 내부 객체(SwordDecorator)의 GetDefense()를 호출하고, SwordDecorator는 다시 자신의 내부 객체(Player)의 GetDefense()를 호출한다. 그 결과(5)가 다시 SwordDecorator를 거쳐 ArmorDecorator로 돌아오고, 최종적으로 15가 더해져 20이 반환된다. 이처럼 기능이 동적으로 연쇄 추가된다.정적 데코레이터: 컴파일 타임에 기능 합성하기 동적 데코레이터는 유연하지만 한계가 있다. 만약 Player 클래스에만 있는 고유한 메서드 UseStaminaPotion()을 호출하고 싶다면, ICharacter 인터페이스로 포장된 데코레이터를 통해서는 호출할 수 없다. 이 문제를 해결하기 위해 C++ 템플릿을 이용한 정적 데코레이터를 사용할 수 있다. 이는 믹스인(Mixin) 상속 기법을 활용한다// 템플릿을 이용한 정적 데코레이터template &lt;typename T&gt;class SwordDecoratorStatic : public T {public: // 가변 인자 템플릿으로 모든 생성자 인자를 부모 클래스에 전달한다. template &lt;typename... Args&gt; SwordDecoratorStatic(Args... args) : T(args...) {} int GetAttackPower() const override { return T::GetAttackPower() + 5; }}; 이 데코레이터는 감싸는 대상의 타입(T)을 직접 상속받기 때문에, 대상의 모든 public 인터페이스를 그대로 노출한다.// 사용법// Player 타입을 직접 템플릿 인자로 전달한다.SwordDecoratorStatic&lt;Player&gt; staticPlayer;cout &lt;&lt; \"정적 데코레이터 공격력: \" &lt;&lt; staticPlayer.GetAttackPower() &lt;&lt; endl; // 15// Player의 고유 메서드도 호출 가능하다!// staticPlayer.UseStaminaPotion(); 이 방식은 런타임 유연성은 떨어지지만(컴파일 시점에 타입이 고정됨), 성능이 더 좋고 원본 객체의 전체 인터페이스에 접근할 수 있다는 장점이 있다.함수형 데코레이터: 로깅과 프로파일링 데코레이터의 개념은 클래스뿐만 아니라 함수에도 적용할 수 있다. 예를 들어 특정 함수의 실행 시간을 측정하는 로거(Logger)를 만들어 보자.#include &lt;chrono&gt;// 함수를 감싸는 로거 데코레이터template &lt;typename Func&gt;class StopwatchDecorator {private: Func func; string name;public: StopwatchDecorator(Func f, const string&amp; name) : func(f), name(name) {} // 함수 호출 연산자(operator())를 오버로딩 void operator()() const { auto start = chrono::high_resolution_clock::now(); func(); // 감싸고 있던 원래 함수를 호출 auto end = chrono::high_resolution_clock::now(); chrono::duration&lt;double, milli&gt; elapsed = end - start; cout &lt;&lt; name &lt;&lt; \" 실행 시간: \" &lt;&lt; elapsed.count() &lt;&lt; \" ms\\n\"; }}; 이제 어떤 함수든 이 데코레이터로 감싸서 실행 시간을 측정할 수 있다void ComplexPhysicsCalculation() { // ... 시간이 오래 걸리는 물리 연산 ... for(int i = 0; i &lt; 10000000; ++i);}// 사용법StopwatchDecorator&lt;void()&gt; decoratedFunc(ComplexPhysicsCalculation, \"물리연산\");decoratedFunc(); // 데코레이션된 함수를 호출요약 데코레이터 패턴은 상속을 사용하지 않고, 객체를 다른 객체로 감싸서(wrapping) 새로운 기능을 동적으로 추가하는 패턴이다. 데코레이터는 꾸미려는 대상과 동일한 인터페이스를 가지므로, 클라이언트는 원본과 데코레이터를 구분 없이 사용할 수 있다. 동적 데코레이터는 런타임 유연성을 제공하며, 정적 데코레이터는 컴파일 타임에 기능을 합성하여 성능과 타입 안정성을 높인다. 함수형 데코레이터는 특정 함수의 동작 앞뒤에 부가적인 로직(로깅, 권한 체크, 프로파일링 등)을 추가하는 데 유용하다. 이 패턴은 단일 책임 원칙과 개방-폐쇄 원칙을 잘 지키면서 시스템의 기능을 유연하게 확장할 수 있는 매우 강력한 도구다. " }, { "title": "UPROPERTY", "url": "/posts/UPROPERTY/", "categories": "unreal, 용어", "tags": "unreal", "date": "2023-05-12 00:00:00 +0900", "snippet": "UPROPERTY 변수와 같이 사용하는 리플렉션 매크로로, 매크로의 인자에 값을 넣어 여러가지 방면으로 사용할 수 있다.수정 및 공개 에디터나 월드에서 변수를 수정할 수 있게 하거나 어디까지 공개할지를 정하는 프로퍼티 Visible과 Edit은 변수의 수정 가능 여부를 의미한다. Visible이 사용되면 그 변수는 Read만 가능하다 Edit이 사용되면 그 변수는 Read &amp; Write이 가능하다 DefaultsOnly는 , InstanceOnly는, Anywhere은 변수 공개 범위를 의미한다. DefaultsOnly는 블루 프린트의 에디터에서만 공개함을 의미한다 InstanceOnly는 월드 상에서 존재하는 오브젝트에서만 공개함을 의미한다. Anywhere은 Defaults와 Instance를 합친 것으로, 에디터와 월드 둘 다 접근 가능하다 위를 토대로 작성해보면 * VisibleVisibleDefaultsOnly : 블루프린트 에디터 창의 디테일 패널에서 값을 보기 가능VisibleInstanceOnly : 월드상에 배치된 오브젝트의 디테일 패널에서 값을 보기 가능VisibleAnywhere : 블루프린트 에디터 &amp; 월드상에 배치된 오브젝트의 디테일 패널에서 값을 보기 가능* Edit EditDefulatOnly : 블루프린트 에디터 창의 디테일 패널에서 값을 수정 가능EditInstanceOnly : 월드상에 배치된 오브젝트의 디테일 패널에서 값을 수정 가능EditAnywhere : 블루프린트 에디터 &amp; 월드상에 배치된 오브젝트의 디테일 패널에서 값을 수정 가능블루 프린트 블루 프린트에서 변수를 수정할 수 있게 하거나 어디까지 공개할지를 정하는 프로퍼티 총 4가지로 아래와 같이 있다* BlueprintReadOnly : 블루프린트에서 해당 변수를 읽기* BlueprintReadWrite : 블루프린트에서 해당 변수를 읽기 &amp; 쓰기* BlueprintGetter :\t해당 변수에 접근 할 수 있는 함수를 지정하고 블루프린트는 해당 함수를 통해 변수에 접근* BlueprintSetter :\t해당 변수에 수정 할 수 있는 함수를 지정하고 블루프린트는 해당 함수를 통해 변수에 수정Category 카테고리를 이용해 에디터상에서 변수들의 카테고리를 정해줄 수 있다 UPROPERTY(EditAnywhere, Category = “Player Stats”) Meta 에디터 관련 여러가지 기능을 추가할 수 있다DisplayName 에디터에서 해당 속성이 표시될 때 사용할 이름을 지정 Meta = (DisplayName = “Player Health”) ToolTip 에디터에서 마우스를 속성 위에 올렸을 때 나타나는 툴팁 Meta = (ToolTip = “The health of the player character”) ClampMin/ClampMax 변수의 값을 특정 범위로 제한 Meta = (ClampMin = “0.0”, ClampMax = “100.0”) AllowPrivateAccess 매개변수는 private 변수임에도 불구하고 에디터에서 접근 가능하게 만듦 Meta = (AllowPrivateAccess = “true”) HideInDetailPanel 에디터의 디테일 패널에서 이 속성을 숨긴다. Meta = (HideInDetailPanel) ExposeOnSpawn 속성을 블루프린트의 “노드 스폰”에서 초기값으로 설정, 특정 객체가 생성될 때 초기화해야 하는 속성을 지정할 때 유용 Meta = (ExposeOnSpawn) UIMin,UIMax UPROPERTY에 대한 UI 범위를 설정하는 데 사용되는 매크로 변수 값의 슬라이더나 스핀 박스의 최소값과 최대값을 설정하는 데 사용 Meta = (UIMin = “0.0”, UIMax = “100.0”) BindWidget 언리얼 엔진에서 UMG(언리얼 모션 그래픽) 위젯을 C++ 코드에 바인딩하는 데 사용되는 매크로 Meta = (BindWidget) 단 블루프린트에서의 변수 이름과 C++의 변수이름은 동일해야 한다. InlineEditConditionToggle EditCondition과 함께 사용되어, 조건을 설정하는 변수에 대한 토글 버튼을 에디터에 표시 Meta = (InlineEditConditionToggle) DisplayPriority 에디터의 디테일 패널에서 속성이 표시되는 순서를 결정 Meta = (DisplayPriority = 1) MultiLine 에디터에서 텍스트를 입력할 때 여러 줄의 입력을 허용하는 옵션 Meta = (MultiLine = “true”) HideAlphaChannel 색상에서 알파값을 숨김 Meta = (HideAlphaChannel) PinHiddenByDefault 블루프린트 에디터에서 해당 속성이 기본적으로 핀으로 노출되지 않도록 설정 Meta = (PinHiddenByDefault) TitleProperty 배열이나 맵 같은 복합 데이터 구조에서, 해당 구조체 또는 클래스의 특정 멤버 변수를 배열 요소의 이름으로 표시 Meta = (TitleProperty = “Name”) " }, { "title": "컴포지트 패턴", "url": "/posts/%EC%BB%B4%ED%8F%AC%EC%A7%80%ED%8A%B8-%ED%8C%A8%ED%84%B4/", "categories": "디자인 패턴, 구조 패턴", "tags": "design pattern", "date": "2023-05-09 00:00:00 +0900", "snippet": "컴포지트 패턴 객체들을 트리 구조로 구성하여 부분-전체 계층(part-whole hierarchy)을 표현하는 구조 패턴 이 패턴의 핵심은 클라이언트가 개별 객체(leaf)와 복합 객체(composite)를 동일한 방식으로 다룰 수 있도록 하는 것이다. 간단히 말해, ‘단일 객체’와 ‘객체들의 그룹’을 구분하지 않고 똑같이 취급할 수 있게 만드는 패턴이다. 게임 개발에서 이 패턴은 거의 모든 게임 엔진의 핵심 구조인 씬 그래프(Scene Graph)나 UI 시스템을 구축하는 데 근간이 된다.문제 상황: 개별 객체와 그룹의 분리 게임 화면에 여러 그래픽 객체를 렌더링해야 한다고 가정해보자. 개별적으로 움직이는 Sprite 객체가 있고, 여러 Sprite가 모여 하나의 단위처럼 움직이는 Player 그룹이 있다. 가장 단순한 접근법은 각 타입을 위한 별개의 클래스를 만드는 것이다.// 개별 스프라이트 객체class Sprite {public: void Render() { /* 스프라이트 하나를 화면에 그린다 */ }};// 스프라이트 그룹 객체class SpriteGroup {private: vector&lt;Sprite*&gt; sprites;public: void RenderGroup() { for (auto sprite : sprites) { sprite-&gt;Render(); } }}; 이 방식은 클라이언트 코드(예: 메인 렌더링 루프)를 매우 번거롭게 만든다.// 클라이언트 코드vector&lt;any&gt; sceneObjects; // Sprite와 SpriteGroup을 함께 담기 위해 any 사용for (auto&amp; obj : sceneObjects) { // 렌더링을 위해 매번 타입을 확인해야 한다. if (obj.type() == typeid(Sprite)) { any_cast&lt;Sprite&amp;&gt;(obj).Render(); } else if (obj.type() == typeid(SpriteGroup)) { // 메서드 이름도 다르다! any_cast&lt;SpriteGroup&amp;&gt;(obj).RenderGroup(); }} 이런 코드는 새로운 객체 타입이 추가될 때마다 if-else 분기문이 계속 늘어나고, 그룹 안에 또 다른 그룹을 넣는 중첩 구조를 만들기도 어렵다. 이는 확장성이 매우 떨어지는 나쁜 설계다.해결책: 컴포지트 패턴으로 인터페이스 통일 컴포지트 패턴은 이 문제를 공통 인터페이스를 통해 해결한다.1.공통 컴포넌트 인터페이스(Component Interface) 정의 먼저, 개별 객체와 복합 객체가 모두 구현해야 할 공통 인터페이스를 정의한다. * 게임 객체의 가장 기본적인 행위인 Update와 Render를 포함하는 ISceneNode 인터페이스를 만들어 보자.// 모든 씬 객체(노드)를 위한 공통 인터페이스class ISceneNode {public: virtual ~ISceneNode() = default; virtual void Update(float deltaTime) = 0; virtual void Render() const = 0;};2. 잎(Leaf) 클래스 구현 트리 구조의 가장 말단에 위치하는 개별 객체, 즉 ‘잎’을 구현한다. 잎 노드는 자식 노드를 가질 수 없다.#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;// 개별 스프라이트를 나타내는 '잎' 노드class SpriteNode : public ISceneNode {private: string spritePath;public: SpriteNode(const string&amp; path) : spritePath(path) {} void Update(float deltaTime) override { // 이 스프라이트만의 위치 업데이트 등... } void Render() const override { cout &lt;&lt; \"Rendering sprite: \" &lt;&lt; spritePath &lt;&lt; endl; }};3. 복합(Composite) 클래스 구현 다른 ISceneNode 객체들을 자식으로 가질 수 있는 ‘복합’ 객체를 구현한다. 이 복합 객체는 자신에게 요청된 작업을 자식들에게 재귀적으로 전파하는 역할을 한다. #include &lt;vector&gt;#include &lt;memory&gt;#include &lt;algorithm&gt;// 다른 노드들을 자식으로 가질 수 있는 '복합' 노드class GroupNode : public ISceneNode {private: vector&lt;unique_ptr&lt;ISceneNode&gt;&gt; children; string name;public: GroupNode(const string&amp; name) : name(name) {} void Add(unique_ptr&lt;ISceneNode&gt; child) { children.push_back(move(child)); } // Update 요청이 오면, 모든 자식에게 Update를 전파한다. void Update(float deltaTime) override { for (auto&amp; child : children) { child-&gt;Update(deltaTime); } } // Render 요청이 오면, 모든 자식에게 Render를 전파한다. void Render() const override { cout &lt;&lt; \"--- Start Group: \" &lt;&lt; name &lt;&lt; \" ---\" &lt;&lt; endl; for (const auto&amp; child : children) { child-&gt;Render(); } cout &lt;&lt; \"--- End Group: \" &lt;&lt; name &lt;&lt; \" ---\" &lt;&lt; endl; }};4. 씬 그래프(Scene Graph) 구축 및 사용 이제 이 노드들을 조합하여 트리 구조(씬 그래프)를 만들 수 있다.// 씬 그래프 구축auto root = make_unique&lt;GroupNode&gt;(\"Root\");root-&gt;Add(make_unique&lt;SpriteNode&gt;(\"background.png\"));// 플레이어 그룹 생성 (그룹 안에 다른 노드들을 포함)auto playerGroup = make_unique&lt;GroupNode&gt;(\"Player\");playerGroup-&gt;Add(make_unique&lt;SpriteNode&gt;(\"player_body.png\"));playerGroup-&gt;Add(make_unique&lt;SpriteNode&gt;(\"player_weapon.png\"));// 루트에 플레이어 그룹 추가 (그룹 안에 그룹이 중첩됨)root-&gt;Add(move(playerGroup));// 메인 게임 루프float deltaTime = 0.016f;// 루트 노드에 한 번만 Update와 Render를 호출한다.root-&gt;Update(deltaTime);cout &lt;&lt; \"\\n--- Rendering Frame ---\" &lt;&lt; endl;root-&gt;Render();//결과--- Rendering Frame ------ Start Group: Root ---Rendering sprite: background.png--- Start Group: Player ---Rendering sprite: player_body.pngRendering sprite: player_weapon.png--- End Group: Player ------ End Group: Root --- 게임의 메인 루프는 이제 root가 단일 스프라이트인지, 수천 개의 객체가 중첩된 복잡한 그룹인지 전혀 신경 쓸 필요가 없다. 그저 root의 Update와 Render를 호출하면, 패턴에 의해 모든 작업이 재귀적으로 올바르게 처리된다. 이것이 컴포지트 패턴의 힘이다.요약 컴포지트 패턴은 객체들을 트리 구조로 구성하여, 부분과 전체를 같은 방식으로 다룰 수 있게 한다. 클라이언트는 개별 객체(Leaf)와 객체 그룹(Composite)을 구분하지 않고 공통 인터페이스(Component)를 통해 상호작용할 수 있다. 장점 단순화된 클라이언트 코드: 클라이언트는 객체의 복잡한 구조를 알 필요 없이 단일 인터페이스만 사용하면 되므로 코드가 단순해진다. 계층 구조의 유연한 관리: 객체의 추가, 삭제 등 트리 구조를 동적으로 쉽게 관리할 수 있다. 높은 확장성: 새로운 종류의 잎(Leaf)이나 복합(Composite) 객체를 추가해도 클라이언트 코드는 전혀 영향을 받지 않는다. 재귀적 구조의 자연스러운 처리: 트리 구조를 순회하는 로직을 매우 간결하고 자연스럽게 구현할 수 있다. 게임의 씬 그래프, UI 계층 구조, 복잡한 캐릭터의 파츠 관리 등, 부분과 전체를 동일하게 다뤄야 하는 거의 모든 문제에 컴포지트 패턴은 효과적이고 우아한 해결책을 제공한다. " }, { "title": "브릿지 패턴", "url": "/posts/%EB%B8%8C%EB%A6%BF%EC%A7%80-%ED%8C%A8%ED%84%B4/", "categories": "디자인 패턴, 구조 패턴", "tags": "design pattern", "date": "2023-05-04 00:00:00 +0900", "snippet": "프롤로그 브릿지 패턴을 이해하기 전에, C++ 개발자들이 컴파일 시간을 줄이기 위해 오랫동안 사용해 온 Pimpl(Pointer to implementation) 관례를 먼저 살펴보는 것이 도움이 된다. 이는 브릿지 패턴의 매우 구체적이고 실용적인 예시이기 때문이다. Pimpl의 핵심은 클래스의 구현부를 헤더 파일(.h)에서 완전히 분리하여 소스 파일(.cpp)에 숨기는 것이다.예시 개인 정보를 담는 GameObject 클래스가 있다고 가정하자. 헤더 파일에는 최소한의 정보만 노출한다.// GameObject.h - 헤더 파일#include &lt;string&gt;#include &lt;memory&gt;class GameObject {public: std::string name; void Update(); GameObject(); ~GameObject(); // 소멸자 선언이 반드시 필요하다.private: // 구현부는 전방 선언(forward declaration)만 하고 포인터로 관리한다. class GameObjectImpl; std::unique_ptr&lt;GameObjectImpl&gt; pimpl;}; GameObjectImpl의 실제 정의와 GameObject의 메서드 구현은 모두 .cpp 파일 안에 존재한다.// GameObject.cpp - 소스 파일#include \"GameObject.h\"#include &lt;iostream&gt;#include &lt;vector&gt; // vector 헤더는 .cpp 파일에만 필요하다.// 구현부 클래스의 실제 정의class GameObject::GameObjectImpl {public: std::vector&lt;float&gt; internal_data; // 복잡한 내부 데이터 void Update(GameObject* p) { std::cout &lt;&lt; p-&gt;name &lt;&lt; \" is updating...\" &lt;&lt; std::endl; // ... internal_data를 사용하는 복잡한 로직 ... }};// 생성자와 소멸자 구현GameObject::GameObject() : pimpl(std::make_unique&lt;GameObjectImpl&gt;()) {}GameObject::~GameObject() = default; // unique_ptr가 자동으로 메모리 해제// public 메서드는 실제 구현을 pimpl에 위임한다.void GameObject::Update() { pimpl-&gt;Update(this);} 이 기법은 다음과 같은 강력한 장점을 가진다. 완벽한 정보 은닉: 클라이언트는 GameObjectImpl의 존재나 그 내부의 복잡한 멤버(vector 등)에 대해 전혀 알 필요가 없다. 헤더 파일이 매우 깔끔해진다. 컴파일 시간 단축: GameObjectImpl의 내부 구현이 변경되어도, GameObject.h 파일은 변경되지 않는다. 따라서 이 헤더를 포함하는 수많은 다른 파일들을 다시 컴파일할 필요가 없어진다. 바이너리 호환성: 라이브러리 형태로 제공할 때, 내부 구현을 변경해도 외부에 노출된 바이너리 인터페이스가 그대로 유지되므로 호환성이 깨지지 않는다. 디자인 패턴 관점에서, pimpl 포인터는 공개 인터페이스(GameObject)와 숨겨진 구현(GameObjectImpl) 사이를 연결하는 다리(Bridge) 역할을 한다. 이것이 바로 브릿지 패턴의 핵심 아이디어다. 브릿지 패턴: 추상과 구현의 분리 Pimpl이 브릿지 패턴의 특별한 예시라면, 일반적인 브릿지 패턴은 추상화(Abstraction)와 구현(Implementation)이라는 두 계층을 분리하여 각각 독립적으로 확장할 수 있도록 만드는 것이다.문제 상황: 클래스의 폭발적인 증가 게임에 다양한 캐릭터(Player, Goblin)와 다양한 무기(Sword, Bow)가 있다고 상상해보자. Player는 Sword나 Bow를 사용할 수 있다. Goblin도 Sword나 Bow를 사용할 수 있다. 이를 상속만으로 해결하려고 하면 어떻게 될까? class PlayerWithSword : public Player class GoblinWithBow : public Goblin … 이런 식으로 (캐릭터 종류) x (무기 종류) 만큼의 클래스가 필요하게 된다. 새로운 무기 ‘지팡이’가 추가되면 모든 캐릭터에 대해 WithMagicWand 클래스를 또 만들어야 한다. 이는 클래스의 수가 폭발적으로 증가하는 재앙을 초래한다. 해결책: 브릿지로 연결하기 브릿지 패턴은 이 문제를 두 개의 독립적인 계층으로 분리하여 해결한다.1. 추상화 계층 (Abstraction - “누가” 행동하는가) 캐릭터의 종류와 기본적인 행동을 정의한다.// 전방 선언class IWeapon;// 캐릭터의 최상위 추상 클래스class Character {protected: // 구현부에 대한 참조(브릿지)를 멤버로 가진다. unique_ptr&lt;IWeapon&gt; weapon;public: Character(unique_ptr&lt;IWeapon&gt; weapon) : weapon(move(weapon)) {} virtual ~Character() = default; // 공격 요청을 구현부(weapon)에 위임한다. virtual void Attack() = 0; void EquipWeapon(unique_ptr&lt;IWeapon&gt; new_weapon) { weapon = move(new_weapon); }};// 구체적인 캐릭터들class Player : public Character {public: Player(unique_ptr&lt;IWeapon&gt; weapon) : Character(move(weapon)) {} void Attack() override { cout &lt;&lt; \"Player \"; weapon-&gt;Use(); // 구현부에 위임 }};class Goblin : public Character {public: Goblin(unique_ptr&lt;IWeapon&gt; weapon) : Character(move(weapon)) {} void Attack() override { cout &lt;&lt; \"Goblin \"; weapon-&gt;Use(); // 구현부에 위임 }}; Character는 IWeapon이라는 ‘구현’의 존재를 알지만, 그것이 Sword인지 Bow인지는 전혀 신경 쓰지 않는다.2. 구현 계층 (Implementation - “어떻게” 행동하는가) 무기의 종류와 실제 동작 방식을 정의한다.// 무기의 최상위 인터페이스 (구현부)class IWeapon {public: virtual ~IWeapon() = default; virtual void Use() = 0;};// 구체적인 무기들class Sword : public IWeapon {public: void Use() override { cout &lt;&lt; \"attacks with a Sword!\" &lt;&lt; endl; }};class Bow : public IWeapon {public: void Use() override { cout &lt;&lt; \"attacks with a Bow!\" &lt;&lt; endl; }};3. 브릿지를 통한 결합 이제 이 두 계층을 자유롭게 조합할 수 있다.int main() { // 1. 플레이어에게 검을 장착 unique_ptr&lt;Player&gt; player = make_unique&lt;Player&gt;(make_unique&lt;Sword&gt;()); player-&gt;Attack(); // 출력: Player attacks with a Sword! // 2. 런타임에 무기를 활로 교체 player-&gt;EquipWeapon(make_unique&lt;Bow&gt;()); player-&gt;Attack(); // 출력: Player attacks with a Bow! cout &lt;&lt; \"--------------------\" &lt;&lt; endl; // 3. 고블린에게 활을 장착 unique_ptr&lt;Goblin&gt; goblin = make_unique&lt;Goblin&gt;(make_unique&lt;Bow&gt;()); goblin-&gt;Attack(); // 출력: Goblin attacks with a Bow!} 이제 새로운 캐릭터(Orc)를 추가해도 무기 코드는 수정할 필요가 없고, 새로운 무기(MagicWand)를 추가해도 캐릭터 코드는 전혀 영향을 받지 않는다. 추상화(Character)와 구현(Weapon)이 독립적으로 확장될 수 있게 된 것이다.요약 브릿지 패턴은 ‘상속보다는 구성을 선호하라(Prefer composition over inheritance)’는 객체 지향 원칙의 대표적인 예시다. 추상화(무엇을 하는지)와 구현(어떻게 하는지)을 두 개의 분리된 클래스 계층으로 나누고, 그 사이를 구성(composition) 관계로 연결(bridge)한다. 이를 통해 양쪽 계층이 서로에게 영향을 주지 않고 독립적으로 변경되거나 확장될 수 있다. 장점 추상화와 구현의 분리: 패턴의 핵심. 양쪽의 독립적인 확장이 가능해져 시스템의 유연성과 확장성이 극대화된다. 구현부의 동적 교체: 런타임에 객체의 구현(위 예제에서는 weapon)을 쉽게 교체할 수 있다. 결합도 감소: 추상화 계층은 구현 계층의 구체적인 클래스를 알 필요가 없으므로, 시스템 전체의 결합도가 낮아진다. 확장성 향상: 새로운 추상화(캐릭터)나 새로운 구현(무기)을 추가할 때, 기존 코드를 거의 수정할 필요 없이 새로운 클래스를 추가하기만 하면 된다. 기능의 개념(추상화)과 그 기능의 다양한 구현 방식이 독립적으로 존재하고, 이 둘을 여러 방식으로 조합해야 할 때 브릿지 패턴은 매우 강력하고 우아한 해결책을 제공한다. " }, { "title": "어댑터 패턴", "url": "/posts/%EC%96%B4%EB%8C%91%ED%84%B0-%ED%8C%A8%ED%84%B4/", "categories": "디자인 패턴, 구조 패턴", "tags": "design pattern", "date": "2023-05-01 00:00:00 +0900", "snippet": "어댑터 특정 클래스의 인터페이스를 클라이언트가 기대하는 다른 인터페이스로 변환하는 구조 패턴 서로 호환되지 않는 인터페이스를 가진 클래스들이 함께 작동할 수 있도록, 중간에서 번역기나 변환기 역할을 하는 클래스를 두는 방식 가장 흔한 비유는 해외여행 시 사용하는 ‘전원 어댑터’다. 한국의 220V 플러그를 미국의 110V 콘센트에 직접 꽂을 수는 없다. 이때 둘 사이에 전원 어댑터를 끼우면, 기존 플러그나 콘센트를 전혀 수정하지 않고도 둘을 연결할 수 있다. 어댑터 패턴도 이와 동일한 역할을 한다게임 로직과 애니메이션 시스템 연결하기 게임 캐릭터 로직과 복잡한 애니메이션 시스템을 연결해야 하는 상황을 가정해보자.1. 클라이언트의 요구사항 (게임 캐릭터 로직) Character 클래스는 자신의 상태에만 집중하고 싶어 한다. Jump(), Attack(), Move() 같은 단순하고 의미가 명확한 메서드를 호출하여 자신의 행동을 표현하고자 한다.// 캐릭터의 고수준(High-level) 로직class Character {public: void Move(float speed) { // ... 이동 관련 물리 로직 ... cout &lt;&lt; \"Character is moving at speed: \" &lt;&lt; speed &lt;&lt; endl; // 이제 이 상태를 애니메이션으로 표현해야 한다. } void Jump() { // ... 점프 관련 물리 로직 ... cout &lt;&lt; \"Character jumps!\" &lt;&lt; endl; // 이 행동도 애니메이션으로 표현해야 한다. } void Attack() { // ... 공격 판정 로직 ... cout &lt;&lt; \"Character attacks!\" &lt;&lt; endl; // 이 행동도 애니메이션으로 표현해야 한다. }};2. 호환되지 않는 인터페이스 (애니메이션 시스템) 우리가 사용하는 애니메이션 시스템은 매우 강력하지만, 저수준(Low-level)의 인터페이스를 가지고 있다. 애니메이션을 재생하려면 정확한 애니메이션 클립의 이름, 파라미터 타입과 이름 등을 모두 알아야 한다.// 우리가 사용하는 저수준 애니메이션 시스템 (Adaptee)class AdvancedAnimationSystem {public: void PlayClip(const string&amp; clipName) { cout &lt;&lt; \"Playing animation clip: \" &lt;&lt; clipName &lt;&lt; endl; } void SetFloat(const string&amp; paramName, float value) { cout &lt;&lt; \"Setting float parameter '\" &lt;&lt; paramName &lt;&lt; \"' to \" &lt;&lt; value &lt;&lt; endl; } void SetBool(const string&amp; paramName, bool value) { cout &lt;&lt; \"Setting bool parameter '\" &lt;&lt; paramName &lt;&lt; \"' to \" &lt;&lt; (value ? \"true\" : \"false\") &lt;&lt; endl; }};3. 문제점 Character 클래스 내부에 애니메이션 시스템의 코드를 직접 넣는다면 어떻게 될까?// 안티 패턴: 클라이언트가 저수준 시스템에 직접 의존class Character { AdvancedAnimationSystem* animSystem;public: // ... void Move(float speed) { // ... // 캐릭터 로직이 애니메이션 파라미터 이름을 모두 알아야 한다. animSystem-&gt;SetFloat(\"moveSpeed\", speed); } void Jump() { // ... // 캐릭터 로직이 애니메이션 클립 이름을 모두 알아야 한다. animSystem-&gt;PlayClip(\"Jump_Start_FullBody\"); animSystem-&gt;SetBool(\"isJumping\", true); }}; 이 방식은 Character 로직과 AdvancedAnimationSystem을 강하게 결합(Tightly Coupled)시킨다. 만약 애니메이터가 moveSpeed를 speed로 바꾸거나 Jump_Start_FullBody 클립 이름을 수정하면, 프로그래머는 Character 클래스의 코드를 직접 수정해야만 한다. 이는 유지보수를 매우 어렵게 만든다.해결책: 애니메이션 어댑터 도입 이 문제를 해결하기 위해, Character와 AdvancedAnimationSystem 사이에 어댑터를 도입한다.1. 클라이언트가 원하는 인터페이스(Target Interface)를 정의한다. Character가 사용하기 원하는 단순하고 명확한 인터페이스를 먼저 설계한다.// 캐릭터가 사용하고자 하는 목표 인터페이스class ICharacterAnimator {public: virtual ~ICharacterAnimator() = default; virtual void OnMove(float speed) = 0; virtual void OnJump() = 0; virtual void OnAttack() = 0;};2. 어댑터 클래스(Adapter)를 구현한다. 이 어댑터는 ICharacterAnimator 인터페이스를 구현하며, 내부적으로 AdvancedAnimationSystem의 저수준 API를 호출하여 둘 사이의 변환을 책임진다.// 어댑터 클래스 구현class AnimationAdapter : public ICharacterAnimator {private: // 호환되지 않는 시스템(Adaptee)의 인스턴스를 가짐 AdvancedAnimationSystem* animSystem;public: AnimationAdapter(AdvancedAnimationSystem* system) : animSystem(system) {} // 목표 인터페이스의 메서드를 구현한다. void OnMove(float speed) override { // 고수준의 '움직임' 요청을 저수준의 '파라미터 설정'으로 변환 animSystem-&gt;SetFloat(\"moveSpeed\", speed); } void OnJump() override { // 고수준의 '점프' 요청을 저수준의 '클립 재생' 및 '파라미터 설정'으로 변환 animSystem-&gt;SetBool(\"isJumping\", true); animSystem-&gt;PlayClip(\"Jump_Start_FullBody\"); } void OnAttack() override { animSystem-&gt;PlayClip(\"Primary_Attack_Sword\"); }};3. 클라이언트가 어댑터를 사용하도록 수정한다. 이제 Character는 저수준 시스템 대신, 자신이 원하는 인터페이스(ICharacterAnimator)를 구현한 어댑터를 사용한다.#include &lt;memory&gt;class Character {private: // 캐릭터는 저수준 시스템의 존재를 전혀 모른다. // 오직 자신이 원하는 ICharacterAnimator 인터페이스에만 의존한다. unique_ptr&lt;ICharacterAnimator&gt; animator;public: Character(unique_ptr&lt;ICharacterAnimator&gt; animator) : animator(move(animator)) {} void Move(float speed) { cout &lt;&lt; \"Character is moving at speed: \" &lt;&lt; speed &lt;&lt; endl; animator-&gt;OnMove(speed); // 단순한 위임 호출 } void Jump() { cout &lt;&lt; \"Character jumps!\" &lt;&lt; endl; animator-&gt;OnJump(); // 단순한 위임 호출 }};// --- 실제 게임에서의 조립 과정 ---int main() { // 1. 저수준 시스템 객체 생성 auto animSystem = new AdvancedAnimationSystem(); // 2. 어댑터 생성. 저수준 시스템을 어댑터에 연결한다. auto adapter = make_unique&lt;AnimationAdapter&gt;(animSystem); // 3. 캐릭터 생성. 캐릭터에 어댑터를 주입한다. Character player(move(adapter)); // 4. 캐릭터의 고수준 메서드 호출 player.Move(5.5f); player.Jump(); delete animSystem; // 메모리 정리 return 0;} 이제 Character는 애니메이션 시스템의 복잡한 내부 구현으로부터 완벽하게 분리되었다. 애니메이션 클립 이름이 바뀌거나 파라미터가 변경되어도 AnimationAdapter 클래스만 수정하면 되며, Character의 코드는 전혀 건드릴 필요가 없다요약 어댑터 패턴은 호환되지 않는 인터페이스를 연결하기 위한 ‘다리’ 역할을 하는 구조 패턴이다. 클라이언트가 사용하는 목표 인터페이스(Target Interface), 변환이 필요한 기존 시스템인 어댑티(Adaptee), 그리고 둘을 연결하는 어댑터(Adapter) 세 요소로 구성된다. 이 패턴을 통해 기존 코드를 수정하지 않고도 레거시 시스템이나 외부 라이브러리를 새로운 시스템에 통합할 수 있다.장점 기존 코드의 재사용성 증대: 코드를 전혀 변경하지 않고도 기존 클래스나 시스템을 재사용할 수 있다. 클라이언트와 구현의 분리: 클라이언트는 자신이 사용하는 인터페이스의 실제 구현에 대해 알 필요가 없으므로, 시스템 간의 결합도가 낮아진다(Loose Coupling). 단일 책임 원칙(SRP) 준수: 인터페이스 변환이라는 책임이 어댑터 클래스에 명확하게 분리되므로, 코드의 구조가 더 깔끔해지고 유지보수가 용이해진다. " }, { "title": "싱글톤 패턴", "url": "/posts/%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4/", "categories": "디자인 패턴, 생성 패턴", "tags": "design pattern", "date": "2023-04-27 00:00:00 +0900", "snippet": "싱글톤 패턴 어떤 클래스의 인스턴스가 어플리케이션 전체에 걸쳐 단 하나만 존재하도록 보장하고, 이에 대한 전역적인 접근점(Global Access Point)을 제공하는 생성 디자인 패턴 예를 들어, 게임의 사운드를 총괄하는 AudioManager, 유저의 입력을 처리하는 InputManager, 게임의 전반적인 상태를 관리하는 GameManager 등은 시스템 전체에 두 개 이상 존재할 이유가 없으며, 여러 곳에서 쉽게 접근할 수 있어야 한다. 싱글톤은 동일한 리소스나 데이터를 여러 번 생성하지 않아 메모리 낭비를 막고 상태를 일관성 있게 관리하는 데 목적이 있다. 전통적인 싱글톤 구현 가장 널리 알려진 싱글톤의 구현 방식은 생성자를 숨기고, 유일한 인스턴스를 반환하는 정적(static) 메서드를 제공하는 것 게임의 모든 사운드 재생을 담당하는 AudioManager를 예로 들어보자 #include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class AudioManager{private: // 1. 생성자를 private으로 선언하여 외부에서 인스턴스 생성을 막는다. AudioManager() { cout &lt;&lt; \"AudioManager instance created.\" &lt;&lt; endl; } ~AudioManager() { cout &lt;&lt; \"AudioManager instance destroyed.\" &lt;&lt; endl; }public: // 2. 복제와 이동을 막아 유일성을 보장한다. AudioManager(const AudioManager&amp;) = delete; AudioManager(AudioManager&amp;&amp;) = delete; AudioManager&amp; operator=(const AudioManager&amp;) = delete; AudioManager&amp; operator=(AudioManager&amp;&amp;) = delete; // 3. 유일한 인스턴스를 얻을 수 있는 정적 메서드를 제공한다. static AudioManager&amp; get() { // 이 방식(Meyers' Singleton)은 C++11부터 스레드에 안전(thread-safe)하다. // 함수 내의 정적 지역 변수는 처음 호출될 때 단 한 번만 초기화된다. static AudioManager instance; return instance; } void PlaySound(const string&amp; soundFile) const { cout &lt;&lt; \"Playing sound: \" &lt;&lt; soundFile &lt;&lt; endl; }}; 이 클래스는 오직 get() 메서드를 통해서만 접근할 수 있으며, instance는 프로그램 전체에서 단 하나만 생성됨이 보장된다// 사용법void SomeFunction() { AudioManager::get().PlaySound(\"explosion.wav\");}void AnotherFunction() { // 여러 곳에서 호출해도 항상 동일한 인스턴스를 사용한다. AudioManager::get().PlaySound(\"background_music.mp3\");} 이 방식은 매우 편리해 보이지만, 치명적인 단점을 가지고 있다.싱글톤의 치명적인 문제점: 강한 결합 싱글톤 패턴의 가장 큰 문제는 강한 결합(Tight Coupling)을 유발한다는 점이다. 싱글톤을 사용하는 코드는 구체적인 싱글톤 클래스에 직접적으로 의존하게 된다. 플레이어가 점프할 때 사운드를 재생하는 Player 클래스를 생각해보자.class Player{public: void Jump() { cout &lt;&lt; \"Player jumps!\" &lt;&lt; endl; // Player 클래스가 AudioManager 클래스에 직접 의존한다. AudioManager::get().PlaySound(\"jump.wav\"); }}; 이 코드는 잘 동작하지만, 다음과 같은 질문을 던져봐야 한다. “Player의 Jump() 로직만 독립적으로 테스트할 수 있는가?” 정답은 ‘아니오’다. Player 클래스는 AudioManager의 구체적인 구현에 묶여있기 때문에, Jump()를 테스트하면 실제 사운드가 재생되거나 AudioManager의 로직이 실행된다. 테스트 환경에서는 사운드를 끄고 싶거나, PlaySound가 올바른 파일 이름으로 호출되었는지만 확인하고 싶을 수 있다. 하지만 현재 구조에서는 AudioManager를 가짜 객체(Mock Object)나 더미(Dummy) 객체로 대체할 방법이 없다. 이처럼 싱글톤은 단위 테스트(Unit Test)를 매우 어렵게 만들고, 코드의 유연성을 심각하게 저해한다. 이는 싱글톤이 ‘안티 패턴’으로 비판받는 주된 이유다.해결책: 의존성 주입 (Dependency Injection) 이 문제를 해결하는 가장 현대적이고 효과적인 방법은 의존성 주입(Dependency Injection, DI)을 사용하는 것이다. 클래스가 필요로 하는 의존성을 외부에서 ‘주입’해주는 방식이다.1. 먼저, 오디오 시스템에 대한 추상 인터페이스(IAudioSystem)를 정의한다// 오디오 시스템에 대한 추상 인터페이스class IAudioSystem{public: virtual ~IAudioSystem() = default; virtual void PlaySound(const string&amp; soundFile) = 0;};2. 실제 AudioManager가 이 인터페이스를 구현하도록 한다.class AudioManager : public IAudioSystem { // ... 기존 싱글톤 구현과 유사하지만, 인터페이스를 상속받는다.public: void PlaySound(const string&amp; soundFile) override { cout &lt;&lt; \"Playing sound: \" &lt;&lt; soundFile &lt;&lt; endl; } // ... get() 메서드 등 ...};3.Player 클래스가 구체적인 AudioManager가 아닌, 추상 IAudioSystem에 의존하도록 수정한다.class Player{private: IAudioSystem&amp; audio; // 구체 클래스가 아닌 추상 인터페이스에 의존한다.public: // 생성자를 통해 의존성을 외부에서 주입받는다. Player(IAudioSystem&amp; audioSystem) : audio(audioSystem) {} void Jump() { cout &lt;&lt; \"Player jumps!\" &lt;&lt; endl; audio.PlaySound(\"jump.wav\"); // 주입받은 객체를 사용한다. }}; 이제 Player는 AudioManager의 존재를 전혀 모른다. 그저 IAudioSystem 인터페이스를 만족하는 어떤 객체든 받아서 사용할 수 있다.단위 테스트에서의 활용 테스트 시에는 실제 AudioManager 대신, 아무 동작도 하지 않는 가짜 오디오 시스템을 주입할 수 있다.// 테스트를 위한 가짜 오디오 시스템class NullAudioSystem : public IAudioSystem {public: void PlaySound(const string&amp; soundFile) override { // 실제 사운드를 재생하는 대신, 콘솔에 로그만 남긴다. cout &lt;&lt; \"[Test Log] Sound requested: \" &lt;&lt; soundFile &lt;&lt; endl; }};void TestPlayerJump() { NullAudioSystem fakeAudio; // 가짜 객체 생성 Player player(fakeAudio); // 가짜 객체를 Player에 주입 player.Jump(); // 이제 이 테스트는 실제 오디오 시스템과 완전히 분리된다.} 이처럼 의존성 주입을 통해 클래스 간의 결합도를 낮추고, 코드를 훨씬 더 유연하고 테스트하기 쉽게 만들 수 있다.현대적 대안: 서비스 로케이터 (Service Locator) 의존성 주입은 훌륭하지만, 게임 최상단(main 함수)부터 최하단 객체까지 의존성을 일일이 전달하는 것이 번거로울 수 있다. 이때 서비스 로케이터(Service Locator) 패턴을 대안으로 고려할 수 있다. 서비스 로케이터는 필요한 서비스(객체)를 등록하고 찾아주는 전역 레지스트리 역할을 한다.class ServiceLocator{private: static IAudioSystem* audioService;public: static IAudioSystem&amp; GetAudio() { return *audioService; } static void Provide(IAudioSystem* service) { if (service == nullptr) { // 아무것도 제공되지 않으면 Null 객체를 기본값으로 사용 // static NullAudioSystem defaultService; // audioService = &amp;defaultService; } else { audioService = service; } }};IAudioSystem* ServiceLocator::audioService = nullptr; // 정적 멤버 초기화// 게임 시작 시, 실제 서비스를 등록int main() { AudioManager realAudio; ServiceLocator::Provide(&amp;realAudio); // ... 게임 로직 실행 ...}// Player 클래스에서의 사용class Player {public: void Jump() { // 싱글톤처럼 보이지만, 실제로는 추상 인터페이스를 통해 서비스를 찾는다. ServiceLocator::GetAudio().PlaySound(\"jump.wav\"); }}; 서비스 로케이터는 싱글톤처럼 전역 접근점을 제공하지만, 런타임에 실제 구현을 교체할 수 있다는 장점이 있다. 테스트 시에는 ServiceLocator::Provide(&amp;fakeAudio)처럼 가짜 서비스를 등록하면 되므로, 전통적인 싱글톤보다 테스트 용이성이 훨씬 뛰어나다.요약 싱글톤 패턴은 전역에서 유일한 인스턴스를 보장하지만, 강한 결합을 유발하여 코드의 유연성과 테스트 용이성을 심각하게 해친다는 명확한 단점이 있다. SomeClass::get().DoSomething()과 같은 직접적인 싱글톤 호출은 피하는 것이 좋다.이에 대한 현대적인 해결책은 의존성 주입(DI)이다. 클래스가 필요한 객체를 외부에서 주입받게 함으로써 결합도를 낮추고 테스트를 용이하게 한다. 서비스 로케이터는 전역 접근의 편리함과 DI의 유연성 사이의 절충안이 될 수 있다. 결론적으로, 어떤 객체가 ‘유일해야 한다’는 사실은 그 객체를 사용하는 쪽이 아닌, 어플리케이션의 구성 책임이 있는 최상단(예: main 함수, IoC 컨테이너 등)에서 관리하는 것이 바람직한 설계다. " }, { "title": "프로토 타입 패턴", "url": "/posts/%ED%94%84%EB%A1%9C%ED%86%A0-%ED%83%80%EC%9E%85-%ED%8C%A8%ED%84%B4/", "categories": "디자인 패턴, 생성 패턴", "tags": "design pattern", "date": "2023-04-24 00:00:00 +0900", "snippet": "프로토타입 패턴 객체를 처음부터 새로 만드는 대신, 이미 존재하는 객체를 복제(clone)하여 새로운 객체를 생성하는 디자인 패턴 예를 들어, 수백 마리의 고블린을 필드에 스폰해야 할 때, 매번 new Goblin()을 호출하고 체력, 공격력, AI, 모델링 데이터 등을 일일이 설정하는 것은 비효율적이다. 대신, 모든 설정이 완료된 ‘고블린 원형(prototype)’ 객체를 하나 만들어 두고, 필요할 때마다 이 원형을 복제해서 사용하는 것이 훨씬 효율적이다. Unity나 Unreal Engine의 프리팹(Prefab) 시스템이 바로 이 프로토타입 패턴의 대표적인 예시 이 패턴에서 가장 까다로운 부분은 객체를 ‘어떻게 올바르게 복제할 것인가’ 하는 부분 문제 상황: 대량의 몬스터 스폰 게임 월드에 동일한 종류의 몬스터를 대량으로 배치해야 하는 상황을 가정해 보자. 이 몬스터는 체력, 공격력 같은 단순한 데이터뿐만 아니라, 아이템을 담는 인벤토리나 복잡한 AI 상태 같은 객체를 포인터로 참조하고 있다#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;memory&gt;using namespace std;// 몬스터가 가질 수 있는 아이템struct Item { string name; Item(const string&amp; name) : name(name) {}};// 몬스터의 인벤토리. 아이템 목록을 가짐.struct Inventory { vector&lt;unique_ptr&lt;Item&gt;&gt; items; void AddItem(const string&amp; itemName) { items.push_back(make_unique&lt;Item&gt;(itemName)); }};// 몬스터 클래스class Monster {public: string name; int health; Inventory* inventory; // 인벤토리를 포인터로 가짐 Monster(const string&amp; name, int health) : name(name), health(health), inventory(new Inventory()) {} // 소멸자에서 인벤토리 메모리 해제 ~Monster() { delete inventory; }}; 이 Monster 클래스의 ‘고블린’ 프로토타입을 하나 만들고, 이를 복제해서 새로운 고블린을 생성하려고 한다.// 1. 고블린 프로토타입 생성Monster goblinPrototype(\"Goblin\", 50);goblinPrototype.inventory-&gt;AddItem(\"Rusty Dagger\");// 2. 프로토타입을 단순 대입으로 복제 (문제 발생!)Monster newGoblin = goblinPrototype;newGoblin.name = \"Goblin Guard\";// 3. 복제된 몬스터의 인벤토리에 아이템을 추가newGoblin.inventory-&gt;AddItem(\"Leather Shield\"); 이 코드는 심각한 버그를 유발한다. Monster newGoblin = goblinPrototype; 라인에서 발생하는 것은 얕은 복사(Shallow Copy)다. inventory 포인터의 ‘주소값’만 복사되기 때문에, goblinPrototype과 newGoblin은 완전히 동일한 Inventory 객체를 공유하게 된다. 결과적으로 newGoblin의 인벤토리를 수정했는데 원본인 goblinPrototype의 인벤토리까지 함께 수정되는 문제가 발생한다. 더 심각한 것은, 두 객체의 소멸자가 호출될 때 동일한 inventory 포인터를 두 번 delete하려고 시도하여 프로그램이 비정상 종료된다.해결책 1: 명시적인 clone 메서드 구현 이 문제를 해결하는 가장 직접적인 방법은 깊은 복사(Deep Copy)를 수행하는 복제 전용 메서드를 만드는 것이다 이를 위해 복제 가능한 모든 객체에 대한 추상 인터페이스를 먼저 정의한다. // 복제 가능한 객체를 위한 인터페이스class IPrototype {public: virtual unique_ptr&lt;IPrototype&gt; clone() const = 0; virtual ~IPrototype() = default;}; 이제 Monster와 Inventory가 이 인터페이스를 구현하도록 수정한다// Inventory 클래스 수정class Inventory { /* ... */public: // Inventory 객체를 깊은 복사하는 clone 메서드 unique_ptr&lt;Inventory&gt; clone() const { auto newInventory = make_unique&lt;Inventory&gt;(); for (const auto&amp; item : items) { newInventory-&gt;items.push_back(make_unique&lt;Item&gt;(item-&gt;name)); } return newInventory; }};// Monster 클래스 수정 (IPrototype 상속)class Monster : public IPrototype {public: string name; int health; unique_ptr&lt;Inventory&gt; inventory; // unique_ptr로 변경하여 메모리 관리 자동화 Monster(const string&amp; name, int health) : name(name), health(health), inventory(make_unique&lt;Inventory&gt;()) {} // Monster 객체를 깊은 복사하는 clone 메서드 unique_ptr&lt;IPrototype&gt; clone() const override { // 1. 새로운 Monster 객체 생성 auto newMonster = make_unique&lt;Monster&gt;(this-&gt;name, this-&gt;health); // 2. 포인터 멤버(Inventory)도 재귀적으로 clone 호출 newMonster-&gt;inventory = this-&gt;inventory-&gt;clone(); return newMonster; } void PrintStatus() const { cout &lt;&lt; name &lt;&lt; \" (HP: \" &lt;&lt; health &lt;&lt; \") - Items: \" &lt;&lt; inventory-&gt;items.size() &lt;&lt; endl; }}; 이제 clone 메서드를 사용하면 원본에 영향을 주지 않는 안전한 복제본을 만들 수 있다// 프로토타입 생성auto goblinPrototype = make_unique&lt;Monster&gt;(\"Goblin\", 50);goblinPrototype-&gt;inventory-&gt;AddItem(\"Rusty Dagger\");// clone 메서드를 통한 안전한 복제unique_ptr&lt;Monster&gt; newGoblin = unique_ptr&lt;Monster&gt;(static_cast&lt;Monster*&gt;(goblinPrototype-&gt;clone().release()));newGoblin-&gt;name = \"Goblin Guard\";newGoblin-&gt;inventory-&gt;AddItem(\"Leather Shield\");goblinPrototype-&gt;PrintStatus(); // 출력: Goblin (HP: 50) - Items: 1newGoblin-&gt;PrintStatus(); // 출력: Goblin Guard (HP: 50) - Items: 2 (원본과 다름) 이 방법은 잘 동작하지만, 객체가 복잡해지고 포인터 멤버가 많아질수록 clone 메서드 구현이 매우 번거로워지고 실수가 발생하기 쉽다해결책 2: 직렬화를 이용한 복제 수동으로 깊은 복사 코드를 작성하는 불편함을 해소하기 위한 대안으로 직렬화(Serialization)를 활용할 수 있다. 직렬화는 객체를 바이트 스트림(데이터의 나열)으로 변환하는 과정이다. 객체를 직렬화하여 메모리에 저장한 뒤, 그 데이터를 즉시 역직렬화(바이트 스트림을 다시 객체로 변환)하면 완벽한 깊은 복사본이 만들어진다. C++는 언어 차원에서 직렬화를 지원하지 않으므로, Boost.Serialization과 같은 라이브러리를 사용한다.#include &lt;boost/archive/text_oarchive.hpp&gt;#include &lt;boost/archive/text_iarchive.hpp&gt;#include &lt;boost/serialization/unique_ptr.hpp&gt;#include &lt;boost/serialization/vector.hpp&gt;// Boost.Serialization을 사용하도록 클래스 수정struct Item { string name;private: friend class boost::serialization::access; template&lt;class Archive&gt; void serialize(Archive&amp; ar, const unsigned int version) { ar &amp; name; }};struct Inventory { vector&lt;unique_ptr&lt;Item&gt;&gt; items;private: friend class boost::serialization::access; template&lt;class Archive&gt; void serialize(Archive&amp; ar, const unsigned int version) { ar &amp; items; }};class Monster {public: string name; int health; unique_ptr&lt;Inventory&gt; inventory;private: friend class boost::serialization::access; template&lt;class Archive&gt; void serialize(Archive&amp; ar, const unsigned int version) { ar &amp; name; ar &amp; health; ar &amp; inventory; // 포인터도 라이브러리가 알아서 처리 }}; 모든 클래스에 serialize 함수를 구현했다면, 다음과 같은 범용 복제 함수를 만들 수 있다template &lt;typename T&gt;T CloneViaSerialization(const T&amp; obj){ // 1. 객체를 문자열 스트림으로 직렬화 stringstream ss; boost::archive::text_oarchive oa(ss); oa &lt;&lt; obj; string s = ss.str(); // 2. 문자열 스트림으로부터 역직렬화하여 새로운 객체 생성 T newObj; stringstream new_ss(s); boost::archive::text_iarchive ia(new_ss); ia &gt;&gt; newObj; return newObj;}// 사용 예Monster goblinPrototype; // ... 초기화Monster newGoblin = CloneViaSerialization(goblinPrototype); 이 방법은 수동 clone 구현보다 오류 발생 가능성이 적지만, 직렬화/역직렬화 과정에서 약간의 성능 오버헤드가 발생할 수 있다프로토타입 팩토리 (또는 레지스트리) 게임에 사용될 여러 프로토타입 객체들(고블린, 오크, 드래곤 등)은 어디에 저장하고 관리해야 할까? 전역 변수로 두는 대신, 이 프로토타입들을 관리하는 팩토리 또는 레지스트리(Registry) 클래스를 만드는 것이 좋다. #include &lt;map&gt;// 몬스터 프로토타입을 관리하는 레지스트리class MonsterRegistry {private: map&lt;string, unique_ptr&lt;Monster&gt;&gt; prototypes;public: // 게임 시작 시 프로토타입들을 등록 void RegisterMonster(const string&amp; id, unique_ptr&lt;Monster&gt; monster) { prototypes[id] = move(monster); } // ID를 기반으로 해당 몬스터의 복제본을 생성하여 반환 unique_ptr&lt;Monster&gt; Create(const string&amp; id) const { auto it = prototypes.find(id); if (it == prototypes.end()) { return nullptr; // 해당 ID의 프로토타입이 없음 } // IPrototype 인터페이스의 clone 메서드를 사용한다고 가정 return unique_ptr&lt;Monster&gt;( static_cast&lt;Monster*&gt;(it-&gt;second-&gt;clone().release()) ); }};//사용 방법// 1. 게임 로딩 시, 몬스터 레지스트리 초기화MonsterRegistry registry;registry.RegisterMonster(\"Goblin\", make_unique&lt;Monster&gt;(\"Goblin\", 50));registry.RegisterMonster(\"Orc\", make_unique&lt;Monster&gt;(\"Orc\", 120));// 2. 게임 월드에서 몬스터 스폰이 필요할 때unique_ptr&lt;Monster&gt; newGoblin = registry.Create(\"Goblin\");unique_ptr&lt;Monster&gt; anotherGoblin = registry.Create(\"Goblin\");unique_ptr&lt;Monster&gt; newOrc = registry.Create(\"Orc\");if (newGoblin) { // 위치 설정 등 추가 작업...} 이 방식은 데이터 기반 설계를 가능하게 한다. 몬스터 정보를 파일(JSON, XML 등)에서 읽어와 프로토타입을 동적으로 등록하고, 게임 로직은 단순히 몬스터 ID만으로 필요한 객체를 안전하고 효율적으로 생성할 수 있다요약 프로토타입 패턴은 미리 만들어 둔 원본 객체를 복제하여 새로운 객체를 생성하는 패턴이다. 게임 엔진의 프리팹 시스템이 대표적인 예다. C++에서 프로토타입 패턴 구현의 핵심은 깊은 복사를 올바르게 수행하는 것이다. 방법 1: 명시적인 clone 메서드 구현: 직관적이지만 객체가 복잡해지면 수작업이 많아지고 오류가 발생하기 쉽다. 방법 2: 직렬화 활용: 라이브러리를 통해 비교적 안전하게 깊은 복사를 구현할 수 있지만, 성능 오버헤드가 있을 수 있다. 생성된 프로토타입들은 레지스트리(Registry)나 팩토리(Factory)를 통해 관리하면, 중앙에서 일관되게 객체를 생성하고 관리할 수 있어 코드의 구조를 개선한다. 객체 생성 비용이 높거나, 동일한 상태를 가진 객체를 반복적으로 생성해야 하는 경우 프로토타입 패턴은 매우 효율적이고 강력한 해결책이 된다." }, { "title": "팩토리 패턴", "url": "/posts/%ED%8C%A9%ED%86%A0%EB%A6%AC-%ED%8C%A8%ED%84%B4/", "categories": "디자인 패턴, 생성 패턴", "tags": "design pattern", "date": "2023-04-23 00:00:00 +0900", "snippet": "팩토리 패턴 객체를 생성하는 코드를 캡슐화하여, 클라이언트가 구체적인 클래스 타입을 직접 알지 못해도 객체를 만들 수 있게 해주는 생성 디자인 패턴시나리오 Goblin, Orc, Dragon 등 수많은 종류의 몬스터를 생성해야 한다고 가정한다. 가장 간단한 방법은 몬스터가 필요한 곳마다 if-else나 switch 문으로 분기하여 new Goblin(), new Orc()처럼 직접 객체를 생성하는 것// 안티 패턴: 객체 생성 로직이 외부에 노출됨Enemy* createEnemy(string type) { if (type == \"goblin\") { return new Goblin(); } else if (type == \"orc\") { return new Orc(); } else if (type == \"dragon\") { return new Dragon(); } return nullptr;} 이런 코드는 새로운 몬스터 타입(예: Slime)이 추가될 때마다 이 함수를 수정해야만 한다. 이는 개방-폐쇄 원칙(Open-Closed Principle) 에 위배되며, 코드를 경직시키고 유지보수를 어렵게 만든다. 팩토리 패턴은 이러한 “객체 생성의 복잡성”을 깔끔하게 해결해 준다.팩토리 메서드 (Factory Method) 팩토리 메서드의 가장 흔하고 실용적인 형태는 정적(static) 팩토리 메서드다. 이 방법은 생성자의 한계를 극복하기 위해 사용된다.시나리오: 다양한 방식으로 스펠(Spell) 객체 생성하기 플레이어가 사용하는 스펠 객체를 생성해야 한다. 그런데 스펠은 여러 방식으로 정의될 수 있다. 사전에 정의된 데이터(ID)로부터 생성 (예: “SPELL_FIREBALL_01”) 기본 속성과 레벨을 조합하여 즉시 생성 (예: “Fire” 속성, 레벨 3) 이를 하나의 생성자로 처리하려고 하면 문제가 발생한다. class Spell{public: // 1. ID로 생성하려는 시도 Spell(const string&amp; spellId) { /* ID를 기반으로 데이터 로드 */ } // 2. 속성과 레벨로 생성하려는 시도 // Spell(const string&amp; element, int level) { /* ... */ } // ERROR: 위 생성자와 구분이 모호 // ...}; string을 받는 생성자가 이미 존재하므로, string과 int를 받는 생성자를 추가하려 해도 오버로딩 규칙이 모호해지거나 의도가 불분명해질 수 있다. 생성자의 이름은 항상 클래스 이름과 같아야 하므로, 이름으로 의도를 표현할 수도 없다.해결책: 정적 팩토리 메서드 가장 깔끔한 해결책은 생성자를 private으로 숨기고, 명확한 이름을 가진 정적 메서드를 제공하는 것#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Spell{private: string name; int damage; // 생성자를 private으로 만들어 외부에서의 직접 생성을 막음 Spell(const string&amp; name, int damage) : name(name), damage(damage) {}public: void Cast() const { cout &lt;&lt; name &lt;&lt; \" 시전! (데미지: \" &lt;&lt; damage &lt;&lt; \")\" &lt;&lt; endl; } // 정적 팩토리 메서드 1: ID로부터 스펠 생성 static Spell CreateFromId(const string&amp; spellId) { // 실제로는 spellId를 사용해 데이터베이스나 파일에서 정보를 조회 if (spellId == \"FIREBALL_01\") { return Spell(\"Fireball\", 20); } else if (spellId == \"ICELANCE_01\") { return Spell(\"Ice Lance\", 15); } return Spell(\"Spark\", 5); // 기본 스펠 } // 정적 팩토리 메서드 2: 속성과 레벨로 스펠 생성 static Spell CreateFromElement(const string&amp; element, int level) { string spellName = element + \" Bolt\"; int spellDamage = 5 * level; return Spell(spellName, spellDamage); }}; CreateFromId와 CreateFromElement가 바로 팩토리 메서드 사용 예시 // 사용 예auto fireball = Spell::CreateFromId(\"FIREBALL_01\");auto customSpell = Spell::CreateFromElement(\"Lightning\", 5);fireball.Cast();customSpell.Cast();팩토리 클래스 (Factory Class) 객체 생성 로직이 더 복잡해지면, 생성 관련 코드들을 별도의 팩토리 클래스로 분리하는 것이 좋다.class Spell; // 전방 선언// Spell 객체 생성을 전담하는 팩토리 클래스class SpellFactory{public: static Spell CreateFromId(const string&amp; spellId); static Spell CreateFromElement(const string&amp; element, int level);};// 실제 Spell 클래스class Spell{ // SpellFactory가 Spell의 private 생성자에 접근할 수 있도록 friend로 선언 friend class SpellFactory;private: string name; int damage; Spell(const string&amp; name, int damage) : name(name), damage(damage) {}public: void Cast() const; // 구현은 위와 동일};// 팩토리 메서드들의 실제 구현Spell SpellFactory::CreateFromId(const string&amp; spellId) { if (spellId == \"FIREBALL_01\") return Spell(\"Fireball\", 20); // ... return Spell(\"Spark\", 5);}Spell SpellFactory::CreateFromElement(const string&amp; element, int level) { return Spell(element + \" Bolt\", 5 * level);} 이제 Spell의 생성 책임은 온전히 SpellFactory에게 위임되었다.// 사용 예auto mySpell = SpellFactory::CreateFromId(\"ICELANCE_01\");mySpell.Cast(); 이 구조는 생성 로직과 실제 객체의 코드를 완전히 분리하여 관심사 분리(Separation of Concerns) 원칙을 잘 따른다.추상 팩토리 (Abstract Factory) 연관된 객체들의 ‘묶음(family)’을 생성할 때 사용되는 패턴. 즉, 단일 객체가 아닌, 테마를 가진 여러 객체를 일관성 있게 생성할 때 강력한 힘을 발휘시나리오: 다양한 테마의 UI 생성하기 게임에 “판타지 테마”와 “SF 테마” 두 가지 UI 스킨을 지원해야 한다고 가정해 본다. 각 테마는 자신만의 버튼, 창, 스크롤바를 가진다 판타지 테마: 나무 재질의 버튼, 양피지 스타일의 창 SF 테마: 홀로그램 스타일의 버튼, 메탈 재질의 창 이때, UI를 그리는 클라이언트 코드는 현재 테마가 판타지인지 SF인지 몰라야 한다. 그저 “버튼 하나 만들어줘”라고 요청하면, 현재 설정된 테마에 맞는 버튼이 생성되어야 한다.1. 추상 제품(Abstract Product) 정의 모든 버튼과 창의 기본 인터페이스를 정의한다.// 모든 버튼이 가져야 할 추상 인터페이스class IButton {public: virtual void Render() const = 0; virtual ~IButton() = default;};// 모든 창이 가져야 할 추상 인터페이스class IWindow {public: virtual void Render() const = 0; virtual ~IWindow() = default;};2. 구체적인 제품(Concrete Product) 구현 각 테마에 맞는 실제 버튼과 창을 구현한다.// 판타지 테마 제품군class FantasyButton : public IButton { void Render() const override { cout &lt;&lt; \"Rendering a wooden FantasyButton.\" &lt;&lt; endl; }};class FantasyWindow : public IWindow { void Render() const override { cout &lt;&lt; \"Rendering a parchment FantasyWindow.\" &lt;&lt; endl; }};// SF 테마 제품군class SciFiButton : public IButton { void Render() const override { cout &lt;&lt; \"Rendering a holographic SciFiButton.\" &lt;&lt; endl; }};class SciFiWindow : public IWindow { void Render() const override { cout &lt;&lt; \"Rendering a metallic SciFiWindow.\" &lt;&lt; endl; }};3.추상 팩토리(Abstract Factory) 정의 UI 요소들을 생성하는 메서드를 모아놓은 추상 인터페이스를 정의한다// UI 요소 묶음을 생성하는 추상 팩토리class IGUIFactory {public: virtual unique_ptr&lt;IButton&gt; CreateButton() const = 0; virtual unique_ptr&lt;IWindow&gt; CreateWindow() const = 0; virtual ~IGUIFactory() = default;};4. 구체적인 팩토리(Concrete Factory) 구현 각 테마에 맞는 제품군을 생성하는 실제 팩토리를 구현한다.// 판타지 테마의 UI 요소들을 생성하는 팩토리class FantasyGUIFactory : public IGUIFactory {public: unique_ptr&lt;IButton&gt; CreateButton() const override { return make_unique&lt;FantasyButton&gt;(); } unique_ptr&lt;IWindow&gt; CreateWindow() const override { return make_unique&lt;FantasyWindow&gt;(); }};// SF 테마의 UI 요소들을 생성하는 팩토리class SciFiGUIFactory : public IGUIFactory {public: unique_ptr&lt;IButton&gt; CreateButton() const override { return make_unique&lt;SciFiButton&gt;(); } unique_ptr&lt;IWindow&gt; CreateWindow() const override { return make_unique&lt;SciFiWindow&gt;(); }};5. 클라이언트 코드에서의 사용 클라이언트는 구체적인 팩토리(FantasyGUIFactory 등)가 아닌, 추상 팩토리(IGUIFactory)에만 의존한다.class Application { unique_ptr&lt;IButton&gt; button; unique_ptr&lt;IWindow&gt; window;public: // 클라이언트는 추상 팩토리를 주입받음 Application(const IGUIFactory&amp; factory) { cout &lt;&lt; \"Creating UI elements...\" &lt;&lt; endl; button = factory.CreateButton(); window = factory.CreateWindow(); } void Run() { button-&gt;Render(); window-&gt;Render(); }};// 메인 함수에서 테마를 결정하고 해당 팩토리를 주입int main() { // 현재 게임 테마 설정 string currentTheme = \"SciFi\"; // 이 값을 \"Fantasy\"로 바꾸기만 하면 UI 전체가 바뀜 unique_ptr&lt;IGUIFactory&gt; factory; if (currentTheme == \"Fantasy\") { factory = make_unique&lt;FantasyGUIFactory&gt;(); } else { factory = make_unique&lt;SciFiGUIFactory&gt;(); } // 어플리케이션은 어떤 팩토리가 들어왔는지 전혀 모름 Application app(*factory); app.Run(); return 0;} 추상 팩토리 패턴을 사용하면, currentTheme 변수 하나만 바꿔도 어플리케이션 전체의 UI 테마가 일관성 있게 변경된다. 클라이언트 코드는 전혀 수정할 필요가 없다.요약팩토리 패턴의 종류 팩토리 메서드(주로 정적 팩토리 메서드): 생성자를 대신하여, 명확한 의도를 가진 이름으로 객체를 생성합니다. 팩토리 클래스: 객체 생성 로직이 복잡할 때, 이를 별도의 클래스로 분리하여 관리합니다. 추상 팩토리: 서로 연관된 객체들의 ‘묶음’을 일관성 있게 생성하기 위한 인터페이스를 제공합니다. 팩토리 패턴의 장점 생성 로직의 캡슐화: 객체를 만드는 복잡한 과정을 클라이언트로부터 숨길 수 있습니다. 유연성 및 확장성: 새로운 종류의 제품이 추가되어도, 팩토리 부분만 수정하면 되므로 기존 클라이언트 코드에 미치는 영향이 적습니다. (OCP 원칙) 가독성 향상: new MyObject(true, false, 10, “A”)와 같은 모호한 생성자 호출 대신, MyObject::CreateWithDefaults()처럼 의도가 명확한 메서드를 사용할 수 있습니다. 의존성 감소: 클라이언트 코드가 구체적인 클래스가 아닌 추상 인터페이스에 의존하게 되므로, 시스템의 결합도가 낮아지고 유연해집니다. " }, { "title": "빌더 패턴", "url": "/posts/%EB%B9%8C%EB%8D%94-%ED%8C%A8%ED%84%B4/", "categories": "디자인 패턴, 생성 패턴", "tags": "design pattern", "date": "2023-04-22 00:00:00 +0900", "snippet": "빌더 패턴 복잡한 객체를 생성하는 과정을 단계별로 분리하여, 동일한 프로세스로 다양한 구성의 객체를 만들 수 있게 하는 생성 디자인 패턴시나리오 어떤 게임에 새로운 캐릭터를 추가해야 한다고 가정하면 캐릭터는 다음과 같은 속성을 가진다필수속성 이름 직업선택속성 무기 방어구 방패 스킬문제점 : 점층적 생성자 패턴 (Telescoping Constructor) 가장 단순한 방법은 여러 개의 생성자를 만드는 것// 안티 패턴: 점층적 생성자class Character{public: // Required attributes only Character(const string&amp; name, const string&amp; job); // With a weapon Character(const string&amp; name, const string&amp; job, const string&amp; weapon); // With weapon and armor Character(const string&amp; name, const string&amp; job, const string&amp; weapon, const string&amp; armor); // ... and so on for all combinations ...};// Usage ExampleCharacter warrior(\"Hero\", \"Warrior\", \"Longsword\", \"Iron Armor\");Character mage(\"Mage\", \"Wizard\", \"Magic Staff\");이 방식은 몇 가지 심각한 단점이 있다. 가독성 저하: Character(“Elf”, “Archer”, “Longbow”, “Leather Armor”)와 같은 호출 코드는 각 인자가 무엇을 의미하는지 파악하기 어려움 유연성 부족: 새로운 속성(예: ‘펫’)이 추가될 때마다 수많은 생성자를 수정하거나 새로 만들어야 함. 실수 유발: 인자의 순서를 헷갈리거나, 원치 않는 속성에 nullptr 또는 기본값을 넣어야 하는 경우가 많아 버그를 유발하기 쉬움 해결책: 빌더 패턴의 도입 이 문제를 해결하기 위해, 캐릭터의 생성 과정만을 전담하는 CharacterBuilder 클래스를 만듦1.단순한 빌더// 생성될 대상 객체class Character{public: string name, job, weapon, armor, shield, specialSkill; void PrintStatus() const { cout &lt;&lt; \"--- \" &lt;&lt; name &lt;&lt; \" (\" &lt;&lt; job &lt;&lt; \") ---\" &lt;&lt; endl; if (!weapon.empty()) cout &lt;&lt; \" Weapon: \" &lt;&lt; weapon &lt;&lt; endl; if (!armor.empty()) cout &lt;&lt; \" Armor: \" &lt;&lt; armor &lt;&lt; endl; if (!shield.empty()) cout &lt;&lt; \" Shield: \" &lt;&lt; shield &lt;&lt; endl; if (!specialSkill.empty()) cout &lt;&lt; \" Special Skill: \" &lt;&lt; specialSkill &lt;&lt; endl; }};// 캐릭터 생성을 전담하는 빌더 클래스class CharacterBuilder{private: Character character; // 생성할 캐릭터 객체를 내부에 가짐public: CharacterBuilder(string name, string job) { character.name = name; character.job = job; } void SetWeapon(string weapon) { character.weapon = weapon; } void SetArmor(string armor) { character.armor = armor; } // ... 다른 속성 설정 메서드들 ... // 최종적으로 완성된 객체를 반환하는 메서드 Character Build() { return character; }}; 사용 예시// 빌더 사용 예CharacterBuilder builder(\"Warrior\", \"Swordsman\");builder.SetWeapon(\"Excalibur\");builder.SetArmor(\"Mithril Armor\");Character warrior = builder.Build();warrior.PrintStatus();2. 흐름식 빌더 (Fluent Builder) 메서드 체이닝(Method Chaining)을 이용하면 빌더를 훨씬 더 우아하게 사용할 수 있다. 각 설정 메서드가 void 대신 빌더 자신의 참조(*this)를 반환하도록 수정하면 된다class CharacterBuilder{private: Character character;public: CharacterBuilder(string name, string job) { character.name = name; character.job = job; } // 자기 자신의 참조를 반환하여 메서드 체이닝을 가능하게 함 CharacterBuilder&amp; WithWeapon(string weapon) { character.weapon = weapon; return *this; } CharacterBuilder&amp; WithArmor(string armor) { character.armor = armor; return *this; } CharacterBuilder&amp; WithShield(string shield) { character.shield = shield; return *this; } CharacterBuilder&amp; HasSpecialSkill(string skill) { character.specialSkill = skill; return *this; } Character Build() { return character; }}; 사용 예시// 흐름식 인터페이스 사용 예Character paladin = CharacterBuilder(\"Paladin\", \"Holy Knight\") .WithWeapon(\"Holy Hammer\") .WithArmor(\"Armor of Light\") .WithShield(\"Shield of Protection\") .Build();paladin.PrintStatus();// 흐름식 인터페이스 사용 예Character paladin = CharacterBuilder(\"Paladin\", \"Holy Knight\") .WithWeapon(\"Holy Hammer\") .WithArmor(\"Armor of Light\") .WithShield(\"Shield of Protection\") .Build();paladin.PrintStatus();3. 의도 명확화: 빌더 사용 강제하기 Character의 생성자를 private으로 숨기고, 빌더를 생성해주는 정적(static) 팩토리 메서드를 추가class CharacterBuilder; // 전방 선언class Character{ friend class CharacterBuilder; // 빌더가 Character의 private 멤버에 접근하도록 허용private: string name, job, weapon, armor, shield, specialSkill; Character() = default; // 빌더만 생성자를 호출할 수 있도록 private으로 변경public: void PrintStatus() const; // 빌더를 생성하는 정적 팩토리 메서드 static CharacterBuilder Create(string name, string job);};// CharacterBuilder 클래스는 Character::Create를 통해 생성되므로// 생성자를 외부에 노출할 필요가 없음 (private으로 변경)class CharacterBuilder{ friend class Character; // Character가 빌더를 생성할 수 있도록 허용private: Character character; CharacterBuilder(string name, string job) { character.name = name; character.job = job; }public: // ... (흐름식 메서드들은 동일) ... CharacterBuilder&amp; WithWeapon(string weapon); CharacterBuilder&amp; WithArmor(string armor); CharacterBuilder&amp; WithShield(string shield); CharacterBuilder&amp; HasSpecialSkill(string skill); // ... // 빌더에서 Character로 암시적 변환을 허용할 수도 있음 operator Character() const { return character; } // 또는 명시적인 Build 메서드를 유지 Character Build() { return character; }};// 정적 메서드 구현inline CharacterBuilder Character::Create(string name, string job) { return CharacterBuilder(name, job);} 이제 사용자는 Character를 생성하기 위해 반드시 Create 메서드를 호출해야 함// 빌더 사용이 강제되는 APICharacter rogue = Character::Create(\"Rogue\", \"Thief\") .WithWeapon(\"Poisoned Dagger\") .HasSpecialSkill(\"Stealth\"); // operator Character() 덕분에 Build() 호출 생략 가능rogue.PrintStatus();심화: 복합 빌더 (Composite Builder)// 예시: 복합 빌더 구조// (실제 구현은 더 복잡하지만 개념을 보여주기 위함)class CharacterBuilder; // 메인 빌더 전방 선언// 스탯 빌더: 메인 빌더로 돌아갈 수 있는 참조를 가짐class CharacterStatBuilder{protected: Character&amp; character; // 빌드중인 캐릭터의 참조 CharacterBuilder&amp; mainBuilder; // 메인 빌더의 참조public: CharacterStatBuilder(Character&amp; character, CharacterBuilder&amp; builder) : character(character), mainBuilder(builder) {} CharacterStatBuilder&amp; Strength(int value) { /* 스탯 설정 로직 */ return *this; } CharacterStatBuilder&amp; Agility(int value) { /* 스탯 설정 로직 */ return *this; } // 이 빌더의 작업이 끝났음을 알리고 메인 빌더로 제어권을 넘김 CharacterBuilder&amp; Done() { return mainBuilder; }};// 장비 빌더 (유사한 구조)class CharacterEquipmentBuilder {protected: Character&amp; character; CharacterBuilder&amp; mainBuilder;public: CharacterEquipmentBuilder(Character&amp; character, CharacterBuilder&amp; builder) : character(character), mainBuilder(builder) {} CharacterEquipmentBuilder&amp; WithWeapon(string weapon) { character.weapon = weapon; return *this; } // ... 다른 장비 설정 ... CharacterBuilder&amp; Done() { return mainBuilder; }};// 메인 빌더class CharacterBuilder{private: Character character;public: // 생성자는 Character::Create()에서만 호출되도록 private으로 CharacterBuilder(string name, string job) { character.name = name; character.job = job; } friend class Character; // 하위 빌더로 전환하는 메서드 CharacterStatBuilder Stats() { return CharacterStatBuilder(character, *this); } CharacterEquipmentBuilder Equipment() { return CharacterEquipmentBuilder(character, *this); } Character Build() { return character; }};// 복합 빌더 사용 예Character bossMonster = Character::Create(\"Demon Lord\", \"Boss\") .Stats() // 스탯 빌더로 전환 .Strength(200) .Agility(80) .Done() // 다시 메인 빌더로 복귀 .Equipment() // 장비 빌더로 전환 .WithWeapon(\"Fallen Soul Blade\") .Done() // 다시 메인 빌더로 복귀 .Build();bossMonster.PrintStatus();" }, { "title": "의존성 역전 원칙", "url": "/posts/5.%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%97%AD%EC%A0%84-%EC%9B%90%EC%B9%99/", "categories": "디자인 패턴, SOLID", "tags": "design pattern", "date": "2023-04-18 00:00:00 +0900", "snippet": "의존성 역전 원칙(DPI)A. 상위 모듈이 하위 모듈에 종속성을 가져서는 안 된다. 양쪽 모두 추상화에 의존해야 한다. 이것이 기본적으로 의미하는 것은, 예를 들어 로깅 기능이라면, 로그 리포팅 컴포넌트가 실 구현체인 ConsoleLogger에 의존해서는 안되고 ILogger 인터페이스에만 의존해야 한다는 것이다. 이 경우 리포팅 컴포넌트를 상위 모듈로 취급하고, 반면에 로깅은 파일 입출력이나 스레드 처리에 중점을 두므로 하위 모듈로 취급한다. B. 추상화가 세부 사항에 의존해서는 안된다. 세부 사항이 추상화에 의존해야 한다. 이 부분 또한 종속성이 실 구현 타입이 아닌 인터페이스 또는 부모클래스에 있어야한다는 것을 의미한다. 이 원칙이 지켜지면 구성에 대한 설정이 편리해지고 모듈을 테스트하는 것도 쉬워진다. DPI가 지켜지도록 구현하기 위한 방법 위 두가지 요구사항 A,B가 기술하고 있는 것들을 명시적으로 코드로 나타내야 한다. 예를 들어 Reporting이라는 클래스가 ILogger에 의존해야 하는 코드를 아래와 같이 코드로 나타낼 수 있다. class Reporting{ ILogger&amp; logger;public: Reporting(const ILogger&amp; logger) : logger{logger} {} void prepare_report() { logger.log_info(\"Preparing the report\"); ... }}; 이 클래스를 인스턴스화하려면 구현 클래스를 호출해야 하는 문제가 있다. Reporting{ConsoleLogger{}} 이런 식으로 질문 만약 리포팅 클래스가 서로 다른 5개의 인터페이스를 사용해야 한다면 어떻게 될까? 만약 ConsoleLogger가 자체적으로 다른 종속성을 가지고 있다면 어떻게 해야할까? 위와 같은 문제를 해결하려면 많은 코드를 작성해야 하지만, 다행히 더 나은 방법이 있다. 해결책 의존성 역전 원칙을 구현하는 방법중 하나는 종속성 주입 테크닉을 활용하는 것이다. 종속성 주입은 Boost.DI와 같은 라이브러리를 이용해 어떤 컴포넌트의 종속성 요건이 자동적으로 만족되게 한다는 의미이기도 하다. 예시 자동차(Car)는 엔진(Engine)과 로그(Log) 기능이 필요하다고 할 때, 이 두 기능은 자동차가 의존성을 가진다. 엔진은 다음과 같이 정의할 수 있다.struct Engine{ float volume = 5; int horse_power = 400; friend ostream&amp; operator&amp; (osstream&amp; os, const Engine&amp; obj) { return os &lt;&lt; \"volume: \" &lt;&lt; obj.volume &lt;&lt; \"horse_power: \" &lt;&lt; obj_horse_power; }}; 이제 자동차가 엔진을 제공할 떄 IEngine 인터페이스를 따로 추출할지 말지, 선택에 달려있다. 이 부분은 설계 차원의 의사 결정 만약 엔진들이 어떤 계층을 이루거나, 테스트를 위한 NullEngine이 필요하다면 엔진을 추상화하여 IEngine 인터페이스를 따로 추출해야 한다. 로깅의 경우 여러 가지 방법으로(콘솔 출력, 이메일,핸드폰 SMS, 프린터 등)할 수 있으므로 ILogger 인터페이스를 두는 것이 좋다.struct ILogger{ virtual ~ILogger() {} virtual void Log(const string&amp; s) = 0;}; 이 인터페이스의 구현 클래스로 아래와 같이 ConsoleLogger가 있을 수 있다.struct ConsoleLogger : ILogger{ COnsoleLogger() {} void Log(const string&amp; s) override { cout &lt;&lt; \"Log: \" &lt;&lt; s.c_str() &lt;&lt; endl; }}; 정의할 자동차는 엔진과 로깅 두 컴포넌트 모두에 의존하므로 두 컴포넌트를 내부에서 접근할 수 있어야 한다. 이 부분은 포인터,레퍼런스,unique_ptr/shared_ptr 등 개발자의 자유다. 여기서는 unique_ptr/shared_ptr로 저장한다.struct Car{ unique_ptr&lt;Engine&gt; engine; shared_ptr&lt;ILogger&gt; logger; Car(unique_ptr&lt;Engine&gt; engine, const shared_ptr&lt;ILogger&gt;&amp; logger) : engine{move(engine)}, logger{logger} { logger-&gt;Log(\"making a car\"); } friend ostream operator&lt;&lt;(ostream&amp; os, const Car&amp; ojb) { return os &lt;&lt; \"car with engine: \" &lt;&lt; *obj.engine; }}; Car의 생성자에 make_unique/make_shared의 호출을 예상했겠지만, 종속성 주입에서는 그렇게 하지 않는다. 대신 Boost.DI를 이용한다. 먼저, ILogger를 ConsoleLogger에 연결하는 bind를 정의한다. 이 정의는 “누구든 ILogger를 요청하면 ConsoleLogger를 전달하라”를 의미한다. auto injector = di::make_injector( di::bind&lt;ILogger&gt;().to&lt;ConsoleLogger&gt;()); 이 코드로 Car를 생성하여 이용할 수 있다.auto car = injector.create&lt;shared_ptr&lt;Car&gt;&gt;(); 위 코드는 온전히 인스턴스화된 Car객체를 가리키는 shared_ptr&lt;Car&gt;를 만든다. 이러한 접근 방법의 가장 큰 장점은 사용할 ILogger 인스턴스의 타입을 바꿀 때 단 한 곳.즉, bind가 수행되는 부분만 수정하면 자동으로 ILogger를 사용하는 모든 곳에 적용된다는 점이다. 이러한 방식은 테스트도 쉽게할 수 있다. 단 한 줄만 수정하여 종속성이 있는 객체에 실제 동작하는 구현 객체를 사용할 수도 있고 테스트용 더미 객체를 사용하게 바꿀 수도 있다. DIP는 상위 모듈을 구체적인 구현이 아닌 추상화(인터페이스)에 종속적으로 만들어 하위 모듈에 대한 상위 모듈의 종속성을 줄이는 것을 목표이다. " }, { "title": "인터페이스 분리 원칙", "url": "/posts/4.%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-%EB%B6%84%EB%A6%AC-%EC%9B%90%EC%B9%99/", "categories": "디자인 패턴, SOLID", "tags": "design pattern", "date": "2023-04-18 00:00:00 +0900", "snippet": "인터페이스 분리 원칙(ISP) 밑에는 문제를 설명하기위한 목적의 예시 코드로, 복합 기능 프린터를 만들기로 했다. 프린터는 프린트,스캔,팩스 기능이 합쳐져 있어 다음과 같이 정의한다. struct MyFavouritePrinter{ void print(vector&lt;Document*&gt; docs) override; void fax(vector&lt;Document*&gt; docs) override; void scan(vector&lt;Document*&gt; docs) override;}; 이제 프린터의 구현을 하청 업체에 맡긴다고 가정한다. 하청 업체는 여러곳일 수도 있고, 각기 제품 라인업에 따라 기능 조합을 달리할 수 있다. 각 업체가 복합 기능 프린터를 구현할 수 있도록 아래와 같이 인터페이스를 추출 한다. struct IMachine{ virtual void print(vector&lt;Document*&gt; docs) = 0; virtual void fax(vector&lt;Document*&gt; docs) = 0; virtual void scan(vector&lt;Document*&gt; docs) = 0;}; 이렇게 작성할 때 문제가 발생한다. 어떤 업체는 스캔 기능이나 팩스 기능이 필요하지 않고 프린트만 만들고 싶은데 위의 인터페이스는 모든 기능을 구현하도록 강제한다. 물론 빈 함수를 만들어 대응할 수 있다. 하지만 이는 인터페이스 분리 원칙에 어긋난다. 인터페이스 분리 원칙은 필요에 따라 구현할 대상을 선별할 수 있도록 인터페이스를 별개로 두어야 한다는 것이다. 프린터와 스캐너는 서로 다른 동작이므로 인터페이스를 구분한다. // 프린트struct IPrinter{ virtual void print(vector&lt;Document*&gt; docs) = 0;};// 스캔 struct IScanner{ virtual void scan(vector&lt;Document*&gt; docs) = 0;};// 프린터와 스캐너를 기능적인 필요에 따라 따로 구현할 수 있다.struct Printer : IPrinter{ void print(vector&lt;Document*&gt; docs) override;};struct Scanner : IScanner{ void scan(vector&lt;Document*&gt; docs) override;};// 프린트와 스캔 기능 모두 가진 복합기의 인터페이스는 아래와 같다.struct IMachine : IPrinter, IScanner{}; 이제 복합기의 인터페이스를 구했으므로, 이 인터페이스로 복합기를 구현할 수 있다. IPrinter와 IScanner의 구현을 재활용하여 각각에 동작을 위임하는 방식으로 구현할 수 있다.struct Machine : IMachine{ IPrinter&amp; printer; IScanner&amp; scanner; Machine(IPrinter&amp; printer, IScanner&amp; scanner) : printer{printer}, scanner{scanner} {} void print(vector&lt;Document*&gt; docs) override { printer.print(docs); } void scan(vector&lt;Document*&gt; docs) override { scanner.scan(docs); } }; 다시한번 정리하면 한 덩어리의 복잡한 인터페이스를 목적에 따라 구분하여 나눔으로써, 인터페이스의 모든 항목에 대한 구현을 강제하지 않고 필요한 인터페이스만 구현할 수 있다. 만약 어떤 APP의 플러그인 모듈을 개발할 때 혼란스럽기만 한 수십개의 함수를 빈껍데기 or null 리턴으로 구현하고 있다면, 그 App의 플러그인 인터페이스 설계자는 LSP를 위반한 것이다. " }, { "title": "리스코프 치환 원칙", "url": "/posts/3.%EB%A6%AC%EC%8A%A4%EC%BD%94%ED%94%84-%EC%B9%98%ED%99%98-%EC%9B%90%EC%B9%99/", "categories": "디자인 패턴, SOLID", "tags": "design pattern", "date": "2023-04-18 00:00:00 +0900", "snippet": "리스코프 치환 원칙(LSP) 바바라 리스코프의 이름에서 유래한 원칙 이 원칙은 어떤 자식 객체에 접근할 때 그 부모 객체의 인터페이스로 접근하더라도 아무 문제가 없어야 한다는 것을 의미한다. 즉, 자식 객체를 그 부모 객체와 동등하게 취급할 수 있어야 한다. LSP가 준수되지 않는 경우(예시) 직사각형 클래스로, 가로/세로 길이에 대한 get/set 및 면적 계산을 위한 멤버함수를 가진다.class Rectangle{protected: int width, height;public: Rectangle(const int width, const int height) : width{width}, height{height} {} int get_width() const {return width;} virtual void set_width(const int width) {this-&gt;width = width;} int get_height() const {return height;} virtual void set_height(const int height) {this-&gt;height = height;} int area() const {return width * height;}}; 밑에는 Rectangle 클래스를 상속받는 정사각형의 클래스다. 이 객체는 가로/세로 get/set 함수 모두 오버라이딩 한다.class Square : public Rectangle{public: Square(int size) : Rectangle(size,size) {} void set_width(const int width) override{ this-&gt;width = height = width; } void set_height(const int height) override{ this-&gt;height = width = height; }}; 언뜻 보기에는 문제될 상황이 전혀 없어 보인다, 하지만 이러한 접근 방법은 문제를 일으킨다. 그러면 어떤 부분에 문제가 있을까? 멤버함수 set에서 가로세로값 모두 설정할 뿐이다. 여기서는 잘못될 일이 뭐가 있을까? 이 객체를 그 부모인 Rectangle 객체로서 접근하는 의도치 않은 상황이 생긴다. void process(Rectangle&amp; r){ int w = r.get_width(); /* r이 Rectangle의 파생클래스인 Square이라면 Square의 함수가 호출되어 가로 5 세로 10이 아닌 가로 10 세로 10이 되어 100이 출력된다. */ r.set_height(10); cout &lt;&lt; \"expected area = \" &lt;&lt; (w * 10) &lt;&lt; \" , got \" &lt;&lt; r.area() &lt;&lt; endl;}int main(){ Square s{5}; process(s); // 기대값 : 50, 결과값 : 100 return 0;} process의 인자의 타입은 Rectangle class로, 파생 클래스인 Square도 전달이 가능하다. set_height()함수가 Rectangle이 아닌 Square의 함수가 호출되어 기대값과 다르게 나와버렸다.해결책 위와 같은 상황을 해결하기 위한 방법은 여러가지 있다. 그중 하나는 서브 클래스를 만들지 않는 것이다. 서브 클래스를 만드는 대신 아래와 같은 Factory 클래스를 두어 직사각형과 정사각형 따로따로 생성한다.// 팩토리 디자인struct RectangleFactory{ static Rectangle create_rectangle(int w, int h); static Rectangle create_square(int size);};// 정사각형 여부를 확인하기 위해 Rectangle class에 함수를 추가한다.bool Rectangle::is_square() const{ return width == height;} LSP의 핵심은 자식 클래스가 항상 부모 클래스의 역할을 충실히 수행하는 것이다." }, { "title": "열림-닫힘 원칙", "url": "/posts/2.%EC%97%B4%EB%A6%BC-%EB%8B%AB%ED%9E%98-%EC%9B%90%EC%B9%99/", "categories": "디자인 패턴, SOLID", "tags": "design pattern", "date": "2023-04-18 00:00:00 +0900", "snippet": "열림-닫힘 원칙 (OCP) DataBase에 어떤 제품에 대한 정보가 저장되어 있다고 한다. 제품은 서로 다른 색상과 크기를 가지며 아래와 같이 정의된다.enum class Color { red, green, blue };enum class Size { small, medium, large };struct Product{ string name; Color color; Size size;}; 이제 주어진 제품 집합을 조건에 따라 필터링하는 기능을 아래와 같이 정의한다.struct ProductFilter{ typedef vector&lt;Product*&gt; Items;};// 색상과 관련하여 필터링Product::Items ProductFilter::by_color(Items items, Color color){ Items result; for(auto&amp; i :items) if(i-&gt;color == color) result.push_back(i); return result; }// 사이즈 관련 필터링Product::Items ProductFilter::by_size(Items items, Size size){ Items result; for(auto&amp; i :items) if(i-&gt;color == size) result.push_back(i); return result; } Color와 Size를 필터링하는 함수를 만들었지만 함수의 형태가 인자를 제외하고는 같다. 왜 범용적으로 임의의 조건(함수로 만들어진)을 지정받는 필터 함수로 만들지 않는가?의 대답은 필터 조건마다 처리 형태가 달라질 수 있기 때문이다. 위 필터를 만들고 나서는 이제 색상과 크기를 모두 지정하여 필터링하길 원한다. 그런데 아래와 같은 함수를 추가하는 것 말고는 다른 방법이 있을까? Product::Items ProductFilter::by_color_and_size(Items items, Size size, Color color){ Items result; for(auto&amp; i :items) if(i-&gt;color == size &amp;&amp; i-&gt;size == size) result.push_back(i); return result; } 이러한 시나리오에서 필요한 것이 열림-닫힘 원칙이다. 열림-닫힘 원칙은 타입이 확장에는 열려있지만 수정에는 닫혀 있도록 강제하는 것을 뜻한다. 즉, 기존 코드의 수정 없이 필터링을 확장할 수 있는 방법이 필요하다. 예시 위의 Product 클래스를 이어서 예시로 들자면 먼저, 필터링 절차를 개념적으로 두 개의 부분으로 나누어야 한다 (SRP 원칙을 적용) 첫 번째는 필터(항목 집합을 넘겨 받아 그 일부를 리턴) 두 번째는 명세(데이터 항목을 구분하기 위한 조건의 정의) 명세는 다음과 같이 정의할 수 있다.// 명세의 기본 인터페이스template &lt;typename T&gt;struct Specification{ virtual bool is_satisfied(T* item) = 0;}; 위 코드에서, 타입 T는 임의로 선택할 수 있다. 맥락상 T는 Product이지만 다른 타입도 가능하게 만들어, 이 부분이 전체적인 접근 방법을 재사용 가능하게 만든다. 다음은 Specification&lt;T&gt;에 기반하여 필터링을 수행할 함수 Filter&lt;T&gt;를 정의한다. // 필터의 기본 인터페이스template &lt;typename T&gt;struct Filter{ virtual vector&lt;T*&gt; filter( vector&lt;T*&gt; items, Specification&lt;T&gt;&amp; spec) = 0;}; 이 함수는 전체 항목 집합과 명세를 인자로 받아, 명세에 합치되는 항목들을 리턴한다. 여기서는 항목들이 vector&lt;T*&gt;에 저장된다고 가정하고 있다. 이제 Filter를 상속받는 파생 클래스를 만들어 개선된 필터의 제작이 가능하게 된다. // Product에 대한 Filterstruct BetterFilter : Filter&lt;Product&gt;{ virtual vector&lt;T*&gt; filter( vector&lt;T*&gt; items, Specification&lt;T&gt;&amp; spec) override { vector&lt;Product*&gt; result; for(auto&amp; p : items) result.push_back(p); return result; }}; 인자로 전달된 Specification&lt;T&gt;는 타입이 강하게 규정된 std::function이라고 볼 수 있다. 아래는 색상 필터에 대한 명세 ColorSpecification의 작성의 예이다. struct ColorSpecification : Specification&lt;Product&gt;{ Color color; explicit ColorSpecification(const Color color) : color{color} {} bool is_satisfied(Product* item) override { return item-&gt;color == color; }}; 이러한 명세를 활용하면 주어진 제품 목록을 다음과 같이 필터링할 수 있다.// 제품Product apple{\"Apple\", Color::Green, Size::Small};Product tree {\"Tree\" , Color::Green, Size::Large};Product house{\"House\", Color::Blue, Size::Large};// 필터에 사용할 vector 변수vector&lt;Product*&gt; all{&amp;apple, &amp;tree, &amp;house};// 초록색 명세BetterFilter bf;ColorSpecification green(Color::Green); auto green_things = bf.filter(all,green);for(auto&amp; x : green_things) cout &lt;&lt; x-&gt;name &lt;&lt; \"is green\" &lt;&lt; endl;// 사과와 나무를 초록색 제품으로 필터링한다. 이러한 방식에서 크기와 색상을 동시에 필터링 하는 경우는 어떻게 만들 수 있을까? 그것은 AND 논리 연산을 사용하는 복합 명세로 만들면 된다. template &lt;typename T&gt;struct AndSpecification : Specification&lt;T&gt;{ Specification&lt;T&gt;&amp; first; // 명세1 Specification&lt;T&gt;&amp; second; // 명세2 // 생성자에서 사용할 명세들을 등록 AndSpecification(Specification&lt;T&gt;&amp; first, Specification&lt;T&gt;&amp; second) : first {first}, second{second}{} bool is_satisfied(T* item) override { // item이 두 명세의 조건에 맞으면 true를 반환 return first.is_satisfied(item) &amp;&amp; second.is_satisfied(item); }}; 단순한 Specfication을 연결하여 복합 조건을 얼마든지 만들 수 있다. 앞서 만든 green 명세를 재활용하고 위의 AND 복합 명세를 이용하여 “큰 크기”를 추가 조건으로도 넣을 수 있다.SizeSpecification large(Size::Large); // 크기 명세ColorSpecification green(Color::Green); // 색상 명세AndSpecification&lt;Product&gt; green_and_large{large,green}; // Green,Large 명세auto big_green_things = bf.filter(all, green_and_big);for (auto&amp; x : big_green_things) cout &lt;&lt; x-&gt;name &lt;&lt; \" is large and green\" &lt;&lt; endl;// 출력: Tree is large and green 두 필터를 사용했을 뿐인데, 적지 않은 코드를 작성해야 한다. 하지만 C++의 강력한 연산자 오버로딩을 이용하면 더 단순해진다. &amp;&amp;연산자를 적용하면 두 개 이상의 Specification&lt;T&gt; 객체를 대단히 쉽게 복합 명세로 엮을 수 있다.// 1. Specification 안에 연산자를 추가할 수도 있지만 나중에 추가하게 되면 OCP를 위배하게 된다.template &lt;typename T&gt;struct Specification{ virtual bool is_satisfied(T* item) = 0; // 나중에 추가하게 되면 OCP를 위배하게 됨 // AndSpecification&lt;T&gt; operator &amp;&amp;(Specification&amp;&amp; other) // { // return AndSpecification&lt;T&gt;(*this,other); // }};// 2. 그래서 전역으로 연산자를 선언한다.template &lt;typename T&gt;AndSpecification&lt;T&gt; operator&amp;&amp; (Specification&lt;T&gt;&amp;&amp; first, Specification&lt;T&gt;&amp;&amp; second){ return { first, second };} 다음과 같이 한줄 코드로도 만들 수 있다.auto green_and_big = ColorSpecification(Color::Green) &amp;&amp; SizeSpecification(Size::Large);위의 예에서 OCP 원칙이 어떻게 강제되고 있을까? Specification&lt;T&gt;와 Filter&lt;T&gt;를 만들었기 때문에 인터페이스 자체에는 전혀 손을 대지 않고도 파생 인터페이스의 구현을 통해 새로운 필터링 방식을 추가할 수 있었다. 이것이 확장에는 열려 있지만 수정에는 닫혀 있다의 의미다. " }, { "title": "단일 책임 원칙", "url": "/posts/1.%EB%8B%A8%EC%9D%BC-%EC%B1%85%EC%9E%84-%EC%9B%90%EC%B9%99/", "categories": "디자인 패턴, SOLID", "tags": "design pattern", "date": "2023-04-18 00:00:00 +0900", "snippet": "단일 책임 원칙 (SRP) 클래스로 메모장을 만들기로 하려 한다. 이 메모장에는 제목 하나에 여러 항목이 저장될 수 있도록 만들 것이다. 이러한 기능은 다음과 같이 모델링 될 수 있다. struct Journal{ string title; vector&lt;string&gt; entries; explicit Journal(const string&amp; title) : title{title} {}}; 이제 메모장의 각 항목이 기입된 순서대로 저장되게 하는 기능을 만들면 된다. void Journal::add(const string&amp; entry){ static int count = 1; entries.push_back(boost:lexical_cast&lt;string&gt;(count++) + \": \" + entry);} boost::lexical_cast는 boost 라이브러리에 존재하는 형변환 템플릿 이제 다음과 같이 메모장을 만들 수 있다. Journal j{\"Dear Diary\"};j.add(\"I cried today\"); 이 함수는 각 항목을 기록할 수 있게 하고 관리할 책임이 메모장에 있기 때문에 Journal 클래스에 있는 것이 타당하다. 이제 메모장을 영구적으로 파일에 저장하는 기능을 만들려고 한다. void Journal::save(const string&amp; filename){ ofstream ofs(filename); for (auto&amp; : entries) ofs &lt;&lt; s &lt;&lt; endl;} 그런데 메모장은 메모 항목들을 기입/관리하는 것이지 디스크에 쓰는 것이 아니기 때문에 이러한 방식은 문제가 있다. 만약 메모장 클래스가 디스크에 파일을 쓰는 기능을 책임지도록 한다면 데이터 저장 방식이 바뀔때마다그러한 클래스들은 일일이 모두 수정해야한다 위와 같이 작은 수정을 여러 클래스에 걸쳐서 해야 한다면 아키텍처에 뭔가 문제가 있다는 징조다. 단일 책임 원칙이 의미하는 바가 바로 이러한 것이다. 각 클래스는 단 한 가지의 책임을 부여받아, 수정할 이유가 단 한가지여야 한다. 만약 메모장의 각 항목에 대해 수정사항이 생겼다면 Journal 클래스를 수정해야 하고,저장 방식을 바꾸어야 하기 위해서는 파일을 저장하는 클래스를 수정해야 한다. 아래 코드는 Journal 클래스를 저장하기 위한 별도의 구조체(클래스)이다. struct PersistenceManager{ static void save(const Journal&amp; j, const string&amp; filename) { ofstream ofs(filename); for (auto&amp; s : j.entries) ofs &lt;&lt; s &lt;&lt; endl; }}; " }, { "title": "메모리 관리", "url": "/posts/%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC/", "categories": "윈도우즈시스템프로그래밍, 운영체제", "tags": "windows", "date": "2023-04-17 00:00:00 +0900", "snippet": "가상 메모리(Virtual Memory) 컨트롤 CPU 관점에서 보는 메모리는 물리 메모리 CPU와 프로그래머가 바라보는 메모리는 같은 메모리로, 32bit면 4GB의 메모리 4GB라는 가상 메모리가 있고 실제 메모리는 별도로 존재해면서 가상 메모리와 매핑되는 구조를 가지고 있다. 가상 메모리의 Commit, Free와 물리메모리의 관계 가상 메모리는 페이지 단위로 나눠진다 페이지의 개수는 가상 메모리의 크기/ 페이지 하나당의 크기 페이지는 윈도우상에서 가상 메모리로, 실제로 컨트롤하는 객체는 운영체제이다. 윈도우즈는 가상 메모리(페이지)를 관리할 때 특성 정보를 부여한다.특성 정보 Commit 상태 이 가상메모리는 물리적인 메모리가 할당되었음을 의미 대표적인 예는 malloc() 함수로,호출하면 이 페이지를 물리 메모리와 맵핑시키겠다는 의미이다. free함수를 사용해서 반환하면 그 페이지는 Free 상태가 되면서 물리 메모리와의 연결을 끊는다 Free 상태 초기 상태로, 이 가상메모리는 물리 메모리와 연결되지 않은 비어있는 메모리. Reserve 상태 메모리를 Commit과 Free로만 관리하니 메모리 효율이 비효율적이라 나온것이 Reserve 상태이다 Windows에서만 사용한다. Reserve 상태의 필요성 예시로 평소에는 100정도의 메모리를 사용하는 프로그램이 어떤 경우에 10000의 메모리를 요구하는 매일 실행되는 프로그램이 있다고 가정한다. 그러면 그 메모리를 평소정도인 100이 아닌, 10000도 포함할 수 있게 할당해야 해서 10000을 배열의 크기로 잡을 것이다. 그 어떠한 경우를 위해 10000의 메모리 크기를 부여하는것은 매우 비효율적이다. 위 그림에서 COMMIT 상태의 페이지 5개가 있는데 페이지0,1만 사용한다면 페이지 2,3,4는 할당받은 상태로 아무것도 하지 않아 다른 메모리에서 사용할 수가 없다. 그러면서 물리 메모리와의 연결도 돼 있기 때문에 더 문제이다. 페이지1,2만 잡아놓고 나중에 추가적으로 받으면 되는 것이라고 생각할 수도 있겠지만, 앞에 처럼 만들면 가상메모리상에서의 연결된 메모리 구성이 아니게 된다. 이런 상태를 막기위해 Reserve상태를 사용한다. Reserve는 “예약”이라는 뜻으로,다른 곳에서 Reserve 공간을 할당하려할 때 할당을 허용하지 않는다. 그러면서 RESERVE상태는 COMMIT 상태가 아니면 물리적인 메모리와의 맵핑도 되지 않는다. 쉽게 말하면 나중에 사용할 수도 있으니 접근 X 메모리 할당의 시작점과 단위 확인 평소에는 Free상태로 있다가 Commit 또는 Reserve로 바꿀수 있는데 페이지 중간부터 상태를 바꿀 수가 없다. OS는 페이지 단위로 관리하기 때문에 메모리를 할당하기 위해선 기준인 최소단위가 있다. 최소 단위는 Allocation Granularity Boundary 기준. 메모리 할당의 시작점을 의미한다. 페이지 크기의 몇 배수: 지나친 단편화를 막기 위해. 홀수 번지마다 할당 가능하다면 A B A B 이런 식은 불가능하다. 하지만 A A B B 는 가능하다.메모리 관리측면에서 편해지고 단편화가 해결된다 할당할 메모리의 크기 최소 1페이지 이상 페이지 중간에 할당하는 것을 막기 위해 설정 GetSystemInfo(&amp;si) // SYSTEM_INFO pageSize = si.dwPageSize // 페이지 사이즈 allocGranularity = si.dwAllocationGranularity // 메모리 할당 시작점을 어떻게 잡을지 dwPageSize는 4K일 경우 dwAllocationGranularity 64K 페이지 사이즈가 4KB이면 Allocation Granularity Boundary는 64KB. 그럼 우리는 64KB 번지를 시작으로 4KB 만큼 메모리 할당 요청 가능. 그 다음은 128KB 번지를 시작으로 4KB만큼 메모리 할당 요청 가능. // malloc()과 유사하다.// malloc()은 힙 메모리,VirtualAlloc는 가상 메모리(가상 메모리도 힙메모리)// malloc()은 COMMIT/FREE 상태만 가능하지만 아래 함수는 RESERVE 상태도 가능하다..LPVOID VirtualAlloc( LPVOID lpAddress, // 할당의 시작 주소. SIZE_T dwSize, // 할당의 크기 DWORD flAllocationType, // MEM_RESERVE(거의 쓸일 X) or MEM_COMMIT DWORD flProtect // PAGE_NOACCESS or PAGE_READWRITE); // 반환: 할당이 이뤄진 메모리의 시작번지// VirtualFree()는 COMMIT 상태를 FREE 상태로 끌어내리기도 하지만,// RESERVE 상태를 FREE 상태로 끌어내리기도 함.(잘 안씀)// 또한 COMMIT 상태를 RESERVE상태로 끌어내리기도 한다.// 결국 아래 함수는 할당 받은 가상 메모리 공간을 반환하는데 의의가 큼.BOOL VirtualFree( LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType // MEM_DECOMMIT(COMMIT-&gt;RESERVE) or MEM_RELEASE);힙 컨트롤디폴트힙 규칙적이지도 않고, 그 크기도 결정되어 있지 않은 경우에는 List 자료구조로 구현한다. List 자료구조는 지울 때 메모리를 반환할 때 일일이 방문해서 전부 지워줘야 한다. 그렇기 때문에 에러 발생 확률이 높다. 위의 예에선 하나의 Heap안에 홍길동과 최대수를 위한 데이터가 같이 존재하기 때문에 최대수의 데이터만 지우려면 일일이 최대수의 데이터를 방문하고 지워주는데 이 때 에러가 발생할 확률이 높아진다. 힙을 만들면 Windows가 기본적으로 제공해주는 Heap을 디폴트 힙이라 한다. 초기 크기가 정해져 있고 늘어날 수도 있다. Windows는 디폴트 힙이외에 힙을 더 만들 수 있게 해주는데 그것이 힙 컨트롤이다. 컨트롤 힙 위에 홍길동을 위한 힙 A와 최대수를 위한 힙 B이 있다. 최대수의 데이터를 지우려면 한번의 함수 호출로 힙B를 삭제시켜버리면 된다. Dynamic Heap이라는 기법이 제공함 가상 메모리 컨트롤은 예약이 주요 관점으로, 메모리를 효율적으로 사용하기 위해서 Dynamic Heap은 메모리 효율성보다는 데이터를 분리(관리)하겠다는 측면이 강하다. Virtual Memory는 스택,힙,데이터, 그 외의 메모리 공간이 있는데 그 외의 메모리 공간에 힙 메모리 공간에 추가로 할당할 수 있다. 이 행동을 힙으로 볼지, 가상 메모리 일부를 다른 용도로 사용하는지는 관점에 따라 다름 그런데 힙 메모리는 할당 및 결정이 Runtime 때 이뤄진다. 가상 메모리의 힙 할당도 Runtime 때 받기 때문에 힙으로도 볼 수 있다.Dynamic Heap의 이점 메모리 단편화 해소 프로그램의 로컬리티가 낮아지는 문제점 발생할 수 있음 동적 힙을 사용하면, 관련된 데이터들만 빈틈없이 연속적으로 배치할 수 있음. 동기화 문제에서 자유 쓰레드 별로 힙을 생성할 수 있는데, 동시에 같은 메모리를 할당할 수 있으므로 다른 쓰레드의 접근을 막는다. 그림의 왼쪽처럼 별도의 힙을 구성한다면, 쓰레드별로 힙을 생성해서 동기화 문제를 막을 수 있음 Dynamic Heap 생성 및 할당 힙의 생성 및 소멸 HeapCreate(): 힙의 생성 디폴트 힙이 아닌 외부의 메모리 공간에서 힙 생성할 때 사용하는 함수 HeapDestroy(): 힙의 소멸. 위 그림에서 힙B처럼 모든 메모리가 한꺼번에 날아간다. 생성된 힙 내의 메모리 할당 및 해제 HeapAlloc(): 힙 내에 메모리 할당. HeapCreate()시에 반환되는 힙 핸들을 이용. HeapFree(): 힙 내에 메모리 반환 malloc()/free()는 디폴트 힙에 할당하고 반환 MMF(Memory Mapped File)1번 그림2번 그림 File의 일부 메모리를 프로세스의 가상메모리에 연결시킨다. (1번) 연결 후, 프로세스의 가상 메모리에 데이터를 저장하면 그 파일에 반영된다 (2번) 이 때 위치(오프셋)도 적용됨, 그림에서 보면 색깔 부분으로 구분되어 있음. MMF의 개념 파일에 저장되어 있는 기능을 정렬하려면, 전부 메인메모리에 올려 정렬하고 다시 파일에 저장해야 한다. MMF를 사용하면 메모리가 파일에 Mapping 돼 있으니까 메인 메모리에서 정렬하면 알아서 적용된다. MMF의 장점 데이터를 메모리에 Write하기 때문에 가장 최신 데이터도 메모리에 있다. 그래서 read할 때 File이 아닌 메모리에서 Read하면 된다. 일단 메모리에 Write,Read하기 때문에 File에 저장하는건 주기적 or 특정 이벤트 발생했을 때만 해도 된다. 즉, 빈번한 I/O가 발생하는 곳은 가장 최근 데이터를 유지하고, 데이터를 저장할 수 있는 상황이 보장된다면 주기적,상황적으로 저장해도 된다. 결국 File에 있는 Data를 메모리가 Cash역할을 해주고 있는 것. MMF 구현과정 1단계: 파일의 생성 HANDLE hFile = CreateFile(…); 2단계: 파일 연결 오브젝트 생성 HANDLE hMapFIle = CreateFileMapping(hFile, …); 파일 만들고 바로 메모리와 매핑시키는게 아니다. 매핑을 시킬 수 있도록 파일 정보를 담은 오브젝트를 만들어야 한다. 파일 매핑을 위한 연결 오브젝트라고도 함. 이 오브젝트를 통해서 OS에게 “이 파일의 이부분을 매핑 시켜주세요.”라고 요청. 3단계: 가상 메모리에 파일 연결 TCHAR* pWrite = (TCHAR*)MapViewOfFile(hMapFile, …); 실질적으로 파일과 메모리의 어디서부터 어디까지를 매핑 진행 요청. 이제 pWrite 부터 원하는 위치까지 포인터 연산을 통해서 접근하면 된다. ptr to char이기 때문에 1byte 마다 접근 가능. ptr ro int로 바뀌면 4byte 단위 마다 접근 가능. " }, { "title": "비동기 I/O와 APC", "url": "/posts/%EB%B9%84%EB%8F%99%EA%B8%B0-I-O%EC%99%80-APC/", "categories": "윈도우즈시스템프로그래밍, 운영체제", "tags": "windows", "date": "2023-04-17 00:00:00 +0900", "snippet": "I/O와 CPU 클럭의 관계 일반적으로 CPU 클럭이 높으면 높은 퍼포먼스를 보여준다. I/O도 일반적으로 CPU 클럭이 높으면 빨라지긴 하지만, I/O의 속도는 버스 클럭에 좀 더 의존적이다. CPU 클럭과 I/O의 관계 생성된(받아온) 데이터를 가공해서 목적지까지 보내야하는 시스템 A,B가 있다고 가정한다. A의 클럭은 100이고 B의 클럭은 200이라고 한다면, 일반적으로 B의 I/O가 더 빠르다고 생각하지만 그렇지 않다. I/O라고 한다면 대상은 파일,네트워크,콘솔이든 버퍼링을 한다. 버퍼링을 한다는 것은 버퍼가 있다는 것을 의미 버퍼를 둔 이유는 데이터를 한번에 모아서 보내는게 빠르기 때문에 존재함 버퍼는 비우는 방법은 프로그래머가 결정할 수 있다. 시스템 A,B는 10클럭마다 버퍼를 비우는 동작을 한다면, A는 10번 B는 20번 버퍼를 비운다. 시스템은 기본적으로 일정량의 데이터(예를들어 A,B)를 버퍼에 쌓여야 통신 프로토콜이 작동한다고 한다면, 시스템A는 속도가 느리기 때문에 버퍼에 A,B가 차고 나서 보내는 통신 프로토콜이 한사이클로 작동하지만, 시스템B는 속도가 빠르기 때문에 버퍼에 B가 오기도 전에 A를 보내는 경우도 생겨버려서 I/O에서는 오히려 시스템A보다 느려질 수 있다. 만약,목적지가 외부인 네트워크 통신이라면 이러한 프로토콜을 활용한다는 것은 더 부담스러운 일이다. 아무리 클럭속도가 빠를지라도, 외부와의 네트워크 프로토콜을 주고 받는 시간을 줄일 수 없기 때문. 즉, I/O는 CPU 클럭과 관계가 상당히 작다. 비동기 I/O의 이해동기화 I/O 함수가 호출되는 순간 데이터를 전송하고, 함수가 반환되는 순간 전송이 끝나는 함수가 있다고 한다면 함수의 호출과 데이터 전송이 동기화, 함수의 반환과 전송의 끝이 동기화가 되어있는 이러한 게 동기화 I/O를 의미한다. 동기화 I/O는 데이터 전송이 끝날 때까지 반환하지 않아, 그 시간동안 다른 할 일이 있음에도 불구하고 다른 일을 할 수 없다는 것이 특징이다. 왼쪽의 그래프를 보면 아래에 있을 때는 CPU가 Blocking 상태로, CPU를 원활하게 사용하지 못하는 프로그램비동기화 I/O 동기화 I/O처럼 함수가 호출되는 순간 데이터를 전송하는 것은 동일하지만, 반환 되는 시점이 전송의 끝을 의미하지 않는다. 비동기화 I/O는 함수가 호출되자마자 반환이 이뤄지고 나서, 내부적으로 데이터 전송이 진행되는 것이 특징 반환이 되었다는 것은 다른 할 일을 할 수 있다는 것을 의미한다. 아무리 반환했다고 할지라도, 내부적으로 데이터 전송이 진행되는데 다른 것을 할 수 있나라고 생각할 수 있는데 가능하다. 왜냐하면 I/O 연산은 CPU의 도움을 많이 받지 않기 때문이다. I/O를 담당하는 모듈과 연산을 담당하는 CPU는 역할이 나뉘어져 있기 때문에 도움이 필요하긴 하지만 의존도가 상당히 낮다. 왼쪽의 그래프는 CPU 사용률이 너무 높지않고 계속 사용되는 형태로, CPU를 원활하게 사용하는 프로그램비동기 I/O의 종류 중첩 I/O(Overlapped I/O)와 완료루틴 I/O(Completion Routine)가 있다.중첩 I/O (Overlapped I/O) 위 그림에서는 처음에 Read함수가 호출되면서(화살표가 함수호출을 의미) 데이터수신이 일어나자마자 반환하면서 곧바로 다시 Read함수를 호출하는 상황이 4번의 I/O가 중첩되고 있다. I/O를 중첩시키면 좋은 이유 CPU연산이 I/O 연산보다 훨씬 빠르다. 그래서 CPU는 I/O연산을 하면서 많이 기다린다. 그 시간에 차라리 더욱 많은 I/O를 중첩시켜서 기다리는 시간을 줄이는 것이 좋다. I/O 연산이 끝나면 그에 따른 부가적인 작업을 처리해줘야 하는데 I/O마다 부가적인 작업이 달라 확인하고 분류하는 작업이 부담스럽다. 그래서 나온 것이 완료 루틴 I/O이다. 완료루틴 I/O (Completion Routine) 각 I/O가 끝나면서 해야할 루틴을 묶는 것이 가능한 것이 완료루틴 I/O 여기서 루틴은 함수를 의미 I/O연산이 끝났을 때 그 I/O가 해야하는 부가작업을 확인하는 연산을 하지 않아도 된다. 중첩 I/O 구현 모델 중첩 I/O를 구현할 때는 WriteFile함수를 사용하면 된다. WriteFile 함수에 Overlapped 구조체를 받는 인자가 있다. Overlapped는 I/O를 중첩하겠다는 의미와 관련 정보도 담을수 있다는 것을 의미한다. typedef struct _OVERLAPPED { ULONG_PTR Internal; ULONG_PTR InternalHigh; union { struct { DWORD Offset; DWORD OffsetHigh; }; }; HANDLE hEvent;} OVERLAPPED; 위 코드의 Overlapped 구조체의 변수중 hEvent를 사용해 I/O가 끝났는지를 확인할 수 있다. Internal 변수들은 내부적으로 사용하는 값들 Offset과 OffsetHigh는 파일을 이동하는데 사용되는 함수 Overlapped 구조체를 초기화하는 방법은 전체 초기화한 후에 이벤트 오브젝트를 생성해서 hEvent에 저장시켜주면 됨 Overlapped 구조체를 초기화한 상태에서 WriteFile함수를 호출하는데 대상이 되는 I/O의 핸들 정보를 넘겨줘야 한다. 위 그림에서는 Pipe의 핸들을 넘겨주고 있음 Overlapped 구조체와 I/O핸들을 넘겨준 WriteFile함수를 호출하면서 비동기 I/O가 실행되고, I/O 연산이 끝나면 자동적으로 Event가 Signaled 상태로 변경된다. 위의 과정이 중첩 I/O의 기본 틀 완료루틴 I/O 구현 모델 중첩 I/O와 다르게 완료 루틴이라는 것이 존재한다. 완료루틴 : I/O가 끝나면 루틴(함수)을 실행 완료루틴 I/O은 중첩I/O 모델에서 완료루틴을 추가한 것이 전부 WriteFileEx()라는 함수는 WriteFile()과 다르게 완료루틴을 인자로 받는다 위 그림에서 WriteFileEx()는 Completionm Routine을 인자로 받으면서 I/O와 연결해주는 역할을 한다 I/O가 끝나면서 Completionm Routine이 실행되기 때문에 Overlapped 구조체의 이벤트 오브젝트 핸들이 필요없어진다. Event를 제외한 나머지 변수들은 사용되기 때문에 Overlapped 구조체는 넘겨야함. BOOL WriteFileEx( HANDLE hFile, // handle to output file. LPCVOID lpBuffer, // data buffer. DWORD nNumberOfBytesToWrite, // number of bytes to write. LPOVERLAPPED lpOverlapped, // overlapped buffer LPOVERLAPPED_COMPLETION_ROUTIME lpCompletionRoutine // completion routine)// Windows에 의해서 자동적으로 호출되는 CallBack 함수.// 인자들은 프로그래머가 아닌 Windows에서 자동으로 전달한다.VOID CALLBACK FileIOCompletionRoutine( DWORD dwErrorCode, // completion code. 무슨 에러가 발생했는지 DWORD dwNumberOfBytesTransfered, // number of bytes transferred. 몇 바이트가 전송되었는지 LPOVERLAPPED lpOverlapped // IO Information buffer. 내가 전달한 OVERLAPPED 구조체를 다시 전달);알림 가능한 상태(Alertable State) 어떠한 I/O와 임의의 Completion Routine를 연결했다고 가정한다면 비동기 I/O이기 때문에 CPU 연산과 동일하게 진행되는데, I/O가 끝나는 시점에 Completion Routine으로 진입해야 하면서 일의 우선순위가 CPU연산이 아닌 Completion Routine에 뺏기는 상황이 와버린다. 기존 작업이 더 진행이 되고 나서야 Completion Routine이 호출되는 상황이 더욱 좋은 상황이 있을 수도 있기 때문에 Completion Routine의 우선순위를 낮추는 것이 가능해야 안정적으로 디자인이 가능하다. 그러한 것을 해결하기 위한 것이 Alertable State 알림 가능한 상태 진입을 위한 함수 3가지 DWORD SleepEx( DWORD dwMilliseconds, // time-out interval BOOL bAlertable // true 전달 시 Alertable State);DWORD WaitForSingleObjectEx(...);DWORD WaitForMultipleObjectsEx(...);APC(Asynchronous Procedure Call) 모든 쓰레드는 자신만의 APC Queue를 소유하고 있다. APC Queue 해당 쓰레드가 알람 가능한 상태가 됐을 때 호출할 CallBack 함수를 모아놓은 Queue Alertable State가 들어가면 APC Queue에 들어간 모든 Callback함수들이 실행된다. WriteFileEx() 함수의 경우, I/O 완료시 APC Queue에 함수 정보를 입력해준다." }, { "title": "디자인 패턴에 사용될 C++ 개념", "url": "/posts/%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4%EC%97%90-%EC%82%AC%EC%9A%A9%EB%90%A0-C++-%EA%B0%9C%EB%85%90/", "categories": "디자인 패턴", "tags": "design pattern", "date": "2023-04-17 00:00:00 +0900", "snippet": "이상한 재귀 탬플릿 패턴(CRTP) Curious Recurring Template Pattern, CRTP라고도 부른다. 자기 자신을 베이스 클래스의 템플릿 인자로 상속받는 패턴 struct Foo : SomeBase&lt;Foo&gt;{ ....}; 이 방식의 장점은 베이스 클래스의 구현부에서 타입이 지정된 this 포인터를 사용할 수 있는 것이다. SomeBase를 상속받는 모든 서브 클래스들에 begin() 메서드를 구현한다고 가정해보자. SomeBase의 메서드 안에서 서브 클래스의 객체를 순회할 방법이 있을까? 부모 클래스인 SomeBase에 begin()/end() 인터페이스가 정의되어 있지 않는 한 불가능하다. 하지만 CRTP를 적용하면 this를 서브 클래스 타입으로 캐스팅할 수 있다. CRTP 기반 클래스에서 파생 클래스의 이름을 사용할 수 있으며, 가상함수(virtual) 없이 가상 함수를 override 한 것과 같은 효과를 볼 수 있다. 가상함수를 호출하는 데에 많은 오버헤드 비용(동적 다형성의 비용)이 발생하게 되는데 해당 비용을 없앨 수 있다 template&lt;typename Derived&gt;struct SomeBase{public: void foo() { auto&amp; check = *static_cast&lt;Derived*&gt;(this); check.Begin(); } void Begin() { cout &lt;&lt; \"SomeBase\" &lt;&lt; endl; }};struct Foo : public SomeBase&lt;Foo&gt;{public: void Begin() { cout &lt;&lt; \"Foo\" &lt;&lt; endl; }};int main(){ Foo a; a.foo();\treturn 0;}결과/*Foo*/첨가(Mixin) 상속 C++는 클래스를 정의할 때 자기 자신을 템플릿 인자로 할 수 있다.template &lt;typename T&gt;struct Mixin : T{ ...}; 이러한 방식을 첨가 상속(mixin inheritance) 라고 한다 is-a 관계를 완전히 구현하지 않고도 기능을 추가할 때 사용한다. 첨가 상속을 이용하면 계층적으로 여러 타입을 합성할 수 있다. #include &lt;iostream&gt;using namespace std;struct Number {\ttypedef int value_type;\tint n;\t void set(int v) { \t\tn = v; \t} \tint get() const { \treturn n; }};template &lt;typename BASE, typename T = typename BASE::value_type&gt;struct Undoable : BASE { \ttypedef T value_type; \tT before; \tvoid set(T v) { \tbefore = BASE::get(); BASE::set(v); } \tvoid undo() { \t\tBASE::set(before); \t}};template &lt;typename BASE, typename T = typename BASE::value_type&gt;struct Redoable : BASE { typedef T value_type; T after; void set(T v) { \tafter = v; BASE::set(v); \t} void redo() { \tBASE::set(after); }};typedef Redoable&lt; Undoable&lt;Number&gt; &gt; ReUndoableNumber;int main() { ReUndoableNumber mynum; mynum.set(42); mynum.set(84); cout &lt;&lt; mynum.get() &lt;&lt; '\\n'; // 84 mynum.undo(); cout &lt;&lt; mynum.get() &lt;&lt; '\\n'; // 42 mynum.redo(); cout &lt;&lt; mynum.get() &lt;&lt; '\\n'; // back to 84} ReUndoableNumber의 원형인 Redoable&lt;Undoable&lt;Number&gt;&gt;와 같이 새로운 타입을 따로 구현하지 않고도 세 가지 타입의 속성을 지니게 할 수 있다. 장점 컴파일 타임에 컴파일된 클래스 유형을 알고있기 때문에 가상함수는 필요 없다. 단점 보다시피 직관적인 접근 방법을 제공하지 않는다. https://stackoverflow.com/questions/18773367/what-are-mixins-as-a-concept 참고.속성 get/set메서드를 가지는 클래스 내부 변수(보통 private으로 선언되는)를 보통 그 클래스의 속성이라 부른다. C++은 다른 언어들과 달리 속성을 언어 자체의 내장기능으로 제공하지 않는다. 그럼에도 대부분의 컴파일러(MSVC, Clang, Intel)에서 비표준적인 방법으로 지원하고 있다. class Person{public: int age;public: int get_age() const { return age; } void set_age(int value) { age = value; } __declspec(property(get = get_age, put = set_age)) int age;};int main(){ Person person; person.age = 20; // calls p.set_age(20) return 0;}" }, { "title": "객체 지향 5원칙", "url": "/posts/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-5%EC%9B%90%EC%B9%99-(SOLID)/", "categories": "디자인 패턴, SOLID", "tags": "design pattern", "date": "2023-04-17 00:00:00 +0900", "snippet": "SOLID 디자인 원칙 SOLID는 다음과 같이 디자인 원칙들의 앞글자를 따서 만든 약어이다. 단일 책임 원칙 (Single Responsibility Principle, SRP) 모든 클래스는 각각 하나의 책임만 가져야 한다. 클래스는 그 책임을 완전히 캡슐화해야 함을 말한다. 열림-닫힘 원칙 (Open-Closed Principle, OCP) 확장에는 열려있고 수정에는 닫혀있는. 기존의 코드를 변경하지 않으면서( Closed), 기능을 추가할 수 있도록(Open) 설계가 되어야 한다는 원칙을 말한다. 리스코프 치환 원칙(Liskov Substitution Principle, LSP) 자식 클래스는 언제나 자신의 부모 클래스를 대체할 수 있다는 원칙이다. 즉 부모 클래스가 들어갈 자리에 자식 클래스를 넣어도 계획대로 잘 작동해야 한다. 인터페이스 분리 원칙(Interface Segregation Principle, ISP) 한 클래스는 자신이 사용하지않는 인터페이스는 구현하지 말아야 한다. 하나의 일반적인 인터페이스보다 여러개의 구체적인 인터페이스가 낫다. 의존성 역전 원칙(Dependency Inversion Principle, DIP) 의존 관계를 맺을 때 변화하기 쉬운 것 또는 자주 변화하는 것보다는 변화하기 어려운 것, 거의 변화가 없는 것에 의존하라는 것이다. 한마디로 구체적인 클래스보다 인터페이스나 추상 클래스와 관계를 맺으라는 것이다. " }, { "title": "파일 I/O와 디렉터리 컨트롤", "url": "/posts/%ED%8C%8C%EC%9D%BC-I-O%EC%99%80-%EB%94%94%EB%A0%89%ED%84%B0%EB%A6%AC-%EC%BB%A8%ED%8A%B8%EB%A1%A4/", "categories": "윈도우즈시스템프로그래밍, 운영체제", "tags": "windows", "date": "2023-04-16 00:00:00 +0900", "snippet": "파일 I/O와 디렉터리 컨트롤 ANSI에서 파일 I/O에 대해 정의하고 있다. 파일 I/O에 관련된 ANSI 표준 함수를 사용하면 플랫폼(윈도우,리눅스등)과 의존하지 않고 작업할 수 있다. ANSI가 이러한 것들을 구성하는 방법 H/W가 있으면 H/W에 윈도우나 리눅스,유닉스를 설치할수 있음 각각의 운영체제에서 프로그램을 동작시킬 때, 파일을 생성하면 H/W에 저장된다. 파일을 저장할 때 중요한 것은 File System에 의존적이라는 것 파일을 어떻게 정의하고 어떻게 구성할것인지가 파일시스템의 정의 파일 시스템은 운영체제의 일부로, 운영체제에서 구현하고 있는 독립적인 시스템 호출할 때는 ANSI 표준 함수를 호출하지만 실제 파일을 만드는 대상은 운영체제다. 윈도우에서 만들면 윈도우, 리눅스에서 만들면 리눅스가 만듦 호출할 때 파일이 만들어지는 과정 ANSI 표준함수가 구현되기 이전에는 System 함수가 완성이 된다. 윈도우에서 파일을 만들려면 윈도우에서 제공하는 System 함수를 사용해야 한다. 내가 파일을 만들기 위해서는 System함수를 사용해서 만드는 수 밖에 없다 ANSI표준함수로 만들 수도 있고 운영체제에서 제공하는 System함수로 만들 수도 있다. 차이점 만약 ANSI 표준함수 fopen이 윈도우에서 실행된다면 윈도우에서 제공하는 fopen함수를 재호출하여 만들어지게 된다. 즉,ANSI 표준함수는 OS의 System 함수를 내부적으로 다시 호출하는 과정으로 파일이 생성된다. ANSI에서 사용하는 표준 함수는 윈도우,리눅스,유닉스 모든 운영체제에서 제공되는 함수만 제공이 가능하다. 각각의 운영체제에서 더욱 세밀하게 작업하기 위해서는 교집합인 ANSI 표준함수가 아닌 각각의 운영체제의 System 함수를 호출해야 한다.파일 관련 함수 파일 생성 CreateFile 입력 및 출력 ReadFile, WriteFile 파일 종료 CloseHandle 파일 정보 얻어오기 GetFileTime 만든 날짜, 수정한 날짜, 액세스한 날짜 핸들을 통해 정보 확인 GetFileAttributes 읽기 전용, 숨김, 보관 파일 이름을 통해 정보 확인 GetFileInformationByHandle 위 두 함수를 통해 얻을 수 있는 정보 모두 얻을 수 있다. 핸들을 통해 정보 확인 파일 포인터의 이동 32비트 기반 이동 SetFilePointer(hFile, sizeof(TCHAR)*4, NULL, FILE_BEGIN); ANSI 표준 함수로는 fseek() 4GB - 1 == INVALID_SET_FILE_POINTER(0xFFFFFFFF) 파일의 최대 크기 : 4GB-2 32비트의 최대 크기는 4GB이고 0부터 시작하므로 마지막은 4GB-1이 된다. 파일 관련 I/O 함수는 오류가 발생했을 때 0xFFFFFF(4GB-1)값을 사용하므로 최대크기는 4GB-2가된다. 64비트 기반 이동 SetFilePointer(hFile, IDistanceLow, &amp;IDistanceHigh, FILE_BEGIN); 파일포인터의 현재 위치를 반환 64비트여도 SetFilePointer()가 반환하는 바이트는 4바이트 나머지 4바이트는 3번째 인자 IDistanceHigh를 통해 얻을 수 있다. IDistanceLow는 반환값을 통해 얻음 반환된 값이 0xFFFFFFFF이면 32비트때와 마찬가지로 오류를 의미.근데 64비트 기반에서 파일의 크기가 4GB-1가 될수도 있기 때문에 검사해야한다. 4GB - 1의 검사dwPtrLow = SetFilePointer(…)if ( (INVALIDE_SET_FILE_POINTER == dwPtrLow) &amp;&amp; (NOERROR != GetLastError())) " }, { "title": "구조적 예외 처리", "url": "/posts/%EA%B5%AC%EC%A1%B0%EC%A0%81-%EC%98%88%EC%99%B8-%EC%B2%98%EB%A6%AC/", "categories": "윈도우즈시스템프로그래밍, 운영체제", "tags": "windows", "date": "2023-04-09 00:00:00 +0900", "snippet": "예외가 발생하는 구조 System은 보통 OS와 CPU, App을 이야기한다. 개발자 관점으로는 OS와 CPU까지 내부, App은 직접 개발하는 부분으로 외부로 나눠서 이야기한다. CPU 관점으로는 OS,APP 모두 소프트웨어로 취급한다. CPU로 명령어가 들어가면 순차적으로 연산할 뿐, OS든 APP든 구분해서 실행하진 않는다. CPU는 동일한 바이트 크기의 연산만 가능 4byte / 1byte같은 연산은 X 32비트면 4byte, 64비트 8byte char같은 1byte들은 4byte로 맞춰서 연산을 진행 0으로 나누라는 연산할 수 없는 상황같은 명령어가 들어올 때 예외가 발생한다. CPU는 예외가 생기는 상황을 정해놓고 소프트웨어(OS,APP)에서 예외가 발생하면 예외가 발생함을 알려주기만 하고 소프트웨어에서 예외를 처리해야 한다. 소프트웨어에서 예외를 처리하는 코드를 핸들러라고 부름. CPU가 예외를 발생시키면 소프트웨어에서 그에 맞는 핸들러를 동작시킴 예외가 생기는 상황은 하드웨어적으로 고정되어있어 프로그래머가 결정할 수 없고, 결국 소프트웨어적인 핸들러에서 결정해야 한다. 이러한 핸들러들은 OS에 이미 설정되어 있어 OS를 설치하면 예외에 따른 핸들러도 동시에 등록이 된다. SEH예외처리의 필요성 예외 처리 전 코드FILE* ptrFile = fopen(\"test.txt\", \"r\");if (NULL == ptrFile) // 파일이 없는 경우{ // Exception Handling.}char* dataBuffer = (char*)malloc(sizeof(char)*100);if (NULL == dataBuffer) // 동적할당 받을 메모리가 없는 경우{ // Exception Handling.}int nRead = fread(dataBuffer, 1, 10, ptrFile);if (10 != nRead) // 읽은 데이터의 개수가 다른지{ // Exception Handling. // 추가로 파일의 끝인지, EOF(end of file)인지 비교해야 한다.} 예외 처리 후 코드// 프로그램의 실제 흐름FILE* ptrFile = fopen(\"test.txt\", \"r\");char* dataBuffer = (char*)malloc(sizeof(char)*100);int nRead = fread(dataBuffer, 1, 10, ptrFile);// 위 흐름에 대한 예외 처리 영역if (NULL == ptrFile) { // Exception Handling.}if (NULL == dataBuffer) { // Exception Handling.}if (10 != nRead){ // Exception Handling.} 예외를 처리하는 코드만 따로 모아서 가독성을 높일수 있다.예외(예외상황)와 에러(혹은 오류)의 차이점 컴파일 타임 오류는 에러 문법적 오류 에러는 고쳐야 한다. 런타임 오류는 일반적으로 예외 ex) 파일이 있어야 하는데 없는 경우, 즉 소프트웨어적인 흐름에서 벗어나는 경우를 예외라고함 예외는 종료가 안되게끔 적절히 처리되어야 한다. 하드웨어 예외와 소프트웨어 예외 하드웨어 예외 하드웨어에서 문제시 삼는 상황 ex) 0으로 정수를 나누는 상황 소프트웨어 예외 운영체제 개발자나,프로그래머가 정의한 예외 SEH 매커니즘 동작 소프트웨어 예외 발생시 Windows는 예외처리 매커니즘을 동작시킨다. 하드웨어 예외가 발생되었음에도 Windows에 의해 인식되어서 예외처리 매커니즘 동작 핸들러에는 예외 핸들러와 종료 핸들러가 있다.종료 핸들러// 기본적인 형태__try{ // 예외 발생 경계 블럭 ... 중략 ...}__finally{ // 종료 처리 블럭 ... 중략 ...} try블럭이 실행되기만 한다면 빠져나갈 때 무조건 finally블럭을 실행한다.// 예시. . . .__try{ _tprintf(_T(\"Input divide string [a / b]: \")); _tscanf(_T(\"%d / %d\", &amp;a, &amp;b)); if (0 == b) { return -1; } // return 후 __finally 블럭 진입}__finally{ _tprintf(_T(\"In __finally block.\\n\"));}_tprintf(_T(\"result: %d\\n\", a / b));... 중략 ...종료 핸들러 활용 사례__try{ ptrFile = _tfopen(_T(\"string.dat\"), _T(\"a+t\")); if (NULL == ptrFile) { DWORD strLen = 0; return -1; } strBuffer = (TCHAR*)malloc((strLen + 1) * sizeof(TCHAR)); if (NULL == strBuffer) { return -1; }}__finally{ if (NULL != ptrFile) { fclose(ptrFile); } if (NULL != strBuffer) { free(strBuffer); strBuffer = NULL; }} 위 코드의 try블럭에서 file을 열고 난후 동적할당에서 에러가 터지면 파일을 닫지도 않고 종료하게 되버린다. 파일을 열거나 동적할당을 받는 등, 후처리를 반드시 해줘야 할 때 에러가 나더라도 실행하는 finally블럭을 작성하여 예외 처리를 해준다. 예외 핸들러 기본적인 형태 try와 except블럭은 위치는 다르지만 하나의 구문처럼 작동 try블럭에서 발생하는 예외는 except블럭에서 처리한다. 예외를 처리하는 방식에는 3가지 필터가 있다. 필터 EXCEPTION_EXECUTE_HANDLER EXCEPTION_CONTINUE_EXECUTION EXCEPTION_CONTINUE_SEARCH 위 그림의 예외처리 방식이 써져있는 괄호 안이 필터의 위치 예외(EXCEPTION_EXECUTE_HANDLER) 처리 매커니즘의 흐름 EXCEPTION_EXECUTE_HANDLER는 try블럭에서 예외가 발생하면 그이후는 건너뛰고 바로 except블럭을 실행하는 구조예외 핸들러의 활용 사례 연구__try{ switch(sel) { ... 중략 ... case DIV: result = num1 / num2; // 여기서 끊고 __except 블럭으로 넘어감. 뒤는 의미없음. _tprintf(_T(\"%d / %d = %d\\n\\n\"), num1, num2, num1/num2); break; ... 중략 ... }}__except(EXCEPTION_EXECUTE_HANDLER){ _tprintf(_T(\"Wrong number inserted. Try again!\\n\\n\"));}처리되지 않는 예외의 이동 Divide함수 안에서 DIVIDE_BY_ZERO (위 그림에서는 a/b) 예외가 발생 H/W가 OS에 예외를 알리고 Windows OS가 SEH 를 처리 하지만 DIVIDE_BY_ZERO는 try블럭에 묶여있지 않아 except블럭이 실행되지 않음. SEH는 예외 처리가 되지 않을 시, 예외가 발생한 함수를 콜스택에서 꺼내버리고, 함수 콜스택의 역순으로 예외를 전달. 위 StackMemory 그림을 보면 Divide함수에서 예외가 발생해서 Calculator 함수로 돌아왔고 try블럭이 있어서 그에 맞는 exception블럭을 실행한다. 만약 main함수까지 갔는데 try except블럭이 없다면 프로그램을 강제 종료 OS는 예외를 감지해서 알려주기만 할 뿐, 처리하지는 않음 이 것이 Windows의 예외처리 방식 예외를 구분하는 방법 GetExceptionCode() 함수는 예외가 발생한 이유를 알려주는 함수 호출 가능 위치 __exception 블럭 내 / 예외필터 표현식 지정 위치 이외에는 의미가 없다. 예외가 발생하지 않을 수도 있는 위치이기 때문. 반환 값의 예 EXCEPTION_STACK_OVERFLOW EXCEPTION_INT_DIVIDE_BY_ZERO MSDN 참조. __try{ ... 중략 ...}__except(EXCEPTION_EXECUTE_HANDLER){ DWORD exceptionType = GetExceptionCode(); switch(exceptionType) { case EXCEPTION_ACCESS_VIOLATION: _tprintf(_T(\"Access violation\\n\\n\")); break; case EXCEPTION_INT_DIVIDE_BY_ZERO: _tprintf(_T(\"Divide by zero\\n\\n\")); break; }}EXCEPTION_CONTINUE_EXECUTION __except 블럭을 실행하지 않고, 예외가 발생한 지점에서부터 다시 실행. DIVIDE_BY_ZERO 예외의 경우에 값을 하나 더 받아서, 다시 실행하면 됨. EXCEPTION_CONTINUE_SEARCH 예외가 발생한 위치와 예외처리하는 위치를 달리하는데 사용 스택에서 그 함수를 pop하는 형식" }, { "title": "컴퓨터 구조에 대한 네번 째 이야기", "url": "/posts/%EC%BB%B4%ED%93%A8%ED%84%B0-%EA%B5%AC%EC%A1%B0%EC%97%90-%EB%8C%80%ED%95%9C-%EB%84%A4%EB%B2%88-%EC%A7%B8-%EC%9D%B4%EC%95%BC%EA%B8%B0/", "categories": "윈도우즈시스템프로그래밍, 운영체제", "tags": "windows", "date": "2023-03-30 00:00:00 +0900", "snippet": "메모리 범위와 종류 보통 메모리라고 하면 메인 메모리에 해당하는 램을 생각하지만 메모리는컴퓨터를 구성하는 요소 중에서 임시적이든, 영구적이든 저장 기능을 조금이라도 가지고 있으면 무조건 메모리의 범위로 포함한다. 보통 메인메모리와 하드디스크를 비교하면 메인 메모리는 실행, 하드디스크는 저장의 기능으로 비교하지만 하드디스크는 실행이라는 기능도 가지고 있다. 메인 메모리 정확히는 D램(D-RAM)계열의 메모리 메인 메모리는 반드시 램이어야할 이유는 없다. 따라서 메인 메모리와 램에는 등호관계가 성립하지 않는다. 그러나 대부분 메인메모리를 램으로 사용한다. 레지스터 레지스터들도 당연히 메모리. CPU안에 내장되어 있어서 연산을 위한 저장소를 제공한다. 캐쉬 캐쉬는 D램보다 빠른 S램(S-RAM)으로 구성하는데, 램이라는 단어는 메인 메모리를 의미하는 용도로 사용되므로, 캐쉬 메모리는 캐쉬라고 부른다. 캐쉬는 CPU와 램 사이에서 중간 저장소 역할을 하는 메모리이다. 캐쉬가 CPU에 내장되어 있다고 표현하기도 하는데, 캐쉬 메모리는 원래 CPU의 일부로 존재하는 메모리 개념이 아니다. CPU에 근접해 있는 메모리 개념이다. CPU의 일부로 존재하는 메모리는 레지스터이다. 하드디스크와 이외의 저장 장치들 하드디스크는 크고 작은 파일들을 저장하기 위한 용도로 사용되지만, 프로그램 실행에 있어서도 중요한 의미를 지닌다. 그밖에 SD카드,CD_ROM과 같은 I/O 장치들도 메모리에 해당한다. 프로그래머는 레지스터,캐쉬, 메인 메모리,하드디스크뿐만 아니라 그 밖의 I/O 장치들과의 입/출력 타이밍 및 대기 시간 등을 가장 중요한 요소로 생각하고 항상 고민해야 한다. 메모리 계층 구조 프로그램이 실행되는 동안 메모리가 하는 역할은 데이터의 입출력이다. 따라서 기본적인 역할은 모든 메모리가 동일하다. 하지만 차이점이 존재하는데 가장 큰 차이점은 CPU를 기준으로 얼마나 떨어져 있느냐이다. 레지스터 &gt; 캐쉬 메모리 &gt; 메인 메모리 &gt; 하드 디스크 순으로 CPU에 가깝다. CPU와 가까이 있을수록 빠르고, 멀리 있을수록 느리다. 그렇다면 가장 가까운 레지스터만 사용하면 가장 빠르겠지만 문제는 기술과 비용이 든다. CPU 근처로 대용량의 메모리를 가져 갈수록 기술적인 문제들과 비용이 훨씬 많이 든다 계층 구조 가장 위쪽에 있는 것은 레지스터 크기가 가장 작지만 가장 빠르다 그 다음 L1 캐쉬와 L2 캐쉬가 존재하다. L1캐쉬가 L2캐쉬보다 CPU에 근접해 있다. 그 다음은 메인 메모리. 캐쉬보다는 크지만 상대적으로 느리다. 그 다음은 하드 디스크. 가장 크지만 가장 느리다. 원리 CPU는 메인 메모리에게 데이터를 요청한다. 메인 메모리가 갖고 있으면,바로 CPU에게 주지만 없으면 하드 디스크에 요청한다. 하드 디스크는 그 데이터 블럭을 메인 메모리에게 올려준다. 그래서 메인 메모리는 CPU에게 데이터를 넘겨준다. ALU가 L1 캐시에 데이터를 요청한다. (레지스터가 아님.) L1 캐시가 갖고 있지 않으면 L1 캐시는 L2 캐시에게 요청한다. L2 캐시가 갖고 있지 않으면 메인 메모리에게 요청한다. 메인 메모리에게 없으면 하드 디스크에게 요청한다. 하드 디스크에 있었으면 메인 메모리에 데이터를 올려주는 등, 역으로 아래에서 위로 데이터를 올려주고를 반복해서 CPU까지 전달한다. 근데, CPU에서 바로 하드디스크로 접근해서 데이터를 요청하는게 빠르지 않을까 생각할 수 있다. 만약 프로그램의 실행 흐름이 산발적이라면(여기저기 랜덤으로 실행) 하드디스크의 요청이 더 빠를 수도 있다. 하지만 지역적인 특성을 지니기 때문에, 메모리가 계층적인 것이 더 성능이 향상된다. 지역적인 특성은 실행 흐름이 여기저기서 실행하는 것이 아닌 어느 지역에 국한되어서 실행됨을 의미 캐쉬와 캐쉬 알고리즘 캐쉬 메모리가 존재했을 떄 성능이 향상되는 이유는 프로그램의 일반적인 특성 Locality가 존재하기 때문이다. 캐쉬메모리는 Temporal Locality와 Spatial Locality 두가지 특성을 지니고 있다. Temporal Locality (반복 접근) 프로그램 실행시 한 번 접근이 이뤄진 주소의 메모리 영역은 자주 접근하게 된다는 프로그램 특성Spatial Locality (주변 접근) 프로그램 실행시 접근하는 메모리 영역은 이미 접근이 이루어진 영역의 근처일 확률이 높다는 프로그램 성격을 표현할 떄 사용하는 말 cpu가 필요한 데이터를 캐쉬 메모리에 요구할 때 있을 확률이 90%가 넘는데 그 이유가 바로 Spatial Locality 때문이다. 밑에서 이야기하는 데이터 블록 단위 이동이 곧 Spatial Locality의 특징이다. 캐쉬 알고리즘 Temporal Locality와 Spatial Locality의 특성이 캐쉬에 어떻게 반영하는지에 대한 과정 Cpu가 L1에 캐쉬를 요구한다고 가정했을 때 L1 캐쉬에 해당 데이터가 존재할 경우를 캐쉬 힛이 발생했다고 하며, 이 데이터를 레지스터로 이동시킨다. 반대로 L1 캐쉬에 해당 데이터가 존재하지 않을 경우 캐쉬 미스가 발생했다고 하고, 캐쉬 미스가 발생하면 L2 캐쉬에서 해당 데이터를 가져오게 된다. L 2캐쉬에도 없다면 그 밑의 계층인 메인메모리에서 데이터를 가져온다. 메모리 사이에서 데이터의 이동은 블록 단위로 진행이 된다. 메모리의 피라미드 구조 아래로 갈수록 블록 크기는 커진다. 이는 피라미드 구조 아래에 존재하는 메모리일 수록 접근 횟수를 줄이는 효과를 가져다 준다. Cpu가 캐쉬에게 데이터를 요청했을 때, 그 데이터만 요구하는게 아닌 그 데이터를 포함한 데이터 블록을 전달하기 때문에 다음번에 데이터를 요청했을 때 확률이 높아지는 것이다. 블록단위 전송이 이뤄지기 때문에 캐쉬 메모리에 데이터가 있을 확률이 90퍼가 넘는 이유. 캐쉬 미스가 발생할 떄 고려하게 되는 부분 운영체제가 동작하고, 프로그램이 실행되는 동안 하드 디스크를 제외한 모든 메모리가 항상 채워져 있다. L2캐쉬의 경우 캐쉬 메모리를 채워놔야만 L1 캐쉬에서 요구하는 데이터를 소유하고 있을 확률이 높아지기 때문에 조금이라도 비워둘 필요가 없다. 그런데 L1 캐쉬에서 캐쉬미스가 발생해서 L2캐쉬로부터 데이터 블록을 읽어 들일 때 해당 데이터 블록을 L1 캐쉬에 저장을 해야하는데 저장하려면 기존 L1 캐쉬 데이터를 밀어야 한다. 이 때 보편적으로 거론되는 알고리즘이 LRU 알고리즘이다. LRU 알고리즘 : 가장 오래전에 참조된 블록을 밀어내는 알고리즘 캐쉬 프렌드리 코드 캐쉬의 도움을 많이 받을수 있도록 구현하는 코드int total = 0;for(int i = 0;i &lt; 10;i++){ for(int j = 0;j &lt; 10;j++) { total+= arr[i][j]; }}// arr[0][0] -&gt; arr[1][0] 보다 arr[0][0] -&gt; arr[0][1] 같이 해당 데이터의 근처에 있을수록 좋음 산발적인 접근이 아닌 순차적으로 접근했을 때가 캐쉬의 도움을 받을 수 있다.가상 메모리 CPU가 요구하는 메모리 공간이 2GB라고 했을 때 메인 메모리가 가지고 있는 공간이 256MB라고 한다면 부족한 메모리 공간을 채워주기 위해 더 큰 메모리 공간을 지닌 하드디스크까지 확장해서 사용한다. 하드디스크까지 확장해서 메모리 공간을 넓히는 것을 가상 메모리 기법이라고 한다. 가상 메모리에는 가상 주소와 물리 주소가 있다. 물리주소 데이터는 컴파일이 완료된 운영체제와 그 운영체제를 바탕으로 동작하는 프로그램을 총칭하는 것이다. 위 그림에서는 운영체제 코드와 프로그램을 하나의 바이너리 코드로 생성해서 시스템에 로딩한다. 위 그림의 램 용량을 16MB라고 가정한다면 임베디드 시스템에서 접근 가능한 메모리 영역은 0번지부터 “(16 x 1024 x 1024) -1”번지까지 사이가 된다. 이 접근 가능한 메모리 영역이 바로 실제 물리적인 메인 메모리의 주소 범위에 해당한다. 이렇게 주소를 할당하는 것을 가리켜 물리적 주소 지정이라고 한다. 물리적 주소 지정의 특징은 메인 메모리 크기에 따라 지정 가능한 주소의 범위가 결정된다는 것이다. 물리적 주소 지정을 하게 되면 CPU 입장에서는 접근 가능한 주소의 범위가 제한된다. 이것은 프로그래머가 할당할 수 있는 주소 범위도 제한적이라는 뜻도 된다. 이렇게 주소 범위가 제한되면 프로그래머는 주소 범위를 넘지 않게 개발해야하기 때문에 상당한 제약사항으로 작용한다. 이러한 제약 사항을 겪지 않게 하기 위해 가상 주소 시스템을 사용한다.가상 주소 시스템 1 32비트 시스템에서 프로세스 생성시 4GB의 메모리를 할당받을 수 있다. 하지만 메인 메모리의 크기는 턱없이 부족하다. 따라서 4GB는 실제 존재하지 않는 가상의 주소라는 것을 알 수 있다. 이렇게 가상의 주소를 지정하는 것을 가상 주소 지정이라 한다. 가상 주소 지정을 통해 할당받는 4GB를 가리켜 가상 메모리 공간이라 한다. 하드 디스크까지 확장하여 사용하는 가상 메모리 기법을 사용할 때 고려해야할 점이 있다. 가상 메모리 시스템의 원리를 배우고 나면 이 두 문제를 해결하기 위한 방법은 해결할 수 있다. 1.선 할당으로 인한 부담 프로세스를 생성할 시 4GB씩 할당해줄 것인지 아주 작은 프로그램(ex) “Hello World”)를 실행시킬 때에도 4GB씩 할당할지 2.느린 속도의 개선 필요성 메인 메모리와 하드 디스크는 속도에 차이가 있어 생기는 문제가상 메모리 시스템의 원리 1 가상 메모리 시스템을 구현하는 방법은 표준으로 정해져 있지는 않다. 그러나 대부분의 시스템에서는 페이징(Paging)이라는 기법을 사용하므로 이를 바탕으로 설명한다. 페이징 알고리즘의 구현방법은 다양하여 구현이 아닌 이해의 관점으로 본다. 가상 메모리 시스템을 설명하기 위한 약간의 설정밑에서 설명할 시스템의 사양-------------------------가정 1. 16비트 시스템. 따라서 0부터 64K-1까지 주소 지정 가능가정 2. 프로세스별로 64K바이트 메모리 할당, 물론 가상 메모리 할당가정 3. 메인 메모리 16K바이트, 즉 램 용량이 16K바이트 실제 메모리는 16K 바이트이지만, 프로세스를 생성할 때마다 64K바이트를 할당하고자 하니 문제가 생긴다. 특히 16K번지 이상의 메모리는 접근조차 불가능 최대 할당 가능한 메모리는 16K-1번지까지 이 문제를 해결하기 위해 다음과 같은 구조를 생각한다. 첫번째 요청에서 16KB가 있다고 가정할 때 CPU는 실제보다 더 큰 메모리가 있다고 생각하고 MMU에게 요구하는데 1K번지부터 20바이트 할당을 요청한다. 여기서 20바이트를 할당할 때 메인 메모리를 블럭 단위로 할당하기 때문에 1K번지에 해당하는 0 - 4K를 할당한다. 메모리 블럭 단위를 4K라고 가정 두번째 요청에서 36K번지에서 20바이트를 요청하면 순차적으로가 아니라 그 다음 블록을 순간순간적으로 바로 결정짓기 때문에 36K - 40K를 할당한다. 여기서 실제 물리적인 주소를 생각하면 36K - 40K는 4K에 해당한다. CPU가 만약 36K에 있는 데이터를 요청한다면 MMU는 물리 메모리 4K에 있는 데이터를 가져다 CPU에게 전달한다. CPU가 가상 메모리로 접근한다면 MMU는 물리 메모리로 접근하고 그 메모리를 CPU에게 전달한다. 즉, MMU(Memory management unit)는 존재하지 않는 메모리를 존재하는 것 처럼 CPU가 느끼도록 컨트롤 하는 역할이다. CPU가 실제보다 더 큰 메모리가 있다고 가정하여 존재하지 않는(기존 보다 큰) 메모리를 요청하기 때문에 MMU가 해결하는 구조. 가상 메모리 시스템의 원리 2 가상 메모리 시스템의 원리 1에서는 물리메모리와 가상 메모리에 대한 설명이고 2는 페이지와 페이지 프레임에 대한 설명이다.페이지 &amp; 페이지 프레임 소프트웨어 입장에서의 메모리 블록을 페이지 라고 부른다. 하드웨어 입장에서의 메모리 블록을 페이지 프레임이라고 부른다 페이지 단위로 데이터를 할당하고 페이지 프레임 단위로 데이터를 해제하기 때문에 페이지와 페이지 프레임의 크기는 같다. 위 그림은 가상 메모리(페이지)와 그에 해당하는 실제 메모리(페이지 프레임)가 어떻게 매핑되는지 보여준다. 느린속도를 개선하기 위해 하드디스크의 일부까지 메인메모리를 확대하는 것이 가상메모리, 실질적인 메모리는 RAM에 국한된다고 이야기 했었다. RAM에 접근할 때는 빨라지고 하드디스크에 접근해질 때는 느려지기 때문에 하드디스크와 RAM의 관계를 Cash관계로 구성한다. RAM부터 하드디스크까지 2GB라고 한다면 2GB의 메모리 공간 전부를 하드디스크에 넣어버린다. Temporal Locality와 Spatial Locality에 의해 메모리를 블록단위로 하드디스크에 놓고 RAM은 그 블록을 가져다가 사용하는 형태. 속도가 빠른 램과 메모리가 큰 하드디스크의 역할을 완전시 동일시 해서 등장하기 때문에 이러한 문제점이 나타난 것이다. 하드디스크는 스왑파일을 통해서 메인 메모리를 보조하고 램과 동일한 성격의 메인 메모리 역할을 하는것이 아니기 때문에 발생한 것. 하드디스크의 역할 램이 꽉찬 상태에서 CPU로부터 4-8K를 할당하겠다는 명령이 들어오면 램은 자리를 내어주기 위해 한 메모리 블럭을 빼야한다. 가장 오래 사용되지 않은 메모리 블럭인 8-12K를 하드디스크에 옮기고 그 자리에 4-8K의 메모리 블럭을 할당한다. 만약 하드디스크로 옮겨진 8-12K를 다시 할당한다면 들어온 4-8K가 아닌, 똑같이 가장 오래 사용되지 않은 메모리 블럭을 빼내고 다시 할당하는 형태로 구성된다. 하드디스크는 저장할 때 파일시스템기반으로 저장하는데 이러한 프로세스의 가상 메모리 확장을 위해 메모리 공간에 파일을 저장하는 것을 스왑파일이라고 한다. 둘 이상의 프로세스와 가상 메모리 가상 메모리에서 하드디스크의 역할에 대해 살펴보았는데, 이를 바탕으로 둘 이상의 메모리가 큰 프로세스에게 어떻게 할당이 가능한지 설명할 수 있다.- 프로세스 A가 실행을 멈추고 프로세스 B를 실행시킨다고 가정한다.1. 현재 메인 메모리중 RAM은 프로세스 A를 실행시키기 위한 데이터가 존재한다.2. 프로세스 B를 실행하기 전에 RAM에 존재하는 프로세스 A의 실행을 위한 데이터 모두를 프로세스 A 스왑파일에 저장한다.3. 프로세스 B의 실행을 위한 데이터를 프로세스 B 스왑파일로부터 램에 가져다 놓는다. 이러한 과정을 반복하여 둘 이상의 프로세스가 각각 할당받아 실행을 이어가는 것ㄷ이다. 이러한 메모리를 채우고 비우고하는 것도 콘텍스트 스위칭에 해당하기 때문에 부담이 크다. " }, { "title": "쓰레드 풀링", "url": "/posts/%EC%93%B0%EB%A0%88%EB%93%9C-%ED%92%80%EB%A7%81/", "categories": "윈도우즈시스템프로그래밍, 운영체제", "tags": "windows", "date": "2023-03-29 00:00:00 +0900", "snippet": "쓰레드 풀에 대한 이해 쓰레드를 커널 오브젝트의 관점으로 바라본다고 했을 때 커널 오브젝트는 생성과 소멸이 상당히 많은 리소스를 사용한다. 메모리 할당 , 반환 커널 모드와 유저 모드의 변환 쓰레드는 일반 커널 오브젝트보다 시스템에 부담을 준다. 스케줄러 관리 대상이기 때문에 스케줄러에 의해서도 감지가 되어야 함. 예시 처리해야할 일이 여러 가지고, 그 일이 동시가 아닌 시간적인 텀을 두고 처리해야 할 때 하나의 쓰레드로 모든 일을 처리할 수 있다면 나머지 쓰레드의 생성과 소멸을 피할 수 있다. 하지만 동시에 처리해야 할 일이 늘어 난다면 할 일만큼 쓰레드를 생성했다가 일이 끝나면 소멸시켜야 한다. 이렇게 하면 생성과 소멸이 빈번해 지면서 Overhead가 늘어날 수 밖에 없다. 그래서 아예 쓰레드를 일이 한번에 최대로 요구되는 수만큼 쓰레드를 만들어놓고 다른 곳에 저장해 두는 것이 바로 쓰레드 풀이다. 그림 쓰레드를 해야할 일의 수만큼 할당하고 할 일을 마친 쓰레드들은 다시 쓰레드풀에 저장해놓는 방식이다. 즉, 쓰레드를 사용할 때마다 생성과 소멸에서 발생되는 리소스 낭비를 줄이기 위해 그 쓰레드들을 미리 생성해 놓고 쓰레드 풀이라는 곳에 저장해서 사용하는 방식이다. 쓰레드 풀의 구현// 쓰레드가 해야 하는 작업(Work)는 기본적으로 함수 포인터로, 함수가 Work의 기본 단위다.// 즉, 쓰레드에게 일을 시키기 위해서는 일에 해당하는 하나의 함수를 정의해야 한다.// 함수에 따라 매개변수,반환형은 바뀔 수 있음 typedef void(*WORK)(void);// 쓰레드를 관리하기 위한 구조체// 예제는 간단하게 2개의 변수만 제공, 필요하다면 추가 가능typedef struct __WorkerThread{ HANDLE hThread; // 쓰레드의 HANDLE DWORD idThread; // 쓰레드의 ID} WorkerThread;// Work와 Thread 관리를 위한 구조체. Thread Pool의 기본적인 모델.typedef struct __ThreadPool{ // Work을 등록하기 위한 배열. WORK workList[WORK_MAX]; // Thread 정보와 각 Thread별 Event Object WorkerThread workThreadList[THREAD_MAX]; // Thread 정보를 저장하는 배열 HANDLE workerEventList[THREAD_MAX]; // Event Object 정보를 저장하는 배열 // Work에 대한 정보 DWORD idxOfCurrentWork; // 대기 1순위 Work Index. DWORD idxOfLastAddedWork; // 마지막 추가 Work Index + 1. // Number of Thread DWORD idxOfThread; // Pool에 존재하는 Thread의 갯수.} gThreadPool; 위 그림에서 work는 함수 포인터 worklist는 쓰레드에게 순차적으로 work를 할당해주기 위한 배열 idxOfCurrentWork는 처리되어야 할 Work의 위치 idxOfLastAddedWork는 새로운 Work가 등록될 떄 등록 위치 Linked list나 Circle Queue의 형태가 좋지만 예제에서는 간단하게 배열로 되어있다. 함수 WORK GetWorkFromPool(void); 쓰레드 풀에서 Work를 가져올 때 호출하는 함수 DWORD AddWorkToPool(WORK work); 새로운 Work를 등록할 때 호출하는 함수 DWORD MakeThreadToPool(DWORD numOfThread); 쓰레드 풀이 생성된 이후에 풀에 쓰레드를 생성(등록)하는 함수. 인자의 수만큼 쓰레드 생성 void WorkerThreadFunction(LPVOID pParam); 쓰레드가 생성되자마자 호출하는 쓰레드의 main함수.이 함수의 구성을 봐야 어떻게 Work를 할당받아 처리하는지, 그리고 Work가 없을 때의 쓰레드 상태를 알 수 있다. 이벤트 오브젝트 쓰레드를 생성하는데 이벤트 오브젝트도 같이 생성한다. 그 이유는 쓰레드가 일을 하지 않는다면(쓰레드 풀에 들어가 있는 상태) 스케줄러에 의해 스케줄링이 되면 안되기 때문에 안되게 하기 위해 이벤트 오브젝트를 사용한다. 쓰레드는 생성될 때 WaitForSingleObject()를 호출하는데 이벤트 오브젝트는 생성과 동시에 Non-Signaled이기 때문에 쓰레드는 Blocked상태가 된다.매커니즘 MakeThreadToPool 함수의 호출을 통해 쓰레드를 생성 및 등록한다.이렇게 생성된 쓰레드는 이벤트 오브젝트가 Signaled 상태가 되기를 기다리며 Blocked 상태가 된다. AddWorkToPool 함수 호출을 통해 Work를 등록한다. Work가 등록되면, 쓰레드 풀에서 Blocked 상태에 있는 모든 이벤트 오브젝트를 Signaled 상태로 변경한다. 여기서는 구현하기 편하게 하기 위해 모든 쓰레드들 깨웠지만, 하나만 깨우게 하는게 좋음 모든 이벤트 오브젝트가 Signaled 상태가 되므로, 모든 쓰레드가 Running 상태가 된다.그러나 Work를 할당받은 하나의 쓰레드를 제외하고 나머지는 Blocked가 된다. Running 상태로 남아 있게 될 하나의 쓰레드는 GetWorkFromPool 함수 호출을 통해 Work를 할당받아서 실행하게 된다. 일이 끝난 쓰레드는 반환되기 위해 WaitForSingleObject를 호출하여 Non-Signaled로 변경하고 쓰레드 풀에 돌아간다. " }, { "title": "최단 경로", "url": "/posts/%EC%B5%9C%EB%8B%A8%EA%B2%BD%EB%A1%9C/", "categories": "자료구조, Tree", "tags": "data_structure", "date": "2023-03-28 00:00:00 +0900", "snippet": "최단 경로 가중치 그래프에서 간선의 가중치의 합이 최소가 되는 경로 최단 경로를 구하려는 가중치 그래프의 가중치는 가중치 인접 행렬에 저장한다. 가중치 인접 행렬은 그래프에서 사용한 인접 행렬과 같은 2차원 배열이고, 두 정점 사이에 간선이 없으면 0이 아니라 ∞를 표시한다고 할 때 그리고 각 정점은 자기 자신과 이어진 간선을 허용하지 않으므로 가중치 인접 행렬에서 대각선 값은 0으로 표시한다. 최단 경로를 찾는 방법에는 두가지 알고리즘이 있다. 다익스트라 알고리즘 플로이드 알고리즘 다익스트라 하나의 시작 정점에서 다른 정점까지의 최단 경로를 구하는 알고리즘 정점 하나를 출발점으로 두고 다른 모든 정점을 도착점으로 하는 단일점에서의 최단 경로 알고리즘 중 가장 많이 사용된다. 무방향 그래프나 방향 그래프 모두 적용할 수 있다. 원리 시작 정점 v에서 가장 가까운 정점을 선택하여 추가하면서 추가된 새로운 정점에 의해 단축되는 경로가 있으면, 경로 거리를 수정하는 과정을 반복하면서 시작 정점에서 모든 정점에 대한 최단 경로를 구하는 것이다. 시작 정점 v에서 정점 u까지의 최단 경로 distance[u]를 구해 정점 u가 집합 S에 추가되면 새로 추가된 정점 u에 의해 단축되는 경로가 있는지 확인한다. 즉, 현재 알고 있는 distance[w]를 새로 추가된 정점 u를 거쳐서 가는 distance[u] + weight[u][w]를 계산하는 경로와 비교해 경로가 단축되면 distance[w]를 단축된 경로값으로 수정함으로써 최단 경로를 찾는다. 과정* 다익스트라 최단 경로 알고리즘에서 최단 경로 찾기1. 경로 길이를 저장할 distance 준비 : 시작 정점으로부터 각 정점에 이르는 경로의 길이를 저장하기 위한 배열 distance를 ∞(무한대)로 초기화한다.2. 시작 정점 초기화 : 시작 정점의 distance를 0으로 초기화하고 집합 S에 추가한다.3. 최단 거리 수정 : 집합 S에 속하지 않은 정점 중에서 distance가 최소인 정점 u를 찾아 집합 S에 추가한다. 새로운 정점 u가 추가되면, u에 인접하고 집합 S에 포함되지 않은 정점 w의 distance값을 다음 식에 따라 수정한다.집합 S에 모든 정점이 추가될 때까지 3번을 반복한다. 다익스트라 최단 경로 알고리즘은 최소 비용 신장 트리인 프림 알고리즘과 비슷하지만, 프림 알고리즘이 단순히 간선 하나의 길이를 비교하여 선택하는 것과 달리 시작 정점에서부터의 경로 길이를 비교하여 선택한다.다익스트라 Code// dijkstar.h#pragma once#define TRUE 1#define FALSE 0#define INF 10000 // 무한대 값#define MAX_VERTICES 5\t// 그래프의 정점 개수int distance[MAX_VERTICES];\t// 시작 정점으로부터의 최단 경로 길이 저장int S[MAX_VERTICES];\t\t\t\t// 정점의 집합 Sint nextVertex(int n);int printStep(int step);void Dijkstra_shortestPath(int start, int n);// dijkstar.c#include &lt;stdio.h&gt;#include \"dijkstra.h\"#include \"graphG.h\"// 최소 거리를 갖는 다음 정점을 찾는 연산int nextVertex(int n) {\tint i, min, minPos;\tmin = INF;\tminPos = -1;\tfor (i = 0; i &lt; n; i++)\t\tif ((distance[i] &lt; min) &amp;&amp; !S[i]) {\t\t\tmin = distance[i];\t\t\tminPos = i;\t\t}\treturn minPos;}// 최단 경로 구하는 과정을 출력하는 연산int printStep(int step) {\tint i;\tprintf(\"\\n %3d 단계 : S={\", step);\tfor (i = 0; i &lt; MAX_VERTICES; i++)\t\tif (S[i] == TRUE)\t\t\tprintf(\"%3c\", i + 65);\tif (step &lt; 1) printf(\" } \\t\\t\\t\");\telse if (step &lt; 4) printf(\" } \\t\\t\");\telse printf(\" } \\t\");\tprintf(\" distance :[ \");\tfor (i = 0; i &lt; MAX_VERTICES; i++)\t\tif (distance[i] == INF)\t\t\tprintf(\"%4c\", '*');\t\telse printf(\"%4d\", distance[i]);\tprintf(\"%4c\", ']');\treturn ++step;}void Dijkstra_shortestPath(int start, int n) {\tint i, u, w, step = 0;\tfor (i = 0; i &lt; n; i++) {\t// 초기화\t\tdistance[i] = weight[start][i];\t\tS[i] = FALSE;\t}\tS[start] = TRUE;\t\t\t// 시작 정점을 집합 S에 추가\tdistance[start] = 0;\t\t// 시작 정점의 최단경로를 0으로 설정\tstep = printStep(0);\t\t// 0단계 상태를 출력\tfor (i = 0; i &lt; n - 1; i++) {\t\tu = nextVertex(n);\t\t// 최단 경로를 만드는 다음 정점 u 찾기\t\tS[u] = TRUE;\t\t\t// 정점 u를 집합 S에 추가\t\tfor (w = 0; w &lt; n; w++)\t\t\tif (!S[w])\t\t\t// 집합 S에 포함되지 않은 정점 중에서\t\t\t\tif (distance[u] + weight[u][w] &lt; distance[w])\t\t\t\t\tdistance[w] = distance[u] + weight[u][w];\t// 경로 길이 수정\t\tstep = printStep(step);\t// 현재 단계 출력\t}}플로이드 모든 정점에서 다른 모든 정점까지의 최단 경로를 구하는 알고리즘 플로이드 최단 경로 알고리즘은 모든 정점 사이의 최단 경로를 구하고 이 알고리즘으로 만드는 최단 경로를 k-최단 경로라고도 한다. 플로이드 Code// floyd.h#pragma once#define INF 10000 // 무한대 값#define MAX_VERTICES 5\t// 그래프의 정점 개수int A[MAX_VERTICES][MAX_VERTICES];\t\t\t// k-최단 경로 배열void printStep(int step);void Floyd_shortestPath(int n);// floyd.c#include &lt;stdio.h&gt;#include \"floyd.h\"#include \"graphG.h\"// 최단 경로를 구하는 과정을 출력하는 연산void printStep(int step) {\tint i, j;\tprintf(\"\\n A%d : \", step);\tfor (i = 0; i &lt; MAX_VERTICES; i++) {\t\tprintf(\"\\t\");\t\tfor (j = 0; j &lt; MAX_VERTICES; j++) {\t\t\tif (A[i][j] == INF)\t\t\t\tprintf(\"%4c\", '*');\t\t\telse printf(\"%4d\", A[i][j]);\t\t}\t\tprintf(\"\\n\\n\");\t}}void Floyd_shortestPath(int n) {\tint v, w, k, step = -1;\tfor (v = 0; v &lt; n; v++)\t\t// 초기화\t\tfor (w = 0; w &lt; n; w++)\t\t\tA[v][w] = weight[v][w];\tprintStep(step);\tfor (k = 0; k &lt; n; k++) {\t\tfor (v = 0; v &lt; n; v++)\t\t\tfor (w = 0; w &lt; n; w++)\t\t\t\tif (A[v][k] + A[k][w] &lt; A[v][w])\t\t\t\t\tA[v][w] = A[v][k] + A[k][w];\t\tprintStep(++step);\t}}" }, { "title": "쓰레드 동기화 기법 - 2", "url": "/posts/%EC%93%B0%EB%A0%88%EB%93%9C-%EB%8F%99%EA%B8%B0%ED%99%94-%EA%B8%B0%EB%B2%95-2/", "categories": "윈도우즈시스템프로그래밍, 운영체제", "tags": "windows", "date": "2023-03-28 00:00:00 +0900", "snippet": "실행순서에 있어서의 동기화 “쓰레드의 실행 순서를 동기화한다”는 것은 다음과 같다. 메모리에 접근하는 쓰레드의 실행 순서를 동기화한다. 따라서 실행순서 동기화는 메모리 접근 동기화를 포함하는 개념이다. 생산자/소비자 모델 생산자/소비자 모델은 실행되는 쓰레드의 순서가 중요한 상황을 설명할 때 종종 소개되는 모델 이 모델을 통해서 실행 순서를 동기화 해야 하는 이유를 알 수 있다. 예시 만일 10Byte가 입력받는다고 했을 때 출력은 입력된 크기만큼 출력하기 때문에 10Byte를 출력한다. 출력은 입력에 의존적 입력은 외부 환경에 의존적 그런데 10Byte를 출력도중에 외부환경에 의해 또 10Byte를 입력받는다고 한다면 입력받은 값을 처리할 수도 있겠지만 처리하지 못할 경우 데이터 손실이 발생한다. 출력속도가 입력속도를 따라가지 못하는 상황을 의미한다. 이러한 문제점을 해결하기 위해 아래 그림과 같은 모델을 적용한다. 두 개의 쓰레드를 활용해서 하나는 입력, 하나는 출력을 담당한다. 여기서 입력 쓰레드는 생산자라 부르고 출력 쓰레드는 소비자 라고한다. 생산자는 문자열을 생성하고(입력받는다), 소비자는 문자열을 소비하는(출력한다) I/O 모델이다. 그리고 그 사이에 메모리 버퍼를 둬서 두 개의 쓰레드가 입력 및 출력 속도에 상관없이 독립적으로 실행되도록 한다. 이러한 I/O모델에서 만약 버퍼가 비어있는 상태에서 생산자가 입력받기 전에 소비자가 출력해버린다면 쓰레기값이 나오게 된다. 이러한 이유 때문에 실행순서를 동기화할 필요가 있다. 이벤트 기반 동기화 이벤트 기반 동기화는 실행 순서를 동기화 하기 위한 기법이다. 이 기법에도 동기화를 위한 오브젝트인 이벤트 오브젝트가 필요하다. // 이벤트 오브젝트를 생성하는 함수HANDLE CreateEvent( LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPTSTR lpName); // in the function fails, the return value is NULL.// 이벤트 오브젝트를 소멸시키는 함수는 CloseHandle을 사용한다. 이벤트 오브젝트를 이용하여 생산자/소비자 모델을 이벤트 기반 동기화를 이용하여 실행 순서를 동기화 할 수 있다. 설명하기 위해서 위에서의 생산자/소비자 모델을 이어서 예시로 든다면 과정 생산자 쓰레드가 실행을 완료가 됐다는 것을 아는 방법은 생산자 쓰레드만 알 수 있다. 그러므로 소비자 쓰레드가 실행되는 시점은 프로그래머가 결정하는데 이 시점을 생산자 쓰레드의 실행 도중으로 결정해야 한다. 결정하기 위해서 생산자 소비자 쓰레드 둘다 알 수 있는 커널 오브젝트 하나를 생성하고 초기에 Non-signaled 상태로 만든다. 생산자 쓰레드가 실행을 완료했다는 것을 알리기 위해 생성한 커널 오브젝트를 Non-Signaled에서 Signaled로 변경해서 소비자 쓰레드가 감지하고 버퍼에 들어가 추가적인 작업을 진행한다. 이 때 소비자는 WaitForSingleObject() 함수를 통해 해당 커널 오브젝트를 체크한다. 생산자 쓰레드가 실행을 완료했을 때 호출 하는 함수가 위에서 언급한 이벤트 오브젝트를 사용하는 SetEvent 함수이다. BOOL SetEvent( HANDLE hEvent);// in the function fails, the return value is zero. 여기까지가 전반적인 이벤트 기반 동기화의 모델에 대한 내용이고 더 깊이 들어간다면 아래 그림과 같다. CreateEvent()함수를 이용하여 이벤트 오브젝트를 생성할 때 수동리셋 모드 이벤트와 자동 리셋 모드 이벤트를 결정할 수 있다. 수동 리셋 모드 이벤트는 이벤트 오브젝트가 신호를 일일이 수동으로 바꿔줘야 하는 이벤트를 의미한다. Non-Signaled -&gt; Signaled는 SetEvent() 호출로 직접 조작 Signaled -&gt; Non-Signaled는 ResetEvent() 호출로 직접 조작 BOOL ResetEvent{ HANDLE hEvent};// in the function fails, the return value is zero. 자동 리셋 모드 이벤트는 신호를 줬을 때 이벤트 오브젝트가 자동으로 Non-Signaled로 변경되는 이벤트를 의미한다. Signaled 상태에서 Non-signaled 상태로 되돌아가는 것은 자동임. Non-signaled -&gt; Signaled는 SetEvent() 호출로 직접 조작 Signaled -&gt; Non-Signaled는 WaitForSingleObject() 함수가 호출될 때 어떤 모드의 이벤트를 선택해야 하는지는 결과를 보고 결정하면 된다. 자동 리셋 모드 이벤트 A 쓰레드와 B 쓰레드가 하나의 커널 오브젝트를 기다리고 있는 상태라고 할 때 해당 커널 오브젝트에게 신호를 줘서 Signaled로 바꿔버린 다면 자동 리셋 모드 이벤트는 WaitForSingleObject()을 호출해서 대기하고 있는 쓰레드중 하나가 빠져나오자 마자 Non-Signaled로 변경된다. 쓰레드가 빠져나오자 마자 Non-Signaled로 변경되므로 둘 중 하나의 쓰레드만 실행의 기회를 얻게 된다. 한 순간에 하나의 쓰레드만 실행기회를 얻게 되기 위해서는 자동 리셋 모드 이벤트를 사용한다. 수동 리셋 모드 이벤트 A 쓰레드와 B 쓰레드가 하나의 커널 오브젝트를 기다리고 있는 상태라고 할 때 해당 커널 오브젝트에게 신호를 줘서 Signaled로 바꿔버린다고 해도 Signaled로 남아 있기 때문에 A와 B쓰레드가 동시에 빠져나오는 즉, 두 쓰레드 모두 실행의 기회를 얻게 된다. 관찰하고 있는 둘 이상의 쓰레드가 동시에 실행 해야 하기 위해서는 수동 리셋 모드 이벤트를 사용한다. 문자열 관련 생산자/소비자 예제/* StringEvent.cpp 프로그램 설명: 1. 생산자/소비자 모델의 이해 2. 동기화 event에 대한 이해.*/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;windows.h&gt;#include &lt;process.h&gt; /* _beginthreadex, _endthreadex */unsigned int WINAPI OutputThreadFunction(LPVOID lpParam);TCHAR string[100];HANDLE hEvent;int _tmain(int argc, TCHAR* argv[]){\t HANDLE hThread; DWORD dwThreadID; hEvent = CreateEvent(\t// event object 생성. NULL,\t\t// 상속 불가. TRUE,\t\t// manual-reset mode로 생성. FALSE,\t\t// non-signaled 상태로 생성. NULL\t\t// 이름 없는 event. );\t if(hEvent==NULL){ _fputts(_T(\"Event object creation error \\n\"), stdout); return -1; } hThread = (HANDLE)_beginthreadex ( // [자식 쓰레드] 소비자 스레드 생성. NULL, 0, OutputThreadFunction, NULL, 0, (unsigned *)&amp;dwThreadID ); if(hThread==0) { _fputts(_T(\"Thread creation error \\n\"), stdout); return -1; }\t _fputts(_T(\"Insert string: \"), stdout); _fgetts(string, 30, stdin); SetEvent(hEvent);\t// [메인 쓰레드]event의 state를 signaled 상태로 변경. WaitForSingleObject(hThread, INFINITE); // [메인 쓰레드] 메인 쓰레드가 먼저 종료되면 안되기에 기다림. CloseHandle(hEvent);\t// event 오브젝트 소멸 CloseHandle(hThread); return 0;}unsigned int WINAPI OutputThreadFunction(LPVOID lpParam){ WaitForSingleObject(hEvent, INFINITE); // [자식 쓰레드]event가 signaled 상태가 되기를 기다린다. _fputts(_T(\"output string: \"), stdout); _fputts(string, stdout); return 0;}===========//결과Insert string : test stringOutput string : test string수동 리셋 모드 이벤트 활용의 예 위의 StringEvent.cpp에서의 이벤트 오브젝트는 모드 상관없이 달라질것 없는 예제였다. 그러나 수동 리셋 모드 이벤트가 아주 유용하게 사용되는 상황이 존재한다. 앞에서는 두 개의 쓰레드(하나는 main쓰레드)가 각각 데이터를 입력, 그리고 출력하도록 역할이 분담되어 있었다. 여기에 하나의 쓰레드를 더 추가해서 이 쓰레드는 소비자 역할을 하는 쓰레드로 만든다. 입력받은 문자열의 길이를 계산해서 출력하는 역할의 쓰레드 /* StringEvent2.cpp 프로그램 설명: manual-reset mode 동기화 적용 사례. 이전 예제와 다르게, 하나의 쓰레드가 더 등장.*/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;windows.h&gt;#include &lt;process.h&gt; /* _beginthreadex, _endthreadex */unsigned int WINAPI OutputThreadFunction(LPVOID lpParam);unsigned int WINAPI CountThreadFunction(LPVOID lpParam); TCHAR string[100];HANDLE hEvent;int _tmain(int argc, TCHAR* argv[]){\t HANDLE hThread[2]; DWORD dwThreadID[2]; hEvent = CreateEvent(\t// event object 생성. NULL,\t\t// 상속 불가. TRUE,\t\t// manual-reset mode로 생성. FALSE,\t\t// non-signaled 상태로 생성. NULL\t\t// 이름 없는 event. );\t if(hEvent==NULL){ _fputts(_T(\"Event object creation error \\n\"), stdout); return -1; } hThread[0] = (HANDLE)_beginthreadex ( NULL, 0, OutputThreadFunction, NULL, 0, (unsigned *)&amp;dwThreadID[0] ); hThread[1] = (HANDLE)_beginthreadex ( NULL, 0, CountThreadFunction, NULL, 0, (unsigned *)&amp;dwThreadID[1] ); if(hThread[0]==0 ||hThread[1]==0) { _fputts(_T(\"Thread creation error \\n\"), stdout); return -1; }\t _fputts(_T(\"Insert string: \"), stdout); _fgetts(string, 30, stdin); SetEvent(hEvent);\t// event의 state를 signaled 상태로 변경. WaitForMultipleObjects ( // [메인 쓰레드] 둘 이상의 쓰레드를 기다릴 때 호출하는 함수. 2, // 배열의 길이. hThread, // 핸들의 배열. TRUE, // 모든 핸들이 신호받은 상태로 될 때 리턴. INFINITE\t // 무한 대기. ); CloseHandle(hEvent);\t// event 오브젝트 소멸 CloseHandle(hThread[0]); CloseHandle(hThread[1]); return 0;}unsigned int WINAPI OutputThreadFunction(LPVOID lpParam){ WaitForSingleObject(hEvent, INFINITE); // event가 signaled 상태가 되기를 기다린다. _fputts(_T(\"Output string: \"), stdout); _fputts(string, stdout); return 0;}unsigned int WINAPI CountThreadFunction(LPVOID lpParam){ WaitForSingleObject(hEvent, INFINITE); // event가 signaled 상태가 되기를 기다린다. _tprintf(_T(\"Output string length: %d \\n\"), _tcslen(string)-1); return 0;}// 실행 결과Insert string : I love youOutput string : I love youOutput string length: 10or Insert string : i love youOutput string : Output string length: 10I love you 문자열을 입력받는 생산자 쓰레드가 이벤트 오브젝트를 Signlaed 상태로 변경하면, 두 개의 소비자 쓰레드는 동시에 블로킹을 빠져 나와 실행을 재개한다. 때문에 잘못된 출력결과를 보일 수 있다. 위에서 실행순서가 꼬인 이유는 실행 순서는 동기화했지만 콘솔의 접근에 대한 순서는 동기화하지 않았기 때문 실행 순서가 정해져 있다면 실행 순서 동기화, 정해져 있지 않다면 임계 영역(메모리 접근) 동기화를 사용한다. 임계영역은 보통 하나의 메모리 블럭을 이야기 하지만, 위와 같이 둘 이상의 메모리 블럭이 하나의 임계영역으로 나타날 수도 있다. 이벤트 더하기 뮤텍스 StringEvent2의 예제를 뮤텍스를 이용하여 해결이 가능하다./* StringEvent3.cpp 프로그램 설명: event, mutex 동시 사용 사례.*/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;windows.h&gt;#include &lt;process.h&gt; /* _beginthreadex, _endthreadex */unsigned int WINAPI OutputThreadFunction(LPVOID lpParam);unsigned int WINAPI CountThreadFunction(LPVOID lpParam); typedef struct _SynchString{ TCHAR string[100]; HANDLE hEvent; HANDLE hMutex; } SynchString;SynchString gSynString;int _tmain(int argc, TCHAR* argv[]){\t HANDLE hThreads[2]; DWORD dwThreadIDs[2]; gSynString.hEvent = CreateEvent(\t NULL,\t\t TRUE,\t\t FALSE,\t\t NULL\t\t );\t gSynString.hMutex = CreateMutex ( NULL, FALSE, NULL ); if(gSynString.hEvent==NULL || gSynString.hMutex==NULL) { _fputts(_T(\"kernel object creation error \\n\"), stdout); return -1; } hThreads[0] = (HANDLE)_beginthreadex ( NULL, 0, OutputThreadFunction, NULL, 0, (unsigned *)&amp;dwThreadIDs[0] ); hThreads[1] = (HANDLE)_beginthreadex ( NULL, 0, CountThreadFunction, NULL, 0, (unsigned *)&amp;dwThreadIDs[1] ); if(hThreads[0]==0 ||hThreads[1]==0) { _fputts(_T(\"Thread creation error \\n\"), stdout); return -1; }\t _fputts(_T(\"Insert string: \"), stdout); _fgetts(gSynString.string, 30, stdin); SetEvent(gSynString.hEvent);\t// event의 state를 signaled 상태로 변경. WaitForMultipleObjects ( 2, // 배열의 길이. hThreads, // 핸들의 배열. TRUE, // 모든 핸들이 신호받은 상태로 될 때 리턴. INFINITE\t // 무한 대기. ); CloseHandle(gSynString.hEvent); CloseHandle(gSynString.hMutex); CloseHandle(hThreads[0]); CloseHandle(hThreads[1]); return 0;}unsigned int WINAPI OutputThreadFunction(LPVOID lpParam){ WaitForSingleObject(gSynString.hEvent, INFINITE); // event가 signaled 상태가 되기를 기다린다. WaitForSingleObject(gSynString.hMutex, INFINITE); // 뮤텍스 추가 _fputts(_T(\"Output string: \"), stdout); _fputts(gSynString.string, stdout); ReleaseMutex(gSynString.hMutex); return 0;}unsigned int WINAPI CountThreadFunction(LPVOID lpParam){ WaitForSingleObject(gSynString.hEvent, INFINITE); // event가 signaled 상태가 되기를 기다린다. WaitForSingleObject(gSynString.hMutex, INFINITE); // 뮤텍스 추가 _tprintf(_T(\"Output string length: %d \\n\"), _tcslen(gSynString.string)-1); ReleaseMutex(gSynString.hMutex); return 0;}타이머 기반 동기화 타이머와 이벤트 커널 오브젝트 사이에 어떤 의미가 있는지가 중요하다. 타이머 오브젝트는 정해진 시간이 지나면 자동으로 Signaled 상태가 되는 하나의 커널 오브젝트 알람을 울린다면 Signaled 상태가 됐음을 의미 수동 리셋 타이머는 몇초뒤 알람이 울릴지 시간을 정해줄 수 있다. 자동 리셋 타이머는 수동 리셋 타이머의 기능에 추가적인 기능이 붙어있다. HANDLE CreateWaitableTimer( // 타이머 커널 오브젝트 생성. LPSECURITY_ATTRIBUTES lpTimerAttributes, BOOL bManualReset, LPCTSTR lpTimerName);BOOL SetWaitableTimer( // 타이머 커널 오브젝트의 시간 설정. HANDLE hTimer, const LARGE_INTEGER* pDueTime, // 초기 시간 LONG lPeriod, // 반복 시간 PTIMERAPCROUTINE pfnCompletionRoutine, // LPVOID lpArgToCompletionRoutine, BOOL fResume);Code/* ManualResetTimer.cpp 프로그램 설명: 수동 리셋 타이머 오브젝트에 대한 이해.*/#define _WIN32_WINNT\t0x0400#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;windows.h&gt;int _tmain(int argc, TCHAR* argv[]){ HANDLE hTimer = NULL; LARGE_INTEGER liDueTime; liDueTime.QuadPart=-100000000; // 음수를 주게끔 정의되어 있음. 현재 시간이 0초이고, 상대시간을 설정할땐 음수를 줌. // ns 단위. hTimer = CreateWaitableTimer(NULL, FALSE, _T(\"WaitableTimer\")); if (!hTimer) { _tprintf( _T(\"CreateWaitableTimer failed (%d)\\n\"), GetLastError()); return 1; } _tprintf( _T(\"Waiting for 10 seconds...\\n\")); SetWaitableTimer(hTimer, &amp;liDueTime, 0, NULL, NULL, FALSE); WaitForSingleObject(hTimer, INFINITE); _tprintf( _T(\"Timer was signaled.\\n\") ); MessageBeep(MB_ICONEXCLAMATION); return 0;}/* PeriodicTimer.cpp 프로그램 설명: 주기적 타이머에 대한 이해.*/#define _WIN32_WINNT\t0x0400#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;windows.h&gt;int _tmain(int argc, TCHAR* argv[]){ HANDLE hTimer = NULL; LARGE_INTEGER liDueTime; liDueTime.QuadPart=-100000000; hTimer = CreateWaitableTimer(NULL, FALSE, _T(\"WaitableTimer\")); if (!hTimer) { _tprintf( _T(\"CreateWaitableTimer failed (%d)\\n\"), GetLastError()); return 1; } _tprintf( _T(\"Waiting for 10 seconds...\\n\")); SetWaitableTimer(hTimer, &amp;liDueTime, 5000, NULL, NULL, FALSE); // 이 함수의 인자는 ms 단위. while(1) { WaitForSingleObject(hTimer, INFINITE); _tprintf( _T(\"Timer was signaled.\\n\") ); MessageBeep(MB_ICONEXCLAMATION); } return 0;}" }, { "title": "UBT와 UHT", "url": "/posts/UBT%EC%99%80-UHT/", "categories": "unreal, 용어", "tags": "unreal", "date": "2023-03-28 00:00:00 +0900", "snippet": "UBT (Unreal Build Tool) 언리얼 엔진의 빌드 시스템에서 중요한 역할을 하는 도구로, 주로 C++ 헤더 파일을 분석하고, 코드 생성을 자동화하는 데 사용된다. UHT는 특히 언리얼 엔진의 객체 시스템(UObject System)과 관련된 코드 작업을 지원 기능 코드 분석 및 처리: C++ 헤더 파일을 스캔하여 언리얼 엔진의 반사(reflection) 시스템에 필요한 메타데이터를 생성한다. 이를 통해, 게임 개발자가 엔진의 다양한 기능(예: 가비지 컬렉션, 네트워킹, 에디터 지원 등)을 쉽게 활용할 수 있도록 돕는다 자동 코드 생성: UHT는 UCLASS, UPROPERTY 등과 같은 매크로를 포함하는 코드를 자동으로 처리하여, 추가적인 C++ 파일을 생성한다. 이 과정에서 .generated.h 파일이 생성되어, 엔진과 개발자 코드 간의 통합을 원활하게 한다. 에러 검출: 코드에서 발생할 수 있는 다양한 오류를 사전에 검출해 빌드 과정에서 문제를 방지한다 generated.h 언리얼 엔진의 코드베이스에서 중요한 역할을 하는 자동 생성된 헤더 파일기능 클래스, 구조체, 함수 등에 대한 메타데이터가 포함되어 있고, 이 메타데이터가 언리얼 엔진의 리플렉션 시스템에 사용되어 런타임에 객체의 속성을 쿼리하거나 수정할 수 있도록 한다. ex) 에디터에서 블루프린트에 노출되는 속성, 네트워크에서 복제되는 데이터에 대한 정보 generated.h 파일은 엔진의 빌드 과정에서 필수적인 요소로, UHT가 생성한 코드를 프로젝트에 포함시킨다.UHT (Unreal Header Tool) 언리얼 엔진 프로젝트의 빌드 프로세스를 관리하는 도구기능 빌드 관리: UBT는 프로젝트의 타겟 파일(.Target.cs)을 검색하여, 각 타겟의 빌드 설정을 처리한다. 여기에는 에디터 빌드, 게임 빌드, 서버 빌드 등이 포함된다 모듈 종속성 해결: 프로젝트 내 모듈 간의 종속성을 관리하고, 필요한 모듈들을 빌드 과정에 포함시킨다. 이를 통해 모듈화된 프로젝트 구조를 효과적으로 유지할 수 있다. 코드 컴파일: UBT는 C++ 코드의 컴파일러를 호출하고, 소스 파일을 컴파일한 후 링커를 호출하여 최종 실행 파일을 생성한다. 이 과정에서, 필요한 전처리기 정의와 헤더 파일 포함 경로 등을 자동으로 설정한다. Unreal Header Tool 통합: UBT는 UObject를 사용하는 모듈에서 UHT를 호출하여, 필요한 헤더 파일을 생성하고, 이를 빌드 과정에 포함시킨다 " }, { "title": "Reflection System", "url": "/posts/Reflection-System/", "categories": "unreal, 용어", "tags": "unreal", "date": "2023-03-28 00:00:00 +0900", "snippet": "Reflection System Reflection System은 주로 UObject를 기반으로 작동하며, 언리얼 엔진의 다양한 시스템과 통합됩니다. 이를 통해 엔진은 런타임에 객체의 속성을 쿼리하고, 에디터에서 이를 노출하며, 블루프린트에서 C++ 코드를 호출할 수 있다 기능 런타임 클래스 탐색 및 조작: Reflection System을 통해 게임 내에서 특정 클래스의 인스턴스를 찾고, 이 클래스에 정의된 함수나 변수를 동적으로 호출하거나 수정할 수 있습니다 메타데이터 관리: 클래스와 변수에 대한 추가 정보를 저장하고, 이를 기반으로 다양한 시스템에서 활용할 수 있게 합니다. 예를 들어, 에디터에서 변수의 이름, 카테고리, 툴팁 등을 표시할 수 있습니다. 블루프린트 통합: Reflection System은 블루프린트와 C++ 코드를 긴밀하게 통합합니다. C++에서 정의된 함수나 변수를 블루프린트에서 호출하거나, 반대로 블루프린트에서 정의된 기능을 C++에서 확장할 수 있습니다. 네트워크 및 복제: 네트워크 게임에서 객체의 상태를 클라이언트와 서버 간에 동기화하는 데도 사용됩니다. 이를 통해, 네트워크를 통해 전달되는 데이터가 정확하게 복제되고 관리됩니다 Reflection System와 연관있는 매크로 UCLASS: C++ 클래스가 언리얼 엔진의 UObject 시스템에 통합되도록 지정합니다. 이 매크로가 있는 클래스는 언리얼 엔진의 다양한 시스템(예: 가비지 컬렉션, 네트워킹, 블루프린트 등)과 통합될 수 있습니다. USTRUCT: C++ 구조체를 Reflection System에 등록합니다. 이를 통해 구조체도 클래스처럼 블루프린트나 에디터에서 사용할 수 있습니다. UENUM: C++ 열거형을 Reflection System에 통합합니다. 블루프린트에서 이 열거형을 선택하거나 사용할 수 있습니다. UFUNCTION: C++ 함수를 Reflection System에 등록합니다. 이 매크로는 함수가 블루프린트에서 호출 가능하도록 하거나, 네트워크 통신을 지원하도록 설정할 수 있습니다. UPROPERTY: C++ 클래스의 멤버 변수를 Reflection System에 통합합니다. 이를 통해, 변수는 에디터의 디테일 패널에 노출되거나, 블루프린트에서 사용할 수 있습니다. Reflection System의 동작 방식 언리얼 엔진의 빌드 과정에서, UHT(Unreal Header Tool)는 C++ 헤더 파일을 스캔하여 Reflection System에 필요한 데이터를 생성합니다. 이 데이터는 .generated.h 파일에 포함되며, 런타임에서 Reflection System이 이를 참조합니다. 이 과정은 빌드 시에 자동으로 이루어지며, 이를 통해 런타임에 안전하고 일관성 있는 데이터 처리가 가능해집니다." }, { "title": "GENERATED_BODY", "url": "/posts/GENERATED_BODY/", "categories": "unreal, 용어", "tags": "unreal", "date": "2023-03-28 00:00:00 +0900", "snippet": "GENERATED_BODY, GENERED_USTRUCT_BODY 언리얼 엔진의 Reflection System과 통합되는 데 필요한 기본 코드를 자동으로 생성하는 데 사용 이 매크로들은 UHT(Unreal Header Tool)에 의해 처리되어, Reflection System에서 필요한 데이터를 생성하고, 클래스 또는 구조체가 엔진의 다양한 기능과 통합된다 GENERATED_BODY GENERATED_BODY 매크로는 주로 UCLASS 매크로가 있는 클래스에서 사용되며, 해당 클래스가 언리얼 엔진의 Reflection System과 제대로 통합되도록 기본적인 초기화 코드와 메타데이터를 생성기능 클래스 초기화: 해당 클래스에 필요한 기본 생성자와 소멸자를 생성 메타데이터 연결: 클래스에 메타데이터를 추가하여, 엔진이 클래스의 속성과 기능을 처리 Reflection 지원: 클래스가 런타임에 Reflection System에 의해 탐지되고 조작될 수 있도록 설정 GENERATED_USTRUCT_BODY GENERATED_USTRUCT_BODY 매크로는 USTRUCT 매크로가 있는 C++ 구조체에서 사용되며, 구조체가 언리얼 엔진의 Reflection System과 통합될 수 있도록 기본적인 코드를 생성 이 매크로는 구조체의 초기화와 메타데이터 설정을 처리하며, 블루프린트 및 기타 시스템과의 통합을 가능하게 함 기능 구조체 초기화: 구조체의 기본 생성자와 소멸자를 생성 메타데이터 추가: 구조체에 필요한 메타데이터를 추가하여, 엔진이 이를 인식하고 처리 Reflection 지원: 구조체가 런타임에 Reflection System에 의해 관리될 수 있도록 설정 " }, { "title": "CDO(Class Data Object)와 GDO(Global Default Object)", "url": "/posts/CDO-&&-GDO/", "categories": "unreal, 용어", "tags": "unreal", "date": "2023-03-28 00:00:00 +0900", "snippet": "CDO(Class Data Object) CDO(Class Default Object)는 언리얼 엔진에서 각 클래스에 대해 생성되는 특별한 객체로, 클래스의 기본 속성 값을 저장하는 역할. CDO는 특정 클래스의 모든 인스턴스에 적용되는 초기 상태를 정의하며, 이는 클래스의 인스턴스화 과정에서 참조된다 기능 기본 값 저장: CDO는 클래스의 속성에 대한 기본 값을 저장합니다. 이 값들은 클래스의 모든 인스턴스가 생성될 때 참조됩니다. 성능 최적화: 객체를 생성할 때 기본값을 CDO에서 복사함으로써, 성능을 향상시키고 메모리 사용을 최소화합니다. 엔진 초기화: 엔진이 시작될 때 각 UClass의 CDO가 생성됩니다. 이는 엔진의 Reflection System에서 해당 클래스의 기본 상태를 인식하고 관리할 수 있도록 도와줍니다. 동작 방식 CDO는 엔진 초기화 시 자동으로 생성 C++ 클래스의 경우, 클래스 생성자에서 설정된 값들이 CDO에 저장 블루프린트 클래스의 경우, 블루프린트 에디터에서 설정된 값들이 CDO에 저장 CDO는 이후 해당 클래스의 모든 객체 생성 시 기본 상태를 복사하는 데 사용 장점 CDO는 각 클래스의 기본 속성을 미리 저장하여 객체 생성 시 이 기본 값을 복사하는 방식으로 성능을 최적화GDO(Global Default Object) 언리얼 엔진에서 모든 클래스의 공통 기본 설정을 관리하는 객체 GDO는 시스템 수준에서 기본 설정을 관리하거나 전역적으로 적용할 설정을 저장하는 데 사용 기능 전역 설정 관리: 엔진 또는 특정 서브시스템에서 공통적으로 사용되는 설정을 관리동작방식 GDO는 특정 시스템이나 서브시스템에서 사용되며, 필요에 따라 각 클래스의 CDO와 유사한 방식으로 전역 상태를 관리합니다. 이는 CDO와 달리 특정 클래스에 종속되지 않고, 엔진의 전반적인 설정이나 공통 상태를 관리하는 데 중점을 둡니다. 장점 GDO는 시스템 또는 엔진 전체에서 공통적으로 적용될 설정이나 상태를 중앙에서 관리" }, { "title": "신장 트리", "url": "/posts/%EC%B5%9C%EC%86%8C-%EC%8B%A0%EC%9E%A5-%ED%8A%B8%EB%A6%AC/", "categories": "자료구조, Tree", "tags": "data_structure", "date": "2023-03-27 00:00:00 +0900", "snippet": "신장트리 그래프 관점에서 트리는 사이클이 없는 연결 그래프이다. 모든 정점들을 포함하면서 가장 적은 수의 간선을 사용하여 연결하는 트리를 신장 트리라고 한다. 그래프에는 여러 형태의 신장 트리가 있다. 그래프에서 순회를 하면 n-1개의 간선을 이동하면서 n개의 모든 정점을 방문하게 되므로 순회 경로는 신장트리가 된다. 깊이 우선 탐색을 이용하여 생성된 신장트리는 깊이 우선 신장트리라 하고, 너비 우선 탐색을 이용하여 생성된 신장트리는 너비 우선 신장 트리라 한다. 최소 비용 신장 트리 무방향 가중치 그래프에서 신장 트리 비용은 트리를 구성하는 간선 n-1개의 가중치를 합한 값이 된다. 이 때 가중치 합이 최소인 신장 트리를 최소 비용 신장 트리라고 한다. 최소 비용 신장 트리에는 크루스칼 알고리즘과 프림 알고리즘이 있다. 크루스칼 알고리즘 Ⅰ 크루스칼 알고리즘 Ⅰ은 가중치가 높은 간선을 제거하면서 최소 비용 신장 트리를 만든다.크루스칼 알고리즘 Ⅰ 의 순서1. 그래프의 모든 간선을 가중치에 따라 내림차순으로 정렬한다.2. 그래프에서 가중치가 가장 높은 간선을 제거한다. 단, 이때 정점을 그래프에서 분리시키는 간선을 제거할 수 없으므로 이런 경우는 그다음으로 가중치가 높은 간선을 제거한다.3. 그래프에서 간선이 n-1개만 남을 때까지 반복한다.4. 그래프에 간선이 n-1개만 남으면 최소 비용 신장 트리가 완성 된다.프림 알고리즘 프림 알고리즘은 크루스칼 알고리즘처럼 미리 간선을 정렬하지 않고,하나의 정점에서 시작하여 트리를 확장해 나가는 방법이다.프림 알고리즘의 순서1. 그래프에서 시작 정점을 선택한다.2. 선택한 정점에 부속된 모든 간선 중에서 가중치가 가장 낮은 간선을 연결하여 트리를 확장한다.3. 이전에 선택한 정점과 새로 확장된 정점에 부속된 모든 간선 중에서 가중치가 가장 낮은 간선을 삽입한다.단, 사이클을 형성하는 간선은 삽입할 수 없으므로 이런 경우에는 그다음으로 가중치가 낮은 간선을 선택한다.1. 그래프에 간선이 n-1개가 삽입될 때까지 3번을 반복한다.2. 그래프의 간선이 n-1개가 되면 최소 비용 신장 트리가 완성된다." }, { "title": "쓰레드 동기화 기법 - 1", "url": "/posts/%EC%93%B0%EB%A0%88%EB%93%9C-%EB%8F%99%EA%B8%B0%ED%99%94-%EA%B8%B0%EB%B2%95-1/", "categories": "윈도우즈시스템프로그래밍, 운영체제", "tags": "windows", "date": "2023-03-27 00:00:00 +0900", "snippet": "쓰레드 동기화 여기서 동기화란 일치함을 의미하는게 아닌 순서에 있어서 질서가 지켜지고 있음을 의미한다. 두가지 관점에서의 쓰레드 동기화 실행순서의 동기화 메모리 접근에 대한 동기화 실행순서 동기화 만일 A 쓰레드가 계산한 결과를 B 쓰레드가 받아 출력하는 경우, 반드시 A 쓰레드가 먼저 실행을 완료해야 한다. 쓰레드의 실행 순서를 정의하고 이 순서에 반드시 따르도록 하는 것이 쓰레드 동기화이다 메모리 접근 동기화 한 순간에 하나의 쓰레드만 접근해야 하는 메모리 영역이 존재한다. ex) 데이터와 힙 메모리 접근에 잇어서 동시 접근을 막는 것 또한 쓰레드의 동기화에 해당한다쓰레드 동기화에 있어 두가지 방법 유저 모드 동기화와 커널 모드 동기화가 있다.유저모드 동기화가 진행되는 동안 커널 코드가 실행되지 않는 동기화 기법 커널모드로의 전환이 없기 때문에 성능에 이점이 있지만, 기능이 제한됨 커널 모드 동기화 커널에서 제공하는 동기화 기능을 활요하는 기법 커널 모드로 변경이 필요하여 성능이 저하되지만, 유저 모드에서 사용하지 못하는 기능을 제공받는다. 임계 영역 접근 동기화 메모리 접근의 동기화는 임계 영역의 접근을 동기화하겠다는 뜻으로 해석할 수 있다.임계 영역에 대한 이해 임계영역이란 배타적 접근(한 순간에 하나의 쓰레드만 접근)이 요구되는 공유 리소스(전역변수와 같은)에 접근하는 코드블록을 의미한다. 임계 영역의 해결책은 임계 영역의 동시 접근을 막는 것이다. 동기화 기법을 통해 한 순간에 하나의 쓰레드만 접근이 가능토록 하게 한다. Windows에서 제공하는 동기화 기법 유저 모드 동기화 크리티컬 섹션 기반의 동기화 인터락 함수 기반의 동기화 커널 모드 동기화 뮤텍스 기반의 동기화 세마포어 기반의 동기화 이름 있는 뮤텍스 기반의 프로세스 동기화 이벤트 기반의 동기화 위의 5가지는 임계 영역 접근 동기화에서 사용하기 적절한 기법이다. 이벤트는 실행순서 동기화에서 사용하는 것이 적절한 기법이다.(다음장에서 설명) 아래에서 임계 영역 접근 동기화에 대한 설명을 작성할 것이다. 유저 모드의 동기화 유저 모드는 커널 모드로의 전환도 불필요하고, 커널 모드 동기화에 비해 단순하므로 이 기법으로도 해결 가능하다면 커널 모드 동기화를 사용할 필요는 없다.크리티컬 섹션 기반의 동기화 화장실(혹은 벽 어딘가) 앞에 걸어놓은 화장실 열쇠를 예시로 들어 설명한다. 임계 영역을 화장실이라고 했을 때, 이 화장실에 들어가기 위해 화장실 앞에 걸려 있는 열쇠(혹은 벽 어딘가에 걸려있는 열쇠)를 가져가야 한다. 열쇠가 걸려있다면 이 열쇠로 문을 열고 들어가면 되고, 일을 다 보고 난 후에 다시 열쇠를 화장실 앞에 걸어 놓는다. 이것이 바로 크리티컬 섹션의 동기화 방식 열쇠를 얻은 자만이 화장실(임계 영역)에 들어갈 수 있다. // critical section object는 CRITICAL_SECTION의 변수를 의미CRITICAL_SECTION gCriticalSection; // critical section object. 열쇠를 의미.InitializeCriticalSection(gCriticalSection); // 사용하기 위한 초기화 함수// 임계 영역 진입을 위한 크리티컬 섹션 오브젝트. 즉 열쇠 획득.// 여러 쓰레드 중, 빠른 하나만 열쇠를 얻고 나머지는 Blocked 상태EnterCriticalSection(&amp;gCriticalSection); // ...임계영역...// 크리티컬 섹션 오브젝트 반환. 즉 열쇠 반환.LeaveCriticalSection(&amp;gCriticalSection);// ... 중략 ...// 열쇠 소멸DeleteCriticalSection(&amp;gCriticalSection);인터락 함수 기반의 동기화 전역으로 선언된 변수 하나의 접근 방식을 동기화 하는 것이라면,이러한 용도로 특화된 인터락 함수를 사용하는 것도 나쁘지 않다. 인터락 함수는 함수 내부적으로 하나의 쓰레드에 의해서만 실행되도록 동기화되어 있다. // 값을 하나 증가시킬 32 비트 변수의 주소값 전달LONG InterlockedIncrement( LONG volatile* Addend);// 값을 하나 감소시킬 32 비트 변수의 주소값 전달LONG InterlockedDecrement( LONG volatile* Addend);// 위 함수들을 사용하면 동기화 상태에서 접근하는 것과 동일한 안정성을 보장받는다.void IncreaseCount(void){ InterlockedIncrement(&amp;gTotalCount); // ~= ++gTotalCount. 원자적 접근(Atomic Access)을 보장한다} 한 순간에 하나의 쓰레드만 접근하기 때문에 둘 이상의 쓰레드 접근에 의한 문제는 결코 발생하지 않음 크리티컬 섹션 동기화 기법도 내부적으론 인터락 함수 기반으로 구현되어 있다. 인터락 함수들은 유저 모드 기반이기 때문에 속도가 상당히 빠르다. 마이크로소프트는 MSDN에 보다 다양한 인터락 함수들을 제공한다. volatile 위 두 함수 선언에 포함된 키워드 volatile은 크게 두가지 의미를 지낸다.1. 최적화를 수행하지 말 것 컴파일러는 자동적으로 최적화를 실행한다.// 함수 원형int func(){ int a = 10; a = 20; a = 30; cout &lt;&lt; a;}// 컴파일러가 최적화한 함수int func(){ int a = 30; cout &lt;&lt; a;} 이러한 최적화때문에 문제가 발생할 수 있기 때문에 volaitle 키워드를 사용하여 최적화를 멈출 수 있다.2. 메모리에 직접 연산할 것 메모리가 아닌 Cash 메모리에 저장하여 문제가 생길 수 있다.커널 모드 동기화 유저 모드에 비해 느리지만 Windows 커널 레벨에서 제공해주는 동기화 기법이기 때문에 유저 모드 동기화에서 제공해 주지 못하는 기능을 제공받을 수 있다.뮤텍스 기반의 동기화 크리티컬 섹션 동기화에서 열쇠는 크리티컬 섹션 오브젝트이고, 이는 CRITICAL_SECTION이라는 자료형의 변수였다면, 뮤텍스 기반 동기화 기법에서 열쇠는 뮤텍스 오브젝트이다.HANDLE CreateMutex( LPSECURITY_ATTRIBUTES lpMutexAttributes, // 보안 속성을 지정 BOOL bInitialOwner, // 소유자 지정 LPCTSTR lpName // 뮤텍스 이름 지정);// If the below function fails, the return value is NULL.BOOL ReleaseMutex( HANDLE hMutex // 반환할 뮤텍스의 핸들);// If the below function fails, the return value is zero 뮤텍스는 크리티컬 섹션 오브젝트와 달리 초기화 함수의 호출이 필요 없다. 위 함수가 호출되면서 초기화가 이뤄지기 때문 뮤텍스 또한 커널오브젝트이므로 상태를 지니는데 Signaled와 Non-signaled상태가 있다. 커널 오브젝트는 Non_Signaled인 상태에서 특정 상황에 Signaled 상태가 된다. 뮤텍스는 누군가에 의해 획득이 가능할 때 Signaled상태에 놓이는데, 이 특성을 이용해 동기화를 한다.과정 쓰레드는 임계영역에 들어가기 위해 뮤텍스를 획득해야 하므로 뮤텍스 핸들 인자를 전달하며 WaitForSingleObject 함수를 호출한다. 뮤텍스가 획득 가능한 상태라면 Signaled 상태고, 뮤텍스를 획득하면서 임계 영역에 진입한다. WaitForSingleObject()함수는 인자로 전달된 핸들의 커널오브젝트가 Signaled 상태가 되어 반환하는 경우, 해당 커널 오브젝트를 Non-Signaled로 변경하므로, 다른 쓰레드들은 임계영역에 대한 진입이 제한된다. 임계 영역에서 일을 마친 쓰레드가 임계 영역을 마치면서 ReleaseMutex함수를 호출한다. 이 함수가 호출되면 뮤텍스는 Signaled가 되어 다른 쓰레드들의 진입을 허용한다. 세마포어 기반의 동기화 세마포어는 뮤텍스와 상당히 비슷하지만 차이가 있다. 그 차이는 세마포어에는 카운트 기능이 존재하고, 뮤텍스에는 존재하지 않는다. 카운터 기능이란 임계 영역에 접근 가능한 쓰레드 개수를 조절하는 기능을 의미한다. HANDLE CreateSemaphore( LPSECURITY_ATTRIBUTES lpSemaphoreAttribures, // 보안 속성 LONG lInitialCount, // 임계 영역에 접근 가능한 쓰레드 개수(열쇠 개수) LONG lMaximumCount, // 세마포어가 가질 수 있는 카운트의 최대 크기 지정 // lInitialCount와 같다면 mutex와 동일한 기능을 하고, 작을수는 없다 LPCTSTR lpName // 세마포어에 이름을 붙이기 위해 사용);// If the below function fails, the return value is NULL.BOOL ReleaseSemapohre( HANDLE hSemaphore, // 반환할 세마포어의 핸들 LONG lReleaseCount, /* 증가시킬 값의 크기 (2라면 세마포어 카운터는 2증가) 만일 최대 카운터값을 넘기면 FALSE를 반환 */ LPLONG lpPreviousCount // 변경되기 전 세마포어 카운트 값을 저장할 변수);// If the below function fails, the return value is zero 카운트가 0일 경우 Non-Signaled, 1 이상인 경우 Signaled 상태가 된다 세마포어의 핸들을 인자로 전달하면서 WaitForSingleObject 함수를 호출할 경우, 그 값이 하나씩 감소하면서 함수를 반환한다. 과정은 뮤텍스와 비슷하지만 차이점이 있다면 세마포어의 카운터가 0이 되기 전까지 WaitForSingleObject 함수를 호출할 수 있다는 점이다. 만약 0인 경우 블로킹 상태가 된다. 임계영역에 빠져나온 쓰레드는 ReleaseMutex함수가 아닌 ReleaseSemaphore 함수를 호출해야 한다. 이름 있는 뮤텍스 기반의 프로세스 동기화 위의 함수들에 생성하는 오브젝트에 이름을 붙일수 있도록 디자인되어 있음을 알 수 있다. 뮤텍스에 이름을 붙이면 이름 있는 뮤텍스, 세마포어에 이름을 붙이면 이름있는 세마포어가 된다. 지금까지는 하나의 프로세스 내에 둘 이상의 쓰레드 동기화를 목적으로 뮤텍스가 사용되었다. 뮤텍스는 커널, 즉 운영체제 소유이기 때문에 다음과 같은 형태의 동기화도 가능하다. 위 그림은 서로 다른 프로세스 영역에 존재하는 쓰레드가 뮤텍스를 이용해서 동기화 하는 상황이다. 뮤텍스는 커널 오브젝트이므로, 프로세스 A의 요청에 의해 생성되었다고 할지라도 커널에 있기 때문에 다른 프로세스에 대한 접근도 가능하다. 다만, 핸들 테이블에 커널 오브젝트와 이를 지칭하는 핸들값에 대한 정보를 담고 있어, 다른 프로세스에서 접근이 불가능하다. 이러한 접근 불가능한 상황을 해결하기 위해 뮤텍스에 이름을 붙여주기로 결정한다. 동기화가 가능하려면, 프로세스 B의 쓰레드도 뮤텍스에 접근이 가능해야 한다. 프로세스 A 쓰레드의 핸들테이블에 적힌 뮤텍스의 핸들값을 넘겨준다고 해도 프로세스 A의 핸들테이블에서만 유효한 값이다. 아래 그림에서 핸들값은 204를 의미 프로세스 B의 핸들테이블에서 204는 의미가 없다. 프로세스 A의 핸들테이블에 등록된 뮤텍스의 핸들 정보를 프로세스 B의 핸들테이블에서도 사용가능하기 위해서는 이에 대한 정보를 전달해야 한다. 하지만 다른 프로세스이기 때문에 핸들이 아닌 이름으로 전달해야 한다. CreateMutex나 CreateSemaphore의 매개변수로 뮤텍스의 이름을 지정할 수 있다. OpenMutex()함수를 통해 이름있는 뮤텍스를 지정한다.HANDLE OpenMutex( DWORD dwDesiredAccess, // 이름있는 뮤텍스로의 접근 권한을 지정 BOOL bInheritHandle, // 핸들의 상속 유무를 결정하기 위한 전달 인자 LPCTSTR lpName, /* 얻고자 하는 핸들 정보의 커널 오브젝트 이름을 전달 이름과 일치하는 뮤텍스가 있다면, 이 뮤텍스의 핸들을 반환 핸들 테이블에 정보도 추가된다.*/);// If the below function fails, the return value is NULL.뮤텍스 소유와 WAIT_ABANDONED예시전에 알아야 할 내용 WaitForSingleObject() 함수 호출 후 반환값으로 WAIT_ABANDONED가 반환될 때가 있다. 뮤텍스는 획득한 쓰레드가 직접 반환하는것이 원칙이고, 세마포어와 그 이외 동기화 오브젝트는 다른 쓰레드가 반환해줘도 문제가 되지 않는다. 예시 두 개의 쓰레드 A,B와 동기화 오브젝트인 뮤텍스 C가 존재한다. 쓰레드 A가 뮤텍스 C를 획득하고 쓰레드 B는 쓰레드 A가 뮤텍스를 반환하기를 기다린다. 그런데 예상치 못한 일로 쓰레드 A가 종료되어 뮤텍스가 반환되지 않고 사라진다. 때문에 쓰레드 B는 없어져 버린 뮤텍스 대신 WAIT_ABANDONED값을 반환하게 된다. WAIT_ABANDONED의 반환 자체는 오류가 아니다. 즉 WAIT_ABANDONED는 운영체제가 뮤텍스 반환이 정상적으로 이루어지지 않았을 때 대신 반환하는 값이다." }, { "title": "조건변수", "url": "/posts/%EC%A1%B0%EA%B1%B4%EB%B3%80%EC%88%98/", "categories": "C++", "tags": "C++", "date": "2023-03-16 00:00:00 +0900", "snippet": "조건 변수 조건 변수를 이용하면 다른 스레드가 조건을 설정하기 전이나 따로 지정한 시간이 경과하기 전까지 스레드의 실행을 멈추고 기다리게 할 수 있다. 스레드 통신을 구현할 수 있다. 윈도우의 이벤트 객체와 비슷하다. C++은 두 가지 조건 변수를 제공한다. &lt;condition_varaible&gt; 헤더파일에 정의돼 있다. 두 가지 조건 변수 std::condition_variable : unique_lock&lt;mutex&gt;만 기다리는 조건 변수 std::condition_variable_any : 커스텀 락 타입을 비롯한 모든 종류의 객체를 기다릴 수 있는 조건 변수 condition_variable이 제공하는 메서드 notify_one() : 조건 변수를 기다리는 스레드중 하나를 깨운다. notify_all() : 조건 변수를 기다리는 스레드를 모두 깨운다. wait(unique_lock&lt;mutex&gt;&amp; lk) wait()을 호출하는 스레드는 반드시 lk에 대한 락을 걸고 있어야 한다 wait()을 호출하면 lk.unlock()을 아토믹하게 호출해서 그 스레드를 블록시키고, 알림이 오길 기다린다. 다른 스레드에서 호출한 notify_one()이나 notify_all()로 인해 블록된 스레드가 해제되면, lk.lock()을 다시 호출해서 락을 완전히 걸 때까지 블록시킨 뒤 리턴한다. wait(unique_lock&lt;mutex&gt;&amp; lk, const chrono:duration&lt;Rep, Period&gt;&amp; rel_time) wait()과 비슷하지만 notify_one()이나 notify_all()이 호출되거나 지정된 시간이 만료하면 현재 스레드의 블록 상태를 해제한다. wait(unique_lock&lt;mutex&gt;&amp; lk, const chrono:duration&lt;Rep, Period&gt;&amp; rel_time) wait()과 비슷하지만 notify_one()이나 notify_all()이 호출되거나 시스템 시간이 절대 시간으로 지정한 시간을 경과하면 스레드의 블록 상태를 해제한다. 조건 변수 사용하기 큐에 담긴 원소를 백그라운드로 처리할 때 조건 변수를 사용한다고 가정한다. 처리할 원소를 추가할 큐에 정의하고, 백그라운드 스레드는 큐에 원소가 들어올 때까지 기다리다 추가되면 스레드를 깨워서 원소를 처리하고 다음 원소가 들어올 때까지 잠든 상태로 기다린다. queue&lt;string&gt; mQueue;// 하나의 스레드만 큐를 수정하기 위해 뮤텍스 선언mutex mMutex;// 백그라운드 스레드에 원소가 추가된 것을 알리기 위한 조건 변수condition_variable mCondVar; 큐에 원소를 추가하는 스레드는 뮤텍스에 락부터 걸고 나서, 큐에 원소를 추가하고 백그라운드 스레드에 알려준다. 이때 락을 걸었는지 관계없이 notify_one() 이나 notify_all() 을 호출한다. // 뮤텍스에 락을 걸고 큐에 원소 추가uniuqe_lock lock(mMutex);mQueue.push(entry);// 스레드를 깨우도록 알림mCondVar.notify_all(); 이러면 백그라운드 스레드는 무한 루프를 돌면서 알림오기를 기다린다. 이때 프레디케이트를 인수로 받는 wait()을 이용하여 비정상적으로 깨어나지 않게 만든다. 이 프레디케이트로 큐에 실제로 원소가 추가됐는지 확인한다 wait()을 호출한 결과가 리턴되면 실제로 큐에 뭔가 추가됐다고 보장할 수 있다. unique_lock lock(mMutex);while(true){ // 알림을 기다린다 mCondVar.wait(lock, [this] { return !mQueue.empty(); }); // 조건 변수를 통한 알림 도착, 큐에 무언가 추가됨 // 추가된 항목 처리}promise와 future future를 사용하면 스레드의 실행 결과를 쉽게 받아올 수 있을 뿐만 아니라 익셉션을 다른 스레드로 전달해서 원하는 방식으로 처리할 수 있다. 익셉션이 발생한 스레드에서 벗어나지 않도록 항상 같은 스레드 안에서 익셉션을 처리하는 것이 바람직하다. 스레드의 실행결과를 promise에 담으면 future로 그 값을 가져올 수 있다. 같은 스레드나 다른 스레드에서 실행하는 함수가 계산해서 리턴하는 값을 promise에 담으면 나중에 그 값을 future에서 가져갈 수 있다. future&lt;T&gt; myFuture = ...;T result = myFuture.get(); get() 함수로 가져온 결과를 result 변수에 저장하고 get()을 호출한 부분은 계산이 끝날 때까지 멈춰서 기다린다. future 하나에 대해 get()을 한 번만 호출할 수 있다. 두번 호출하는 경우는 표준에 정해져 있지 않다. 코드가 블록되지 않게 하려면 다음과 같이 future를 검사해서 결과가 준비됐는지 확인부터 한다. if(myFuture.wait_for(0)) { // 계산이 끝난 경우 T result = myFuture.get();}else { // 계산이 아직 끝나지 않은 경우 ...}std::promise와 std::future promise에 대해 set_value()를 호출해서 결과를 저장하거나, set_exception()을 호출해서 익셉션을 promise에 저장할 수 있다. 특정 promise에 대해 set_value()나 set_exception()을 단 한번만 호출할 수 있다. 여러번 호출할 경우 std::future_error 익셉션이 발생한다. 예시 A스레드가 어떤 계산을 B 스레드로 처리하기 위해 std::promise를 생성해서 B 스레드를 구동할 때 이 promise를 인수로 전달한다. 이때 promise는 복제될 수 없고, 이동만 가능 B스레드는 promise에 값을 저장하고, A스레드는 promisse를 B스레드로 이동시키기 전에 생성된 promise에 get_future()을 호출한다. 그러면 B가 실행을 마친후 나온 결과에 접근할 수 있다. void Dowork(promise&lt;int&gt; thePromise){ // 원하는 작업 수행 // 최종 결과를 promise에 저장 thePromise.set_value(42);}int main(){ // 스레드에 전달할 promise 생성 promise&lt;int&gt; myPromise; // 이 promise에 대한 future를 가져온다 auto theFuture = myPromise.get_future(); // 스레드를 생성하고 앞에서 만든 promise를 인수로 전달한다. thread theThread { Dowork, std::move(myPromise) }; // 원하는 작업 수행 ... // 최종 결과 int result = theFuture.get(); // 스레드 조인 theThread.join();} Note 위 코드는 promise와 future의 사용법을 위한 코드이다. 먼저 스레드를 생성 후, 계산한 뒤 future에 대해 get()을 호출하면 최종결과가 나올때까지 블록되지만이렇게 작성하면 성능이 크게 떨어진다. 실전에서는 future에 최종 결과가 나왔는지 주기적으로 검사하도록 구현하거나(wait_for()등으로) 조건 변수와 같은 동기화 기법을 사용하도록 구현한다. 그러면 결과가 나오기 전에 무조건 멈춘 뒤 기다리지 않고 다른 작업을 수행할 수 있다. std::packaged_task std::packaged_task를 사용하면 std::promise를 명시적으로 사용하지 않고 promise를 구현할 수 있다.예시int CalculateSum(int a, int b) { return a + b; }int main(){ // packaged_task를 생성해서 CalculateSum을 실행 packaged_task&lt;int(int, int)&gt; task(CalculateSum); // 생성한 packaged_task로부터 CalculateSum의 결과를 담을 future을 받는다. auto theFuture = task.get_future(); // 스레드를 생성한 뒤 앞에서 만든 packaged_task를 이동시키고, // 인수를 전달하고 작업 수행 thread theThread{ std::move(task), 39, 3 }; // 다른 작업 수행 // ... // 결과 int result = theFuture.get(); // 스레드 조인 theThread.join();} 스레드로 이 pacakaged_task를 이동시키는데 이 packaged_task는 복제되지 않는다. 스레드가 구동되고 나면 받아온 future에 대해 get()을 호출해서 결과를 가져오는데 이때 결과가 나오기 전까지 블록된다. std::async 스레드로 계산하는 작업을 C++ 런타임으로 좀 더 제어하고 싶다면 std::async()을 사용한다. std::async()는 실행할 함수를 인수로 받아 결과를 future로 리턴한다. async()로 구동하는 방법은 두가지다 함수를 스레드로 만들어 비동기식으로 구현 스레드를 따로 만들지 않고, 리턴된 future에 대해 get()을 호출할 때 동기식으로 함수 호출 async()에 인수를 주지 않고 호출하면 CPU의 코어 수나 동시 작업량에 따라 앞에 나온 두가지 방법 중 하나를 적절히 고른다. 다음과 같이 정책을 나타내는 인수를 정하면 이러한 선택 과정에 가이드라인을 제시할 수 있다. launch::async : 주어진 함수를 다른 스레드에서 실행시킨다.launch::deferred : get()을 호출할 때 주어진 함수를 현재 스레드와 동기식으로 실행시킨다.launch::async | launch::deferred : C++ 런타임이 결정한다(디폴트 동작)async 사용 예int calculate(){ return 123;}int main(){ auto myFuture = async(calculate); // auto myFuture = async(launch::async, calculate); // auto myFuture = async(launch::deferred, calculate); // 다른 작업 수행 // ... // 결과 int result = myFuture.get();} 이 예제에서 볼 수 있듯이 std::async()는 원하는 계산을 비동기식으로 처리하거나(다른 스레드에서), 동기식으로 처리해서 (현재 스레드에서) 나중에 결과를 가져오도록 구현하는 가장 쉬운 방법이다.async()를 호출해서 리턴된 future은 실제 결과가 담길 때까지 소멸자에서 블록된다.다시말해 async()을 호출한 뒤 리턴된 future를 가져가지(캡처하지) 않으면 async()가 블록되는 효과가 발생한다.예를 들어 다음 코드는 calculate()를 동기식으로 호출한다. async(calcualte);이 문장에서 async()는 future를 생성해서 리턴한다.이렇게 리턴된 future를 캡처하지 않으면 임시 future 객체가 생성된다그래서 이 문장이 끝나기 전에 소멸자가 호출되면서 결과가 나올 때까지 블록된다.익셉션 처리 future의 가장 큰 장점은 스레드끼리 익셉션을 주고 받는데 활용할 수 있다는 것이다. future에 대해 get()을 호출해서 계산된 결과를 리턴하거나, 이 future에 연결된 promise에 저장된 익셉션을 다시 던질 수 있다. packaged_task나 async()를 사용하면 구동된 함수에서 던진 익셉션이 자동으로 promise에 저장된다. 이때 promise를 std::promise로 구현하면 set_exception()을 호출해서 거기에 익셉션을 저장한다. int calculate(){ throw runtime_error(\"Exception thrown from calculate().\");}int main(){ // 강제로 비동기식으로 실행하도록 async를 사용 auto myFuture = async(launch::async, calculate); // 다른 작업 수행 // ... // 결과 try{ int result = myFuture.get(); cout &lt;&lt; result &lt;&lt; endl; } catch(const exception&amp; ex){ cout &lt;&lt; \"Caught exception: \" &lt;&lt; ex.what() &lt;&lt; endl; }}std::shared_future future&lt;T&gt;의 인수 T는 이동 생성할 수 있어야 한다. future&lt;T&gt;에 대해 get()을 호출하면 future로부터 결과가 이동돼 버리기 때문에 get()을 한번만 호출할 수 있다. get()을 여러 스레드에 대해 여러 번 호출하고 싶다면 std::shared_future&lt;T&gt;를 사용한다. 이때 T는 복제 생성할 수 있어야 한다 shared_future는 std::future::share()로 생성하거나 shared_future 생성자에 future를 전달하는 방식으로 생성한다. 이때 future는 복제될 수 없어서 shared_future 생성자에 이동시켜야 한다 예시 shared_future은 여러 스레드를 동시에 깨울 때 사용한다. 다음 코드는 람다 표현식 두 개를 서로 다른 스레드에서 비동기식으로 실행한다. 각 람다 표현식은 먼저 promise에 값을 설정해서 스레드가 구동됐다는 사실을 알린다. 그다음 signalFuture에 대해 get()을 호출해서 블록시켰다 future를 통해 매개변수가 설정되면 각 스레드를 실행한다. 각 람다 표현식은 promise를 레퍼런스로 캡처하고, signalFuture은 값으로 캡처한다 따라서 두 표현식 모두 signalFuture의 복제본을 들고 있다 메인 스레드는 async()을 이용해 두 람다 표현식을 서로 다른 스레드에서 비동기식으로 실행시킨다. 그러고 나서 두 스레드가 구동될 때까지 기다리다 두 스레드 모두 깨우도록 signalPromise에 매개 변수를 지정한다. auto function1 = [&amp;thread1Started, signalFuture] { thread1Started.set_value(); // 매개변수가 설정될 때까지 기다린다 int parameter = signalFuture.get();};auto function2 = [&amp;thread2Started, signalFuture] { thread2Started.set_value(); // 매개변수가 설정될 때까지 기다린다 int parameter = signalFuture.get();};// 두 람다 표현식을 비동기식으로 구동한다.// async()에서 리턴한 future를 까먹지 말고 캡처한다.auto result1 = async(launch::async, function1);auto result2 = async(launch::async, function2);// 두 스레드 모두 구동될 때까지 기다린다.thread1Started.get_future().wait();thread2Started.get_future().wait();// 이제 두 스레드 모두 구동될 때까지 기다린다// 두 스레드를 깨우는 매개변수를 설정한다.signalFuture.set_value(42);" }, { "title": "mutex와 lock", "url": "/posts/mutex%EC%99%80-lock/", "categories": "C++", "tags": "C++", "date": "2023-03-16 00:00:00 +0900", "snippet": "상호 배제 멀티스레드 프로그램을 작성할 때는 반드시 연산의 순서를 신중하게 결정해야 한다. 스레드에서 공유 데이터를 읽거나 쓰면 문제가 발생할 수 있다. 이러한 문제를 해결하기 위해서는 스레드끼리 데이터를 아예 공유하지 않거나 공유해야 한다면 한 번에 한 스레드만 접근할 수 있도록 동기화 매커니즘을 제공해야 한다. 부울값이나 정숫값을 비롯한 스칼라값은 아토믹 연산만으로도 충분히 동기화 할 수 있다. 하지만 복잡하게 구성된 데이터를 여러 스레드가 동시에 접근할 때는 동기화 매커니즘을 사용해야 한다. mutex와 lock 클래스를 통해 상호 배제 매커니즘을 제공할 수 있다.mutex 상호 배제를 뜻하는 mutual exclusion의 줄임말이다. mutex의 기본 사용법 다른 스레드와 공유하는 (읽기/쓰기용) 메모리를 사용하려면 먼저 mutex 객체에 락을 걸어야 한다.다른스레드가 먼저 락을 걸어뒀다면 그 락이 해제되거나 타임아웃으로 지정된 시간이 경과해야 쓸 수 있다. 스레드가 락을 걸었다면 공유 메모리를 마음 껏 쓸 수 있다. 물론 공유 데이터를 사용하려는 스레드마다 뮤텍스에 대한 락을 걸고 해제하는 동작을 정확히 구현해야 한다. 공유 메모리에 대한 읽기/쓰기 작업이 끝나면 다른 스레드가 공유 메모리에 대한 락을 걸 수 있도록 락을 해제한다.두 개 이상의 스레드가 락을 걸고 있다면 어느 스레드가 먼저 락을 걸어 작업을 진행할지 알 수 없다. C++ 표준은 시간 제약이 없는 뮤텍스(non-timed mutex)와 시간 제약이 있는 뮤텍스(timed mutex) 클래스를 제공한다. 시간 제약이 없는 뮤텍스 클래스 표준 라이브러리는 다음과 같은 시간 제약이 없는 뮤텍스 클래스를 제공한다. mutex recursive_mutex shared_mutex mutex와 recursive_mutex는 &lt;mutex&gt; 헤더파일에 정의돼 있고 shared_mutex는 C++17부터 추가된 헤더파일에 정의돼 있다 각 뮤텍스마다 다음과 같은 메서드를 제공한다. lock() 호출하는 측의 스레드가 락을 완전히 걸 때까지 대기한다(블록). 이 때 대기시간에 제한은 없다. 스레드가 블록되는 시간을 정하려면 시간 제약이 있는 뮤텍스를 사용한다. try_lock() 호출하는 측의 스레드가 락을 걸도록 시도한다. 현재 다른 스레드가 락을 걸었다면 호출이 즉시 리턴된다. 락을 걸었다면 try_lock()은 true를 리턴하고 ,그렇지 않으면 false를 리턴한다. unlock() 호출하는 측의 스레드가 현재 걸어둔 락을 해제한다. 그러면 다른 스레드가 락을 걸 수 있게 된다. std::mutex &lt;mutex&gt;헤더파일에 정의돼 있다. 소유권을 독점하는 기능을 제공하는 표준 뮤텍스 클래스 이 뮤텍스는 한 스레드만 가질 수 있다. 다른 스레드가 이 뮤텍스를 소유하려면 lock()을 호출하고 대기한다. try_lock()을 호출하면 락 걸기에 실패해 곧바로 리턴된다. 뮤텍스를 이미 확보한 스레드가 같은 뮤텍스에 대해 lock()이나 try_lock()을 또 호출하면 데드락이 발생한다. std::recursive_mutex &lt;mutex&gt;헤더파일에 정의돼 있다. mutex와 비슷하지만 recursive_mutex를 확보한 스레드가 동일한 recursive_mutex에 대해 lock() 이나 try_lockk()을 또 다시 호출할 수 있다. recursive_mutex에 대한 락을 해제하려면 lock()이나 try_lock()을 호출한 횟수만큼 unlock()을 호출해야 한다. std::shared_mutex &lt;shared_mutex&gt;헤더파일에 정의돼 있다. 공유 락 소유권 Or 읽기-쓰기 락이란 개념을 구현한 것. 스레드는 락에 대한 독점 소유권이나 공유 소유권을 얻는다 독점 소유권 Or 쓰기 락은 다른 스레드가 독점 소유권이나 공유 소유권을 가지고 있지 않을 때만 얻을 수 있다. 공유 소유권 Or 읽기 락은 다른 스레드가 독점 소유권을 가지고 있지 않거나 공유 소유권만 가지고 있을 때 얻을 수 있다. lock(), try_lock(), unlock() 메서드를 제공한다. 이 메서드는 독점 락을 얻거나 해제한다. lock_shared(), try_lock_shared(), unlock_shared()와 같은 공유 소유권 관련 메서드도 제공한다. 공유 소유권 버전의 메서드도 기존 메서드와 비슷하지만 획득하고 해제하는 대상이 공유 소유권이라는 점이 다르다. 시간 제약이 있는 뮤텍스 클래스 표준 라이브러리는 다음과 같은 시간 제약이 있는 뮤텍스 클래스를 제공한다. timed_mutex recursive_timed_mutex shared_timed_mutex timed_mutex와 recursive_timed_mutex 는 &lt;mutex&gt;헤더파일에 정의돼 있고 shared_timed_mutex는 &lt;shared_mutex&gt;헤더파일에 정의돼 있다. 3가지 클래스 모두 lock(), try_lock(), unlock() 메서드를 제공한다. shared_timed_mutex는 ock_shared(), try_lock_shared(), unlock_shared()도 제공한다. 추가로 다음 메서드도 제공한다. try_lock_for(rel_time) 호출하는 측의 스레드는 주어진 상대 시간 동안 락을 획득하려 시도한다. 주어진 타임 아웃 시간 안에 락을 걸 수 없으면 호출은 실패하고 false를 리턴한다. 주어진 타임아웃 시간 안에 락을 걸었다면 호출을 성공하고 true를 리턴한다. 타임 아웃은 std::chrono::duration 타입으로 지정한다. try_lock_until(abs_time) 호출하는 측의 스레드는 인수로 지정한 절대 시간이 시스템 시간과 같거나 초과하기 전까지 락을 걸도록 시도한다.그 시간 내에 락을 걸 수 있다면 true를 리턴한다. 지정된 시간이 경과하면 이 함수는 더이상 락을 걸려는 시도를 멈추고 false를 리턴한다. 절대 시간은 std::chrono::time_point로 지정한다. shared_timed_mutex는 try_lock_shared_for() 와 try_lock_shared_until()도 제공한다.lock lock 클래스는 RAII 원칙이 적용되는 클래스로서 뮤텍스에 락을 정확히 걸거나 해제하는 작업을 쉽게 처리해준다. lock 클래스의 소멸자는 확보했던 뮤텍스를 자동으로 해제시킨다. C++ 표준에서는 std::lock_guard, unique_lock, shared_lock, scope_lock의 4가지 타입의 락을 제공한다 scoped_lock는 C++17부터 추가됐다. lock_guard &lt;mutex&gt; 헤더파일에 정의돼 있다. 다음 두 가지 생성자를 제공한다. exlpicit lock_guard(mutex_type&amp; m); 뮤텍스에 대한 레퍼런스를 인수로 받는 생성자. 이 생성자는 전달된 뮤텍스에 락을 걸려 시도하고, 완전히 락을 걸릴 때까지 블록된다. lock_guard(mutex_type&amp; m, adopt_lock_t); 뮤텍스에 대한 레퍼런스와 std::adopt_lock_t의 인스턴스를 인수로 받는 생성자다. std::adopt_lock이라는 이름으로 미리 정의된 adopt_lock_t 인스턴스가 제공된다. 이 때 호출하는 측의 스레드는 인수로 지정한 뮤텍스에 대한 락을 이미 건 상태에서 추가로 락을 건다. 락이 제거되면 뮤텍스도 자동으로 해제된다. unique_lock &lt;mutex&gt; 헤더파일에 정의돼 있다. 락을 선언하고 한참 뒤 실행될 때 락을 걸도록 지연시키는 기능을 제공한다. owns_lock()이나 unique_lock에서 제공하는 bool 타입 변환를 사용해 lock이 걸렸는지 확인할 수 있다. 다음과 같은 생성자를 제공한다. explicit unique_lock(mutex_type&amp; m); unique_lock(mutex_type&amp; m, defer_lock_t) noexcept; unique_lock(mutex_type&amp; m, try_to_lock_t); unique_lock(mutex_type&amp; m, adopt_lock_t); unique_lock(mutex_type&amp; m, const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time); unqiue_lock(mutex_type&amp; m, const chrono::duration&lt;Rep, Period&gt;&amp; rel_time); 다음과 같은 메서드를 제공한다. lock() try_lock() try_lock_for() try_lock_until() unlock() shared_lock &lt;shared_mutex&gt; 헤더파일에 정의돼 있다. unique_lock과 같은 생성자와 메서드를 제공하고, 내부 공유 뮤텍스에 대해 공유 소유권에 관련된 메서드를 호출한다는 점이 다르다. shared_lock 메서드는 lock(), try_lock()을 호출할 때 내부적으로 lock_shared(), try_lock_shared()등 공유 뮤텍스에 대한 메서드를 호출한다. 이렇게 하는 이유는 shared_lock와 unique_lock의 인터페이스를 통일시켜 unique_lock을 사용하던 자리에 그대로 넣을 수 있기 때문 한 번에 여러 개의 락을 동시에 걸기 C++는 두 가지 제네릭 락 함수를 제공한다. 이 함수는 데드락이 발생할 걱정 없이 여러 개의 뮤텍스 객체를 한 번에 거는데 사용된다. lock()는 인수로 지정된 뮤텍스 객체를 데드락 발생 걱정 없이 한꺼번에 락을 건다. 이 때 락을 거는 순서는 알 수 없다. 그 중 어느 하나의 뮤텍스 락에 대해 익셉션이 발생하면 이미 확보한 락에 대해 unlock()을 호출한다. * lock()함수의 프로토 타입template &lt;class L1, class L2, class... L3&gt; void lock(L1&amp;, L2&amp;, L3&amp;...); try_lock의 프로토타입도 비슷하지만, 주어진 모든 뮤텍스 객체에 대해 락을 걸 때 try_lcok()을 순차적으로 호출한다. 모든 뮤텍스에 대해 try_lock()이 성공하면 -1을 리턴, 하나라도 실패하면 확보된 락에 대해 unlock()을 호출한다. 예시 먼저 두 뮤텍스 에 대한 락을 생성하고, std::defer_lcok_t 인스턴스를 unqiue_lock의 두 번째 인수로 지정해 그 시간안에 락을 걸지 못하게 한다. mutex mut1;mutex mut2;void process(){ unique_lock lock1(mut1, defer_lock); // C++17 unique_lock lock2(mut2, defer_lock); // C++17 lock(lock1,lock2); // 락을 걸었다.} // 락을 자동으로 해제한다.scoped_lock &lt;mutex&gt; 헤더파일에 정의돼 있다. lock_guard과 비슷하지만 뮤텍스를 지정하는 인수 개수에 제한이 없다. scoped_lock을 사용하면 여러 락을 한번에 거는 코드를 간편하게 작성할 수 있다. mutex mut1;mutex mut2;void process(){ scoped_lock locks(lock1,lock2); // 락을 걸었다.} // 락을 자동으로 해제한다." }, { "title": "heap", "url": "/posts/heap/", "categories": "자료구조, Tree", "tags": "data_structure", "date": "2023-03-15 00:00:00 +0900", "snippet": "heap 완전 이진 트리에 있는 노드 중에서 키값이 가장 큰 노드나 키값이 가장 작은 노드를 찾기 위해 만든 자료구조 키값이 가장 큰 노드를 최대 히프(Max heap)라 하고 가장 작은 노드를 최소 히프(Min heap)라 한다. 최대 히프(Max heap) 부모 노드의 키값이 자식 노드의 키값보다 항상 크거나 같은 크기의 관계(부모 노드의 키값&gt;= 자식 노드의 키값)의 관계를 가지는 노드들의 완전 이진 트리이다. 최대 히프에서는 키값이 가장 큰 노드가 루트 노드가 된다. 최소 히프(Min heap) 부모 노드의 키값이 자식 노드의 키값보다 항상 작거나 같은 크기의 관계(부모 노드의 키값 &lt;&gt;= 자식 노드의 키값)의 관계를 가지는 노드들의 완전 이진 트리이다. 최소 히프에서는 키값이 가장 작은 노드가 루트 노드가 된다. 히프의 삽입연산 단계 완전 이진 트리의 조건이 만족하도록 다음 자리를 확장한다. 부모 노드와 크기 조건이 만족하도록 삽입 원소의 위치를 찾는다. 예시1 마지막 노드의 다음 자리를 확장하여 삽입하고 부모 노드보다 작은 경우예시2 마지막 노드의 다음 자리를 확장하여 삽입하고 부모 노드보다 큰 경우히프의 삭제연산 히프에서 원소를 삭제하는 연산은 언제나 루트 노드에 있는 원소를 삭제하여 반환한다. 최대 히프에서 수행하는 삭제 연산은 가장 큰 원소를 삭제하여 반환하는 연산이다 최소 히프에서 수행하는 삭제 연산은 가장 작은 원소를 삭제하여 반환하는 연산이다 히프의 삭제 연산에서 중요한 것은 루트 노드의 원를 삭제한 후에도 완전 이진 트리의 형태와 노드의 키값에 대한 히프의 조건이 유지되어야 한다. 예시 루트노드의 원소를 삭제한다. 완전 이진 트리의 형태를 유지해야 하므로 마지막 노드를 루트 노드에 임시 저장한다. 이 후에 키값의 관계가 유지되어야 하므로(여기서는 최대히프) 루트 노드의 양쪽 자식 노드의 크기와 비교하여 세 개의 키값 중 가장 큰 원소가 부모 노드가 되도록 바꾼다. 만약 루트노드에서 자식노드로 이동했다면 이동한 노드의 위치의 자식 노드들과 비교하여 자리를 바꾼다. Code 1차원 배열로 구현하면 인덱스 관계를 이용하여 부모 노드를 찾기가 쉽다. 부모노드의 인덱스 = i/2 왼쪽 자식 노드의 인덱스 = i*2 오른쪽 자식 노드의 인덱스 = i*2+1 heap.h#define MAX_ELEMENT 100// 히프에 대한 1차원 배열과 히프 원소의 개수를 구조체로 묶어서 선언typedef struct { int heap[MAX_ELEMENT]; int heap_size;} heapType;heapType* createHeap();void insertHeap(heapType* h, int item);int deleteHeap(heapType* h);void printHeap(heapType* h); heap.cheapType* createHeap() { heapType* h = (heapType*)malloc(sizeof(heapType)); h-&gt;heap_size = 0; return h;}// 히프에 item을 삽입하는 연산void insertHeap(heapType* h, int item) { int i; h-&gt;heap_size = h-&gt;heap_size + 1; i = h-&gt;heap_size; while ((i != 1) &amp;&amp; (item &gt; h-&gt;heap[i / 2])) { h-&gt;heap[i] = h-&gt;heap[i / 2]; i /= 2; } h-&gt;heap[i] = item;}// 히프의 루트를 삭제하여 반환하는 연산int deleteHeap(heapType* h) { int parent, child; int item, temp; item = h-&gt;heap[1]; temp = h-&gt;heap[h-&gt;heap_size]; h-&gt;heap_size = h-&gt;heap_size - 1; parent = 1; child = 2; while (child &lt;= h-&gt;heap_size) { if ((child &lt; h-&gt;heap_size) &amp;&amp; (h-&gt;heap[child]) &lt; h-&gt;heap[child + 1]) child++; if (temp &gt;= h-&gt;heap[child]) break; else { h-&gt;heap[parent] = h-&gt;heap[child]; parent = child; child = child * 2; } } h-&gt;heap[parent] = temp; return item;}// 1차원 배열 히프의 내용을 출력하는 연산void printHeap(heapType* h) { int i; printf(\"Heap : \"); for (i = 1; i &lt;= h-&gt;heap_size; i++) printf(\"[%d] \", h-&gt;heap[i]);}" }, { "title": "atomic", "url": "/posts/atomic/", "categories": "C++", "tags": "C++", "date": "2023-03-14 00:00:00 +0900", "snippet": "아토믹 연산 라이브러리 아토믹 타입을 사용하면 동기화 기법을 적용하지 않고 읽기와 쓰기를 동시에 처리하는 아토믹 접근이 가능하다.비교 아토믹 연산을 사용하지 않고 값을 증가시키면 스레드에 안전하지 않다. 컴파일러는 먼저 메모리에서 이 값을 읽고, 레지스터로 불러와서 값을 증가시킨 다음, 그 결과를 메모리에 다시 저장한다. 이 과정에서 같은 메모리 영역을 다른 스레드가 건드리면 데이터 경쟁이 발생한다. int counter = 0; // 전역 변수++counter; // 여러 스레드에서 실행한다. counter 변수에 std::atomic 타입을 적용하면 동기화 기법을 따로 사용하지 않고도 스레드에 안전하게 만들 수 있다.atomic&lt;int&gt; counter(0); // 전역 변수++counter; // 여러 스레드에서 실행한다.아토믹 설명 &lt;atomic&gt; 헤더 파일을 인클루드해야 한다. atomic 클래스는 정수형 또는 포인터 타입에 대해 산술 연산들을 atomic하게 수행할 수 있도록 해 주는 템플릿 클래스이다. C++ 표준은 언어에서 제공하는 모든 기본 타입마다 네임드 정수형 아토믹 타입을 정의하고 있다. 네임드 아토믹 타입 동등std::atomic 타입 atomic_bool atomic&lt;bool&gt; atomic_char atomic&lt;char&gt; atomic_uchar atomic&lt;unsinged char&gt; atomic_int atomic&lt;int&gt; atomic_uint atomic&lt;unsigned int&gt; atomic_long atomic&lt;long&gt; atomic_ulong atomic&lt;unsigned long&gt; atomic_llong atomic&lt;long long&gt; atomic_ullong atomic&lt;unsigned long long&gt; atomic_wchar_t atomic&lt;wchar_t&gt; 아토믹 타입을 사용할 때는 동기화 메커니즘을 명시적으로 사용하지 않아도 된다. 하지만 특정 타입에 대해 아토믹 연산으로 처리할 때는 뮤텍스와 같은 동기화 메커니즘을 내부적으로 사용하기도 한다. 예를 들어 아토믹 방식으로 처리하는 인스터럭션을 타깃 하드웨어에서 제공하지 않을 수 있다. 이럴 때는 아토믹 타입에 대해 is_lock_free() 메서드를 호출해서 잠그지 않아도 되는지(lock-free 인지), 즉 명시적으로 동기화 메커니즘을 사용하지 않고도 수행할 수 있는지 확인한다. 아토믹 타입 사용예 다음과 같이 정수 레퍼런스 매개변수를 루프 안에서 증가시키도록 구현된 increment() 함수를 예시로 든다. std::this_thread::sleep_for()로 루프를 한 바퀴 돌 때마다 일정한 시간을 지연시킨다. sleep_for()는 std::chrono::duration 타입의 인수를 하나로 받는다.void increment(int&amp; counter){ for(int i = 0;i &lt; 100; ++i) { ++counter; this_thread::sleep_for(1ms); }} 이렇게 정의한 increment() 함수를 실행하는 스레드를 여러 개 띄운다고 한다면, counter 변수 하나를 여러 스레드가 공유하게 된다. 아토믹이나 스레드 동기화 메커니즘을 사용하지 않고 단순하게 구현한다면 데이터 경쟁이 발생한다. 아래 코드는 스레드 열 개를 생성하고 ,모든 작업이 끝날 때까지 기다리도록 각 스레드마다 join()을 호출한다. int main(){ int counter = 0; vector&lt;thread&gt; threads; for (int i = 0; i &lt; 10; i++) { threads.push_back( thread{increment, ref(counter)}); } for(auto&amp; : t : threads) { t.join(); } cout &lt;&lt; \"Result = \" &lt;&lt; counter &lt;&lt; endl;} 스레드 열 개를 실행하면 각각 동일한 counter 공유 변수에 대해 increment()를 실행 시켜 1000이란 결과를 만들려 한다. 하지만 프로그램을 여러차례 실행시켜보면 예상과 다른 결과가 나온다. 데이터 경쟁이 발생하는 것을 해결하기 위해 아토믹 타입을 사용하도록 수정해야 한다. // 위 코드에서 바뀌는 부분만 수정void increment(atomic&lt;int&gt;&amp; counter){ ...}int main(){ atomic&lt;int&gt; counter(0); ...} ++counter 연산을 수행하는데 필요한 불러오기,증가,저장 작업을 하나의 아토믹 트랜잭션으로 처리해 중간에 다른 스레드가 개입할 수 없어 데이터 경쟁이 발생하지 않는다. 하지만 아토믹이나 동기화 매커니즘을 사용할 때 동기화를 위한 작업으로 인해 성능이 떨어지기 때문에 이 부분을 처리하는데 걸리는 시간을 간소화하도록 구현해야 한다. increment()처럼 간단한 코드라면 로컬 변수에 대해 결과를 계산하도록 만들고, 루프를 마친 후 그 결과를 counter 레퍼런스로 추가하도록 작성해야 하는 것이 가장 바람직하다. 이렇게 할 때도 아토믹 타입을 사용해야 한다. 여러 스레드가 counter 변수에 쓰는 작업을 수행한다는 점은 변하지 않기 때문이다. void increment(atomic&lt;int&gt;&amp; counter){ int result = 0; for(int i = 0;i &lt; 100; ++i) { ++result; this_thread::sleep_for(1ms); } counter += result;}아토믹 연산 C++ 표준에서는 여러 가지 아토믹 연산을 정의하고 있다.예제 정수 아토믹 타입에 적용되는 atomic&lt;T&gt;::fetch_add()를 사용한다. fetch_add()는 주어진 아토믹 타입의 현재 값을 가져와서 지정한 값만큼 증가시킨 다음, 증가시키기 전의 값을 리턴한다. atomic&lt;int&gt; value(10);cout &lt;&lt; \"Value = \" &lt;&lt; value &lt;&lt; endl;int fetched = value.fetch_add(4);cout &lt;&lt; \"Fetched = \" &lt;&lt; fetched &lt;&lt; endl;cout &lt;&lt; \"Value = \" &lt;&lt; value &lt;&lt; endl;// fetch와 value 변수의 값을 건드리는 스레드가 없다면 결과가 다음과 같이 나온다Value = 10Fetched = 10Value = 14 아토믹 연산은 대부분 원하는 메모리 순서를 지정하는 매개변수를 추가로 받는다.T atomic&lt;T&gt;::fetch_add(T value, memory_order = memory_order_seq_cst); 그러면 디폴트로 설정된 memory_order 값을 다른 값으로 변경시킬 수 있다. C++ 표준에서는 memory_order_relaxed, memory_order_consume, memory_order_acquire, memory_order_release, memory_order_acq_rel, memory_order_seq_cst 를 제공하고 있다. https://en.cppreference.com/w/cpp/atomic/memory_order " }, { "title": "RadixSort", "url": "/posts/RadixSort/", "categories": "자료구조, Sort", "tags": "data_structure", "date": "2023-03-12 00:00:00 +0900", "snippet": "기수 정렬 기수 정렬 분배 방식의 정렬 방법으로 정렬할 원소의 키값에 해당하는 버킷(bucket)에 원소를 분배하였다가 버킷의 순서대로 원소를 꺼내는 방법을 반복해서 정렬하는 방법 시간 복잡도 기수 정렬의 수행시간은 정렬할 원소의 수 n, 키값의 자릿수 d, 버킷수를 결정하는 기수 r에 따라 달라진다. 정렬할 원소 n개를 r개의 버킷에 분배하는 작업이 (n+r)이고, 이 작업을 자릿수 d만큼 반복해야하므로 수행할 작업은 d(n+r)이다. 고로 시간 복잡도는 O(d(n+r))이 된다. 특징 원소의 키를 표현하는 값의 기수만큼 버킷이 필요하고, 키값의 자릿수만큼 기수 정렬을 반복한다. 기수 정렬은 n개의 원소에 대한 n개의 메모리 이외에 버킷 큐에 대한 메모리 공간이 추가로 필요하다. Code#include#include \"LinkedQueue.h\"#define RADIX 10 // 정렬할 자료의 키값이 10진수이므로 10으로 정의#define DIGIT 2 // 정렬할 자료의 키값이 두 자리이므로 2로 정의void radixsSort(int a[], int n){ int i,bucket,d,factor = 1; // 정렬할 자료의 기수, 즉 RADIX에 따라 10개의 버킷을 큐로 생성 LQueueType* Q[RADIX]; // 버킷 큐의 헤드 포인터를 포인터 배열로 선언 for(bucket = 0; bucket &lt; RADIX; bucket++) Q[bucket] = createLinkedQueue(); // 키값의 자릿수만큼, 즉 두번 기수 정렬을 반복 수행 for(d = 0;d &lt; DIGIT; d++){ // 키값의 1의 자리에 대한 버킷을 찾아 원소를 저장(enQueue) for(i = 0;i&lt; n;i++) enLQueue(Q[ (a[i] / factor) % RADIX] , a[i]); // 버킷 0부터 9까지 저장된 원소를 순서대로 꺼내어(deQueue) 배열 a에 저장 for(bucket = 0; bucket &lt; RADIX; bucket++) while(!isLQEmpty(Q[bucket])) a[i++] = deLQueue(Q[bucket]); // 1의 자리에 대해 기수 정렬이 끝난 현재 상태를 출력 printf(\"\\n\\n %d 단계 : \",d+1 ); for(i = 0;i&lt; n;i++) printf(\" %3d\", a[i]); // 10의 자리에 대해 기수 정렬을 반복하기 위해 factor을 상위 단위로 수정(1의 자리 -&gt; 10의 자리) factor = factor * RADIX; }}" }, { "title": "Priority Queue", "url": "/posts/Priority-Queue/", "categories": "STL, stl", "tags": "coding test", "date": "2023-03-12 00:00:00 +0900", "snippet": "Priority Queue특징 우선순위 큐는 보통 힙(heap)이라는 자료구조로 구현 힙은 완전 이진 트리 우선순위 큐는 일반적인 큐와 비슷하지만, 요소가 삽입될 때 우선순위에 따라 정렬되며, 가장 높은 우선순위를 가진 요소가 먼저 꺼낸다. 모든 정점은 자신의 자식들보다 우선순위가 높다. top이 최댓값인 우선순위 큐를 최대 힙, 최솟값인 우선순위 큐를 최소 힙이라 함 다른 원소들을 다 넣고 전부 pop하면 정렬된 순서로 원소들이 빠져나오게 되는데, 이걸 사용하는 정렬을 힙 소트(heap sort)헤더파일 #include &lt;queue&gt;성능 추가 연산 성능은 O(log(N)) 삭제 연산 성능은 O(log(N)) priority_queue의 기본 구조template &lt;typename T, typename Container = std::vector&lt;T&gt;, typename Compare = std::less&lt;typename Container::value_type&gt;&gt;class priority_queue; T는 우선순위 큐에 저장될 요소의 타입 Container는 요소를 저장할 컨테이너 타입을 나타냅니다. 기본적으로 std::vector가 사용된다. Compare는 요소를 비교하는데 사용될 함수 객체 타입을 나타낸다. 기본적으로는 std::less를 사용하여 요소를 내림차순으로 정렬한다. priority_queue의 함수void push( const value_type&amp; value );void push( value_type&amp;&amp; value ); 주어진 요소를 우선순위 큐에 삽입합니다.std::pop_heap(c.begin(), c.end(), comp); c.pop_back(); 우선순위 큐에서 가장 높은 우선순위를 가진 요소를 제거합니다.const_reference top() const; top(): 우선순위 큐에서 가장 높은 우선순위를 가진 요소에 대한 참조를 반환합니다.bool empty() const;[[nodiscard]] bool empty() const; empty(): 우선순위 큐가 비어있는지 여부를 반환합니다.size_type size() const; size(): 우선순위 큐의 요소 수를 반환합니다.priority_queue의 예시#include &lt;iostream&gt;#include &lt;queue&gt;int main() { // std::priority_queue를 선언하고 초기화합니다. std::priority_queue&lt;int&gt; myQueue; // 요소를 추가합니다. myQueue.push(3); myQueue.push(1); myQueue.push(4); myQueue.push(1); myQueue.push(5); // 가장 높은 우선순위를 가진 요소를 출력합니다. std::cout &lt;&lt; \"Top element: \" &lt;&lt; myQueue.top() &lt;&lt; std::endl; // 모든 요소를 제거합니다. while (!myQueue.empty()) { std::cout &lt;&lt; myQueue.top() &lt;&lt; \" \"; myQueue.pop(); } std::cout &lt;&lt; std::endl; return 0;}" }, { "title": "균형 이진 트리", "url": "/posts/%EA%B7%A0%ED%98%95-%EC%9D%B4%EC%A7%84-%ED%8A%B8%EB%A6%AC/", "categories": "자료구조, Tree", "tags": "data_structure", "date": "2023-03-11 00:00:00 +0900", "snippet": "균형 이진 트리(AVL 트리) 오른쪽 서브트리의 높이와 왼쪽 서브트리의 높이의 차이가 1 이하인 이진 탐색 트리특징 왼쪽 서브 트리 &lt; 부모 노드 &lt; 오른쪽 서브 트리의 크기 관계를 가진다. 각 노드의 왼쪽 서브 트리의 높이와 오른쪽 서브 트리 높이의 차이 (hL-hR)인 노드의 BF(균형 인수)를 관리한다. BF(균형 인수) : 한 노드에 대해 왼쪽 서브트리와 오른쪽 서브트리의 높이 차 각 노드의 균형 인수로 {-1, 0, 1}값만 가지게 함으로써 왼쪽 서브 트리와 오른쪽 서브 트리의 균형을 항상 유지한다. 단말노드의 균형인수는 0 이다. 장점 BF가 1 이하이므로 비교 연산 횟수(탐색,삽입,삭제)가 모두 시간복잡도 O(log₂n)을 가진다 동적으로 데이터 집합 크기가 바뀌고 순서가 바뀌어도 문제 없다 단점 균형 유지로 인해 일정 수준의 검색 성능을 보장하는 대신 자료의 개수가 증가하여 트리의 높이가 계속해서 높아진다. 자료의 추가나 삭제가 빈번하게 발생하면 균형 유지가 힘들어진다. AVL 트리의 회전 연산 이진 탐색 트리에서 노드를 삭제한 후, 트리를 재구성하는 작업이 필요하듯이 AVL트리도 삽입과 삭제 작업 후에 BF를 확인해 균형을 맞추는 재구성 작업이 필요하다 AVL트리의 삽입,삭제는 이진 탐색 트리의 삽입,삭제와 같고, 이후에 균형을 맞추는 작업을 회전연산을 통해 작업한다. LL 회전(Left-Left) AVL트리에 LL 유형의 불균형이 발생했을 때 적용한다. (a) 에서 균형인수에 문제가 생긴 노드 L1과 L1의 왼쪽 자식 노드 L2를 오른쪽으로 회전시키면 (b)와 같이 L2의 부모였던 L1이 L2의 오른쪽 자식 노드가 되면서 균형이 회복된다. RR 회전(Right-Right) AVL트리에 RR 유형의 불균형이 발생했을 때 적용한다. (a) 에서 균형인수에 문제가 생긴 노드 L1과 L1의 오른쪽 자식 노드 L2를 외;ㄴ쪽으로 회전시키면 (b)와 같이 L2의 부모였던 L1이 L2의 오른쪽 자식 노드가 되면서 균형이 회복된다. LR 회전(Left-Right) AVL트리에 LR 유형의 불균형이 발생했을 때 적용한다. LR 회전은 회전 연산을 두 번 수행하는 이중 회전 연산이다. 회전 불균형 문제가 있는 구간의 하위 레벨에서 수행하는 1차 회전은 BF에 문제가 생긴 노드 L1의 왼쪽 자식 노드 L2와 L2의 오른쪽 자식 노드 L3을 왼쪽으로 회전시킨는 RR 회전이다. 1차 회전으로 오른쪽 자식 노드인 L3이 왼쪽으로 회전하여 L2의 부모가 되고, 부모 노드였던 L2는 L3의 왼쪽 자식 노드가 되어 L1-L3-L2의 LL유형이 된다. 2차 회전으로 LL 회전을 수행한다. RL 회전(Right-Left) AVL트리에 RL 유형의 불균형이 발생했을 때 적용한다. RL 회전은 회전 연산을 두 번 수행하는 이중 회전 연산이다. 회전 불균형 문제가 있는 구간의 하위 레벨에서 수행하는 1차 회전은 BF에 문제가 생긴 노드 L1의 오른쪽 자식 노드 L2와 L2의 왼쪽 자식 노드 L3을 오른쪽으로 회전시킨는 LL 회전이다. 1차 회전후에 오른쪽 자식 노드인 L2의 오른쪽 자식 노드였던 L3이 오른쪽으로 회전하여 L2의 부모가 되고, L2는 L3의 오른쪽 자식 노드가 되어 L1-L3-L2의 RR유형이 된다.2차 회전으로 RR 회전을 수행한다. Code 노드typedef int element;\t// 이진 탐색 트리 element의 자료형 수정typedef struct treeNode { element key;\t\t\t\t// 데이터 필드 struct treeNode* left; \t// 왼쪽 서브 트리 링크 필드 struct treeNode* right;\t// 오른쪽 서브 트리 링크 필드} treeNode; AVL 트리#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include \"avl.h\"treeNode* LL_rotate(treeNode* parent) { treeNode* child = parent-&gt;left; parent-&gt;left = child-&gt;right; child-&gt;right = parent; return child;}treeNode* RR_rotate(treeNode* parent) { treeNode* child = parent-&gt;right; parent-&gt;right = child-&gt;left; child-&gt;left = parent; return child;}treeNode* LR_rotate(treeNode* parent) { treeNode* child = parent-&gt;left; parent-&gt;left = RR_rotate(child); return LL_rotate(parent);}treeNode* RL_rotate(treeNode* parent) { treeNode* child = parent-&gt;right; parent-&gt;right = LL_rotate(child); return RR_rotate(parent);}// 서브 트리의 높이를 구하는 연산int getHeight(treeNode* p) { int height = 0; if (p != NULL) height = MAX(getHeight(p-&gt;left), getHeight(p-&gt;right)) + 1; return height;}// 서브 트리의 높이를 이용해 균형 인수 BF를 구하는 연산int getBF(treeNode* p) { if (p == NULL) return 0; return getHeight(p-&gt;left) - getHeight(p-&gt;right);}// BF를 검사하여 불균형이 발생한 경우, 회전 연산 호출treeNode* rebalance(treeNode** p) { int BF = getBF(*p); if (BF &gt; 1) { if (getBF((*p)-&gt;left) &gt; 0) *p = LL_rotate(*p); else *p = LR_rotate(*p); } else if (BF &lt; -1) { if (getBF((*p)-&gt;right) &lt; 0) *p = RR_rotate(*p); else *p = RL_rotate(*p); } return *p;}// AVL 트리에 노드를 삽입하는 연산: 이진 탐색 연산처럼 삽입한 후에, rebalance() 호출 treeNode* insertAVLNode(treeNode** root, element x) { if (*root == NULL) { *root = (treeNode*)malloc(sizeof(treeNode)); (*root)-&gt;key = x; (*root)-&gt;left = NULL; (*root)-&gt;right = NULL; } else if (x &lt; (*root)-&gt;key) { (*root)-&gt;left = insertAVLNode(&amp;((*root)-&gt;left), x); *root = rebalance(root); } else if (x &gt; (*root)-&gt;key) { (*root)-&gt;right = insertAVLNode(&amp;((*root)-&gt;right), x); *root = rebalance(root); } else { printf(\"\\n 이미 같은 키가 있습니다! \\n\"); exit(1); } return *root;}" }, { "title": "set", "url": "/posts/set/", "categories": "STL, stl", "tags": "coding test", "date": "2023-03-11 00:00:00 +0900", "snippet": "Set특징 C++의 표준 라이브러리 컨테이너 중 하나로, 유일한 키만 포함하는 정렬된 연관 컨테이너 원소가 중복될 수 없다. 표준 라이브러리에 구현된 set은 원소에 순서가 정해져 있다. 순서를 둔 이유는 클라이언트가 원소를 나열할 때 원소 타입에 지정된 operator&lt; 연산자나 사용자가 직접 정의한 비교 연산자로 순서를 정해서 출력하기 위함 따라서 이론적으로 set에서 원소를 추가하거나 삭제하는 연산은 vector보다 빠르고 list보다 느리다. 조회 연산은 list보다 빠르고 vector보다 느리다 set은 원소의 중복을 허용치 않아서 set에 중복된 원소를 추가하려면 multiset을 사용한다. multiset도 &lt;set&gt;에 정의돼 있다. 헤더파일 #include &lt;set&gt;성능 추가 연산 성능은 O(log(N)) 삭제 연산 성능은 O(log(N)) 조회 연산 성능은 O(log(N))사용시기 원소를 정렬된 묶음에 담고, 조회/추가/삭제 성능도 모두 같게 만들고 싶을 때, 원소의 중복을 허용치 않으려면 set을 사용set의 기본 형태template &lt;typename Key, typename Compare = std::less&lt;Key&gt;, typename Allocator = std::allocator&lt;Key&gt;&gt;class set; Key는 set의 요소의 타입을 나타낸다. Compare는 요소를 비교하는데 사용할 함수 객체의 타입을 나타낸다. 기본적으로는 std::less를 사용하여 오름차순으로 정렬 Allocator는 set에서 사용할 메모리 할당자(Allocator)의 타입을 나타낸다. 기본적으로는 std::allocator를 사용 set의 함수// find 함수 오버로딩 목록1. const_iterator find (const value_type&amp; val) const;2. iterator find (const value_type&amp; val); 주어진 요소를 검색하고, 요소가 발견되면 해당 요소에 대한 반복자를 반환한다. 요소가 발견되지 않으면 std::set의 끝에 대한 반복자를 반환한다.// insert 함수 오버로딩 목록1. pair&lt;iterator,bool&gt; insert (const value_type&amp; val); pair&lt;iterator,bool&gt; insert (value_type&amp;&amp; val);2. iterator insert (const_iterator position, const value_type&amp; val); iterator insert (const_iterator position, value_type&amp;&amp; val);3. template &lt;class InputIterator&gt; void insert (InputIterator first, InputIterator last); 반복자를 이용해서 원하는 위치에 삽입한다. 만약 중복되는 Key가 있다면 무시한다.//erase 함수 오버로딩 목록1. iterator erase (const_iterator position);2. size_type erase (const value_type&amp; val);3. iterator erase (const_iterator first, const_iterator last); erase 함수는 단일(val) 혹은 범위(first, last)를 삭제할 수 있다.set의 예시#include &lt;iostream&gt;#include &lt;set&gt;int main() { // std::set을 선언하고 초기화합니다. std::set&lt;int&gt; mySet = {3, 1, 4, 1, 5, 9, 2, 6, 5, 3}; // set의 모든 요소를 출력합니다. for (int x : mySet) { std::cout &lt;&lt; x &lt;&lt; \" \"; } std::cout &lt;&lt; std::endl; // set에서 요소를 제거합니다. mySet.erase(5); // set의 모든 요소를 다시 출력합니다. for (int x : mySet) { std::cout &lt;&lt; x &lt;&lt; \" \"; } std::cout &lt;&lt; std::endl; return 0;}// 중복을 허용하지 않기 때문에, mySet에 중복되는 값인 1과 5는 한 번만 저장되고 출력1 2 3 4 5 6 91 2 3 4 6 9" }, { "title": "ShellSort", "url": "/posts/Shell-sort/", "categories": "자료구조, Sort", "tags": "data_structure", "date": "2023-03-10 00:00:00 +0900", "snippet": "셀 정렬 셀 정렬 일정한 간격으로 떨어져 있는 자료들끼리 부분집합을 구성하고, 각 부분집합에 있는 원소에 대해 삽입 정렬을 수행하는 작업을 반복하여 전체 원소를 정렬하는 방법 전체 원소보다 부분집합으로 나누어 삽입 정렬하는 것이 비교 연산과 자리 이동 연산을 줄일 수 있다. 시간 복잡도 비교 횟수는 처음 원소 상태와 상관없이 매개변수 h(부분집합을 만드는 기준)에 영향을 받아서 알고리즘 성능을 분석하기 쉽지 않지만, 일반적으로 (n¹˙²⁵)로 측정한다. [n^1.25] 셀 정렬은 삽입 정렬의 시간복잡도(n²)보다 개선된 방법이다. 특징 셀 정렬은 n개 자료의 메모리 공간과 매개변수를 저장할 공간을 사용한다. Code 셀 정렬에서 부분집합을 만드는 기준이 되는 간격을 매개변수 h에 저장한 후에 한 단계가 수행될 때마다 h값을 감소시키고 셀 정렬을 순환 호출하는데, 결국 h가 1이 될 때까지 반복하면서 정렬을 완성한다. 일반적으로 사용하는 h값은 원소 개수의 1/2을 사용하고, 한 단계를 수행할 때마다 h값을 반으로 감소시키면서 반복 수행한다. #include &lt;stdio.h&gt;void intervalSort(int a[],int begin, int end, int interval){ int i,j,them; for(i = begin + interval; i &lt;= end; i = i + interval) { item = a[i]; for(j = i -interval; j &gt;= begin &amp;&amp; item &lt; a[j]; j = j - interval) { a[j + interval] = a[j]; } a[j + interval] = item; }}void ShellSort(int a[], int size){ int i , interval; interval = size / 2; while(interval &gt;= 1) { for(i = 0; i &lt; interval; i++) intervalSort(a, i , size-1, interval); printf(\"\\n interval=%d&gt;&gt;\", interval); for(i = 0; i&lt; size ; i++) printf(\"%d\", a[i]); printf(\"\\n\"); interval =interval /2; }}int main(){ int i, list[8] = { 69,10,30,2,16,8,31,22}; int size = sizeof(list) / sizeof(list[0]); // list 배열의 원소 개수 printf(\"\\n정렬할 원소 : \"); for(i = 0; i &lt; size;i++) printf(\"%3d\", list[i]); printf(\"\\n\\n&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;셀 정렬 수행&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\\n\"); shellSort(list,size); getchar(); return 0;}" }, { "title": "이진 탐색 트리", "url": "/posts/%EC%9D%B4%EC%A7%84-%ED%83%90%EC%83%89-%ED%8A%B8%EB%A6%AC/", "categories": "자료구조, Tree", "tags": "data_structure", "date": "2023-03-10 00:00:00 +0900", "snippet": "이진 탐색 트리 이진 트리를 탐색용 자료구조로 사용하기 위해 원소 크기에 따라 노드 위치를 정의한 트리 탐색하려면 찾을 데이터를 식별할 수 있는 키값이 필요하다. 특징 모든 원소는 서로 다른 유일한 키를 갖는다. 왼쪽 서브 트리에 있는 원소들의 키는 그 루트의 키보다 작다. 오른쪽 서브 트리에 있는 원소들의 키는 그 루트의 키보다 크다. 왼쪽 서브 트리와 오른쪽 서브 트리도 이진 탐색 트리이다. 이진 탐색 트리 탐색 키값이 x인 원소를 탐색하는 경우 탐색은 항상 루트 노드에서 시작하고 키값 x와 루트노드의 키값을 비교한다. x = 루트 노드의 키값 : 원하는 원소를 찾았으므로 성공 x &lt; 루트 노드의 키값 : 루트 노드의 왼쪽 서브 트리 탐색 수행 x &gt; 루트 노드의 키값 : 루트 노드의 오른쪽 서브 트리 탐색 수행 루트 노드의 서브 트리도 이진 탐색 트리이므로 서브 트리에 대해서도 탐색을 순환적으로 반복한다.treeNode* searchBST(treeNode* root, element x){ treeNode* p; p = root; while(nullptr != p) { if(x &lt; p-&gt;key) p = p-&gt;left; else if( x = p-&gt;key) return p; else p = p-&gt;right; } printf(\"\\n 찾는 키가 없습니다.\"); return p;}이진 탐색 트리 삽입 먼저 이진 탐색 트리에 같은 원소가 있는지 확인한다. 성공하면 삽입 연산을 수행하지 않는다. 실패하면 트리에 원소가 없으므로 탐색 실패가 발생한 위치에 원소를 삽입한다. treeNode* insertBST(treeNode* root, element x){ treeNode* newNode; if(nullptr == p) { newNode = new treeNode; newNode-&gt;key = x; newNode-&gt;left = nullptr; newNode-&gt;right = nullptr; return newNode; } else if(x &lt; p-&gt;key) p-&gt;left = insertBSTNode(p-&gt;left,x); else if(x &gt; p-&gt;key) p-&gt;right = insertBSTNode(p-&gt;right,x); else printf(\"\\n 이미 같은 키가 있습니다.\"); return p;}이진 탐색 트리 삭제 이진 탐색 트리에서 노드를 삭제할 때 자식 노드의 수에 따라 경우가 나뉜다.삭제할 노드가 단말노드일 경우 삭제할 노드가 단말 노드라면 해당 노드를 삭제하고 부모 노드의 링크를 nullptr로 설정하는 것만으로 간단히 처리할 수 있다.// 삭제할 노드가 단말 노드일 경우if((nullptr == p-&gt;left) &amp;&amp; (nullptr == p-&gt;right)){ if(nullptr != parent){ if( parent-&gt;left == p) parent-&gt;left = nullptr; else parent-&gt;right = nullptr; } else root = nullptr;}삭제할 노드가 자식 노드를 한 개 가진 경우 (차수 = 1) 삭제할 노드가 자식 노드를 한개 가진 부모 노드일 경우, 노드를 삭제하고 나면 자식 노드가 트리에서 떨어진다. 이런 경우 자식 노드를 부모 노드의 자리로 올려주는 후처리 작업을 해야한다. // 삭제할 노드가 자식 노드를 한 개 가진 경우else if((nullptr == p-&gt;left) || (nullptr == p-&gt;right)){ if(nullptr != p-&gt;left) child = p-&gt;left; else child = p-&gt;right; if(parent != nullptr){ if(parent-&gt;left == p) parent-&gt;left = child; else parent-&gt;right = child; } else root = child;}삭제할 노드가 자식 노드를 두 개 가진 경우 (차수 = 2) 자식 노드를 두 개 가지고 있는 노드인 경우에는 직계 자식 노드뿐만 아니라 전체 자손 노드중에서 후계자를 찾는다. 노드가 삭제되고 자손 노드에게 물려준 후에도 유지되어야 한다. 그러려면 후계자로 선택된 자손 노드의 키값은 왼쪽 서브 트리의 값들보다 커야하고 오른쪽 서브 트리의 값들보다 작아야 한다. 그래서 왼쪽 서브 트리에서 가장 큰 자손 노드를 후계자로 하거나 오른쪽 서브 트리에서 가장 작은 자손 노드를 후계자로 선택해야 한다. // 삭제할 노드가 자식 노드를 두 개 가진 경우else{ succ_parent = p; succ = p-&gt;left; while(nullptr != succ-&gt;right){ // 왼쪽 서브 트리에서 후계자 찾기 succ_parent = succ; succ = succ-&gt;right; } if(succ_parent-&gt;left == succ) succ_parent-&gt;left = succ-&gt;left; else succ_parent-&gt;right = succ-&gt;left; p-&gt;key = succ-&gt;key; p = succ;}Codevoid deleteBSTNode(treeNode* root, element key){ treeNode* parent, *p, *succ, *succ_parent; treeNode* child; parent = nullptr; p = root; // 삭제할 노드의 위치 탐색 while((nullptr != p) &amp;&amp; (p-&gt;key !=key)){ parent = p; if (key &lt; p-&gt;key) p = p-&gt;left; else p = p-&gt;right; } // 삭제할 노드가 없는 경우 if(nullptr == p){ printf(\"\\n 찾는 키가 이진 트리에 없습니다.\"); return; } // 삭제할 노드가 단말 노드일 경우 if((nullptr == p-&gt;left) &amp;&amp; (nullptr == p-&gt;right)){ if(nullptr != parent){ if( parent-&gt;left == p) parent-&gt;left = nullptr; else parent-&gt;right = nullptr; } else root = nullptr; } // 삭제할 노드가 자식 노드를 한 개 가진 경우 else if((nullptr == p-&gt;left) || (nullptr == p-&gt;right)){ if(nullptr != p-&gt;left) child = p-&gt;left; else child = p-&gt;right; if(parent != nullptr){ if(parent-&gt;left == p) parent-&gt;left = child; else parent-&gt;right = child; } else root = child; } // 삭제할 노드가 자식 노드를 두 개 가진 경우 else{ succ_parent = p; succ = p-&gt;left; while(nullptr != succ-&gt;right){ // 왼쪽 서브 트리에서 후계자 찾기 succ_parent = succ; succ = succ-&gt;right; } if(succ_parent-&gt;left == succ) succ_parent-&gt;left = succ-&gt;left; else succ_parent-&gt;right = succ-&gt;left; p-&gt;key = succ-&gt;key; p = succ; } delete p;}" }, { "title": "map", "url": "/posts/map/", "categories": "STL, stl", "tags": "coding test", "date": "2023-03-10 00:00:00 +0900", "snippet": "map특징 클래스 템플릿으로, 연관 배열을 표현한 것 내부적으로 레드-블랙 트리(Red-Black Tree)라는 자료구조를 사용하여 요소들을 정렬하고 저장한다. map은 키/값 쌍으로 저장하며 원소를 값이 아닌 키를 기준으로 정렬한 상태를 유지한다. operator[]도 제공한다 헤더파일 #include &lt;map&gt;성능 추가 연산 성능은 O(log(N)) 삭제 연산 성능은 O(log(N)) 조회 연산 성능은 O(log(N))사용시기 원소를 키와 값이 연관된 순서쌍으로 키 값에 대해 정렬된 상태, 즉 연관 배열로 저장하면서 조회/추가/삭제 성능도 모두 같게 만들 때map의 기본 구조template &lt;typename Key, typename T, typename Compare = std::less&lt;Key&gt;, typename Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;&gt;class map; Key는 맵의 키(key)의 타입, T는 값(value)의 타입을 나타낸다. Compare는 맵의 키를 비교하는데 사용할 함수 객체의 타입을 나타낸다. 기본적으로는 std::less를 사용하여 오름차순으로 정렬 Allocator는 맵에서 사용할 메모리 할당자(Allocator)의 타입을 나타낸다. 기본적으로는 std::allocator를 사용 Map의 함수// find 함수 오버로딩 목록1. iterator find (const key_type&amp; k);2. const_iterator find (const key_type&amp; k) const; 주어진 키(key)에 해당하는 요소의 반복자(iterator)를 반환합니다. 해당 키가 없으면 end() 반복자를 반환// insert 함수 오버로딩 목록1. pair&lt;iterator,bool&gt; insert (const value_type&amp; val); template &lt;class P&gt; pair&lt;iterator,bool&gt; insert (P&amp;&amp; val);2. iterator insert (const_iterator position, const value_type&amp; val); template &lt;class P&gt; iterator insert (const_iterator position, P&amp;&amp; val);3. template &lt;class InputIterator&gt; void insert (InputIterator first, InputIterator last); 반복자를 이용해서 원하는 위치에 삽입한다. 만약 중복되는 Key가 있다면 무시한다.// erase 함수 오버로딩 목록1. iterator erase (const_iterator position);2. size_type erase (const key_type&amp; k);3. iterator erase (const_iterator first, const_iterator last); erase 함수는 단일(_Where) 혹은 범위 (_First, _Last)를 삭제한다.//[] 연산자 오버로딩 목록1. mapped_type&amp; operator[] (const key_type&amp; k);2. mapped_type&amp; operator[] (key_type&amp;&amp; k); 주어진 키(key)에 해당하는 값을 반환한다. 만약 해당 키가 없으면 새로운 키-값 쌍을 추가하고, 값은 기본값(default value)으로 초기화Map 예제#include &lt;iostream&gt;#include &lt;map&gt;int main() { // std::map을 선언하고 초기화 std::map&lt;std::string, int&gt; myMap = { {\"apple\", 2}, {\"banana\", 3}, {\"cherry\", 1} }; // 새로운 키-값 추가 myMap.insert({\"orange\", 4}); // 가장 앞에 있는 iterator를 삭제 myMap.erase(myMap.begin()); // [] 연산자를 이용하여 출력 std::cout &lt;&lt; \"banana: \" &lt;&lt; myMap[\"banana\"] &lt;&lt; std::endl;}" }, { "title": "Thread", "url": "/posts/Thread/", "categories": "C++", "tags": "C++", "date": "2023-03-10 00:00:00 +0900", "snippet": "멀티 스레드 프로그래밍 프로세서 유닛이 여러개 장착된 컴퓨터 시스템을 이용한 병렬 프로그래밍 장점 주어진 연산 작업을 작은 문제로 나눠 각각을 멀티프로세서 시스템에서 병렬로 실행하면 전반적인 성능을 높일 수 있다. 연산을 다른 관점에서 모듈화 연산을 UI스레드에 종속적이지 않은 독립 스레드로 분리해서 구현하면 처리 시간이 긴 연산을 백그라운드로 실행시키는 방식으로 UI의 응답속도를 높일 수 있다. 경쟁 상태 여러 스레드가 공유 리소스를 동시에 접근할 때 경쟁 상태가 발생 그 중에서도 공유 메모리에 대한 경쟁 상태를 흔히 데이터 경쟁이라 부른다. 테어링 데이터 경쟁의 특수한 경우로서, 읽기 테어링과 쓰기 테어링 두 가지가 있다. 읽기 테어링 어떤 스레드가 메모리에 데이터의 일부만 쓰고 나머지 부분을 미처 쓰지 못한 상태에서 다른 스레드가 이 데이터를 읽으면 두 스레드가 보는 값이 달라짐 쓰기 테어링 두 스레드가 이 데이터에 동시에 쓸 때 한 스레드는 그 데이터의 한쪽 부분을 쓰고, 다른 스레드는 그 데이터의 다른 부분을 썼다면 각자 수행한 결과가 달라짐 데드락(교착 상태) 여러 스레드가 서로 상대방 작업이 끝날 때까지 동시에 기다리는 상태를 말한다. 예시 두 스레드가 공유 리소스를 서로 접근하려면 먼저 그 리소스에 대한 접근 권한 요청부터 해야 한다. 현재 둘 중 한 스레드가 그 리소스에 대한 접근 권한을 확보한 상태로 계속 머물러 있으면 그 리소스에 대한 접근 권한을 요청하는 다른 스레드도 무한히 기다려야 한다. 이 때 공유 리소스에 대한 접근 권한을 얻기 위한 방법중 뮤텍스가 있다. 데드락이 발생하지 않게 하려면 모든 스레드가 일정한 순서로 리소스를 획득해야 한다.스레드 &lt;thread&gt;헤더 파일에 정의된 c++ 스레드 라이브러리를 사용하면 매우 간편하게 생성할 수 있다.스레드에 대한 설명 현재 시스템에서 thread 객체가 실행 가능한 상태에 있을 때 조인 가능하다고 표현한다. 이런 스레드는 실행을 마치고 나서도 조인 가능한 상태를 유지한다. 디폴트로 생성된 thread 객체는 조인 불가능하다. 조인 가능한 thread 객체를 제거하려면 먼저 그 객체의 join()이나 detach()부터 호출해야한다. join()을 호출하면 그 스레드는 블록된다. 다시말해 그 스레드가 작업을 끝날 떄까지 기다린다. deatch()를 호출하면 thread 객체를 OS 내부의 스레드와 분리한다. 그래서 OS스레드는 독립적으로 실행된다. 조인 가능 상태의 thread 객체를 제거하면 그 객체의 소멸자는 std::terminate()를 호출해서 모든 스레드뿐만 아니라 애플리케이션마저 종료시킨다.함수 포인터로 스레드 만들기 윈도우시스템의 CreateThread(), _beginthread()와 같은 함수나 pthreads 라이브러리의 pthreads_create()와 같은 스레드 함수는 매개변수를 하나만 받는다. 반면 C++ 표준에서 제공하는 std::thread 클래스에서 사용하는 함수는 매개변수를 원하는 만큼 받을 수 있다. void FuncName(int num){ ...}thread t1(FuncName, 1); thread 클래스 생성자는 가변 인수 템플릿이기 때문에 인수 개수를 원하는 만큼 지정할 수 있다 첫번째 인수는 새로 만들 스레드가 실행할 함수의 이름이고 그 뒤는 실행할 함수의 전달할 인수 개수이다. 함수 객체로 스레드 만들기 함수 포인터로 스레드를 만들면 함수에 인수를 전달하는 방식으로만 스레드에 정보를 전달할 수 있다. 반면 함수 객체로 만들면 그 함수 객체의 클래스에 멤버 변수를 추가해서 원하는 방식으로 초기화해서 사용할 수 있다. 이 클래스는 ID와 반복 횟수를 표현하는 멤버 변수를 가지고 있다. 두 변수 모두 생성자로 초기화한다. class Counter{ public: Counter(int id, int numIterations) : mId(id), mNumIterations(numIterations) { } void operator()() consst { for(int i = 0; i &lt; mNumIterations; ++i){ cout&lt;&lt; \"Counter \" &lt;&lt; mId &lt;&lt; \"has value\" &lt;&lt; i &lt;&lt; endl; } } private: int mId; int mNumIterations;};// 유니폼 초기화를 사용하는 방법thread t1{Counter{1,20}};// 일반 변수처럼 네임드 인스턴스로 초기화하는 방법Counter c(2, 12);thread t2(c);// 임시 객체를 사용하는 방법thread t3(Counter(3,10));// 세 스레드가 모두 마칠 때까지 기다린다.t1.join();t2.join();t3.join(); 함수 객체로 만드는 스레드를 초기화하는 세 가지 방법 유니폼 초기화 처리한다. Counter 생성자에 인수를 지정해서 인스턴스를 생성하면 그 값이 중괄호로 묶인 thread 생성자 인수로 전달된다. Counter 인스턴스를 일반 변수처럼 네임드 인스턴스로 정의하고, 이를 thread 클래스의 생성자로 전달한다. Counter 인스턴스를 생성해서 이를 thread 클래스 생성자로 전달하는 점에서 첫번째와 비슷하지만,중괄호가 아닌 소괄호로 묶는다 t1과 t3의 생성 과정을 비교하면 비슷하지만, 다음과 같은 차이가 있다.class Counter{ public: Counter(){} ...}int main(){ // thread t1(Counter()); // 에러! thread t1{Counter{}}; // 정상 처리 t1.join();} C++ 인터프리터는 main()의 첫줄을 t1 함수의 선언문으로 해석하기 때문에 오류가 난다. 즉 매개변수 없이 Counter 객체를 리턴하는 Counter 함수에 대한 포인터를 인수로 받아서 thread 객체를 리턴하는 t1함수로 처리한다. 이 때는 유니폼 초기화를 사용하는 것이 좋다.람다 표현식으로 스레드 만들기int main(){ int id=1; int numIterations = 5; thread t1([id, numIterations]{ for(int i=0; i&lt; numIterations; ++i){ cout&lt;&lt; \"Counter \" &lt;&lt; mId &lt;&lt; \"has value\" &lt;&lt; i &lt;&lt; endl; } }); t1.join();}멤버 함수로 스레드 만들기class Request{ public: Request(int id) : mId(id) {} void Process() { cout &lt;&lt; \"Processing request \" &lt;&lt; mId &lt;&lt; endl; } private: int mId;};int main(){ Request req(100); thread t {&amp;Request::process, &amp;req}; t.join();} 이렇게 하면 특정 객체에 있는 메서드를 스레드로 분리해서 실행할 수 있다. 똑같은 객체를 여러 스레드가 접근할 때 데이터 경쟁이 발생하지 않도록 스레드에 안전하게 작성해야한다. 스레드에 안전하게 구현하는 방법중 하나는 뒤에서 설명할 상호 배제(뮤텍스)라는 동기화 기법을 활용한다 스레드 로컬 저장소 C++ 표준은 스레드 로컬 저장소라는 개념을 제공한다. 원하는 변수에 thread_local이란 키워드를 지정해 스레드 로컬 저장소로 지원하면 각 스레드마다 이 변수를 복제해서 스레드가 없어질 때까지 유지한다. 이 변수는 각 스레드에서 한번만 초기화 된다. 밑에는 두 개의 전역 변수가 정의돼 있는데, 모든 스레드가 k의 복제본 하나를 공유하며, 각 스레드는 자신의 고유한 n 복제본을 가진다. int k;thread_local int n; 만일 thread_local 변수를 함수 스코프 안에서 선언하면 모든 스레드가 복제본을 따로 갖고 있고, 함수를 아무리 많이 호출하더라도 스레드마다 단 한 번만 초기화된다는 점을 제외하면 static으로 선언할 때와 동일하게 작동한다." }, { "title": "쓰레드의 생성과 소멸", "url": "/posts/%EC%93%B0%EB%A0%88%EB%93%9C%EC%9D%98-%EC%83%9D%EC%84%B1%EA%B3%BC-%EC%86%8C%EB%A9%B8/", "categories": "윈도우즈시스템프로그래밍, 운영체제", "tags": "windows", "date": "2023-03-09 00:00:00 +0900", "snippet": "Windows에서의 쓰레드 생성과 소멸쓰레드 생성 함수 Windows에서 사용할 수 있는 가장 기본적인 쓰레드 생성 함수HANDLE CreateThread( LPSECURITY_ATTRIBUTES lpThreadAttributes, // 핸들 테이블의 상속 여부 결정. SIZE_T dwStackSize, // 생성된 쓰레드의 스택 크기 LPTHREAD_START_ROUTINE lpStartAddress, // 쓰레드의 main 함수 역할하는 함수 포인터 __drv_aliasesMem LPVOID lpParameter, // 쓰레드 main 함수에 전달할 인자 DWORD dwCreationFlags, // 생성 옵션 LPDWORD lpThreadId // 쓰레드 ID를 전달받기 위한 변수의 주소값);생성가능한 최대 쓰레드 개수 메모리가 허용하는 만큼이다. 쓰레드가 생성될 때마다 독립된 스택을 할당해 줘야만 한다. 즉 스택을 할당할 수 있을 때 까지 쓰레드의 생성을 허용한다. 디폴트 스택 사이즈는 1MB(1메가바이트)이다. (1024x1024) CreateThread의 2번째 인자에 0(디폴트 스택 사이즈) 넣지 않고 1MB보다 큰 숫자를 넣으면 더 적은 수의 쓰레드가 생성된다. 그렇다고 1MB바이트보다 적은 숫자인 0.5MB를 넣는다고 해도 1MB바이트와 동일한 수의 쓰레드가 생성된다. 디폴트 스택 크기는 쓰레드에서 필요로 하는 최소한의 스택 크기이지만 너무 작은 스택 크기를 요구할 경우 무조건 1MB로 사이즈를 지정한다.쓰레드 소멸 가장 이상적인 쓰레드 소멸 방법은 쓰레드 함수 내에서 return 문을 통해 종료 및 소멸시키는 방법이 이상적이다.그 외에 쓰레드를 종료할 수 있는 추가적인 방법case 1. 쓰레드 종료 시 return을 이용하면 좋은 경우 (거의 대부분의 경우) 가장 일반적인 경우. 예를들어 외부로부터 입출력 작업이 아주 많이 요구되어 Blocked 상태에 자주 놓이는 작업을 생각해보자. 이 작업을 빨리끝내기 위해 총 세 개의 쓰레드를 생성해서 일의 부담을 나눠주고자 한다. 이럴 경우 정해진 시간 동안에 CPU에게 보다 많은 일을 시킬 수 있고 Blocked 상태에 놓이는 상황도 세 개의 쓰레드가 나눠서 감당하기 때문에 속도가 높아질 확률이 높다. 여기서 쓰레드가 할 일은 두 개의 숫자를 전달하면, 두 값의 합을 계산해주면 된다. case 2. 쓰레드 종료 시 ExitThread 함수 호출이 유용한 경우(특정 위치에서 쓰레드의 실행을 종료시키고자 하는 경우) ExitThread 함수는 현재 실행중인 쓰레드를 종료하고자 할 때 호출하는 함수다. return 방식의 쓰레드 종료만큼이나 선호되는 편이다. VOID ExitThread{DWORD dwExitCode // 커널 오브젝트에 등록되는 쓰레드 종료코드(Exit code)를 지정}// 종료코드는 GexExitCodeThread를 통해 알 수 있다. 장점은, 언제 어디서나 쓰레드를 종료시킬 수 있고, return문 보다 코드를 이해하기 좋다. return문은 쓰레드를 종료시키기 위해선 함수가 실행 된 만큼의 return문이 호출되어야 한다. 그러나 ExitThread에 의한 종료 시점은 어디서든 상관 없다. 하지만 주의점은, 위처럼 A B C 3개의 함수가 호출되어서 3개의 스택 프레임에 C++객체가 존재한다고 가정했을 때, C함수에서 ExitThread함수를 호출한다면 A B함수의 스택 프레임에 존재하는 객체의 소멸자는 호출되지 않는다. 따라서 메모리 유출 현상이 발생할 수도 있다. C, C++ 구분 없이 가장 좋은 방법은 역시 return문에 의한 쓰레드 종료이다. case 3. 쓰레드 종료 시 TerminateThread 함수 호출이 유용한 경우(외부에서 쓰레드를 종료시키고자 하는 경우) main함수에서 쓰레드를 생성할 경우 해당 쓰레드의 핸들을 얻게 된다. 이 핸들을 이용해서 쓰레드를 강제종료 시킬 수 있다. 외부에 의한 강제종료로 쓰레드 스스로가 종료 시점을 결정짓는 상황이 아니다. 문제는 강제종료 종료되는 시점까지도 자신이 종료된다는 사실을 인식하지 못한다. 따라서 할당받은 메모리나 리소스 해제를 처리 못하고 바로 종료된다. 이 함수의 호출이 존재하는 프로그램 코드는 문제가 있다고 인식되는 것이 보통이다. 쓰레드의 성격과 특성힙, 데이터 영역, 그리고 코드 영역의 공유에 대한 검증—————– 쓰레드는 메모리를 공유한다. 특히 전역변수가 할당되는 데이터 영역과, 메모리가 동적으로 할당되는 힙 영역을 공유한다. 동시 접근에 있어서의 문제점예를들어 10이라는 숫자가 전역변수로 있고 A쓰레드와 B쓰레드가 각각 6과 9를 더해서 저장한다고 한다면 덧셈의 과정은 3단계로 표현할 수 있다 연산이 이뤄지기 위해 메모리에 저장된 데이터를 레지스터로 이동한다 그리고 ALU에 의해 실질적인 덧셈 연산이 진행된다. 마지막으로 그 결과가 다시 메모리에 저장되는 구조로 진행이 된다. 이 때 스레드 A가 2단계까지 완료해서 16이라는 연산결과를 레지스터에 저장했다. 이제 메모리에 저장해야하는 찰나에 스케줄러가 실행의 대상을 쓰레드 B로 옮겼다. 쓰레드 B는 메모리에 10이 들어있으므로 ALU로 10을 가져다 연산해서 메모리에 19를 저장한다. 실행을 마친 쓰레드 B가 종료를 하고 쓰레드 A가 아까 하지 못했던 작업을 위해 데이터를 복원하고 나머지 절차를 진행하는데 19가 16에 의해 덮어써진다. 결과는 10 + 6 + 9 = 25가 나왔어야 했는데 16이 나오는 상황이 일어났다. 실행중인 쓰레드의 변경은 프로그램 라인 단위로 일어나지 않는다!!! printf, scanf, ++, – 를 실행시키는 중간에도 컨텍스트 스위칭은 빈번히 발생한다. 따라서 둘 이상의 쓰레드가 같은 메모리 영역을 동시에 참조하는 것은 문제를 일으킬 가능성이 높다.프로세스로부터의 쓰레드 분리 프로세스는 쓰레드를 담는 상자라고 했었다. 그렇다면 프로세스 핸들 테이블도 사실은 쓰레드 핸들 테이블이 되어야 옳지 않을까? 즉, 각각의 쓰레드별로 핸들 테이블이 존재하는 것은 아닐까? 아니다. 핸들 테이블은 프로세스 소유이다. 즉 하나의 프로세스에 하나의 핸들 테이블이 존재한다. 예를들어, 프로세스 A가 특정 리소스 C (파이프, 메일슬롯, 혹은 파일 등등)를 생성하면서 얻은 핸들값이 204라고 가정하자. 이때 프로세스 A와 전혀 관계가 없는 프로세스 B가 리소스 C의 핸들 값이 204라는 것을 알았을 때 이 숫자 정보만을 가지고 리소스 C에 접근이 가능한가? 아니다. 핸들값은 핸들 테이블에 정보가 등록된 이후에, 이 핸들 테이블의 소유자에 해당하는 프로세스에게만 의미를 지닌다. 즉 프로세스 B의 핸들 테이블에는 핸들 204에 대한 정보가 존재하지 않는다. 따라서 접근이 불가능하다. 그렇다면 쓰레드의 관점에서는 어떨까??? 프로세스 A 내에서 생성된 쓰레드들에게는 핸들 204가 의미를 지닐까? 지닌다 왜냐하면, 같은 프로세스 내에서 생성된 모든 쓰레드들은 스택 이외의 모든 것을 공유하기 때문이다. 즉 핸들 테이블까지도 공유한다. 그렇다면 Usage Count는 어떨까??? 자식 프로세스의 Usage Count는 생성과 동시에 2가 되지만, 부포 프로세스가 CloseHandle을 호출하면 하나 감소한다. 쓰레드도 마찬가지이다. 쓰레드 역시 생성과 동시에 Usage Count는 2가 된다. 하나는 쓰레드 종료 시 감소하고, 나머지 하나는 쓰레드 핸들을 인자로 CloseHandle 함수가 호출될 떄 감소한다. 따라서, 이전에 자식 프로세스의 커널 오브젝트 소멸과 관련된 문제가 동일하게 쓰레드에서도 발생할 수 있다. 부모 프로세스가 자식 프로세스를 생성했는데, 자식 프로세스가 종료되어도 Usage Count가 아직 1이어서(부모때문에) 커널 오브젝트가 소멸되지 않고 있는 상황 이러한 상황을 막기 위해 쓰레드 생성시 반환된 핸들 값을 인자로 전달하면서 CloseHandle을 곧바로 호출한다. 이렇게 되면 쓰레드의 Usage Count는 1이 되고, 쓰레드가 종료함과 동시에 0이 되면서 모든 메모리를 반환하게 된다. 이때의 CloseHandle 함수 호출을 가리켜 “프로세스로부터 쓰레드를 분리한다” 고 한다.ANSI 표준 C 라이브러리와 쓰레드 C라이브러리가 구현될 때 쓰레드에 대한 고려가 전혀 이루어지지 않았다. 따라서 멀티쓰레드 기반으로 프로그램을 구현하면 동일한 메모리 영역을 동시에 접근하는 불상사가 발생할 수 있다. _tprintf 함수는 c 라이브러리 함수인데 이 함수가 멀티쓰레드 기반에서 문제를 일으키지 않으려면?쓰레드에 안전한 런타임 라이브러리를 속성에서 선택하고, CreateThread 함수 대신 _beginthreadex 함수를 사용해야만 한다. _beginthreadex 함수는 CreateThread 함수와 동일하다. 차이는 _beginthreadex 함수는 쓰레드를 생성하기에 앞서서 쓰레드를 위해 독립적인 메모리 블록을 할당한다는 차이가 있다. 다만, 선언된 매개변수 자료형과 반환형에 차이가 있다. 때문에 쓰레드 함수 선언의 변경과 형변환이 필요할 뿐이다. 추가로 ExitThread를 return대신 사용하는 경우, _endthreadex 함수를 쓰자. 이 함수의 역할은 내부적으로 쓰레드에 할당된 메모리를 해제하고 ExitThread 함수를 호출한다. 또한 종료될 때 return문을 이용해서 종료하면 이 함수가 자동으로 호출되니, 그냥 return으로 종료한다고 생각하자. 쓰레드의 상태 컨트롤 쓰레드의 상태는 프로그램이 실행된느 과정에서 수도 없이 변한다. 입력 및 출력 연산을 시작하거나 종료하는 경우에도 변경되고 새로운 쓰레드의 생성에 의해서도 변경된다. 상황에 따라서, 운영체제 관리 방법에 따라슨 것으로, 프로그래머가 직접 상태를 컨트롤 하는 것이 아니다. 그러나 경우에 따라서 쓰레드의 상태를 프로그래머가 임의로 변경시켜야만 하는 경우도 있을 수 있다. 특정 쓰레드를 지목해서 실행을 잠시 멈추기 위해 Blocked 상태로 만든다거나 다시 실행을 재개시키기 위해서 Ready 상태로 둔다거나 하는 일이 경우에 따라서는 필요할 수 있다. 쓰레드의 상태 변화 Windows에서는 상태가 변화하는 주체가 프로세스가 아니라 쓰레드이다. 하지만 프로세스의 상태 변화와 다를 바 없다. 상황 1 &amp; 2 생성하자마자 Ready 상태에 놓인다. 스케줄러에 의해서 선택될 경우 Running 상태가 되면서 실제 실행이 이뤄진다. 따라서 Ready 상태에 놓이는 쓰레드는 여럿이 될 수 있지만, Running 상태에 놓이는 쓰레드는 하나밖에 될 수 없다. 상황 3 실행중인 쓰레드에게 할당된 타임 슬라이스(Time Slice)가 모두 소비되어, 다른 쓰레드에게 실행의 기회를 넘겨야 할 때, Running 상태에서 Ready 상태로 이동이 이루어진다. 간혹 Running 상태에서 Blocked 상태로 이동하는 것으로 오해하는 경우가 있는데, 실행의 기회를 넘겼다 하더라도 언제든지 다시 실행되어야 하기 때문에 Ready 상태로 이동하는 것이 맞다. 상황 4 &amp; 5 Running 상태에 있는 쓰레드가 입출력 연산을 하거나 Sleep 함수 호출로 인해서 잠시 실행이 중단된 경우 Blocked 상태로 이동을 하면서 다른 쓰레드의 실행을 도모하게 된다. Blocked 상태로 이동시킨 원인이 해결되면 다시 Ready 상태로 돌아가서 실행되기만을 기다린다.모든 상황은 프로세스의 상태 변화와 100% 동일하다. Suspend &amp; Resume 쓰레드의 상태를 컨트롤 하기 위해 필요한 두가지 함수를 소개한다. 특정 스레드를 지목해서 그 쓰레드를 Blocked 상태로 이동시킬 수 있고, 또 다시 Ready 상태로 옮겨놓을 수 있다. DWORD SuspendThread ( 1 )1. HANDLE hThreadBlocked 상태에 두고자 하는 쓰레드의 핸들을 인자로 전달한다DWORD ResumeThread ( 1 )2. HANDLE hThread &lt;br&gt; Ready 상태에 두고자 하는 쓰레드의 핸들을 인자로 전달한다. 첫번째 함수는 Blocked 상태에 두는 함수이다 두번째 함수는 Blocked 상태에 있는 함수를 Ready 상태에 두기 위한 함수이다. 그런데 쓰레드의 커널 오브젝트에는 SuspendThread 함수의 호출 빈도수를 기록하기 위한 서스펜드 카운트 (Suspend Count)라 불리는 멤버가 존재하는데, 현재 실행중인 쓰레드의 서스펜드 카운트는 0이다. 그러니 이 쓰레드의 핸들은 인자로 SuspendThread 함수가 호출되면, 서스펜드 카운트는 1이 되고 쓰레드는 Blocked 상태에 놓인다 그리고 다시 SuspendThread 함수가 호출되면 서스펜드 카운트는 2가 된다. 즉, SuspendThread 함수는 서스펜드 카운트 값을 하나 증가시키는 역할을 한다. 이렇게 서스펜드 카운트가 2인 상황에서는 한번의 ResumeThread 호출로 바로 Ready 상태가 되지 않는다. ResumeThread 함수의 호출은 서스펜드 카운트를 하나 감소시키는 역할을 한다. 따라서 이러한 상황에서는 두 번 호출되어야 Ready 상태에 놓이게 된다. 함수의 반환값을 통해서 서스펜드 카운트의 변화를 확인하는 것이 가능하다. 위 두 함수 모두 함수 호출이 성공하면 변경되기 이전에 저장되었던 서스펜드 카운트를 반환하기 때문이다.쓰레드의 우선순위 컨트롤 프로세스는 실행의 주체가 아닌 쓰레드를 담는 그릇에 불과하다. 따라서 Windows에서는 프로세스가 우선순위를 갖는 것이 아니다. 프로세스 안에서 동작하는 쓰레드가 우선순위를 갖는다. 프로세스의 기준 우선순위 쓰레드의 상대적 우선순위쓰레드의 우선순위는? 프로세스의 기준 우선순위와, 쓰레드의 상대적 우선순위의 조합으로 정해진다. 즉, 프로세스의 기준 우선순위를 기준으로 해서 상대적 우선순위에 해당하는 값을 더하거나 빼면 쓰레드의 실질적인 우선순위를 계산해 낼 수 있다. 표에 있는 우선순위 상수들은 Windows 버전별로 차이가 있다. 프로세스 내에서 생성되는 모든 쓰레드의 상대적 우선순위는? THREAD_PRIORITY_NORMAL이다. 즉 프로세스의 기준 우선순위를 그대로 수용하는 것이다. 변경하기 위해서는 두 함수를 쓴다 BOOL SetThreadPriority ( HANDLE hThread, int nPriority ) 첫번째 인자는 우선순위를 변경할 쓰레드의 핸들, 두번째 인자는 표의 상수값이다. int GetThreadPriority ( HANDLE hThread )" }, { "title": "바인더", "url": "/posts/%EB%B0%94%EC%9D%B8%EB%8D%94/", "categories": "C++", "tags": "C++", "date": "2023-02-26 00:00:00 +0900", "snippet": "바인더(binder)1 - bind 함수 객체를 생성할 때 인자를 지정하게 해주는 함수 &lt;functional&gt; 헤더 파일에 정의된 std::bind()를 이용한다. 기본적으로 std::function을 이용하여 타입을 지정할 수 있지만, auto를 사용하는게 간편하다. void func(int num, string_view str){ cout &lt;&lt; \"func(\" &lt;&lt; num &lt;&lt; \", \" &lt;&lt; str &lt;&lt; \")\" &lt;&lt; endl;}===========int main(){ std::function&lt;void()&gt; f1 = std::bind(func,1,\"abc\"); // auto f1 = std::bind(func,1,\"abc\"); f1();} f1은 함수func()에 인자값이 1과 abc가 들어가 있는 상태의 함수 객체2 - 인자를 변수로 지정 바인더를 이용하면 호출 가능 개체의 매개변수를 일정한 값으로 묶어둘(바인딩) 수 있다.void func(int num, string_view str){ cout &lt;&lt;\"func(\" &lt;&lt; num &lt;&lt; \", \" &lt;&lt; str &lt;&lt; \")\" &lt;&lt; endl;}string myString = \"abc\";auto f1 = bind(func, placeholders::_1, myString);// placeholders::_1의 다음 인자값인 myString을 첫 번째 매개변수에 지정f1(16);// f1(16)은 func(16,abc)로 실행된다. func()의 두 번째 인수를 myString의 값을 이용해서 고정된 값을 바인딩한다. 특정한 값에 바인딩 되지 않은 인수는 반드시 std::placeholders 네임 스페이스에 정의된 _1,_2,_3등으로 지정해야 한다. _1은 func()을 호출할 때 f1()의 첫 번째 인수가 들어갈 지점을 지정한다. 3 - 인수의 순서 바꾸기 bind()로 인수의 순서를 바꿀 수 있다.auto f2 = bind(func, placeholderss::_2 , placeholders::_1);f2(\"Test\", 32); 여기서 _2는 func()을 호출할 때 f2()의 두 번째 인수가 들어갈 지점을 지정한다.4 - bind를 이용한 레퍼런스 &lt;functional&gt; 헤더파일에 std::ref()와 cref() 헬퍼 템플릿 함수가 정의돼 있다. 이를 사용하면 레퍼런스나 const 레퍼런스를 바인딩 할 수 있다. void increment(int&amp; value) {++value;}int index = 0;increment(index); increment()를 호출하면 index의 값은 1 증가 이 함수를 다음과 같이 bind()로 호출하면 index의 값이 증가하지 않는다. index의 복제본에 대한 레퍼런스가 increment()함수의 첫 번째 매개변수로 바인딩되기 때문이다. int index = 0;auto incr = bind(increment, index);incr(); incr()함수를 호출해도 index의 값이 증가하지 않음 다음과 같이 std::ref()로 레퍼런스를 제대로 지정하면 index의 값이 증가한다.int index = 0;auto incr = bind(increment, std::ref(index));incr();5 - 오버로딩 함수에 bind를 사용할 때 주의점 바인딩 매개변수를 오버로딩된 함수와 함께 사용할 때 사소한 문제가 발생할 수 있다.void overloaded(int num) {}void overloaded(float f) {} 이렇게 오버로딩된 함수에 대해 bind()를 사용하려면 어느 함수에 바인딩해야할 지 명시적으로 지정해야 한다.auto f3 = bind(overloaded, placeholders::_1); // 컴파일 에러auto f4 = bind((void(*)(float)overloaded, placeholders::_1); // OK" }, { "title": "함수 객체,람다", "url": "/posts/%ED%95%A8%EC%88%98-%EA%B0%9D%EC%B2%B4,%EB%9E%8C%EB%8B%A4/", "categories": "C++", "tags": "C++", "date": "2023-02-24 00:00:00 +0900", "snippet": "std::function functional 헤더 파일에 정의된 std::function 템플릿을 이용하면 함수를 가리키는 타입,함수 객체,람다 표현식을 비롯하여 호출 가능한 모든 대상을 가리키는 타입을 생성할 수 있다. std::function을 다형성 함수 래퍼라고도 부르며, 함수 포인터로도 사용할 수도 있고, 콜백을 구현한는 함수를 나타내는 매개변수로 사용할 수도 있다. std::function의 템플릿의 문법std::function&lt;R(ArgTypes..)&gt; R은 리턴 타입이고, ArgTypes는 각각을 콤마로 구분한 매개변수의 타입 목록 예제void func(int num, const string&amp; str){ // 내용}int main(){ function&lt;void(int, const string&amp;)&gt; f1 =func; f1(1,\"test\"); return 0;} function을 auto로 대신 사용할 수도 있다. 하지만 auto를 사용하면 f1의 타입이 std::function이 아닌 함수포인터라고 판단한다. 그래서 void(*f1)(int, const string&amp;)라고 변환해버린다. std::function은 콜백을 클래스의 멤버 변수에 저장할 때 장점이 드러난다. 또한 함수 포인터를 매개변수로 받아야 할 때도 유용하다. 예제void process(const vector&lt;int&gt;&amp; vec, function&lt;void(int)&gt; f){ for (auto&amp; i : vec) { f(i); }}void print(int num){ cout&lt;&lt; num &lt;&lt; \" \";}int main(){ vector&lt;int&gt; vec{0,1,2,3,4,5,6,7,8,9}; process(vec, print); cout &lt;&lt; endl; int sum = 0; process(vec, [&amp;sum](int num){sum += num;}); // 함수의 매개변수를 람다로 전달 cout &lt;&lt; \"sum =\" &lt;&lt; sum &lt;&lt; endl; return 0;} 콜백 매개변수를 std::function을 사용하지 않고, 함수 템플릿으로 만들어도 된다.template &lt;typename F&gt;void process(const vector&lt;int&gt;&amp; vec,F f){ for (auto&amp; i : vec) { f(i); }} 이렇게 정의한 함수 템플릿은 비템플릿 process()함수와 기능이 같다. processTemplate은 일반 함수 포인터와 람다 표현식 모두 받을 수 있다. 람다 표현식 람다 표현식 함수나 함수 객체를 별도로 정의하지 않고 필요한 지점에서 곧바로 함수를 직접 만들어 쓸 수 있는 일종의 익명 함수 람다의 문법 람다 표현식은 람다 선언자(람다 소개자)라 부르는 대괄호 []로 시작하고, 그 뒤에 람다 표현식의 본문을 담는 중괄호{}가 나온다. 형태) [캡쳐블록] (매개변수) -&gt;리턴타입 { 함수 내용 } (매개변수에 전달할 값); 람다는 기본적으로 캡쳐블록, 전달인자(매개변수) , 리턴타입을 생략할 수 있다. 람다 표현식은 auto타입 변수에도 대입이 가능하다.auto basicLambda = [] {cout &lt;&lt; \"Hello from Lambda\" &lt;&lt; endl; };basicLambda(); 람다 표현식은 자신이 속한 스코프에 있는 변수에 접근할 수 있다.double data = 1.23;auto capturingLambda = [data]{cout &lt;&lt; \"Data =\" &lt;&lt; data &lt;&lt; endl;};캡처블록 대괄호 부분을 람다의 캡처블록이라 한다. 어떤 변수를 대괄호안에 지정해서 람다 표현식의 본문 안에서 그 변수를 사용할 수 있다. 캡처블록을 []와 같이 비워두면 람다 표현식이 속한 스코프에 있는 변수를 캡처하지 않는다. 캡처 블록에 변수 이름만 쓰면 그 변수를 값으로 캡처한다. 캡처한 변수는 이 펑터의 데이터 멤버가 된다. 값으로 캡처한 변수는 펑터의 데이터 멤버로 복제된다. 이렇게 복제된 데이터 멤버는 const속성을 그대로 이어받는다.(non-const면 non-const, const면 const) 컴파일러는 람다 표현식을 이름 없는 펑터(함수 객체)로 변환한다. 펑터마다 함수 호출 연산자인 operator()가 구현돼 있어서 람다 표현식의 경우 이 연산자는 기본적으로 const로 설정된다. non-const변수를 람다표현식에 값으로 캡처해도 람다 표현식 안에서 값의 복제본을 수정할 수 없다. 하지만 람다 표현식을 mutable로 지정하면 함수 호출 연산자를 non-const로 만들 수 있다.double data = 1.23;auto capturingLambda = [data] () mutable {data *= 2; cout &lt;&lt; \"Data = \" &lt;&lt; data &lt;&lt;endl;};// 만약 mutable이 없으면 data는 const로 지정되어 data*=2 처럼 값을 수정하는 코드에서 에러가 발생한다. 변수 이름 앞에 &amp;를 붙이면 레퍼런스로 캡처한다.double data =1.23;auto capturingLambda = [&amp;data]{ data*=2; }; 람다 표현식이 속한 스코프의 변수를 모두 캡처할 수도 있다.[=] : 스코프에 있는 변수를 모두 값으로 캡처한다.[&amp;] : 스코프에 있는 변수를 모두 레퍼런스로 캡처한다.캡처 리스트 캡처리스트를 지정하면 캡처할 변수를 지정할 수 있다.[&amp;x] : 변수 x만 레퍼런스로 캡처한다.[x] : 변수 x만 값으로 캡처한다.[=, &amp;x ,&amp;y] : x와 y는 레퍼런스로 캡처하고, 나머지는 값으로 캡처한다.[&amp;, x] : x만 캡처하고 나머지는 레퍼런스로 캡처한다.[this] : 현재 객체를 캡처한다. 람다 표현식 본문안에선 이 객체에 접근할 때 this-&gt;를 붙이지 않아도 된다.[*this] : 현재 객체의 복제본을 캡처한다. 람다 표현식을 실행하는 시점에 객체가 살아있지 않을 때 유용하다. 변수 이름 앞에 &amp;나 =를 붙이려면 캡처 리스트의 첫번째 원소가 반드시 캡처 디폴트(&amp; or =)여야 한다.람다 표현식의 문법 정리[캡처 블록](매개 변수) mutable constexpr noexcpt 속성 -&gt; 리턴타입{본문} 캡처 블록: 스코프에 있는 변수를 캡처하는 방식을 지정하고, 람다 표현식의 본문에서 그 변수를 접근할 수 있게 만든다. 매개변수(생략 가능) : 람다 표현식에 대한 매개변수 목록. 매개변수를 받지않고 mutable, const 표현식, noexcept 지정자, 속성, 리턴타입을 지정하지 않는다면 생략해도 된다. mutable(생략 가능) : 람다 표현식을 mutable로 지정한다. constexpr(생략 가능) :람다 표현식을 const로 지정한다. 그러면 컴파일 시간에 평가된다.명시적으로 지정하지 않아도 람다 표현식이 일정 요건을 충족하면 내부적으로 const로 처리한다. noexcept(생략 가능) : noexcept 구문을 지정할 때 사용 가능하다. 속성(생략 가능) : 람다 표현식에 대한 속성을 지정한다. 리턴_타입(생략 가능) : 리턴값의 타입을 지정한다. 생략하면 컴파일러가 추론한다. " }, { "title": "스마트 포인터", "url": "/posts/%EC%8A%A4%EB%A7%88%ED%8A%B8%ED%8F%AC%EC%9D%B8%ED%84%B0/", "categories": "C++", "tags": "C++", "date": "2023-02-22 00:00:00 +0900", "snippet": "스마트 포인터 포인터처럼 동작하는 클래스 템플릿으로, 사용이 끝난 메모리를 자동으로 해제 특징 템플릿을 이용하여 모든 포인터 타입에 대해 타입에 안전한 스마트 포인터 클래스를 작성 가능하다. 연산자 오버로딩을 이용하여 스마트 포인터 객체에 대한 인터페이스를 제공해서 스마트 포인터 객체를 일반 포인터처럼 활용할 수 있다. 특히 *와 -&gt;를 연산자 오버로딩하면 스마트포인터 객체를 일반 포인터처럼 역참조할 수 있다. 스마트 포인터는 메모리뿐만 아니라 동적으로 할당한 모든 리소스를 가리킨다. 스마트 포인터가 스코프를 벗어나거나 리셋되면 거기에 할당된 리소스가 자동으로 해제된다. 일반 포인터와 스마트 포인터의 차이점 동적 메모리 공간(힙or자유공간)에 할당된 메모리의 주소만 저장 가능하다 Automatic cleanup : 자유공간에 할당된 메모리가 더 필요하지 않을 때 메모리가 자동으로 해제 한다. delete를 사용하지 않아도 됨 =&gt; 메모리 누수 발생 가능성을 제거한다. Automatic initialization : 스마트 포인터를 NULL로 초기화할 필요 없다 memory management나 locking 등 좀 더 유용하다. Dangling pointers 해제된 메모리 영역을 가리키고 있는 포인터 Exception(try/catch) safety Garbage collection 일반 포인터에서 하던 증가/감소 같은 산술연산 X 헤더 unique_ptr 특정 객체에 유일한 소유권을 부여하는 포인터 객체1 - 동적할당한 뒤에 메모리 누수 현상이 발생하는 경우// 1 - 메모리 해제하지 않는 경우void leaky(){ Simple* mySimplePtr = new Simple(); // 버그! 메모리 해제하지 않음 mySimplePtr-&gt;go();}// 2 - go() 메서드에서 익셉션이 발생해서 delete가 실행되지 않을 경우void couldbeLeaky(){ Simple* mySimplePtr = new Simple(); // 버그! 메모리 해제하지 않음 mySimplePtr-&gt;go(); delete mySimplePtr;} 위 코드들을 unique_ptr로 구현하면 객체에 대해 delete를 직접 호출하지 않아도 된다. unique_ptr 인스턴스가 스코프를 벗어나면(함수가 끝나거나 익셉션이 발생해서) 소멸자가 호출될 때 Simple 객체가 자동으로 해제된다. void notleaky(){ auto mySimpleSmartPtr = make_uniuqe&lt;Simple&gt;(); // 괄호 안에 생성자 인수 전달 가능 mySimpleSmartPtr-&gt;go(); // 만약 make_unique()를 지원하지 않는 컴파일러일 때 아래와 같이 작성한다. // unique_ptr&lt;Simple&gt; mySimpleSmartPtr(new Simple());}2 - unique_ptr 사용 방법 일반 포인터와 똑같이 *나 -&gt;로 역참조가 가능하다.mySimpleSmartPtr-&gt;go();(*mySimpleSmartPtr).go(); get() 메서드를 이용하면 내부 포인터에 직접 접근할 수 있다.// Simple*를 인자로 받는 함수void processData(Simple* simple);=========auto mySimpleSmartPtr = make_unique&lt;Simple&gt;();/* mySimpleSmartPtr는 make_unique&lt;Simple&gt;타입이지만 get()메서드로 내부 포인터에 직접 접근하여 Simple*로 사용할 수 있다. */processData(mySimpleSmartPtr.get()); reset()을 이용하면 unique_ptr의 내부 포인터를 해제하고 다른 포인터로 변경할 수 있다.// 리소스 해제 후 nullptr로 초기화mySimpleSmartPtr.reset(); // 리소스 해제 후 새로운 Simple 인스턴스로 설정 mySimpleSmartPtr.reset(new Simple()); release()를 이용하면 unique_ptr와 내부 포인터의 관계를 끊을 수 있다. release()메서드는 리소스에 대한 내부 포인터를 리턴한 뒤, 스마트 포인터를 nullptr로 설정 스마트 포인터는 리소스에 대한 소유권을 잃고, 리소스는 따로 직접 해제해야 한다. Simple* simple = mySimpleSmartPtr.release(); // 소유권 해제delete simple;simple = nullptr; unique_ptr는 단독 소유권을 표현하기 때문에 복사할 수 없다. std::move를 사용하면 unique_ptr를 다른 곳으로 이동할 수 있다. class Foo{ public: Foo(unique_ptr&lt;int&gt; data) : mData(move(data)) {} private: unique_ptr&lt;int&gt; mData;};auto myIntSmartPtr = make_unique&lt;int&gt;(42);Foo f(move(myIntSmartPtr));3 - 커스텀 제거자 기본적으로 unique_ptr는 new와 delete로 메모리를 할당하거나 해제한다. 다음과 같이 방식을 변경할 수도 있다. int* malloc_int(int value){ int* p = (int*)malloc(sizeof(int)); *p = value; return p;}int main(){ unique_ptr&lt;int, decltype(free)*&gt; myIntSmartPtr(malloc_int(42),free); return 0;} C++에서는 malloc보다 new를 사용하는 것이 좋지만, unique_ptr는 malloc()와 free()함수를 제공한다. 이유는 메모리가 아닌 다른 리소스를 관리하기 편하기 때문 파일,네트워크 소켓등 가리키던 unique_ptr가 스코프를 벗어날 때 리소스를 자동으로 닫는데 활용할 수 있다. unique_ptr의 커스텀 제거자를 작성하는 문법은 지저분하다. 작성하는 커스텀 제거자의 타입을 템플릿 타입 매개변수로 지정하기 때문 free()의 타입을 알아내기 위해 decltype(free)를 사용함. 템플릿 타입 매개변수는 함수에 대한 포인터 타입이어야 하므로 decltype(free)에 *를 붙임 shared_ptr 어떤 하나의 객체를 참조하는 스마트 포인터의 개수를 참조하는 스마트 포인터 make_shared()로 생성할 수 있다. shared_ptr를 생성할 때는 반드시 make_shared()를 사용한다. auto mySimpleSmartPtr = make_shared&lt;Simple&gt;(); unique_ptr와 마찬가지로 get()과 reset()메서드를 제공한다. 차이점은 shared_ptr의 reset()메서드를 호출하면 레퍼런스 카운팅 매커니즘에 따라 마지막 shared_ptr가 제거되거나 리셋될 떄 리소스가 해제된다. shared_ptr은 release()를 지원하지 않는다. shared_ptr은 현재 동일한 리소스를 공유하는 shared_ptr의 개수는 use_count로 알아낼 수 있다. shared_ptr은 커스텀 제거자의 타입을 템플릿 타입 매개변수로 지정하지 않아도 된다. shared_ptr&lt;int&gt; myIntSmartPtr(malloc_int(42), free);1 - shared_ptr 캐스팅 shared_ptr를 캐스팅하는 함수는 다음과 같이 지원한다. const_pointer_cast() dynamic_pointer_cast() static_pointer_cast() reinterpret_pointer_cast() 2 - 레퍼런스 카운팅이 필요한 이유 레퍼런스 카운팅 : 어떤 클래스의 인스턴스 수나 현재 사용중인 특정 객체를 추적하는 매커니즘 레퍼런스 카운팅을 지원하는 스마트 포인터는 실제 포인터를 참조하는 스마트 포인터의 수를 추적한다. 그래서 스마트 포인터가 중복 삭제 되는 것을 방지한다. // 메모리 중복 삭제로 에러 발생void doubleDelete(){ Simple* mySimple = new Simple(); shared_ptr&lt;Simple&gt; smartPtr1(mySimple); shared_ptr&lt;Simple&gt; smartPtr2(mySimple);}// 두 개의 shared_ptr 한 객체를 동시에 가르켜도 객체는 한 번만 삭제void noDoubleDelete(){ auto smartPtr1 = make_shared&lt;Simple&gt;(); shared_ptr&lt;Simple&gt; smartPtr2(smartPtr1);}3 - 앨리어싱 shared_ptr은 앨리어싱을 지원한다. 앨리어싱(aliasing) : 여러 변수 및 객체에서 서로 다른 이름으로 같은 메모리를 참조하는 것 그래서 한 포인터(소유한 포인터)를 다른 shared_ptr와 공유하면서 다른 객체(저장된 포인터)를 가리킬 수 있다. class Foo{ public: Foo(int value) : mData(value) {} int mData;};auto foo = make_shared&lt;Foo&gt;(42);auto aliasing = shared_ptr&lt;int&gt;(foo, &amp;foo-&gt;mData); 두 shared_ptr(foo와 aliasing)가 모두 삭제될 때만 Foo 객체가 삭제된다.weak_ptr shared_ptr가 가리키는 리소스의 레퍼런스를 관리하는데 사용된다. weak_ptr은 리소스를 직접 소유하지 않기 때문에 shared_ptr가 해당 리소스를 해제하는 데 아무런 영향이 없다. weak_ptr는 삭제될 때 가리키던 리소스를 삭제하지 않고, shared_ptr가 그 리소스를 해제했는지 알아낼 수 있다. weak_ptr의 생성자는 shared_ptr나 다른 weak_ptr를 인수로 받는다. weak_ptr에 저장된 포인터를 접근하려면 shared_ptr로 변환시켜야 한다. 방법 weak_ptr 인스턴스의 lcok() 메서드를 이용하여 shared_ptr를 리턴받는다.이 떄 shared_ptr에 연결된 weak_ptr가 해제되면 shared_ptr은 nullptr가 된다. shared_ptr의 생성자에 weak_ptr를 인수로 전달해서 shared_ptr를 새로 생성한다.]이 떄 shared_ptr에 연결된 weak_ptr가 해제되면 std::bad_weak_ptr 익셉션이 발생한다. void useResource(weak_ptr&lt;Simple&gt;&amp; weakSimple){ auto resource = weakSimple.lock(); if(resource) { cout &lt;&lt; \"Resource still alive\" &lt;&lt; endl; } else { cout &lt;&lt; \"Resource has been freed!\" &lt;&lt; endl; }}int main(){ auto sharedSimple = make_shared&lt;Simple&gt;(); weak_ptr&lt;Simple&gt; weakSimple(sharedSimple); // weak_ptr를 사용한다. useResource(weakSimple); // shared_ptr를 리셋한다. // Simple 리소스에 대한 shared_ptr은 하나뿐이므로 // weak_ptr가 살아 있더라도 리소스가 해제된다. sharedSimple.reset(); // weak_ptr를 한번 더 사용한다. useResource(weakSimple); return 0;}// 결과Simple constructor calledResource still alive;Simple destructor calledResource has been freed!" }, { "title": "쓰레드의 이해", "url": "/posts/%EC%93%B0%EB%A0%88%EB%93%9C%EC%9D%98-%EC%9D%B4%ED%95%B4/", "categories": "윈도우즈시스템프로그래밍, 운영체제", "tags": "windows", "date": "2023-02-19 00:00:00 +0900", "snippet": "멀티 프로세스 기반 프로그램 둘 이상의 서로 다른 프로그램을 실행을 위해서 둘 이상의 프로세스를 생성하는 것 또는 하나의 프로그램이 두가지 이상의 일을 동시에 처리하기 위해서도 둘 이상의 프로세스를 생성해야 하기도 한다. 하나의 프로그램 내에서 여러 개의 실행 흐름을 찾을 수 있다. 멀티 프로세스 운영 기반 프로그램의 문제점과 새로운 제안 두 가지 이상의 일을 동시에 처리하기 위해서, 혹은 둘 이상의 실행 흐름이 필요해서 추가적으로 프로세스를 추가하는 것은 부담스럽다. 많은 수의 프로세스 생성은 빈번한 컨텍스트 스위칭으로 이어져 성능에 영향을 미치기 때문이다. 1 - 컨텍스트 스위칭에 소요되는 시간을 줄이기 위해 해야할 것 저장하고 복원하는 컨텍스트 정보의 개수를 줄여주면 된다. 컨텍스트 정보란 프로세스의 상태 정보와 관련이 있으므로 결국 프로세스 상태 정보를 줄여야 한다. 2 - 컨텍스트 스위칭이 필요한 이유 프로세스들이 서로 완전히 독립되기 때문 다른 프로세스를 실행하기 위해 CPU와 메모리까지 다른 프로세스가 사용할 수 있도록 자리를 비켜야 함 쓰레드 별개의 프로그램을 동시 실행하기 위해서는 독립된 프로세스 구조가 필요하다. 하지만 하나의 프로그램 내에서 둘 이상의 실행 흐름을 두기 위해서,모든 것을 독립시키는 구조로 갈 필요는 없다. 그래서 등장한 것이 쓰레드 쓰레드와 프로세스의 차이점 프로세스는 독립된 두 개의 프로그램을 위해서 사용된다. 쓰레드는 하나의 프로그램 내에서 둘 이상의 프로그램을 만들어 내기 위해 디자인됐다. 프로세스와 달리 쓰레드간에는 공유하는 상태 정보들이 있다. 이것이 쓰레드의 컨텍스트 스위칭을 빠르게 하는 요인이 된다. 정리 쓰레드는 하나의 프로그램 내에서 여러 개의 실행 흐름을 두기 위한 모델 쓰레드는 프로세스처럼 독립적인 구조가 아닌, 쓰레드들 사이에는 공유하는 요소들이 있다. 쓰레드는 공유하는 요소가 있는 관계로,컨텍스트 스위칭에 걸리는 시간이 프로세스보다 짧다. 메모리 구조 관점에서 본 프로세스와 쓰레드 프로세스와 쓰레드의 차이점을 이해하는 가장 좋은 방법은 메모리 구조 관점에서 비교하는 것 프로세스 생성 후 메모리 구조 자식 프로세스들은 생성되고 나서 모든 것이 부모 프로세스와 독립적이다. 부모 프로세스는 자신이 가지고 있는 핸들 테이블을 상속하는 등 부모역할을 하지만, 어디까지나 생성되는 과정에서 발생하는 일 메모리 구조상 생성이후에는 아무런 관계가 없다. 이러한 메모리 구조를 지녔기 때문에 프로세스간의 통신을 위해선 IPC라는 매커니즘이 필요 쓰레드 생성후 메모리 구조 생성된 쓰레드들은 스택영역을 제외한 나머지 부분을 공유하고 있다. 쓰레드의 특성 쓰레드마다 스택을 독립적으로 할당해 준다. 스택은 함수 호출시 전달되는 인자, 되돌아갈 주소값 및 함수 내에서 선언하는 변수등을 저장하는 메모리 공간 이 메모리 공간이 독립적이라는 뜻은 추가적인 실행 흐름을 만들 수 있다는 의미가 된다. 즉, 실행 흐름의 추가를 위한 최소 조건이 독립된 스택의 제공 코드 영역을 공유한다. 프로세스는 다른 프로세스의 코드 영역에 있는 함수를 호출할 수 없지만, 쓰레드는 코드 영역을 공유하므로 함수를 호출할 수 있다. 1. 프로세스이므로 첫 시작인 main 함수가 있다.2. 이 영역에 또 다른 실행의 하는 쓰레드의 main 함수가 있다.3. 이 쓰레드 main 함수는 코드 영역에 존재하는 모든 함수를 호출할 수 있다.쓰레드가 있는 프로그램은 시작과 동시에 총 3개의 흐름이 형성하는가? X자식 프로세스를 생성하는 부모 프로세스처럼, 쓰레드 생성을 위해 마련된 함수를 호출을 통해서 쓰레드를 생성한다. &lt;br&gt;&lt;br&gt; 데이터 영역과 힙을 공유한다. 힙과 데이터 영역을 공유하므로 힙과 데이터 영역에 메모리 공간을 할당해서 서로 통신하는 것이 가능하다. IPC와 같은 복잡한 통신기법이 필요없다. 즉, 전역변수와 malloc 함수를 통해서 동적 할당된 메모리 공간은 공유가 가능하다. 그러나, 데이터 영역과 힙 영역의 공유가 장점만 있는 것은 아니다. 메모리 영역을 공유하는 만큼 문제가 발생할 수도 있다. Windows에서의 프로세스와 쓰레드 프로세스와 쓰레드의 관계 Windows입장에서 프로세스는 단순히 쓰레드를 담는 상자에 지나지 않는다. 때문에 실제 프로그램의 흐름을 형성하는 것은 쓰레드이다. 프로세스의 상태 정보들은 어떻게 이해해야 하는가? 사실 windows 운영체제에 있어서 프로세스는 상태(Running, Ready, Blocked)를 지니지 않는다. 상태를 지니는 것은 프로세스가 아니라 쓰레드이다. 스케줄러가 실행의 단위로 선택하는 것도 프로세스가 아닌 쓰레드이다. Windows에 있어서 실행의 중심에 있는 것은 프로세스가 아닌 쓰레드 같은 프로세스 내부의 쓰레드끼리의 컨텍스트 스위칭은 기존에 알던 프로세스의 컨텍스트 스위칭보다 속도가 빠르다. 하지만, 서로 다른 프로세스의 내부에 있는 쓰레드끼리 컨텍스트 스위칭을 한다면 기존에 알던 프로세스 컨텍스트 스위칭과 같다. 속해있는 프로세스 영역이 다르면 공유하는 영역이 없기 때문이다. 그림 프로세스 B안에 두개의 쓰레드가 존재하는데, 이 둘은 하나의 프로세스 내에 존재하므로 별개의 쓰레드가 아니다. 이 둘 사이에서 발생하는 컨텍스트 스위칭은 프로세스의 컨텍스트 스위칭보다 속도가 훨씬 빠르다. 같은 프로세스 내에 있으므로 스택을 제외한 나머지 영역을 공유하기 때문 프로세스 A의 쓰레드가 실행 도중 프로세스의 B의 쓰레드로 실행을 옮기는 과정은 프로세스의 컨텍스트 스위칭가 다를 바가 없다. 쓰레드를 생성하지 않는 프로세스의 실행 방식 생성과 동시에 기본적으로 main함수를 호출해 줄 쓰레드를 생성하는데, 이러한 쓰레드를 main 쓰레드라고 한다. 일반적으로 프로그래머에 의해 직접적으로 생성되는 쓰레드와 구분짓는다. 쓰레드 구현 모델에 따른 구분 쓰레드의 구현 원리1 - 커널 레벨(Kernel Level) 쓰레드와 유저 레벨(User Level) 쓰레드 쓰레드를 생성해 주는 대상은 커널일 수 있다. 이러한 경우 운영체제가 제공하는 시스템 함수 호출을 통해 쓰레드 생성을 요구해야 한다. 그러면 운영체제는 해당 쓰레드를 생성 및 관리하면서 새로운 흐름을 형성하도록 도와준다. 이렇듯 프로그래머 요청에 따라 쓰레드를 생성 및 스케줄링 하는 주체가 커널인 경우, 이를 가리켜 커널 레벨 쓰레드라 한다. 커널 레벨에서 쓰레드가 지원된다는 뜻이다. 2 - 커널 레벨(Kernel Level) 쓰레드 하나의 프로세스에 할당되는 메모리 공간이 4G(기가)바이트라고 가정한다면 일부는 프로그램 코드를 올리고, 일부는 실행중에 변수 선언이나 메모리 동적할당 용도로 쓴다. 이렇게 프로그램이 동작하기 위해 사용되는 메모리 공간을 유저 영역이라 한다. 즉 코드영역, 데이터 영역, 스택,힙 영역을 가리켜 유저 영역이라고 한다. 그러면 커널 영역은? 하나의 프로세스에 할당되는 메모리 공간 중 유저 영역을 제외한 나머지 영역을 의미한다. 운영체제가 실행되기 위해 운영체제 역시 메모리에 올라가야하고, 일반 프로그램처럼 실행중에 변수 선언과 메모리 동적 할당도 필요하다. 이렇게 운영체제라는 하나의 소프트웨어를 실행시키기 위해서 필요한 메모리 공간을 커널 영역이라 한다. 과거 32비트 Windows 운영체제에서는 총 4G바이트 메모리 영역(물론 가상메모리 크기) 중 2G바이트를 유저영역, 나머지 2G바이트를 커널 영역으로 활용하였다 오늘날 64비트 운영체제에서는 총 16T(테라)바이트의 메모리를 프로세스에게 할당하고, 유저영역과 커널영역은 각각 8T바이트씩 할당하고 있다. 아래 그림에서, 쓰레드에게 일을 시키기 위한 프로그램 코드는 프로그래머가 개발하므로 쓰레드 A B C의 실행 코드는 유저영역에 존재한다 그러나 스케줄러와 스케줄링에 필요한 쓰레드 정보는 커널 영역에 존재한다. 이것이 바로 커널 레벨 쓰레드의 유형이다. 오늘날 대부분의 운영체제(Windows, Linux)는 커널 레벨 쓰레드를 기반으로 쓰레드 모델을 지원한다. 커널 레벨 쓰레드 모델3 - 유저 레벨(User Level) 쓰레드 모델 멀티 프로세스 운영체제라고 해서 커널이 기본적으로 쓰레드를 지원하는 것은 아니다. 과거 UNIX에서는 비록 멀티프로세스 운영체제이긴 하나 쓰레드를 지원하지 않았다. 이렇듯 커널에서 쓰레드 기능을 지원하지 않았을 때 생각해 볼 수 있는 것이 유저 레벨 쓰레드이다. 혹은 커널이 제공하는 쓰레드 모델이 마음에 들지 않을 겅우에도 커널에 의존적이지 않은 형태로 쓰레드의 기능을 제공하는 라이브러리를 활용할 수 있는데, 이러한 방식을 제공되는 쓰레드가 유저 레벨 쓰레드이다. 커널에서 제공되는 기능이 아니므로 당연히 실행 시 유저 영역에서 실행된다. 유저레벨 쓰레드와 커널 레벨 쓰레드는 기능의 제공 주체가 누구냐에 달려있다. 유저 레벨 쓰레드 모델을 적용할 경우, 운영체제는 쓰레드의 존재를 알지도 확인하지도 못한다. 아래 그림은 쓰레드를 지원하지 않는 운영체제에서 유저 레벨 쓰레드 모델을 적용한 상황이다. 쓰레드를 지원하지 않기 때문에 스케줄러가 스케줄링 하는 대상은 프로세스이다. 그리고 쓰레드를 스케줄링 하는 스케줄러는 유저 영역에서 실행된다. 커널 레벨 쓰레드 모델 중간 정리 내용메모리는 활용 대상에 따라서 유저 영역과 커널 영역으로 나뉜다.유저 영역은 사용자가 구현한 프로그램 동작 시 사용하게 되는 메모리 영역이고, 커널 영역은 운영체제 동작 시 사용하게 되는 메모리 영역이다.그리고 커널이 쓰레드를 지원할 경우 쓰레드 관리가 커널 영역에서 이뤄지기 때문에 커널 레벨 쓰레드 모델이라 하고, 커널이 지원하지 않을 경우에 라이브러리를 통해서 제공받아야 하는데 이러한 경우에는 유저 영역에서 쓰레드의 관리가 이뤄지기 때문에 유저 레벨 쓰레드 모델이라 한다.커널 모드와 유저 모드 Windows는 동작할 때 커널 모드와 유저 모드 중 한가지 모드로 동작한다. 커널 모드는 유저 영역에 비해서 상대적으로 중요하다. 유저 영역에서 메모리 참조 오류가 발생한다면 실행중인 프로그램에만 영향을 끼치지만커널 영역은 커널의 코드가 실행되는 영역이므로 시세틈 전체에 문제를 일으킬 수도 있다. 그런데 우리가 구현하거나 사용하는 프로그램은 유저 영역에서 실행되므로 커널 영역에서 문제를 일으킬 일은 없어 보인다. 그러나 C언어의 특성상 메모리 참조가 용이하기 떄문에 C언어로 구현하면 이에 대한 보장을 할 수 없다. 따라서 안전성 제공 측면에서 다른 방법이 필요하다. 이에 등장한 것이 커널 모드와 유저 모드이다. 일반적인 프로그램은 기본적으로 유저 모드에서 동작한다 그러다가, Windows커널이 실행되어야 하는 경우에는 커널모드로 전환이 일어난다. 커널 영역에서 실행이 이뤄져야 할 경우에는 커널 모드로 전환이 일어나는 것이다. 여러 개의 프로세스들이 실행 중에 있다. 정해진 타임 슬라이스가 지나서 스케줄러가 동작하려고 한다. 이 때 커널 모드로의 전환이 일어나겠는가? 당연히 일어난다, 스케줄러는 커널의 일부에 해당하기 때문이다 이러한 스케줄러가 동작하려면 커널의 모드로의 전환이 필수다 그렇다면, 커널 모드와 유저 모드의 차이점은 무엇인가? 프로세스가 유저모드에서 동작할 때에는 커널 영역으로의 접근이 금지된다. 즉 뜻하지 않게 유저 모드에서 실행중인 프로그램이 커널 영역에 접근을 시도하면 시스템에서 오류가 발생했음을 알리고 접근을 봉쇄한다. 반면 커널 모드에서 동작할 때에는 모든 영역의 접근이 허용된다. 하지만 모드의 전환(커널 모드 유저 모드)는 시스템에 부담을 주는 일이므로 상황에 따른 적절한 반영이 요구된다. 커널 모드와 유저 모드를 제공하는 대상은 Windows 운영체제가 아닌 프로세서(Processor)이다. 즉, 메모리 보호 기능이 CPU에 달려있다. 이는 메모리 관리 부분에서 설명하겠다. 1 - 커널 레벨 쓰레드와 유저 레벨 쓰레드의 장점 및 단점 커널 레벨 쓰레드의 장점 및 단점 장점 : 커널에서 직접 제공해 주기 때문에 안전성과 다양한 기능성이 제공된다 단점 : 커널에서 제공해 주는 기능이기 때문에 유저 모드에서 커널 모드로의 전환이 빈번하게 일어난다. 따라서 이는 성능의 저하로 이어지게 된다. 유저 레벨 쓰레드의 장점 및 단점 장점 : 커널은 쓰레드의 존재조차 모른다. 오로지 유저 모드로 동작하기 때문에 유저 모드에서 커널 모드로의 전환이 필요없다. 때문에 성능이 좋다. 단점 : 하나의 프로세스 내에 총 3개의 쓰레드 A B C가 있다고 했을 때 A 쓰레드가 시스템 함수를 호출했는데 커널에 의해 블로킹되었다. 이럴 경우 B,C도 실행되지 않는다.운영체제는 프로세스의 존재만 알지 쓰레드의 존재를 모른다. 때문에 A 쓰레드가 속해있는 프로세스 전부가 블로킹되는 문제를 안고 있다.이 문제를 해결하기 위한 방법이 있지만 결국 프로그래밍이 어려워지고 커널 레벨 쓰레드에 비해 결과 예측이 어렵다. 분명 속도의 향상이라는 유저레벨 쓰레드의 장점이 있다. 때문에 Windows 개발자들과 달리 Linux 개발자들은 라이브러리를 통한 유저 레벨 쓰레드를 활용하기도 한다. " }, { "title": "연산자 오버로딩 - 3", "url": "/posts/%EC%97%B0%EC%82%B0%EC%9E%90-%EC%98%A4%EB%B2%84%EB%A1%9C%EB%94%A9-3/", "categories": "C++", "tags": "C++", "date": "2023-02-17 00:00:00 +0900", "snippet": "변환 연산자 구현하기 클래스를 다른 타입으로 변환시키면 컴파일 에러가 발생한다. 컴파일러가 클래스를 그 타입으로 변환하는 방법을 모르기 때문 SpreadsheetCell cell(1.23);double d1 =cell; // 컴파일 에러 발생double d2 =(double)cell; // 명시적으로 적어도 컴파일 에러 발생 변환시키기 위해서는 컴파일러에 구체적인 방법을 알려줘야 한다. 즉 클래스안에 해당 타입으로 변환하는 변환 연산자를 구현 // double로 변환할 시operator double() const;SpreadsheetCell::operator double() const{ return getValue(); // class 안에 있는 double 변수를 반환} 이 함수의 이름은 operator double 함수 이름안에 리턴 타입이 표현됐기 때문에 리턴 타입을 지정할 필요없다. 명시적 변환 연산자로 모호한 문제 해결하기 변환연산자를 추가하면 모호함이 발생할 수 있다.SpreadsheetCell cell(1.23);double d2 = cell + 3.3; // operator double()을 정의했다면 컴파일 에러가 발생 문제가 발생하는 이유는 컴파일러가 cell을 operator double()에 적용해서 double 덧셈으로 처리할지 아니면 3.3을 double 생성자에 적용해서 SpreadsheetCell로 변환한 뒤 SpreadsheetCell 덧셈으로 처리할지 결정할 수 없기 때문 double 변환 연산자를 explicit으로 선언하는 방식으로 해결한다 // explicit 변환 연산자explicit operator double() const;// 다음과 같이 사용SpreadsheetCell cell = 6.6;// 3.3을 SpreadsheetCell로 암묵적으로 변환하고, 이어서 두개의 SpreadsheetCell에 대해// Operator+를 적용한 다음 명시적 캐스팅으로 operator double()을 호출double d1 = static_cast&lt;double&gt;(cell +3.3);부울 표현식으로 표현하기 객체를 부울 표현식에서 사용하면 좋을 때가 있다. 아래와 같이 조건문에서 포인터를 사용할 때가 있다. // ptr이 nullptr인지 if(nullptr != ptr)if(ptr) 스마트 포인터 클래스 템플릿인 Pointer를 위와 같이 사용하면 컴파일 에러가 발생한다. Pointer에 포인터 타입으로 변환하는 연산자를 추가하면 문제없이 쓸 수 있다. 이러한 변환 연산자는 주로 void* 타입을 사용한다. template &lt;typename T&gt;Pointer&lt;T&gt;::operator void*() const{ return mPtr;} 또 다른 방법으로는 operator void*()대신 operator bool()을 오버로딩해도 된다.template &lt;typename T&gt;Pointer&lt;T&gt;::operator bool() const{ return mPtr != nullptr;} 그런데 operator bool()을 이용할 때 nullptr와 비교하는 문장에서 컴파일 에러가 발생한다.if(p != nullptr) { ... } // 에러 nullptr타입은 nullptr_t이고 자동으로 0(false)로 변환되지 않기 때문에 에러가 발생한다. 그래서 대부분 operator bool() 대신 operator vold*()를 선호한다. 메모리 할당과 해제 연산자 오버로딩하기 C++는 메모리 할당과 해제 작업을 원하는 형태로 정의하는 기능을 제공한다. 그로 인해 프로그램 전반이나 클래스 단위로 적용할 수도 있고 메모리 단편화를 방지하는 데 주로 사용된다. 1 - new와 delete의 구체적인 작동 방식 new의 작동 방식SpreadsheetCell* cell = new SpreadsheetCell(); 여기서 new SpreadsheetCell()을 new-표현식 이라고 한다. 이 문장은 두가지 일을 한다. 먼저 operator new를 호출해서 SpreadsheetCell 객체에 대한 메모리를 할당한다 그러고 나서 객체의 생성자를 호출한다. 생성자의 실행이 끝나야 객체에 대한 포인터가 리턴된다. delete의 작동 방식도 비슷하다delete cell; 위와 같은 문장을 delete-표현식 이라고 한다. 이 문장을 실행하면 먼저 cell의 소멸자를 호출한 다음 operator delete를 호출해 cell에 할당된 메모리를 해제한다. operator new와 operator delete를 오버로딩해서 메모리 할당과 해제 과정을 직접 제어할 수 있지만 new-표현식과 delete-표현식 자체를 오버로딩할 수 없다. 즉, 실제로 메모리를 할당하고 해제하는 과정은 커스터마이즈할 수 있지만, 생성자와 소멸자를 호출하는 동작은 변경할 수 없다. 2 - new-표현식과 operator new new-표현식은 여섯 가지 종류가 있다. 그 중 네가지 형태는 &lt;new&gt;헤더파일에 정의돼 있고 형식은 아래와 같다 void* operator new(size_t size);void* operator new[](size_t size);void* operator new(size_t, const std::nothrow_t&amp;) noexcept;void* operator new[](size_t, const std::nothrow_t&amp;) noexcept; 나머지 두 개는 실제로 객체에 할당하지 않고 기존에 저장된 객체의 생성자를 호출만 하는 특수한 형태의 new-표현식이다. 이를 배치 new 연산자라 부르며, 일반 변수 버전과 배열 버전이 있다. 이 연산자를 이용하면 다음과 같이 기존에 확보된 메모리에서 객체를 생성할 수 있다. void* ptr = allocateMemorySomehow();SpreadsheetCell* cell = new (ptr) SpreadsheetCell(); 위의 기능을 알아둬야 매번 메모리를 해제하지 않고 재사용할 수 있는 메모리 풀을 구현할 때 유용하다. 두 가지 버전의 배치 new 연산자에 대응되는 operator new는 다음과 같다 참고로 C++ 표준에서는 다음 두 가지 operator new에 대한 오버로딩을 금지한다. void* operator new(size_t size, void* p) noexcept;void* operator new[](size_t size, void* p) noexcept;3 - delete-표현식과 operator delete operator delete는 nothrow나 배치 버전은 없지만 여섯가지가 있다. 직접 호출할 수 있는 delete-표현식은 단 두개(delete, delete[ ] )뿐이다. operator delete와 delete-표현식이 짝이 맞지 않는 이유는 nothrow 버전과 배치 버전은 생성자에서 익셉션이 발생할 때만 사용되기 때문이다. 익셉션이 발생하면 생성자를 호출하기 전에 메모리를 할당하는데 사용했던 operator new에 대응되는 operator delete가 호출된다. 그런데 기존 방식대로 포인터를 delete로 삭제하면 (nothrow나 배치 버전이 아닌) operator delete나 operator delete[]가 호출된다. C++ 표준에는 delete에서 익셉션을 던질 때의 동작이 명확히 정의돼 있지 않아 실행 결과를 예측할 수 없다. 그래서 delete에서 절대로 익셉션을 던지면 안 되기 때문에 nothrow 버전의 operator delete를 따로 둘 필요가 없다. operator delete의 프로토 타입void operator delete(void* ptr) noexcept;void operator delete[](void* ptr) noexcept;void operator delete(void* ptr, const std::nothrow_t&amp;e) noexcept;void operator delete[](void* ptr, const std::nothrow_t&amp;e) noexcept;void operator delete(void* p , void*) noexcept;void operator delete[](void* p , void*) noexcept;4 - operator new와 operator delete 오버로딩하기 전역 함수 버전인 operator new와 operator delete는 필요에 따라 오버로딩할 수 있다. 하지만 전역 operator new와 operator delete를 교체하는 것은 추천하지 않는다. operator new와 operator delete를 프로그램 전체가 아닌 특정한 클래스에 대해서만 오버로딩하는 것이 좋다.class MemoryDemo{ ... void* operator new(size_t size); void operator delete(void* ptr) noexcept; ...}void* MemoryDemo::operator new(size_t size){ cout &lt;&lt; \"operator new\" &lt;&lt; endl; return ::operator new(size);}void MemoryDemo::operator delete(void* ptr) noexcept{ cout &lt;&lt; \"operator delete\" &lt;&lt; endl; ::operator delete(ptr);}5 - operator new와 operator delete를 명시적으로 삭제하거나 디폴트로 만들기 생성자와 대입연산자에 default나 delete를 지정하는 것처럼 operator new나 delete에도 가능하다.class MyClass{ void* operator new(size_t size) =delete;}MyClass* p1 = new MyClass; // 에러발생6 - operator new와 operator delete에 매개변수를 추가하도록 오버로딩하기 매개변수를 원하는 형태로 추가해서 오버로딩이 가능하다 이렇게 추가하면 자신이 정의한 메모리 할당 루틴에 다양한 플래그나 카운터를 전달할 수 있다. 일부 런타임 라이브러리는 디버그 모드에 활용해서 메모리 누수가 발생하는 문장을 알려줌 class MemoryDemo{ ... void* operator new(size_t size, int extra); void operator delete(void* ptr, int extra) noexcept; ...}void* MemoryDemo::operator new(size_t size, int extra){ cout &lt;&lt; \"operator new with extra int:\"&lt;&lt; extra &lt;&lt; endl; return ::operator new(size);}void MemoryDemo::operator delete(void* ptr, int extra) noexcept{ cout &lt;&lt; \"operator delete with extra int:\" &lt;&lt; extra &lt;&lt; endl; return ::operator delete(ptr);}MemoryDemo* memp = new(5) MemoryDemo();delete memp; operator new에 매개변수를 추가해서 정의할 때는 이에 대응되는 operator delete도 똑같이 매개변수를 추가해서 정의해야 한다. 단, 매개변수가 추가된 버전의 operator delete는 직접 호출할 수 없고, 그에 대응되는 new를 호출할 때 객체의 생성자에서 익셉션을 던져야 호출된다. operator delete에 메모리 크기를 매개변수로 전달하도록 오버로딩 operator delete를 오버로딩할 때 해제할 대상을 가리키는 포인터뿐만 아니라 해제할 메모리 크기도 전달하게 정의할 수 있다. operator delete의 프로토타입에 메모리 크기에 대한 매개변수를 추가해서 선언하면 된다. // 선언void operator delete(void* ptr, size_t size) noexcept;// 구현할 때는 매개변수를 받지않는 전역 operator delete를 호출// 전역 operator delete 중에는 크기를 받는 버전이 없기 때문::operator delete(ptr);" }, { "title": "컴퓨터 구조에 대한 세번째 이야기", "url": "/posts/%EC%BB%B4%ED%93%A8%ED%84%B0-%EA%B5%AC%EC%A1%B0%EC%97%90-%EB%8C%80%ED%95%9C-%EC%84%B8%EB%B2%88-%EC%A7%B8-%EC%9D%B4%EC%95%BC%EA%B8%B0/", "categories": "윈도우즈시스템프로그래밍, 운영체제", "tags": "windows", "date": "2023-02-15 00:00:00 +0900", "snippet": "절차적 함수 호출(Procedure Call)지원 CPU 모델스택 프레임 구조 스택 프레임(Stack Framee) 구조 함수 호출 과정에서 할당되는 메모리 블록 (지역 변수 선언으로 인해 할당되는 메모리 블록) 함수 호출이 완료되면 기존에 선언된 지역변수에 접근이 불가능 하다. 할당되었던 메모리가 반환되었음을 의미 함수가 반환되면 그 함수의 스택 프레임은 모두 반환된다. sp 레지스터 지역 변수를 위한 메모리 공간을 스택이라 부르는 이유는 메모리의 구조적 특성(Last In, First Out) 스택 프레임은 가장 먼저 할당되면,가장 나중에 반환되고 가장 나중에 할당되면 가장 먼저 반환된다. 스택에 데이터를 쌓거나 반환하기 위해 어느 위치까지 데이터를 저장했는지 기억해야만 한다 이를 위해 CPU 내에 sp라는 이름의 레지스터가 존재한다. sp 레지스터 변수가 선언되면 현재 sp가 가리키는 위치에 할당하기 때문에 sp 위치를 아래로 이동시키는 것만으로도 이전에 선언된 변수를 반환할 수 있다. 변수 할당 시 이전에 저장된 값들을 덮어 쓴다. 때문에 sp가 가리키는 위치를 아래로 이동시키는 방식으로 스택 프레임을 반환한다. 그림 sp 레지스터값은 변수가 할당될 때마다 증가하면서 다음 변수가 할당될 메모리 위치를 가리킨다 stack에 변수 a,b,c 차례로 할당 호출된 함수가 종료될 경우 스택 프레임 단위로 sp 레지스터 값을 이동시켜야 한다.(아래로) 호출된 함수가 종료될 경우 그안에서 선언된 변수들을 동시에 모두 반환해야 하기 때문 sp 레지스터의 문제점 호출이 완료된 함수를 빠져 나오는 시점에서 함수 내에서 할당된 메모리 공간을 반환하기 위해 스택 프레임 단위로 sp를 아래로 이동시킬 때 얼마나 이동시켜야 하는지 모른다. 프레임 포인터 레지스터(fp)가 이 역할을 수행한다. 프레임 포인터 레지스터 새로운 함수가 호출될 때마다 fp 레지스터값을 0으로 초기화한다. 그리고 그 변수가 선언될 때마다 그 크기만큼 값을 증가시킨다. 그런데 이 방법은 변수를 선언할 때마다 덧셈 연산을 해야만 한다. 스택 연산에 드는 비용을 상당히 늘리는 결과를 초래 위와 같은 방법이 아니라 되돌아갈 sp의 위치만 저장 결국 목적은 sp 위치를 함수 호출 이전으로 되돌리기 위해서 이므로 위치만 알면 된다. 되돌아갈 sp의 위치를 저장하는 레지스터를 가리켜 fp(Frame Pointer) 레지스터라고 한다. 다만, fp 레지스터의 등장으로 모든 문제가 해결되지 않는다. ex) 함수 호출이 중첩되어 일어날 때 새로운 함수의 스택 프레임 반환을 위한 주소값을 fp 레지스터에 저장하는 과정에서 fp 레지스터에 저장되어 있던 이전 함수의 스택 프레임 반환을 위한 주소값을 덮어 써버린다. 스택에 저장하자, 프레임 포인터 덮어쓰는 문제가 발생하기 전에, fp의 값을 어딘가에 저장해 두면 된다. 즉 함수 호출이 일어날 때마다 fp 레지스터에 저장되어 있는 값을 스택에 저장한다. 그리고 나서 새로운 값으로 fp 레지스터를 채운다. 그림1.fct2 함수가 호출되기 직전에 sp 레지스터에는 주소값 20이 들어가 있다. 현재 스택 주소를 가리키는 것이다.2.fct2 함수가 호출되기 직전에 fp 레지스터에는 주소값 8이 들어가 있다. main 함수나 fct1 함수의 경계에 해당하는 주소 정보이다.3.fct2 함수가 호출되면서, fp 레지스터에 저장된 값 (주소값 8)을 현재 sp 레지스터가 가리키는 위치 20번지에 먼저 저장한다. 그 다음 fp 레지스터 값 20을 저장한다. 이 값은 fct1 스택과 fct2 스택의 경계가 된다.4.이후 fct2 함수 호출이 완료되어 반환하고자 한다면, fp 레지스터에 저장된 값을 참조해서 sp 레지스터 값을 20으로 변경한다. 이는 fct2 함수의 스택 프레임을 날리는 효과를 가져온다.5.현재 sp 레지스터가 가리키는 위치(주소 20번지) 에 저장되어 있는 값을 fp 레지스터에 옮겨다 놓는다. 이로써 fct1 함수 호출이 완료되는 상황에서 sp의 위치를 8번지에 가져다 놓을 수 있게 되었다. 이는 main 스택과 fct1 스택의 경계가 된다.함수 호출 인자의 전달과 PUSH &amp; POP 명령어 디자인함수 호출 인자의 전달 방식 함수 호출시 전달되는 인자들은 어떻게 함수 내부로 전달되는가? 함수 호출시 전달되는 인자들은 모두 스택에 저장한다. 지역변수가 스택에 할당되는 방식과 동일하다. 그림 function이 호출되면서 두 개의 숫자 7, 8이 전달되고 있다. 현재 sp가 가리키는 위치에 7을 저장하면서 sp을 증가시킨 다음, 다시 8을 저장하면서 sp값을 증가시키고 있다. Push &amp; POP 명령어 디자인 sp가 가리키는 현재 위치에 전달되는 인자값을 저장하고 나서, sp를 증가시켜 다음 메모리를 가르키게 한다.함수 호출(Procedure Call)에 의한 실행의 이동 그림 프로그램 실행시 위와 같은 메모리구조가 형성된다. 코드 영역 프로그램이 동작하기 위한 프로그램 코드(컴파일된 명령어들의 집합)가 올라가는 위치 코드 영역에 실행되어야할 명령어들이 올라가서 순차적인 실행이 이뤄진다. Fetch, Decode, Execution 이 세 단계 중 Fetch 단계가 명령어를 cpu 내부로 가져오는 단계인데, 이때 명령어를 가져오게 되는 위치는 프로그램 코드가 존재하는 코드영역이다. 따라서 컴파일된 프로그램 코드가 코드 영역에 올라간 다음부터 명령어는 순서대로 Fetch, Decode, Execution되는 것이다. 명령어 길이가 4바이트라면, 그리고 실행중인 프로그램이 현재 1036번지에 있는 명령어라면, 다음번에는 1040번지에 있는 명령어가 Fetch 되어야 한다. 이 때, 어느 위치에 있는 명령어까지 가져와 실행했는지 기억해둬야 다음번에 실행할 명령어를 가져올 수 있다. 명령어를 순차적으로 fetch하기 위해 \"pc 레지스터\"를 둔다. pc 레지스터는 fetch 연산이 일어날 때마다 자동적으로 pc값이 증가한다.우리가 직접 pc값을 컨트롤 하지 않아도 된다. 하지만, 필요에 따라 프로그램상에서 pc값을 직접 조절해야 하는 경우도 있다. 함수 호출과 함수 종료 주제 함수 호출시 실행위치의 이동은 어떻게 이뤄지는가? 함수 호출이 끝나고 나면 어떻게 이전 실행위치로 복귀하는가? 그림 함수 호출이 발생할 때,그리고 호출된 함수에서 복귀할 때 특정 위치로의 이동이 가능도록 해야한다. 32비트 명령어 기준으로 pc는 명령어를 실행할 때마다 4씩 증가한다. 이 pc에 함수 호출로 인해 이동해야 할 주소값을 저장해 두면 자연스럽게 실행의 위치는 이동하게 된다. 그 전에, 현재 pc의 값을 백업하는 일이 필요하다. 그렇지 않으면 함수 호출이 완료된 이후 돌아오는 길이 막연하다. 스택에 저장하는 수밖에 없다. 함수 호출 시 스택에 저장해야 할 대상이 늘어났다. 함수 호출 규약(Calling Convention) 함수 호출 시 전달되는 인자가 왼쪽의 인자부터 시작해서 스택에 쌓이는 구조가 있으면 반대로 오른쪽 인자부터 시작해서 스택에 쌓이는 구조도 존재할 수 있다. 전달인자의 스택을 쌓는 방법에 두가지가 존재하듯이, 함수 호출과정에서 할당된 스택 프레임을 반환하는 방법에도 두가지가 존재한다. 스택 프레임의 반환 함수 호출이 완료된 이후의 동작을 의미 주체는 호출자(Caller)가 될 수도 있고, 호출이 된 함수(Function)이 될 수도 있다. 이처럼 함수 호출시 인자를 전달하는 방식과 스택 프레임을 반환하는 방식을 약속해 놓은 것을 가리켜 함수 호출규약이라 부른다.__cdecl,__stdcall + α 함수호출 규약을 지정하는 키워드#define CALLBACK __stdcall#define WINAPI __stdcall 호출규약 선언이 존재하지 않은 함수는 프로젝트 속성창 -&gt; C/C++ -&gt; 고급 -&gt; 호출 규칙을 디폴트로 선언한다.호출규약의 종류와 의미 32비트 기반 함수 호출규약 __cdecl은 C/C++의 디폴트 호출규약 인자 전달방식은 C 언어 스타일로, 오른쪽에 전달되는 인자가 먼저 스택에 쌓이는 방식이다. 반환 시에는 함수를 호출하는 호출자가 스택 프레임을 반환하도록 정의되어 있다. __stdcall와 __cdecl의 차이점은 스택 프레임을 반환하는 주체이다. __stdcall은 호출된 함수 내에서 스택프레임을 반환하도록 정의되어 있다. _fastcall은 함수 호출을 빠르게 처리하기 위한 호출규약 첫 번째 인자와 두 번째 인자는 레지스터의 사용유무를 설명한다. (Parameters in register) 각 인자들은 레지스터 ecx와 dex를 통해 전달된다. 여기서 ecx와 dex는 레지스터의 이름을 의미한다. 호출규약에서 레지스터를 사용함으로써 함수 호출이 빨라지는 근거가 된다. 두 개를 넘어서면 인자에 대해서는 스택을 활용하게 된다. 64비트 기반 함수 호출 규약 64비트 시스템에서는 함수 호출규약이 운영체제에 따라서 나뉘게 된다. Windows 기반에서는 총 8개의 레지스터를 활용해서 전달되는 인자를 저장하게 되는데, 실제로 레지스터에 저장되는 전달인자의 개수는 4개에 지나지 않는다. rcx/xmm0 : 첫 번째 전달인자가 rcx 혹은 xmm0 레지스터에 저장되는 것을 의미 따라서 총 4개의 전달인자까지만 레지스터를 통해 처리한다. 반면 Linux나 BSD 계열의 시스템에서는 훨씬 많은 수의 레지스터를 전달되는 인자에 할당하고 있음을 볼 수 있다. 최대 14개의 인자까지 레지스터를 통해 처리한다. 콜백(Callback) 함수란, Windows 시스템에 의해 자동으로 호출되는 함수를 의미한다. 특정상황에서 호출되어야 할 함수를 등록시키는 것이 가능한데, 이때 등록이 되는 함수를 가리켜 콜백 함수라 한다. 보통 UI와 관련된 API의 이벤트 핸들링 관련된 내용을 공부하면서 자주 접하게 된다." }, { "title": "연산자 오버로딩 - 2", "url": "/posts/%EC%97%B0%EC%82%B0%EC%9E%90-%EC%98%A4%EB%B2%84%EB%A1%9C%EB%94%A9-2/", "categories": "C++", "tags": "C++", "date": "2023-02-13 00:00:00 +0900", "snippet": "산술 연산자 오버로딩 단항 뺄셈과 단항 덧셈 연산자 오버로딩하기 단항 뺄셈 연산자는 피연산자의 부호를 반대로 바꾸는 반면 단항 덧셈 연산자는 그대로 리턴한다. int i, j =4;i = -j; // 단항 뺄셈 연산자i = +i; // 단항 덧셈 연산자j = +(-i); // i에 대한 단항 뺄셈 연산의 결과에 단항 덧셈 연산자를 적용한 예j = -(-i); // i에 대한 단항 뺄셈 연산의 결과에 단항 뺄셈 연산자를 적용한 예 클래스에서 단항 덧셈은 대체로 항등 연산을 수행하기에 오버로딩 하지 않는다. 단항 뺄셈 연산자는 피연산자를 변경하지 않기 때문에 음수를 갖도록 클래스의 객체를 새로 만들어 리턴한다. Person Person::operator-() const{ return Person(-getValue());}// Person A(1);Person B = -A;증가와 감소 연산자 오버로딩하기 클래스에서 증가,감소 연산자를 만들 때 선행 증가인지, 후행 증가인지를 표현하기 위해 후행 연산 오버로딩은 int 타입의 인수를 하나만 받는다.Person&amp; operator++(); // 선행 증가Person operator++(int); // 후행 증가Person&amp; operator--(); // 선행 감소Person operator--(int); // 후행 감소 선행 연산 버전의 리턴값은 피연산자의 최종 결과와 같으므로 레퍼런스로 리턴한다. 하지만 후행 증가 및 감소 연산의 리턴값은 피연산자의 최종 상태와 다르기 때문에 레퍼런스로 리턴할 수 없다. 비트 연산자 오버로딩 하기 비트 연산자와 비트 축약 대입 연산자는 산술 연산자와 산술 축약 대입 연산자와 비슷하다 이전 페이지 표의 예제를 참고 논리 연산자 오버로딩하기 논리 연산자는 오버로딩하는 과정이 조금 복잡해 &amp;&amp;나   를 오버로딩하지 않는 것이 좋다. &amp;&amp;나   연산자는 개별 타입에 적용되지 않고 bool 표현식의 결과를 취합하기만 하며 단락 평가 규칙도 적용하지 못한다. 오버로딩한 &amp;&amp;나   연산자의 매개변수에 바인딩하기 전에 좌변 우변 모두 평가해야하기 때문 혹시나 오버로딩을 해야한다면 구체적인 타입에 대해 오버로딩을 해야한다.스트림 입출력 연산자 오버로딩하기 입출력 연산자 ( &lt;&lt; ,&gt;&gt; )를 통해 스트림 입출력 연산자를 사용한다. 스트림 입력이나 출력 연산자의 왼쪽에는 객체가 아닌 istream이나 ostream 객체가 나와야 한다. istream이나 ostream 클래스에는 메서드를 직접 추가할 수 없기 때문에 스트림 입출력 연산자를 전역함수로 만들어서 오버로딩해야 한다. class Person{ ... // friend 선언으로 전역함수에서 Person의 멤버 접근을 가능하게 만듦 friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; ostr, const Person&amp; _person); //선언 ...};// 전역 함수로 구현std::ostream&amp; operator&lt;&lt;(std::ostream&amp; ostr, const Person&amp; _person);std::istream&amp; operator&gt;&gt;(std::istream&amp; istr, Person&amp; _person); 첫 번째 매개변수로 ostream에 대한 레퍼런스를 받도록 정의한다. 파일 출력 스트림, 스트링 출력 스트림, cout, cerr , clog 등에 적용할 수 있다. 스트림을 레퍼런스로 리턴하기 때문에 연산자를 중첩해서 사용할 수 있다. 두 번째 매개변수는 스트림에 쓰거나 읽을 객체에 대한 레퍼런스이다. 출력 연산자는 객체를 변경하지 않아 const로 지정하지만, 입력 연산자는 수정하기 때문에 const로 지정할 수 없다. 아래와 같은 연산자 구문은 실제로 전역 함수인 operator»나 operator«를 호출하는 구문의 축약형이다.// 축약 전operator&gt;&gt;(operator&gt;&gt;(cin , Child), Adult);// 축약 후cin &gt;&gt; Child &gt;&gt; Adult;인덱스 연산자 오버로딩하기 직접 클래스 템플릿을 만들 때, 크기를 resize해야하는 것을 메서드 호출이 아니라 인덱스 연산자로 resize할 수 있다.template&lt;typename T&gt;class Array{ Array&lt;T&gt;&amp; operator=(const Array&lt;T&gt;&amp; rhs) = delete; // 연산자 오버로딩 ... void SetElementAt(size_t, const T&amp; val); // 현재 size보다 높게 접근하면 내부에서 resize 호출 void resize(size_t newSize); // 내부적으로 공간할당 ...};//Array&lt;int&gt; myArray;for(size_t i= 0; i&lt;10 ; i++){ myArray.setElementAt(i,100); // 함수 호출방식 myArray[i] = 100; // operator[] 방식}읽기 전용 operatr[] 만들기 배열의 원소를 const 레퍼런스로 리턴해서 읽기 전용으로 접근하는 기능을 만들 수 있다.T&amp; operator[](size_t x); // 기존 operator[]const T&amp; operator[](size_t x) const; // 읽기 전용 operator[] C++에서는 메서드나 연산자의 리턴타입만 다르게해서 오버로딩할 수 없기 때문에 메서드 전체를 const로 지정 호출되는 변수가 non-const 버전이냐 const 버전이냐를 따져서 버전에 맞게 호출된다 const operator[]로 구현할 때, 인덱스가 배열의 범위를 벗어나면 새 공간을 할당하지 않고 익셉션을 던진다. 익셉션을 던지지 않고 영으로 초기화된 배열을 리턴하는 방식도 있다. template&lt;typename T&gt;const T&amp; Array&lt;T&gt;::operator[](size_t x) const{ if(x&gt; mSize) // mSize는 배열의 크기 { throw std::out_of_range(\"\"); // 익셉션 // static T nullValue = T(); 영초기화 // return nullValue; } return mElements[x]; // mElement는 배열의 이름}배열의 인덱스가 정수가 아닐 때 인덱스를 key값으로 볼 수도 있다. operator[]를 키에 대한 집합을 값에 대한 집합으로 대응시키는 함수로 사용 대표적인 예로 std::map이 있다. 함수 호출 연산자 오버로딩하기 클래스를 정의할 때 operator()를 추가하면 이 클래스의 객체를 함수 포인터처럼 사용할 수 있다. 함수 호출 연산자를 제공하는 클래스의 객체를 함수객체 또는 펑터(모듈함수) 라 부른다. 이 연산자는 non-static 메서드로 오버로딩해야 한다. class FunctionObject{ public: int operator() (int param); // 함수 호출 연산자 int doSquare(int param); // 일반 메서드};// 오버로딩한 함수 호출 연산자의 구현코드int FunctionObject::operator() (int param){ return doSquare(param);}// 일반 메서드 구현 코드int FunctionObject::doSquare (int param){ return param * param;}//int x = 3; xSquared, xSquaredAgain;FunctionObject square;xSquared = square(x); // 함수 호출 연산자를 호출xSquaredAgain = square.doSquare(x); // 일반 메서드 호출 일반 메서드 대신 함수 객체로 만들면 좋은점은 함수 객체를 함수포인터로 표현해서 다른 함수에 콜백 함수로 전달할 수 있다. 또한 전역함수보다 함수 객체로 만들면 다음과 같은 장점이 있다. 함수 호출 연산자를 여러 번 호출하더라도 객체의 데이터 멤버를 통해 정보를 지속적으로 유지할 수 있다. 예를 들어 함수 호출 연산자를 호출할 때마다 누적된 숫자의 합을 함수 객체에 유지할 수 있다. 데이터 멤버를 설정하는 방식으로 함수 객체의 동작을 변경할 수 있다. 예를 들어 함수 호출 연산자에 지정한 인수를 데이터 멤버의 값과 비교하는 함수 객체를 만들 수 있다. 이 때 데이터 멤버를 설정할 수 있다면 비교 방식을 마음대로 변경할 수 있다. 앞에 나온 장점을 전역변수나 static변수로도 구현할 수 있지만 함수 객체를 활용하면 코드가 훨씬 깔끔해진다. 게다가 전역 변수나 static변수는 멀티스레드 애플리케이션에서 문제를 발생시킬 수 있다. 역참조 연산자 오버로딩하기 *와 -&gt;의 기본 의미 * : 포인터가 가리키는 값에 직접 접근하는 역참조 연산자 -&gt; : * 연산자 뒤에 멤버를 지정하는 .연산자를 붙인 것을 축약(간접 접근) 클래스를 직접 정의할 때 역참조 연산자를 오버로딩하면 그 클래스의 객체를 포인터처럼 다룰 수 있다. 이 기능은 스마트 포인터를 구현할 때 사용한다 또한 반복자를 다룰 때도 유용하다. operator* operator* 클래스 예시template&lt;typename T&gt;class Pointer{ public: // 코드 생략 T&amp; operator*(); const T&amp; operator*() const; // 코드 생략 private: T* mPtr = nullptr;};template&lt;typename T&gt;T&amp; Pointer&lt;T&gt;::operator*(){ return *mPtr;}template&lt;typename T&gt;const T&amp; Pointer&lt;T&gt;::operator*() const{ return *mPtr;} operator*는 클래스 내부의 일반 포인터가 가리키던 객체나 변수에 대한 레퍼런스를 리턴operator-&gt; 화살표 연산자를 적용한 결과는 반드시 객체의 멤버나 메서드여야 한다. 이렇게 구현하기 위해서 operator*를 실행한 뒤 바로 operator.를 호출해야 한다. 하지만 C++에서는 operator.을 오버로딩할 수 없다. 그렇기 때문에 C++는 operator-&gt;를 예외취급한다. C++에서는 operator-&gt;은 다른 operator과 다르게 취급한다. (예외취급)Person-&gt;set(5);// C++은 위의 코드를 아래와 같이 해석(Person.operator-&gt;())-&gt;set(5); C++는 operator-&gt; 에서 리턴한 값에 다른 operator-&gt;를 적용하기 때문에 반드시 포인터로 리턴하게 오버로딩해야 한다. operator-&gt; 클래스 예시template&lt;typename T&gt;class Pointer{ public: // 코드 생략 T* operator-&gt;(); const T* operator-&gt;() const; // 코드 생략 private: T* mPtr = nullptr;};template&lt;typename T&gt;T* Pointer&lt;T&gt;::operator-&gt;(){ return mPtr;}template&lt;typename T&gt;const T* Pointer&lt;T&gt;::operator-&gt;() const{ return mPtr;}operator.* 와 operator-&gt;* C++는 클래스의 데이터 멤버와 메서드에 대한 주소를 받아서 포인터를 만드는 기능을 정식으로 지원한다. 하지만 객체를 거치지 않고서는 non-static 메서드나 데이터 멤버를 호출하거나 접근할 수 없다. 클래스에서 데이터와 메서드를 제공하는 목적은 객체마다 데이터멤버와 메서드를 따로 갖게 하기 위함이다. 따라서 포인터를 통해 데이터 멤버에 접근하거나 메서드를 호출하려면 객체의 문맥 안에서 포인터를 역참조해야 한다. SpreadsheetCell myCell;double (SpreadsheetCell::*methodPtr) () const = &amp;SpraedsheetCell::getValue;cout &lt;&lt; (myCell.*methodPtr)() &lt;&lt; endl; .*연산자를 통해 메서드 포인터를 역참조하는 방식이 호출됐다. 또한 객체 자체는 없고, 객체에 대한 포인터만 있을 때는 다음과 같이 -&gt;*로 메서드를 호출한다. SpreadsheetCell* myCell = new SpreadsheetCell();double (SpreadsheetCell::*methodPtr) () const = &amp;SpraedsheetCell::getValue;cout &lt;&lt; (myCell-&gt;*methodPtr)() &lt;&lt; endl operator.와 마찬가지로 operator.*도 오버로딩할 수 없다. operator-&gt;*는 오버로딩이 가능하지만 복잡할 뿐만 아니라 포인터로 데이터 멤버나 메서드를 접근할 수 있다는 사실을 아는 프로그래머가 거의 없기 때문에 굳이 작성할 필요가 없다. " }, { "title": "프로세스의 스케줄링", "url": "/posts/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81/", "categories": "윈도우즈시스템프로그래밍, 운영체제", "tags": "windows", "date": "2023-02-11 00:00:00 +0900", "snippet": "선점형 OS와 비선점형 OS 비선점형 OS 현재 실행중인 프로세스보다 우선순위가 높은 프로세스가 등장한다고 해서 실행대상을 바로 변경하지 않는다. 현재 실행중인 프로세스가 명시적으로 CPU를 양보하거나, I/O 작업등으로 블로킹 상태에 놓일때까지 기다려야 한다. 과거 Windows 시리즈가 비선점형 OS를 사용한다. 선점형 OS 현재 실행 중인 프로세스보다 높은 우선순위의 프로세스가 등장하면 스케줄러에 의한 실행순서 조정이 가해진다. 비선점형 OS에 비해 스케줄러가 하는 일이 많다. 둘 이상의 프로세스를 동작시키는 멀티 프로세스 기반 OS에 적합하다. 요즘 Windows 시리즈는 선점형 OS를 사용한다. 우선순위 스케줄링 알고리즘 각각의 프로세스마다 우선순위를 부여해 우선순위가 높은 프로세스를 먼저 실행시키는 방식 우선순위가 높은 프로세스(A프로세스) 와 우선순위가 낮은 프로세스(B프로세스) 를 동시에 실행한다고 가정한다면 B프로세스는 실행되지 않는다. 이런 상태를 기아상태라고 한다. A프로세스가 먼저 실행되는 것이 맞지만, A프로세스가 I/O관련 작업을 하는 과정에서 B프로세스가 실행 기회를 얻을 수도 있다. 라운드 로빈 스케줄링 알고리즘 우선순위가 동일한 프로세스의 경우를 위한 알고리즘 우선순위의 프로세스들간 형평성 유지를 위해, 정해진 시간 간격만큼만 실행을 하고 우선순위가 동일한 다른 프로세스에게 CPU의 할당을 넘기는 방식을 제공 동일한 우선순위의 모든 프로세스들은 타임 슬라이스를 기준으로 CPU의 할당을 넘기게 된다. 실행의 최소 단위 시간 간격을 가리켜 퀸텀(Quanturm) 혹은 타임 슬라이스(TimeSlice)라 한다. 만약 타임슬라이스를 길게하면 상호작용 관련에서 문제가 생길수도 있다. 마우스의 반응이 늦어짐 만약 타임슬라이스를 짧게하면 컨텍스트 스위칭이 자주 발생하여 성능에 저하를 준다.스케줄링 알고리즘에 의해서 스케줄링이 진행되는 시점 스케줄러가 동작하도록 디자인을 위한 3가지 관점 라운드 로빈 방식 스케줄링 알고리즘 정해진 시간이 지나면 다음 프로세스에게 실행순서를 넘긴다. 스케줄러를 넘기기 위해서는 스케줄러가 동작 해야한다 그렇다면 언제 스케줄러가 동작해야 할까? 프로세스의 실행 간격에 해당하는 매타임 슬라이스마다 스케줄러는 동작해야한다. 우선순위 방식의 스케줄링 알고리즘 적용 우선순위가 높은 프로세스는 무조건 먼저 실행되어야 한다. 따라서 새로운 프로세스가 등장할 때마다 실행중인 프로세스와 비교해야한다. 즉, 새로운 프로세스가 생성될 때마다 스케줄러는 동작해야한다. 현재 실행중인 프로세스가 종료되고 다른 프로세스가 실행될 때도 스케줄러는 동작해야한다. 블로킹 상황 실행중인 프로세스가 블로킹 상태가 되면 다른 프로세스가 대신 실행된다. 따라서 실행될 다른 프로세스를 선정하기 위해서도 스케줄러는 동작해야한다. 정리 매 타임 슬라이스 마다 스케줄러 동작 프로세스가 생성 및 소멸될 때마다 스케줄러 동작 현재 실행 중인 프로세스가 블로킹 상태에 놓일 때마다 스케줄러 동작Priority Inversion 프로세스의 우선순위가 뒤 바뀌는 현상예시 프로세스 A &gt; 프로세스 B &gt; 프로세스 C 순으로 우선순위를 가지는 프로세스가 있다고 가정했을 때 A프로세스가 실행중이다가 C프로세스가 계산해서 줘야할 값이 아직 도착하지 않으면 작업을 멈추고 Blocked 상태에 들어가면서 프로세스 C에게 기회를 준다 그 때 C보다 우선순위가 높은 프로세스 B가 프로세스 C보다 먼저 실행되면서 우선순위가 뒤바뀐다. 프로세스 A가 Blocked 상태가 아닌 프로세스 C에게 우선순위를 잠시 위임하고 Blocked 상태로 빠진다. 운영체제마다 Priority Inversion의 해결방법이 다를 수도 있고 지원하지 않을 수도 있다. " }, { "title": "연산자 오버로딩 - 1", "url": "/posts/%EC%97%B0%EC%82%B0%EC%9E%90-%EC%98%A4%EB%B2%84%EB%A1%9C%EB%94%A9-1/", "categories": "C++", "tags": "C++", "date": "2023-02-11 00:00:00 +0900", "snippet": "연산자 오버로딩 객체에 대한 연산을 위해 연산자를 오버로딩하여 사용한다. 기본적으로 operator연산자 형식 ex) operator+, operator* ,operator-= 등등 예시// 클래스class A{private: int intValue = 5;public: int GetInt() { return intValue; } A() = default; A(int i) : intValue(i) {} A operator+(A&amp; _other) // +연산자 오버로딩 { return A(GetInt() + _other.GetInt()); } };int main(){ A a(5); A b(10); A C(a + b); // 객체 a와 b의 intValue값을 더해서 C의 intValue값에 전달 // A C(a.operator+(b)); 와 동일 cout &lt;&lt; C.GetInt(); // 15 출력}전역 함수 연산자 오버로딩 묵시적 변환을 활용하면 opeartor+를 정의할 수 있지만 교환법칙이 성립하지 않는다. 묵시적 변환은 객체가 연산자의 좌변에 있을 때 적용되기 때문 class A{private: int intValue = 5;public: int GetInt() { return intValue; } A() = default; A(int i) : intValue(i) {} A operator+(int num) { return this-&gt;GetInt() + num; }};int main(){ A a(5); A b(10); A C(a + 10); // A D(10 + a); 객체가 우측에 있어 operator+가 적용되지 않음.} 클래스에 정의한 operator+를 전역 함수로 만들면 교환법칙이 성립하게 만들 수 있다. 전역 함수는 특정 객체에 종속되지 않기 때문 operator 함수에 friend를 선언해서 멤버 변수에 접근할수 있다.class A{private: int intValue = 5;public: int GetInt() const{ return intValue; } void SetInt(int addValue) { intValue += addValue; } A() = default; A(int i) : intValue(i) {} friend A operator+(const A&amp; lhs, const A&amp; rhs);};A operator+(const A&amp; lhs, const A&amp; rhs){ return A(lhs.GetInt() + rhs.GetInt());}int main(){ A a(5); A b(10); A C(a + 10); A D(10 + a); cout &lt;&lt; C.GetInt() &lt;&lt; endl; cout &lt;&lt; D.GetInt();}연산자 오버로딩을 하는 이유 자신이 정의할 클래스를 기본 타입처럼 다루기 위해서 정의한 클래스를 기본 타입에 가까울수록 클라이언트 입장에서는 사용하기 쉽다. 프로그램을 좀 더 세밀하게 제어하기 위해서 직접 정의한 클래스의 객체를 새로 만들어서 분배하고 수거하는 과정을 원하는 방식으로 정의할 때 메모리 할당과 해제 연산자를 오버로딩할 수 있다. 연산자 오버로딩의 한계 연산자 기호를 새로 만들수는 없다. 언어에 정의돼 있는 연산자만 의미를 변경할 수 있다. 다음 연산자는 오버로딩할 수 없다. . (객체의 멤버에 접근하는 연산자) :: (스코프 지정 연산자) sizeof ? : (조건연산자) 에리티를 변경할 수 있는 곳은 함수 호출, new , delete뿐이다. 에리티(arity)는 연산자의 인수 또는 피연산자(operand)의 개수이다. 연산자의 우선순위와 결합순위는 바꿀 수 없다. 기본 타입 연산자의 의미는 바꿀 수 없다. 오버로딩할 수 있는 연산자는 클래스의 메서드이거나, 오버로딩하려는 전역 함수의 인수중 최소 하나가 사용자 정의 타입이어야 한다. 클래스를 직접 정의할 때는 가능 단, 메모리 할당과 해제 연산자는 예외 연산자 오버로딩 선택 연산자를 오버로딩하는 함수나 메서드를 작성할 때 몇가지 결정할 사항이 있다.1 - 메서드와 전역함수오버로딩할 연산자를 클래스의 메서드로 정의할지, 전역함수(주로 클래스의 friend)로 정의할지 선택해야 한다.아래와 같이 세 종류가 있다. 메서드로 정의해야 하는 연산자 어떤 연산자는 클래스 문맥을 벗어나면 의미가 없기 때문에 반드시 클래스에 속한 메서드여야 한다. ex) operator=은 소속 클래스와 밀접한 관계에 있어 클래스와 별도로 존재할 수 없다. 전역함수로 정의해야 하는 연산자 연산자의 좌변에 소속 클래스가 아닌 다른 타입의 변수도 나와야 한다면 연산자를 전역 함수로 만든다. ex) iostream 객체가 나와야하는 operator«와 operator»가 있다. 메서드와 전역 함수 둘 다 가능한 연산자 특별히 전역 함수로 만들어야할 이유가 없다면 메서드로 만드는 것이 좋다 이유는 메서드로 만들면 virtual로 선언할 수 있지만 전역 함수는 그럴 수 없기 때문이다. 2 - 인수 타입에 대한 결정사항인수 타입에 대해서는 인수 개수를 변경할 일이 별로 없어 선택할 사항이 많지 않다.예를 들어 operator/는 전역 함수로 만들면 인수가 두개, 메서드로 만들면 인수가 한개만 받을 수 있다.3 - 리턴 타입에 대한 결정사항C++는 적합한 오버로딩 연산자를 찾을 때 리턴타입을 고려하지 않지만, 마음대로 하는게 바람직하지는 않다.그보다는 오버 로딩 연산자도 기본 타입 연산자와 동일한 타입을 리턴해야 한다.레퍼런스와 const에 대한 결정 원칙은 리턴 타입에도 똑같이 적용된다.일반적으로 레퍼런스로 리턴할 수 있으면 레퍼런스로 리턴하고, 그렇지 않으면 값으로 리턴한다.연산자에서 객체를 새로 생성한다면 값으로 리턴하고 그렇지 않으면 연산자를 호출한 객체나 연산자의 인수에 대한 레퍼런스를 리턴한다.오버로딩하면 안되는 연산자 C++에서 허용하더라도 오버로딩하면 안 되는 연산자가 있다. 주소연산자(operator&amp;) , 이항 부울 연산자 (operator&amp;&amp; 와 operator| ) , 콤마 연산자(operator,)등이 있다. 주소 연산자는 오버로딩해서 좋은 점이 없을 뿐더러 주소를 가져온다는 C++의 기본 동작을 상식과 다르게 해버리면 헷갈리게 된다. 이항 부울 연산자는 C++의 단락 평가 규칙을 적용할 수 없기 때문. 단락 평가는 첫 번째 값만으로 결과가 확실할 때 두 번째 값은 확인(평가)하지 않는 방법을 말한다 오버로딩할 수 있는 연산자우측값 레퍼런스 우측값 레퍼런스는 좌측값 레퍼런스에서 쓰는 &amp; 대신 &amp;&amp;를 사용한다.// 일반 대입연산자의 포로토타입T&amp; operator=(const T&amp;);// 이동 대입 연산자의 프로토타입T&amp; operator=(T&amp;&amp;); 위의 표에서는 우측값 레퍼런스를 적용한 프로토타입은 없지만 대부분의 연산자는 기존 좌측값 레퍼런스 버전과 우측값 레퍼런스 버전이 함께 있어도 상관없다.예시 라이브러리에서 제공하는 std::string 클래스의 operator+는 우측값 레퍼런스로 구현했다.string operator+(string&amp;&amp; lhs, string&amp;&amp; rhs); 두 인수가 레퍼런스 우측값으로 전달됐기 때문에 둘 중 하나에 대한 메모리를 재사용할 수 있다. 참고로 인수가 우측값 레퍼런스라는 말은 연산이 끝나면 삭제되는 임시 객체라는 뜻 이렇게 구현된 operator+는 두 인수의 크기와 용량에 따라 다음 두가지 동작 중 하나를 수행한다.1. return std::move(lhs.append(rhs));2. return std::move(rhs.insert(0,lhs)); 실제로 std::string operator+의 오버로딩 버전을 보면 좌측값 레퍼런스와 우측값 레퍼런스 다양하게 조합해서 사용한다.관계 연산자 C++ 표준 라이브러리는 &lt;utility&gt;라는 헤더 파일을 제공하는데 여기서 다양한 헬퍼 함수와 클래스를 제공한다. 다음과 같은 관계 연산자에 대한 함수 템플릿도 std::rel_ops 네임 스페이스에서 제공한다. template&lt;class T&gt; bool operator!=(const T&amp; a, const T&amp; b); // operator== 정의 필요template&lt;class T&gt; bool operator&gt; (const T&amp; a, const T&amp; b); // operator&lt; 정의 필요template&lt;class T&gt; bool operator&lt;=(const T&amp; a, const T&amp; b); // operator&lt; 정의 필요template&lt;class T&gt; bool operator&gt;=(const T&amp; a, const T&amp; b); // operator&lt; 정의 필요 이런 함수 템플릿은 다른 클래스에 있는 ==, &lt; 연산자로 !=, &gt;, &lt;=, &gt;=와 같은 연산자를 정의한다. 코드에서 #include&lt;utility&gt;문과 using문만 추가한다면 이 템플릿을 사용할 수 있다. using namespace std::rel_ops; 하지만 현재 정의한 클래스뿐만 아니라 관계 연산에 관련된 모든 클래스에 대해 이 연산자가 생성되는 문제가 있다. 또한 이렇게 자동 생성된 관계 연산자는 std::greater&lt;T&gt;와 같은 유틸리티 템플릿과 함께 작동하지 않는다. 암묵적 변환도 적용되지 않는다. 작성할 클래스에서 std::rel_ops를 사용하는것보단 관계 연산자를 구현하는 것이 좋다. " }, { "title": "에러 처리하기 - 3", "url": "/posts/%EC%97%90%EB%9F%AC-%EC%B2%98%EB%A6%AC%ED%95%98%EA%B8%B0-3/", "categories": "C++", "tags": "C++", "date": "2023-02-09 00:00:00 +0900", "snippet": "익셉션 처리 과정에서 흔히 발생하는 문제 익셉션 매커니즘을 이용해서 에러 처리할 때 흔히 발생하는 문제들이 있다.메모리 할당 에러 흔히 사용하는 64비트 플랫폼에서는 이런 일이 거의 없지만, 모바일 시스템이나 레거시 시스템에서는 메모리 할당 에러가 드물지 않게 발생한다. new나 new[]에서 메모리를 할당할 수 없을 때 기본적으로 수행하는 동작은 &lt;new&gt; 헤더 파일에 정의된 bad_alloc 익셉션을 던지낟. new나 new[]를 호출할 때마다 try/catch문으로 감싸도 되지만, 할당하려는 메모리 블럭의 크기가 글 때만 이렇게 하는 것이 좋다. // 메모리 할당 익셉션을 잡는 방법int* ptr = nullptr;size_t integerCount = numeric_limits&lt;size_t&gt;::max();try{ ptr = new int[integerCount];} catch(const bad_alloc&amp; e){ ... return;}익셉션을 던지지 않는 new 익셉션 매커니즘을 사용하지 않고, 예전 C방식처럼 메모리 할당에 실패하면 널포인트를 리턴하도록 작성해도 된다. C++는 익셉션을 던지지 않는 nothrow 버전의 new와 new[]도 제공한다. int* ptr = new(nothrow) int[integerCount]; // 익셉션을 던지지 않는 nothrow버전의 newif ( nullptr == ptr ){ ... return;} nothrow는 new의 인수메모리 할당 에러 처리 방식 커스터마이즈하기 C++는 new 핸들러 콜백 함수를 커스터마이즈하는 기능을 제공한다. 기본적으로 new나 new[]는 new핸들러를 사용하지 않고 bad_alloc 익셉션을 던진다. new 핸들러 new 핸들러를 정의하면 메모리 할당 루틴에서 에러가 발생했을 때 익셉션을 던지지 않고 정의된 new 핸들러를 호출한다. new 핸들러가 리턴하면 메모리 할당 루틴은 메모리를 다시 할당하려 하는데, 실패해도 다시 new 핸들러를 호출한다. new 핸들러는 다음 세 가지 중 한가지 방식으로 구현하지 않으면 무한루프가 발생할 수 있다. 메모리 추가하기 공간 확보를 위한 한가지 방법은 프로그램 구동시 큰 덩어리의 메모리를 할당했다가 new 핸들러로 해제 ex)메모리 할당 에러가 발생하면 현재 상태를 저장하기 위해서는 new 핸들러가 호출되면 이 블록을 해제한 뒤 상태를 저장하고 프로그램을 다시 구동해서 저장된 상태를 불러온다. 익셉션 던지기 C++표준에서는 new 핸들러에서 익셉션을 던질 때 반드시 bad_alloc이나 이를 상속한 익셉션을 던져야 한다. ex) bad_alloc을 상속한 document_recovery_alloc(문서 저장) 다른 new 핸들러 설정하기 이론적으로 new 핸들러를 여러 개 만들어 각각 메모리를 생성하고 문제가 발생하면 다른 new 핸들러를 설정 실제 효과에 비해 코드가 복잡하다는 단점이 있음 생성자에서 발생하는 에러 생성자가 값을 리턴하지 못해도 익셉션을 던질 수 있다. 하지만 익셉션이 발생해서 생성자가 정상종료되지 않고 중간에 실행을 멈추고 빠져나와버리면 나중에 그 객체의 소멸자가 호출될 수 없다 따라서 익셉션이 발생해서 생성자를 빠져나올 때는 반드시 생성자에서 할당했던 메모리와 리소스를 정리해야 한다. 예시// 클래스 템플릿template &lt;typename T&gt;class Matrix{ public: Matrix(size_t width, size_t height); virtual ~Matrix(); private: void cleanup(); size_t mWidth = 0; size_t mHeight = 0; T** mMatrix = nullptr;}// 생성자 구현 코드template&lt;typename T&gt;Matrix&lt;T&gt;::Matrix(size_t width, size_t height){ mMatrix = new T*[width] {}; // 초기화 // 생성자 이니셜라이저로는 초기화하면 안됨. new가 성공적으로 할당될 때만 초기화 mWidth = width; mHeight = height; try{ for(size_t i = 0 ;i &lt; width; i++){ mMatrix[i] = new T[height]; } } catch(...){ // T의 생성자에서 발생한 익셉션을 알 수 없어 모든 익셉션을 잡기위해 ...를 사용 cleanup(); // 발생한 익셉션을 모두 bad_alloc 익셉션 안에 중첩 std::throw_with_nexted(std::bad_alloc()); }}생성자를 위한 try블록 함수 try블록이란 기능으로 익셉션을 처리 함수 try블록은 일반 함수뿐만 아니라 생성자에 적용할 수도 있다. MyClass::MyClass()try : &lt;생성자 이니셜라이저&gt;{ /* 생성자 본문 */}catch (const exception&amp; e){ / * ... */} 함수 try 블록을 적용할 때 주의할 점 catch문은 생성자 이니셜라이저나 생성자 본문에서 발생한 익셉션을 잡아서 처리한다. catch문은 반드시 현재 발생한 익셉션을 다시 던지거나 새 익셉션을 만들어 던져야한다.catch문에서 이렇게 처리하지 않으면 런타임이 자동으로 현재 익셉션을 다시 던진다. catch문은 생성자에 전달된 인수에 접근할 수 있다. ctach문이 함수 try 블록에서 익셉션을 잡으면 생성자의 실행을 정상적으로 마친 베이스 클래스나 그 객체로 된 멤버는 ctach 문을 시작하기전에 소멸한다. catch문 안에서 객체로 된 멤버 변수에 접근하면 안된다.(catch문이 실행되기전에 소멸되기 때문)그런데 익셉션이 발생하기 전에 그 객체에 논클래스 타입(ex)일반 포인터) 데이터 멤버를 초기화 했다면 접근할 수 있음이런 리소스 정리 작업은 catch문에서 처리해야함 함수 try 블록에 있는 catch문은 그 안에 담긴 함수에서 값을 리턴할 때 return 키워드를 사용할 수 없다생성잔는 원래 아무것도 리턴하지 않기 때문 함수 try 블록은 다음과 같은 제한된 상황에 적합하다 생성자 이니셜라이저에서 던진 익셉션을 다른 익셉션으로 변환할 때 메시지를 로그 파일에 기록할 때 생성자 이니셜라이저에서 할당한,소멸자로 자동 제거할 수 없는 리소스를 익셉션에 던지기 전에 해제할 때 소멸자에서 익셉션을 처리하는 방법 소멸자에서 발생한 에러는 반드시 소멸자 안에서 처리해야 한다.(다른곳으로 던지면 안됨) 그 이유는 다음과 같다 소멸자를 명시적으로 noexcept(false)로 지정하지 않거나, 클래스에 있는 객체 중 소멸자에 noexcept(false)가 지정된 것이 없다면 내부적으로 noexcept로 선언된 것으로 취급한다.noexcept 소멸자에서 익셉션을 던지면 C++런타임은 std::terminate()을 호출해서 프로그램 종료 소멸자는 이미 다른 익셉션이 발생해서 스택 풀기를 수행하는 과정에서도 실행될 수 있다. 스택풀기 도중에 소멸자에서 익셉션을 던지면 C++ 런타임은 std::terminate()을 호출해서 종료 클라이언트는 소멸자를 직접 호출하지 않고 delete를 통해 간접적으로 소멸자를 호출한다.그런데 소멸자에서 익셉션을 던지면 이미 delete를 호출한 객체에 다시 delete를 호출할 수도 없고 소멸자를 직접 호출할 수도 없게 된다. 소멸자는 객체에서 사용할 메모리나 리소스를 해제할 마지막 기회이므로, 함수 실행 도중에 익셉션을 던져 기회를 놓치면 다시 돌아가 메모리나 리소스를 해제할 수 없다. " }, { "title": "에러 처리하기 - 2", "url": "/posts/%EC%97%90%EB%9F%AC-%EC%B2%98%EB%A6%AC%ED%95%98%EA%B8%B0-2/", "categories": "C++", "tags": "C++", "date": "2023-02-07 00:00:00 +0900", "snippet": "익셉션 클래스 직접 정의하기 익셉션 클래스를 직접 정의하면 두 가지의 장점이 있다. 익셉션 클래스를 직접 정의하면 runtime_error처럼 광범위한 이름 대신 발생한 에러에 최대한 가까운 이름으로 표현할 수 있다. 원하는 정보를 익셉션에 얼마든지 추가할 수 있다. 표준 라이브러리에서 제공하는 익셉션은 에러 스트링만 넣을 수 있다. 익셉션을 직접 정의할 때는 반드시 표준 exception 클래스를 직접 or 간접적으로 상속하는 것이 좋다. 단, 이 원칙을 따르지 않는 서드파티 라이브러리가 있을 때는 X 파일 에러 클래스class FileError : public exception{ public: FileError(string_view fileName) : mFileName(fileName) {} virtual const char* what() const noexcept override { return mMessage.c_str(); } string_view getFileName() const noexcept { return mFileName; } protected: void setMessage(string_view message) { mMessage = message; } private: string mFileName; string mMessage;}; exception 클래스를 상속하려면 what() 메서드를 오버라이드해야 한다. 이 스트링은 익셉션 객체가 소멸되기 전까지 사용할 수 있다. 이 스트링을 mMessage에 저장하고 파생 클래스에선 setMessage 메서드를 이용하여 다른 값으로 설정할 수 있다. 파일 열기 에러 클래스class FileOpenError : public FileError{ public: FileOpenError(string_view fileName) : FileError(fileName) { setMessage(\"Unable to open\"s + fileName.data()); }}; FileError 클래스를 상속한다. FileOpenError 익셉션은 파일 열기 에러를 표현하는 값을 mMessage에 저장 파일 읽기 에러 클래스class FileReadError : public FileError{ public: FileReadError(string_view fileName, size_t lineNumber) : FileError(fileName) , mLineNumber(lineNumber) { ostringstream ostr; ostr &lt;&lt; \"Error reading \" &lt;&lt; fileName &lt;&lt; \" at line \" &lt;&lt; lineNumber; // 에러 줄 번호 setMessage(ostr.str()); } size_t getLineNumber() const noexcept { return mLineNumber; } private: size_t mLineNumber;} FileError 클래스를 상속한다. FileReadError 클래스는 파일이 열리지 않는 예외 상황을 위한 클래스 이렇게 작성한 FileError 클래스의 다형성을 이용하여 익셉션을 처리하는 catch 구문을 다음과 같이 작성할 수 있다.try { ...} catch (const FileError&amp; e){ ...} 익셉션이 발생하면 그 익셉션 객체를 이동 생성자나 복제 생성자로 이동하거나 복제하게 된다. 익셉션 객체는 최소 한번 이상 이동하거나 복제된다. 익셉션 객체를 레퍼런스로 받지 않으면 여러번 복제될 수 있다. 그래서 익셉션으로 사용할 클래스를 정의할 때는 객체를 복제하거나 이동할 수 있도록 만들어야한다. 중첩된 익셉션 익셉션을 처리하는 도중 다른 에러가 발생해 새로운 익셉션이 전달되면 현재 처리하고 있던 익셉션 정보는 사라진다. 먼저 잡은 익셉션을 새로 발생한 익셉션의 문맥 안에 포함시킬 수 있다. 예시// 클래스class MyException : public std::exception{ public: MyException(string_view message) : mMessage(message) {} virtual const char* what() const noexcept override{ return mMeesage.c_str(); } private: string mMessage; }// 함수void doSomething(){ try{ throw runtime_error(\"Throwing a runtime_error exception\"); } catch(const runtime_error&amp; e){ cout &lt;&lt; __func__ &lt;&lt; \" caught a runtime error\" &lt;&lt; endl; cout &lt;&lt; __func__ &lt;&lt; \" throwing MyException\" &lt;&lt; endl; throw_with_nested( MyException(\"MyException with nested runtime_error\")); // 새로운 익셉션을 throw }}// main()int main(){ try{ doSomething(); } catch(const MyException&amp; e){ cout &lt;&lt; __func__ &lt;&lt; \" caught MyException: \" &lt;&lt; e.what() &lt;&lt; endl; const auto* pNetsed = dynamic_cast&lt;const nested_exception*&gt;(&amp;e); // 이전 익셉션 접근 if(pNested){ try{ pNested-&gt;rethrow_nested(); } catch(const runtime_error&amp; e){ // 중첩된 익셉션 처리 cout &lt;&lt; \"Nested exception :\" &lt;&lt; e.what() &lt;&lt; endl; } } } return 0;} 어떤 익셉션을 처리하는 catch 문에서 새로운 익셉션을 던지려면 std::throw_with_netsed()를 이용한다. 나중에 발생한 익셉션을 처리하는 catch 문에서 먼저 발생했던 익셉션에 접근할 때는 dynamic_cast를 이용한다. MyException을 처리하는 catch 핸들러로 dynamic_cast()를 이용하여 현재 익셉션에 중첩된 익셉션에 접근 중첩된 익셉션이 없다면 널 포인트를 리턴 중첩된 익셉션이 있다면 nested_exception의 rethrow_nested() 메서드를 호출해 다시 익셉션을 던져 다른 try/catch문에서 처리한다. rethrow_if_nested()라는 헬퍼 함수를 이용하여 중첩된 익셉션을 확인할 수도 있다// 아래와 위 모두 같은 동작const auto* pNetsed = dynamic_cast&lt;const nested_exception*&gt;(&amp;e);if(pNested){try{ pNested-&gt;rethrow_nested();} catch(const runtime_error&amp; e)=====================try{ rethrow_if_nested(e);} catch(const runtime_error&amp; e);스택 풀기와 청소 익셉션을 던지면 받아서 처리할 catch 핸들러를 스택에서 찾으려 하는데 catch 핸들러는 스택 프레임에 있을수도 있고 몇 단계의 함수 호출 스택을 거슬러 올라가야 있을 수도 있다. catch 핸들러를 발견하면 그 핸들러가 정의된 스택 단계로 되돌아가는데, 이 과정에서 중간단계에 있는 스택 프레임을 모두 푸는걸 “스택풀기“라 한다. 스코프가 로컬인 소멸자는 모두 호출하고, 각 함수에서 미처 실행하지 못한 코드는 건너뛴다. 스택 풀기가 발생할 때 포인터 변수를 해제하고 리소스를 정리하는 작업이 실행되지 않아 문제가 생길수도 있다.void funcOne();void funcTwo();int main(){ try{ funcOne(); } catch(const exception&amp; e){ cerr &lt;&lt; \"Exception caught!\" &lt;&lt; endl; return 1; } return 0;}void funcOne(){ string str1; string* str2 = new string(); funcTwo(); delete str2;}void funcTwo(){ ifstream fileStream; fileStream.open(\"filename\"); throw exception(); fileStream.close();} funcTwo 에서 익셉션을 던질 때 가장 가까운 핸들러는 main에 있다. 그래서 funcTwo의 throw exception(); 문장에서 main의 cerr « “Exception caught!” « endl로 건너뛴다. 건너 뛰어버리면서 fileStream.close()가 실행되지 않는다 ifStream는 스택에 있는 로컬변수라 소멸자가 호출되어 파일을 대신 닫아주므로 리소스 누수가 발생하지는 않는다. str1도 로컬 변수라 제대로 해제가 된다. delete str2는 실행되지 않아 메모리 누수가 발생한다. 스마트 포인터 활용 스택 기반 할당 방식을 사용할 수 없다면 스마트 포인터를 활용하여 메모리나 리소스를 자동으로 처리한다.void funcOne(){ string str1; auto str2 = make_unique&lt;string&gt;(\"hello\"); funcTwo();} str2 포인터는 funcOne()을 호출한 후 리턴될 때 또는 그 안에서 익셉션이 발생할 때 자동으로 제거된다.익셉션 잡고, 리소스 정리한 뒤,익셉션 다시 던지기 메모리 및 리소스 누수 방지의 다른 기법은 각 함수마다 발생 가능한 익셉션을 모두 잡아서 리소스를 제대로 정리한뒤 그 익셉션을 다시 스택의 상위 핸들러로 던지는 것이다.void funcOne(){ string str1; string* str2 = new string(); try{ funcTwo(); } catch(...) { delete str2; throw; // funcTwo()에서 던져서 잡은 익셉션을 다시 위로 던진다. } delete str2;} 위의 방식보다는 되기는 하지만 스마트 포인터나 RAII 클래스를 사용하는 방법이 더 좋다." }, { "title": "에러 처리하기 - 1", "url": "/posts/%EC%97%90%EB%9F%AC-%EC%B2%98%EB%A6%AC%ED%95%98%EA%B8%B0-1/", "categories": "C++", "tags": "C++", "date": "2023-02-06 00:00:00 +0900", "snippet": "익셉션 예외 상황이나 에러가 코드의 정상적인 실행 흐름에 퍼지지 않도록 알려주는 매커니즘 에러가 발생하면 익셉션을 던지고(throw), 이를 처리하는 코드는 발생한 익셉션을 받아서 처리(catch)한다. 익셉션을 던지면 프로그램의 정상 실행 흐름을 잠시 멈추고 익셉션 핸들러(예외 처리기)로 제어권을 넘긴다. C++에서 익셉션이 필요한 이유 C나 C++ 프로그램을 보면 에러를 처리하는 방식이 제각각이고 체계가 없는 경우가 많다. 함수가 정수코드를 리턴하거나 errno 매크로를 사용해 에러를 표시하는 등 에러 처리를 일관성 없이 구현한 함수들이 뒤섞이면 문제가 발생할 수 있다. 호출한 함수가 예상과 다른 방식으로 코드를 리턴하기 때문 그리고 C++ 함수는 리턴 타입을 하나만 지정할 수 있어 에러와 결과 모두 리턴하려면 다른 수단이 필요하다. ex) std::pair 나 std::tuple 에 결과와 에러를 같이 묶어서 리턴하는등 익셉션 매커니즘을 활용하면 에러를 쉽고 일관성 있고 안전하게 처리할 수 있다. 에러를 리턴값으로 표현하면 호출한 측에서 깜박하고 리턴값을 검사하지 않거나 상위 함수로 전달하지 못할 수 있다. 반면 익셉션은 깜박 잊고 처리하지 않거나 무시할 수 없다. ( 처리하지않으면 프로그램이 멈춤) 에러를 정수 타입 리턴 코드로 표현하면 구체적인 정보를 담기 힘들다반면 익셉션은 에러뿐만 아니라 다른 부가 정보도 담을 수 있다. 익셉션 매커니즘은 콜 스택의 중간 단계를 건너 뛸 수 있다.다시 말해 여러 함수가 연속적으로 호출됐을 때 중간에 호출된 함수에서 에러를 처리하지 않고콜 스택의 최상위 함수에서 에러를 처리하게 만들 수 있다.만약 리턴 코드를 활용한다면 함소 호출의 각 단계마다 반드시 에러 코드를 다음 단계로 전달해야한다. 익셉션 처리 과정 표준 라이브러리나 부스트 같은 유명한 라이브러린는 익셉션을 적극 활용하고 있어 라이브러리를 사용하려면 익셉션을 다루는 방법을 잘 알아야 한다.익셉션 던지고 받기 익셉션은 익셉션을 처리하는 try/catch문과 익셉션을 던지는 throw문 두 부분으로 나뉜다. 대부분의 라이브러리들에서 throw문은 라이브러리 깊숙한 곳에 있어 프로그래머가 직접 볼 수 없을 때가 많지만, try/catch문은 따로 작성해줘야 한다. try / catch문의 구성 try{ // 익셉션이 발생할 수 있는 코드 } catch (익셉션_타입1 익셉션_이름){ // 익셉션_타입1 익셉션을 처리하는 코드 } catch (익셉션_타입2 익셉션_이름){ // 익셉션_타입2 익셉션을 처리하는 코드 } 예외 상황이 발생할 수 있는 코드에 throw 문에 익셉션을 직접 던져도 된다. 또한 throw문으로 익셉션을 직접 던지건나 익셉션을 던지는 함수를 호출하는 문장이 담긴 함수를 호출할 수도 있다. 0으로 나눈 상황을 감시하는 함수double SafeDivide(double num , double den){ if (0 == den) throw invalid_argument(\"Divde by zero\"); return num / den;}int main(){ try{ cout&lt;&lt; SafeDivide(5,2) &lt;&lt; endl; cout&lt;&lt; SafeDivide(10,0) &lt;&lt; endl; cout&lt;&lt; SafeDivide(3,3) &lt;&lt; endl; } catch (const invalid_argument&amp; e){ cout&lt;&lt; \"Caught exception: \" &lt;&lt; e.what() &lt;&lt; endl; } return 0;}// 결과2.5Caught exception: Divde by zero throw문에 나온 invalid_argument()는 던질 invalid_argument 타입의 익셉션 객체를 생성한다. invalid_argument는 C++ 표준 라이브러리에서 제공하는 표준 익셉션 중 하나 표준 라이브러리에 정의된 익셉션은 일정한 계층을 형성하고 있다. 이 계층 구조에 속한 클래스마다 what() 메서드가 있는데, 이 메서드는 익셉션을 표현하는 const char* 스트링을 리턴한다. 이 값은 익셉션 생성자의 인수로 전달하는 방식으로 설정한다. 파일 입출력 과정에서의 익셉션 처리vector&lt;int&gt; readIntegerFile(string_view fileName){ ifstream inputStream(fileName.data()); // 파일에 담긴 정수값을 하나씩 읽어서 벡터에 추가 if(inputStream.fail()) throw exception(); // 파일 열기 실패 : 익셉션을 던진다. vector&lt;int&gt; integers; int temp; while (inputStream &gt;&gt; temp) { integers.push_back(temp); } return integers;}int main(){ const string fileName = \"IntegerFile.txt\"; vector&lt;int&gt; myInts; try{ myInts = readIntegerFile(fileName); } catch (const exception&amp; e){ cerr &lt;&lt; \"Unable to open file \" &lt;&lt; fileName &lt;&lt;endl; return 1; } for (const auto&amp; element : myInts) { cout &lt;&lt; element &lt;&lt; \" \"; } cout &lt;&lt; endl; return 0;} &gt;&gt; 연산을 수행할 때 에러가 발생하면 ifstream 객체에 에러 플래그가 설정된다. 그러면 bool() 변환 연산자가 false를 리턴하면서 while 루프가 종료된다. 파일을 열 때 에러가 발생할 경우 std::exception 타입으로 익셉션을 생성한다. 익셉션 타입 던질 수 있는 익셉션의 타입에는 제한이 없다 하지만 기본 타입을 사용하기 보다는 새로 정의하는 것이 바람직하다.그 이유는 다음과 같다. 객체의 클래스 이름에 예외 상황에 대한 정보를 드러낼 수 있다. 예외 상황의 종류뿐만 아니라 다른 정보도 담을 수 있다. C++ 표준 라이브러리에 정의돼 있는 익셉션 클래스를 활용하거나, 익셉션 클래스를 직접 정의할 수도 있다.여러 가지 익셉션 던지고 받기 위에서의 파일 입출력 과정에서의 익셉션 처리 예시// readIngerFile 함수 안if(inputStream.fail()) throw invalid_argument(\"Unable to open the file.\");..if(!inputStream.eof()){ // 파일의 끝에 도달하지 않았다. // 다시 말해 파일을 읽는 도중 에러 발생으로 익셉션을 던짐 throw runtime_error(\"Error reading the file\");}==========int main(){ ... try{ myInts = readIntegerFile(fileName); } catch (const invalid_argument&amp; e){ cerr &lt;&lt; e.what() &lt;&lt; endl; return 1; } catch (const runtime_error&amp; e){ cerr &lt;&lt; e.what() &lt;&lt; endl; return 2; }} 파일을 열수 없으면 invalid_argument 익셉션을 던지고, 정수를 읽을 수 없으면 runtime_error 익셉션을 던진다. runtime_error와 invalid_argument 둘다 C++ 표준 라이브러리인 &lt;stdexcept&gt; 헤더 파일에 있다. runtime_error와 invalid_argument는 public 디폴트 생성자가 없고 string 인수를 받는 생성자만 있다. try블록에서는 익셉션 타입과 일치하는 catch문(핸들러)을 선택한다. 익셉션 타입 매칭과 const 처리하는 익셉션 타입에 const가 지정됐는지 여부는 매칭 과정에 영향을 미치지 않는다. 예를 들어 다음 문장은 runtime_error 타입에 속하는 모든 익셉션을 매칭한다.// 둘 다 runtime_error 타입에 속하는 모든 익셉션을 매칭} catch (const runtime_error&amp; e)} catch (runtime_error&amp; e)모든 익셉션 매칭하기 catch문에서 모든 종류의 익셉션에 매칭하려면 다음과 같이 작성한다.} catch (...){ …은 모든 익셉션 타입에 매칭 if문의 else처럼 사용할 수 있다. 처리하지 못한 익셉션 프로그램에서 발생한 익셉션을 처리하는 곳이 하나도 없으면 프로그램이 종료돼버린다. 그래서 처리하지 못한 익셉션을 모두 잡도록 main() 함수 전체를 try/catch 구문으로 감싸는 패턴을 사용할 수도 있다. try{ main(argc, argv);} catch(...){ ...} 프로그램이 잡지 못한 익셉션을 만나면 terminate() 함수를 호출하게 만들 수도 있다. 이 함수는 C++에서 기본으로 제공하며, 내부적으로 &lt;cstdlib&gt;헫더에 정의된 abort() 함수를 호출한다. 또는 set_terminate()에 인수를 받지 않고 리턴값도 없는 콜백 함수를 포이넡로 지정하는 방식으로 terminate_handler를 직접 구현해도 된다. try{ main(argc, argv);} catch(...){ if(nullptr != terminate_handler){ terminate_handler(); } else { terminate(); }} 위와 같이 작성하면 결국 에러를 무시하지 못하고 프로그램을 종료시켜버린다. 그래서 종료 직전에 유용한 정보를 담은 에러메세지를 출력할 방법도 있다. void myTerminate(){ cout &lt;&lt;\"Uncaught exception!\" &lt;&lt; endl; exit(1);}// set_terminate은 새로운 핸들러를 지정하면 기존에 설정된 핸들러는 리턴한다int main(){ set_terminate(myTerminate); ...} 프로세스를 종료하는 방식으로 정숫값을 인수로 받고 OS로 전달noexcept 함수가 던질 수 있는 익셉션의 종류에는 제한이 없지만, noexcept 키워드로 어떠한 익셉션도 던지지 않는다고 지정할 수 있다.vector&lt;int&gt; readIntegerFile(string_view fileName) noexcept; noexcept 키워드가 지정된 함수에 익셉션을 던지는 코드가 있다면 C++ 런타임은 terminate()을 호출하여 프로그램을 종료시킨다. 파생 클래스에서 virtual 메서드를 오버라이드할 때 베이스 클래스의 메서드에 noexcept가 지정되지 않더라도 오버라이드하는 메서드에 noexcept를 지정할 수 있다. (반대는 불가능) " }, { "title": "스트림 - 2", "url": "/posts/%EC%8A%A4%ED%8A%B8%EB%A6%BC-2/", "categories": "C++", "tags": "C++", "date": "2023-02-02 00:00:00 +0900", "snippet": "스트링 스트림 string에 스트림 개념을 추가한 것 텍스트 데이터를 메모리에서 스트림 형태로 표현하는 인메모리 스트림을 만들 수 있다. ex) GUI 애플리케이션에서 콘솔이나 파일이 아닌 스트림으로부터 텍스트 데이터를 구성한뒤이를 메세지 박스나 편집 컨트롤과 같은 GUI요소로 결과를 출력할 수 있다. string에 데이터를 쓸 때는 std::ostringstream 클래스를, 읽을 때는 std::istringstream 클래스를 사용한다.둘 다 &lt;sstream&gt; 헤더 파일에 정의돼 있다.// ostreamostringstream outStream;while (cin){ string nextToken; cout &lt;&lt;\"Next Token: \"; cin&gt;&gt; nextToken; if(!cin || nextTokeen == \"done\") break; outStream &lt;&lt; nextToken &lt;&lt; \"\\t\";}//istreamMuffin createMuffin(istringstream&amp; stream){ Muffin muffin; // 데이터가 다음과 같은 형식에 맞게 들어온다. // Description(설명), size(크기), chips(초콜릿칩 존재 여부) string description; int size; bool hasChips; // 세값 모두 읽는다. chips는 true나 false로 스트링을 표현 stream &gt;&gt; description &gt;&gt; size &gt;&gt; boolalpha &gt;&gt; hasChips; if (stream) //읽기 성공 { muffin.setSize(size); muffin.setDescription(description); muffin.setHasChocolateChips(hasChips); } return muffin;} 표준 C++ string만 사용하지 않고 스트링 스트림을 함께 활용하면 데이터를 읽거나 쓸 지점(현재 위치)를 알 수 있어서 좋다. 현재 위치란 다음번에 읽기 또는 쓰기 연산을 수행할 위치를 의미 스트링 스트림은 다양한 매니퓰레이터와 로케일을 지원하므로 string보다 포맷을 보다 융통성있게 다룰 수 있음.파일 스트림 파일 입출력을 위해 std::ofstream과 std::ifstream 클래스를 제공 &lt;fstream&gt; 헤더 파일에 정의돼 있다. 파일시스템을 다룰 때는 에러 처리가 중요하다.이런 에러 처리를 위해 표준 에러 처리 매커니즘을 이용한다. 파일 출력 스트림과 다른 출력 스트림의 가장 큰 차이점은 파일 스트림 생성자는 “파일의 이름”과 파일을 열 때 적용할 “모드”에 대한 인수를 받는다.모드 파일 스트림의 모드로 지정할 수 있는 값 디폴트는 ios_base::out 모드는 한가지뿐만이 아니라 조합해서 사용할 수 있다. 상수 설명 ios_base::app 파일을 열고, 쓰기 연산을 수행하기 전에 파일 끝으로 간ㄷ다. ios_base::ate 파일을 열고, 즉시 파일 끝으로 간다. ios_base::binary 입력 또는 출력을 텍스트가 아닌 바이너리 모드로 처리 ios_base::in 입력할 파일을 열고 시작 지점부터 읽는다. ios_base::out 출력할 파일을 열고 시작 지점부터 쓴다. 기존 데이터를 덮어쓴다. ios_base::trunc 출력할 파일을 열고 기존 데이터를 모두 삭제한다(truncate) 텍스트 모드와 바이너리 모드 파일 스트림은 기본적으로 텍스트 모드로 연다. 텍스트 모드로 열면 파일에서 \\n이 나올 때 마다 한 줄씩 읽거나 쓴다. 파일의 줄끝을 나타내는 문자(EOL)는 OS마다 다르다. ios_base::binary 플래그를 사용하면 바이너리 모드로 연다. 바이너리 모드로 열면 정확히 바이트 단위로 지정한 만큼만 파일에 쓴다. 읽을 때는 파일에서 읽은 바이트 수를 리턴한다. seek과 tell 메서드로 랜덤 액세스하기 입력과 출력 스트림은 모두 seek()과 tell() 메서드를 갖고 있다. seek() 메서드는 입력 또는 출력 스트림에서 현재 위치를 원하는 지점으로 옮긴다. 입력 스트림에 대한 seek() 메서드는 seekg() (g는 get을 의미) 출력 스트림에 대한 seek() 메서드는 seekp() (p는 put을 의미) seekg()와 seekp()는 각각 두가지 버전이 있다. 하나는 절대 위치를 나타내는 인수만 받아서 위치로 이동 다른 하나는 오프셋과 위치에 대한 인수를 받아서 지정한 위치를 기준으로 떨어진 거리(오프셋)로 이동 위치는 std::streampos 오프셋은 std::streamoff C++에 미리 정의된 위치 위치 설명 ios_base::beg 스트림의 시작점 ios_base::end 스트림의 끝점 ios_base::cur 스트림의 현재 위치 // 출력스트림 시작점으로 이동outSream.seekp(ios_base::beg);// 입력스트림 끝점으로 이동inStream.seekg(ios_base::end);// 출력스트림 시작점으로부터 2바이트만큼 이동outStream.seekp(2, ios_base::beg);// 입력스트림 끝에서 세 번째 바이트로 이동inStream.seekg(-3, ios_base::end); tell() 메서드는 스트림의 현재 위치를 알아 낼 수 있다. 현재 위치를 streampos 타입의 값으로 리턴함. seek()와 마찬가지로 입출력에 대해 다른 버전인 tellg()와 tellp()를 제공 std::streampos curPos = inStream.tellg(); // 현재 위치를 저장if(ios_base::beg == curPos) // 현재 위치가 시작점이라면{ cout &lt;&lt; \" beginning\"}스트림끼리 서로 연결하기 입출력 스트림은 언제든지 접근할 때 내보내기(flush-on-acess)방식으로 서로 연결할 수 있다. 즉, 입력 스트림을 출력 스트림에 연결한 뒤 입력 스트림에서 데이터를 읽으면 즉시 출력 스트림으로 보낸다. 스트림을 연결하는 작업은 tie() 메서드로 처리한다. 출력 스트림을 입력 스트림에 연결하려면 입력 스트림에 대해 tie()를 호출한다. 이 때 연결할 출력 스트림의 주소를 인수로 전달 연결을 끊으려면 tie()에 nullptr를 전달해서 호출 ifstream inFile(\"input.txt\");ofstream outFile(\"output.txt\");// inFile과 outFile을 연결inFile.tie(&amp;outFile);// outFile에 텍스트를 쓴다. std::endl이 입력되기 전까지 내보내지 않음outFile&lt;&lt;\"Hello There\";// inFile에서 텍스트를 읽는다. 그러면 outFile에 대해 flush()가 호출된ㄴ다.string nextToken;inFile &gt;&gt; nextToken;// outFile이 내보내짐 입력 스트림을 전혀 다른 파일에 대한 출력 스트림에 연결하는 코드" }, { "title": "스트림 - 1", "url": "/posts/%EC%8A%A4%ED%8A%B8%EB%A6%BC-1/", "categories": "C++", "tags": "C++", "date": "2023-02-01 00:00:00 +0900", "snippet": "스트림 연속적인 데이터의 흐름 혹은 데이터를 전송하는 소프트웨어 모듈 스트림은 바이트 단위로 입출력한다. 스트림마다 방향과 소스(출발지) 또는 목적지를 지정할 수 있다. 1 - C++에서 기본으로 정의된 스트림 스트림 설명 cin 입력 스트림. ‘입력 콘솔’에 들어온 데이터를 읽는다. cout 버퍼를 사용하는 출력 스트림. 데이터를 ‘출력 콘솔’에 쓴다. cerr 버퍼를 사용하지 않는 출력 스트림. 데이터를 ‘에러 콘솔’에 쓴다.에러 콘솔과 출력 콘솔이 같을 때가 많다. clog 버퍼를 사용하는 err 버퍼를 사용하는 스트림 : 받은 데이터를 버퍼에 저장했다가 블록 단위로 목적지에 보낸다. 버퍼를 사용하지 않는 스트림 : 데이터가 들어오자마자 목적지로 보낸다. 버퍼에 잠시 저장(버퍼링) 하는 이유는 블록 단위로 묶어서 보내는 것이 효율적이기 때문이다. 버퍼를 사용하는 스트림은 버퍼를 깨끗이 비우는 flush() 메서드로 현재 버퍼에 담긴 데이터를 목적지로 보낸다. 2 - 스트림의 종류 스트림은 데이터를 입력받거나 출력하는 객체라면 어떤것에도 적용할 수 있다. 콘솔,네트워크,파일 스트림, 스트링 스트림 등등 있다. 출력 스트림1 - 출력 스트림의 기초 &lt;ostream&gt; 헤더파일에 정의되어 있다. ( &lt;iostream&gt; 헤더 안에 있음) C++의 기본 타입은 « 연산자로 처리할 수 있다. cout 스트림은 C++에서 기본으로 제공하는 내장 스트림으로, 콘솔 (표준 출력)에 값을 쓴다. int j = 11;cout &lt;&lt; \"The value of j is\" &lt;&lt; j &lt;&lt; endl;// '\\n' 은 새 줄(New line)에서 시작// endl 은 버퍼를 비우면서 새 줄에서 시작 스트림은 다음과 같은 조건을 만족할 때 모든 데이터를 내보내고 버퍼를 비운다. 스트림의 버퍼를 비우기 위해 flush()를 호출할 때 스트림의 버퍼가 가득 찼을 때 endl과 같은 경곗값에 도달할 때 스트림이 스코프를 벗어나 소멸될 때 출력 스트림에 대응되는 입력 스트림으로부터 요청이 들어올 때 ex) cin으로 입력받으면 cout으로 버퍼를 비움 2 - 출력 스트림에서 제공하는 메서드 put()과 write() 저수준 출력 메서드 데이터에 특정한 포맷을 적용하거나 데이터의 내용을 가공하지 않고 전달된 상태 그대로 출력 // writeconst char* test = \"hello there\\n\";cout.write(test,strlen(test));// putcout/put('a'); flush() 스트림의 버퍼를 명시적으로 비우는 함수 cout &lt;&lt; \"abc\";cout.flush(); // 콘솔에 abc 출력cout &lt;&lt; \"def\";cout.flush(); // 콘솔에 def 출력3 - 출력 에러 처리하기 출력 에러가 발생하는 경우는 다양하다. 존재하지 않는 파일을 열 때 디스크가 꽉 차서 쓰기 연산을 처리할 수 없을 때 에러 관련 메서드 good() 메서드를 사용해 스트림의 상태 정보를 조회할 수 있는 메서드 원인을 알려주지 않기 때문에 bad() 메서드를 사용해야 자세히 볼 수 있다. bad() 메서드는 에러 원인을 알려주는 메서드 bad() 메서드가 true를 리턴하면 심각한 에러가 발생했다는 뜻이다. fail 메서드는 최근 수행한 연산에 오류가 발생했는지 확인하는 메서드 clear 메서드는 스트림의 에러 상태를 초기화 한다. 4 - 출력 매니퓰레이터 C++의 스트림은 단순히 데이터만 전달하는데 그치지 않고, 매니퓰레이터(조종자)라는 객체를 받아 스트림의 동작을 변경할 수 있다. endl이 바로 스트림 매니퓰레이터 endl은 데이터와 동작을 모두 담고있다. 대부분 &lt;ios&gt;나 &lt;iomanip&gt; 표준 헤더 파일에 정의돼 있다. 유용한 매니퓰레이터 boolalpha와 noboolalpha : 스트림에 bool값을 true나 false로 출력하거나 1이나 0으로 출력하도록 설정 기본값은 noboolalpha hex,oct,dec : 각각 숫자를 16진수, 8진수, 10진수로 출력 setprecision : 분숫값을 표현할 때 적용할 소수점 자릿수 지정 setw : 숫자 데이터를 출력할 필드의 너비를 지정 setfill : 지정된 너비보다 숫자가 작을 때 빈 공간을 채울 문자를 지정 showpoint와 noshowpoint : 소수점 아래의 수가 없는 부동소수점수를 스트림에서 표현할 때 소수점의 표시 여부 설정 put_money : 스트림에서 화폐 금액을 일정한 형식에 맞게 표현할 때 사용 put_time : 스트림에서 시간을 일정한 형식에 맞게 표현할 때 사용 quoted: 지정한 스트링을 인용부호(따옴표)로 감싸고, 스트링 안에 있는 인용 부호를 이스케이프로 변환 위에서 setw을 제외한 나머지 매니퓰레이터들은 한번 설정하고 나면 리셋하기 전까지 출력에 계속 반영된다.입력 스트림1 - 입력 스트림의 기초 입력 스트림으로부터 데이터를 읽는 방법은 두가지가 있다. 입력 연산자 »를 사용한다 입력 연산자 »는 공백을 기준으로 입력된 값을 토큰화 한다. 그렇기 때문에 »를 사용하면 입력에 공백을 사용하지 못한다. get()을 이용한다 2 - 입력 에러 처리하기 입력 스트림의 에러는 대부분 읽을 데이터가 없을 때 발생한다. 예를들어 스트림의 끝에 도달할 때 등이 있다. 이에 대처하는 흔한 방법은 입력 스트림에 접근하기 전에 조건문으로 스트림의 상태를 확인하는 것while (cin) {...} 출력 스트림과 마찬가지로 입력 스트림에서도 good() , bad(), fail(), eof() 메서드를 호출할 수 있다. 아래 코드는 데이터를 읽는 과정에서 발생하는 에러에 대처하기 위해 흔히 사용하는 패턴 if(!cin.good()){ cerr &lt;&lt; \"Standard input is in a bad State\" &lt;&lt; endl; return 1;}int number;while(!cin.bad()){ cin&gt;&gt;number; if(cin.good()) sum+=number; else if(cin.eof()) break; //파일 끝에 도달 else if(cin.fail()){ //문제 발생 cin.clear(); //에러 상태를 제거 string BadToken; cin &gt;&gt; BadToken; // 잘못된 입력값을 가져온다. cerr &lt;&lt; \"WARNING : Bad input encounterd:\" &lt;&lt; BadToken &lt;&lt; endl; }}3 - 입력 메서드 get() 스트림의 다음 문자를 리턴 스트림 데이터를 저수준으로 읽음 get()은 주로 » 연산자를 사용할 때 자동으로 토큰 단위로 잘리는 문제를 피하기 위해 사용 string readName(istream&amp; stream){ string name; while(stream) { int next = stream.get(); // 입력 스트림에서 한문자씩 가져옴 if(!stream || next == std::char_traits&lt;char&gt;::eof()) break; name += static_cast&lt;char&gt;(next); // 문자 추가 } return name;} 위의 함수에서 주목할 점 매개 변수의 타입이 non-const 레퍼런스. 스트림에서 데이터를 읽는 메서드는 실제 스트림을 변경하기 때문 get()의 리턴값을 char가 아닌 int 타입. get()은 EOF에 해당하는 std::char_traits::eof()를 비롯한 문자가 아닌 특수한 값을 리턴할 수 있기 때문 unget() 데이터를 다시 입력 소스 방향으로 보내는 메서드 unget()을 호출하면 스트림이 한칸 앞으로 거슬러 올라가서 이전에 읽은 문자를 스트림으로 되돌린다. unget() 연산의 성공 여부는 fail() 메서드로 ㅎ확인한다. putback() unget() 메서드와 마찬가지로 입력 스트림을 한 문자만큼 되돌린다 unget()과 달리 스트림에 되돌릴 문자를 인수로 받는다. peek() get()을 호출할 때 리턴될 값을 미리 보여준다. getline() get()과 달리 미리 설정한 버퍼가 가득 채워질 때까지 문자 한 줄을 읽는다. 한줄의 끝을 나타내는 \\0 (EOF)문자도 버퍼의 크기에 포함한다. 4 - 입력 매니퓰레이터 boolalpha와 noboolalpha boolalpha는 false란 스트링값을 bool 타입인 false로 해석하고 나머지 스트링을 true로 처리 noboolalpha는 0을 부울 값으로 false로 해석하고 0이 아닌 나머지값을 true로 처리한다. 기본적으로 noboolalpha로 설정돼 있다. hex,oct,dec : 각각 16진수, 8진수, 10진수로 읽도록 지정 skipw와 noskipw skipws를 지정하면 토큰화할 떄 공백을 건너뛰고 noskipw를 지정하면 공백을 하나의 토큰으로 지정한다.기본적으로 skipws로 지정돼 있다. ws : 스트림의 현재 위치부터 연달아 나온 공백 문자를 건너뛴다. get_money : 스트림에서 화폐 금액을 표현한 값을 읽는 매개변수 방식의 매니퓰레이터 get_time : 스트림에서 일정한 형식으로 표현된 시각정보를 읽는 매개변수 방식의 매니퓰레이터 quoted : 인용부호(따옴표)로 묶은 스트링을 읽는ㄴ 매니퓰레이터로서 인수를 받는다." }, { "title": "템플릿-2", "url": "/posts/%ED%85%9C%ED%94%8C%EB%A6%BF-2/", "categories": "C++", "tags": "C++", "date": "2023-01-23 00:00:00 +0900", "snippet": "클래스 템플릿의 특수화 특정한 타입에 특화된 버전을 새로 생성한다. 템플릿을 특수화할 때는 클래스 전체를 완전히 새로 구현해야 한다. 어떤 코드도 상속하지 않기 때문에 원본 템플릿 클래스와 다르게 작성 가능하다. 특수화 장점 사용자에게 드러나지 않고 내부적으로 처리한다. // Grid 템플릿을 const char*에 대해 특수화template &lt;&gt;class Grid&lt;const char*&gt;{...// 복제 생성자와 대입 연산자를 명시적으로 디폴트 선언Grid&lt;const char*&gt;&amp; operator=(const Grid&amp; rhs) = default;...// 이동 생성자와 대입 연산자를 명시적으로 디폴트 선언Grid&lt;const char*&gt;&amp; operator=(Grid&amp;&amp; rhs) = default;}클래스 템플릿 상속하기 템플릿을 상속한 파생 클래스도 템플릿이어야 한다. 클래스 템플릿을 특정한 타입으로 인스턴스화한 클래스를 상속할 때는 파생 클래스가 템플릿이 아니어도 된다. 앨리어스 템플릿 타입 앨리어스를 이용해 특정한 타입을 다른 이름으로 부를 수 있다.template&lt;typename T1, typename T2&gt;class MyTemplateClass { /*... */ };// typedef로도 표현 가능using OtherName = MyTemplateClass&lt;int, double&gt;; 타입 매개변수 중에서 일부만 지정하고, 나머지 타입은 그대로 템플릿 타입 매개변수 형태로 남겨둘 수 있다. // 아래와 같은 형태는 typedef로 표현할 수 없다. template&lt;typename T1&gt; using OtherName = MyTemplateClass&lt;T1, double&gt;;함수 템플릿 메서드가 아닌 일반 함수도 템플릿화 할 수 있다.// 함수 템플릿static const size_t NOT_FOUND = static_cast&lt;size_t&gt;(-1);template &lt;typename T&gt;size_t Find(const T&amp; value, const T* arr, size_t size){ for (size_t i = 0, i &lt; size ; i++) { if(arr[i] == value) return i; } return NOT_FOUND;}// 호출 방식int myInt = 3 , intArray[] = {1,2,3,4};const size_t sizeIntArray = std::size(intArray);size_t res;res = Find(myInt, intArray , sizeIntArray); // 타입 추론을 통해 Find&lt;int&gt; 호출res = Find&lt;int&gt;(myInt, intArray , sizeIntArray); // Find&lt;int&gt;를 명시적으로 호출 위에서 구현한 Find 함수는 배열의 크기를 매개변수 중 하나에 지정해야 한다. 컴파일러가 배열의 크기를 아는 경우 ( 스택 기반 배열 ), 매개 변수에 배열의 크기에 대한 인수를 생략하기 위해서 함수 템플릿을 사용할 수 도 있다. // 함수 template&lt;typename T, size_t N&gt; size_t Find (const T&amp; value, const T(&amp;arr)[N]){ return Find(value,arr,N);}// 호출int myInt = 3 , intArray[] = {1,2,3,4};size_t res = Find(myint, intArray); C++ 표준 라이브러리는 위에 보다 훨씬 강력한 템플릿화된 std::find() 함수를 제공한다함수 템플릿의 특수화, 오버로딩 함수 템플릿 특수화template&lt;&gt;size_t Find&lt;const char*&gt;(const char* const&amp; value, const char* const* arr, size_t size){ ...} 이 때 매개변수 타입을 인수로부터 추론할 수 있다면 생략할 수 있다. 하지만 생략할 때, 오버로딩을 함께 적용하면 타입 추론 규칙이 복잡해진다.그렇기 때문에 타입을 명시적으로 지정하는것이 좋다. // 함수 템플릿 특수화 프로토 타입template&lt;&gt;size_t Find(const char* const&amp; value, const char* const* arr, size_t size)// 호출const char* word = \"two\";const char* words[] = { \"one\", \"two\" };const size_t sizeWords = std::size(words);size_t res;// const char*에 대해 특수화된 버전인 템플릿 호출res = Find&lt;const char*&gt;(word, words, sizeWords);// const char*에 대해 특수화된 버전인 템플릿 호출res = Find(word, words, sizeWords);함수 템플릿 오버로딩 함수 템플릿도 오버로딩이 가능하다.// 함수 템플릿의 오버로딩 (일반 함수 버전)size_t Find(const char* const&amp; value, const char* const* arr, size_t size){ ...} 하지만 템플릿 특수화를 오버로딩할 때는 호출될 때 적용되는 규칙이 다르다. ```c++// 호출const char* word = “two”;const char* words[] = { “one”, “two” };const size_t sizeWords = std::size(words);size_t res;// T= const char인 템플릿 호출res = Find&lt;const char&gt;(word, words, sizeWords);// 비템플릿(일반) Find() 호출res = Find(word, words, sizeWords);&lt;br&gt;&lt;br&gt;함수 템플릿 오버로딩과 특수화 동시에 적용========================* 컴파일러는 항상 템플릿 버전 보다 일반 함수버전을 우선시한다* 하지만 템플릿 인스턴스화를 명시적으로 지정하면 컴파일러는 무조건 템플릿 버전을 실행한다```c++const char* word = \"two\";const char* words[] = { \"one\", \"two\" };const size_t sizeWords = std::size(words);size_t res;// const char*에 특수화된 템플릿 버전을res = Find&lt;const char*&gt;(word, words, sizeWords);// 일반 함수로 구현한 Find() 호출res = Find(word, words, sizeWords); 클래스 템플릿의 friend 함수 템플릿 함수 템플릿은 클래스 템플릿에서 연산자를 오버로딩할 때 유용 연산자를 이용할 때 private 멤버에 접근하기 위해 함수 템플릿을 클래스 템플릿의 friend로 생성// Gird 템플릿에 대한 전방 선언template &lt;typename T&gt; class Grid;// 템플릿화한 operator+에 대한 프로토 타입template&lt;typename T&gt;Grid&lt;T&gt; operator+(const Grid&lt;T&gt;&amp; lhs, const Grid&lt;T&gt;&amp; rhs);template &lt;typename T&gt;class Grid{ public: friend Grid&lt;T&gt; operator+ &lt;T&gt; (const Grid&lt;T&gt;&amp; lhs, const Grid&lt;T&gt;&amp; rhs);};함수 템플릿의 리턴 타입 리턴 타입은 템플릿 타입 매개변수에 따라 결정template&lt;typename T1, typename T2&gt;auto add(const T1&amp; t1, const T2&amp; t2){ return t1 + t2;} 위에 함수처럼 auto로 표현식의 타입을 추론하면 reference와 const 지정자가사 사라져버린다. 그래서 따로 명시적으로 지정하거나 decltype을 사용 해야한다.// 일반 함수 const std::string messsage = \"Test\";const std::string&amp; getString(){ return message;}// 방법 1auto s1 = getString(); // 이렇게 작성하면 const와 reference가 사라져 복제 연산이 발생const auto&amp; s2 = getString(); // 그렇기에 명시적으로 지정해야함.// 방법 2decltype(getString()) s3 = getString(); // 이렇게 작성하면 const string&amp;이 되지만 코드 중복 발생decltype(auto) s4 = getString(); // decltype(auto)로 해결할 수 있다. 위의 decltype 와 auto를 이용하여 대체 함수 구문과 후행 리턴 타입으로 const와 referenc를 유지할 수 있다. 하지만 최신 버전의 컴파일러는 대체 함수 구문보다는 decltype(auto)나 자동 리턴 타입 추론 기능을 사용하는 것이 좋음 template&lt;typename T1, typename T2&gt;auto add(const T1&amp; t1, const T2&amp; t2) -&gt; decltype(t1+t2) // 후행 리턴 타입{ return t1 + t2;}변수 템플릿 변수에도 템플릿 적용할 수 있다. 밑에서는 pi의 값을 변수에 맞춰 지정한 타입으로 표현할 수 잇는 범위의 값에 맞게 파이값을 구할 수 있음.template &lt;typename T&gt;constexpr T pi = T(3.141592....);// 특정한 타입의 파이의 변수를 생성할 수 있음float piFloat = pi&lt;float&gt;;long double piLongDouble = pi&lt;long double&gt;;" }, { "title": "템플릿-1", "url": "/posts/%ED%85%9C%ED%94%8C%EB%A6%BF-1/", "categories": "C++", "tags": "C++", "date": "2023-01-22 00:00:00 +0900", "snippet": "템플릿 함수나 클래스 코드를 일반화할 수 있는 방법 template 과 typename 키워드를 이용하여 작성한다. // 형식template &lt;typename T&gt;T: 템플릿을 적용할 타입이나 클래스, 구조체T가 아닌 다른 문자로도 사용가능 하지만 관례적으로 T를 사용클래스 템플릿 멤버 변수 타입, 메서드의 매개 변수 또는 리턴 타입을 매개변수로 받아 클래스로 만들 수 있다. 클래스를 원하는 타입에 맞는 인스턴스화 할 수 있다. 주로 객체를 저장하는 컨테이너나 데이터 구조에서 많이 사용 template &lt;typename T&gt; class MyStack{private: int tos; T data [100]; // T 타입의 배열public: MtStack(); void push(T element); // T 타입 element를 data[]에 푸쉬 T pop(); // 스택의 Top에 있는 T 타입 데이터를 Pop하여 리턴}=============================MyStack&lt;int&gt; iStack; // int 타입을 담는 Stack 객체 생성MyStack&lt;double&gt; dStack; // double 타입을 담는 Stack 객체 생성꺾쇠괄호 C++ 11 이전에는 이중꺾쇠괄호를 연산자로 취급했었음. C++ 11 이후에는 공백없이 표기 가능std::vector&lt;std::vector&lt;T&gt; &gt; mCells; // 이전std::vector&lt;std::vector&lt;T&gt;&gt; mCells; // 이후컴파일러에서 템플릿을 처리하는 방식 선택적 인스턴스화 컴파일러는 항상 제네릭 클래스에 있는 모든 가상 메서드에 대한 코드를 생성하지만non-virtual 메서드는 특정 타입에 대해 호출하는 메서드만 컴파일한다. Grid&lt;int&gt; myIntGrid;myIntGrid.at(0,0) = 10;// 컴파일러는 int 버전의 Grid에서 제로 인수 생성자, 소멸자, non-const at 메서드만 컴파일// 복제 생성자, 대입연산자에 대한 코드는 생성 X 템플릿에 사용할 타입의 요건 T에 지정한 타입의 원소는 언제든지 소멸할 수 있다는 점을 고려해야 한다. 템플릿을 인스턴스화할 때 템플릿에 있는 연산을 모두 지원하지 않으면 컴파일 에러가 발생한다. 만약 인스턴스화할 타입이 템플릿에 정의된 모든 연산에 적용할 수 없다면 선택적 인스턴스화를 통해 일부 메서드만 사용하게 만든다. 템플릿 코드를 여러파일로 나누기 일반적으로 클래스 정의는 헤더파일, 메서드 정의는 소스파일에 적는다. 하지만 템플릿은 사용자가 지정한 타입에 대한 메서드를 사용하는 문장이 나올 때 마다컴파일러는 템플릿 정의와 메서드 정의 코드를 모두 볼 수 있어야 코드를 제대로 생성할 수 있다. 헤더 파일에 템플릿 정의하기 메서드 정의 코드를 클래스 정의 코드가 있는 헤더파일에 작성하는 방법 템플릿을 사용하는 소스파일에 #include 문으로 헤더파일만 불러오면 모두 참조할 수 있다. 템플릿 메서드 정의 코드를 다른 헤더 파일에 적고, 그 헤더 파일을 클래스 정의를 담은헤더 파일에서 #include 문으로 불러오는 방법. 메서드 정의가 담긴 헤더를 추가하는 #include 문은 클래스 정의 코드 뒤에 적어야 한다. 템플릿을 사용할 때는 템플릿이 정의된 헤더파일만 include에서 사용하면 된다. template&lt;typename T&gt;class Grid{ ..};#include \"GridDefinitions.h\"소스파일에 템플릿 정의하기 메서드 정의 코드를 소스 파일에 작성하고, 클래스 템플릿이 있는 헤더파일에 메서드 구현 코드가 있는 소스 파일을 추가하는 #include 문을 작성 이 때 cpp 파일은 프로젝트 빌드 목록에 추가되지 않도록 주의, 추가하면 안될 뿐만 아니라 추가할 방법도 없고 따로 컴파일 할수도 없다. 메서드 구현 코드가 담긴 파일의 이름은 마음대로 정의 가능 template&lt;typename T&gt;class Grid{ ..};#include \"Grid.cpp\"클래스 템플릿의 인스턴스화 제한 Grid 클래스를 int,double, vector에 대해서만 인스턴스화 하기 헤더파일에 메서드 정의, include문도 없앤다 실제 메서드 정의 코드가 담긴 .cpp파일을 프로젝트 빌드목록에 추가한다 그리고 나서 템플릿에서 허용하는 타입으로 명시적으로 인스턴스화 한다. // 헤더파일template&lt;typename T&gt;class Grid{ ...};// 소스(cpp)파일#include \"Grid.h\"#include &lt;utility&gt;template &lt;typename T&gt;Grid&lt;T&gt;::Grid(size_t width, size_t height) : m_Width(width), mHeight(height) { ... }template class Grid&lt;int&gt;;template class Grid&lt;double&gt;;template class Grid&lt;std::vector&lt;int&gt;&gt;;템플릿 매개변수비타입 매개변수 흔히 사용하는 종류의 매개변수를 의미 정수 계열,열거,포인터,레퍼런스 ,null_ptr_t 등 비타입 매개변수로만 사용할 수 있다. C++17 부터 auto, auto&amp; , auto* 등도 비타입 매개변수로 사용할 수 있다. 간결해졌지만 제약사항이 많아진다. non-const 변수는 사용할 수 없고 const 변수만 사용 가능 constexpr 함수로도 가능하다. 템플릿 매개변수를 사용하면 값이 타입의 일부가 된다. ex) Grid&lt;int,10,10&gt; 과 Grid&lt;int,10,11&gt;은 서로 다른 타입이 된다 그래서 위의 두 타입의 객체는 서로 대입할 수 없고 , 함수나 메서드에 전달할 때도 호환되지 않는다. template&lt;typename T , size_t WIDTH, size_t HEIGHT&gt;class Grid{ ...}================Grid&lt;int , 10 , 10&gt; myGrid; // 템플릿 매개변수에 int값 선언// 1. non-const 정수는 사용하지 못함size_t height = 10;Grid&lt;int , 10 , height&gt; testGrid // 컴파일 에러// 1-2 const 정수const size_t height = 10;Grid&lt;int , 10 , height&gt; testGrid // 컴파일 성공// 2. constexpr 함수로도 표현 가능constexpr size_t getHeight() { return 10; }Grid&lt;double, 2 , getHeight()&gt; myDoubleGrid // 컴파일 성공타입 매개변수의 디폴트 값 생성자나 함수처럼 템플릿 매개변수에도 디폴트값을 지정할 수 있다. 생성자나 함수처럼 오른쪽 끝에서 왼쪽 방향으로 중간에 건너뛰지 않고 디폴트값을 지정해야 된다. template&lt;typename T = int, size_t WIDTH = 10 , size_t HEIGHT = 10&gt; class Grid { .. }; 메서드를 정의하는 코드에서는 템플릿 선언문에 디폴트값을 생략해도 가능. 아래처럼 작성하면 다양하게 작성이 가능하다 template&lt;typename T, size_t WIDTH, size_t HEIGHT&gt;const std::optional&lt;T&gt;&amp; Grid&lt;T, WIDTH, HEIGHT&gt;::at(size_t x, size_t y) const{ verifyCoordinate(x,y); return mCells[x][y];}==================Grid&lt;&gt; myIntGrid;Grid&lt;int&gt; myGrid;Grid&lt;int, 5&gt; anotherGrid;Grid&lt;int, 5, 5&gt; aFourthGrid;" }, { "title": "어트리뷰트", "url": "/posts/%EC%96%B4%ED%8A%B8%EB%A6%AC%EB%B7%B0%ED%8A%B8/", "categories": "C++", "tags": "C++", "date": "2023-01-10 00:00:00 +0900", "snippet": "어트리뷰트 특정 벤더에서만 제공하는 정보나 옵션을 소스 코드에 추가하는 매커니즘 형식은 이중 대괄호를 사용하여 표기한다.[[noreturn]] 함수가 호출한 측으로 제어를 리턴하지 않는다는 것을 의미 주로 프로세스나 스레드를 종료시키거나 익셉션을 던지는 함수에 지정 이 어트리뷰트를 붙이면 의도가 명확히 드러나 컴파일러는 경고나 에러를 발생시키지 않는다. 아래 코드에서 [[noreturn]] 코드를 제거한다면 경고 메세지를 출력[[noreturn]] void forceProgramTermination(){ std::exit(1);}bool isDongleAvailable(){ bool isAvailable = false; return isAvailable;}bool isFeatureLicensed(int featureId){ if(!isDongleAvailable()) // 찾지못하면 실행 중단 { forceProgramTermination(); } else { // 찾았다면 라이선스를 검사해서 주어진 기능을 제공하는지 확인 bool isLicensed = false; return isLicensed; }}int main(){ bool isLicensed = isFeatureLicensed(42);}[[deprecated]] 더 이상 지원하지 않는 대상을 지정할 때 사용 현재 사용할 수는 있지만 권장하지 않는 기능임을 표시 // 이 함수를 호출하면 괄호안에 있는 메세지가 발생한다.[[deprecated(\"Unsafe method, please use xyz\")]] void func();[[fallthrough]] C++17부터 추가됨 switch 문에서 의도적으로 fallthrough(완료되지못한)를 적용하고 싶을 때 사용 빈 케이스 문에는 지정하지 않아도 된다. switch (backgroundColor){ case Color::DarkBlue: DarkBlueFunc(); [[fallthrough]]; case Color::Black: // 배경색이 다크 블루나 블랙일 때 실행 DarkBlueOrBlackFunc(); break; case Color::Red; case Color::Green: break;}[[nodiscard]] 값을 리턴하도록 정의된 함수에 사용하면 리턴값을 사용하지 않을 때 경고 메세지를 발생 즉, 값을 사용해야 하는데 사용하지 않았을 경우 경고를 준다. 에러 코드를 리턴하는 함수에 적용하면 좋음 [[nodiscard]] int func(){ return 42;}int main(){ func(); return 0;}[[maybe_unused]] 프로그램에서 사용하지 않는 코드를 발견해도 경고 메세지를 출력하고 싶지 않을 때 사용// 컴파일러의 경고 수준이 높게 설정하면 경고 메세지가 출력된다// warning C4100 : 'param2' unreferenced formal parameter// warning C4100 : 'param1' unreferenced formal parameterinf func(int param1, int param2){ return 42;}=============================inf func(int param1, [[maybe_unused]] int param2){ return 42;}" }, { "title": "캐스팅", "url": "/posts/%EC%BA%90%EC%8A%A4%ED%8C%85/", "categories": "C++", "tags": "C++", "date": "2023-01-09 00:00:00 +0900", "snippet": "const_cast() 포인터 변수나 레퍼런스 변수의 const 속성을 잠시 삭제하는 기능 volatile 키워드도 삭제 가능 const char* ch; char* ch2 = const_cast&lt;char*&gt;(ch);as_const() C++17부터 std::as_const() 란 헬퍼 메서드가 추가됐다 utility헤더에 정의돼 있음 레퍼런스 매개 변수를 const 레퍼런스 버전으로 변환 as_const(obj) 는 const_cast&lt;const T&amp;&gt;(obj)와 같다. as_const와 auto를 같이 사용할 때 주의해야할 점은 auto는 레퍼런스와 const 속성을 제거한다. // const std::string&amp;이 아닌 std::string이 된다. auto result = std::as_const(str);static_cast() 언어에서 제공하는 명시적 변환 기능을 수행 실수형과 정수형, 정수형과 열거형등의 기본 데이터 타입 간의 변환 가능 상속관계의 클래스 계층 간의 변환 가능 void 포인터를 다른 타입의 포인터로 변환 가능 서로 다른 타입의 포인터 간의 타입 변환은 못함 실행 시간 타입 검사를 하지 않음 다형성이 없어도 변환 가능 (RTTI 옵션이 꺼져있어도 됨) 다중 상속에서 기본 클래스 간의 타입 변환은 못함 // 실수형과 정수형double d = 22.22;int result = static_cast&lt;int&gt;(d);// 상속 관계 클래스 간의 변환Base* b;Derived* d = new Derived;b = d; // 업 캐스팅d = static_cast&lt;Derived*&gt;(b); // 다운 캐스팅// 포인터나 레퍼런스에도 적용 가능Derived derived;Base&amp; br = derived;Derived&amp; dr = static_cast&lt;Derived&amp;&gt;(br);reinterpret_cast() static_cast와 달리 C++ 타입 규칙에서 허용하지 않더라도 상황에 따라 캐스팅 하는것이 적합할 때 적용할 수 있다. 서로 관련이 없는 포인터나 레퍼런스끼리 변환 가능 상속 계층에서 아무런 관련이 없는 포인터 타입끼리도 변환 가능 함수 포인터 사이도 변환 가능 class X{};class Y{};int main(){ X x; Y y; X* xp = &amp;x; Y* yp = &amp;y; // 서로 관련 없는 클래스 타입의 포인터 변환 xp = reinterpret_cast&lt;X*&gt;(yp); // 포인터를 void*로 변환할 때는 캐스팅 하지 않아도 된다. void* p = xp; // 변환된 void*를 다시 원래 포인터로 복원할 때는 xp = reinterpret_cast()를 사용해야 한다. xp = reinterpret_cast&lt;X*&gt;(p); // 서로 관련이 없는 클래스 타입의 레퍼런스 변환 // static_cast는 작동하지 않는다 X&amp; xr = x; Y&amp; yr = reinterpret_cast&lt;Y&amp;&gt;(x); return 0;}dynamic_cast() 같은 상속 계층에 속한 타입끼리 캐스팅할 때 사용한다. 내부 객체 타입의 정보를 실행 시간에 검사한다. static_cast나 reinterpret_cast()와 달리 실행 시간에도 타입 검사를 실행 포인터나 레퍼런스를 캐스팅할 때 사용한다. 포인터의 경우 캐스팅 실패시 널 포인터를 리턴 레퍼런스의 경우 std::bad_cast 익셉션을 발생 실행 시간의 타입 정보는 객체의 vtable에 저장되는데 dynamic_cast가 적용되려면 클래스에 virtual 메서드가 최소 하나 이상 있어야 한다.class Base {public: virtual ~Base() = default;};class Derived : public Base {public: virtual ~Derived() = default;};int main(){ Base* b; Derived* d = new Derived(); b = d; d = dynamic_cast&lt;Derived*&gt;(b);}" }, { "title": "타입 앨리어스와 typedef", "url": "/posts/%ED%83%80%EC%9E%85-%EC%95%A8%EB%A6%AC%EC%96%B4%EC%8A%A4%EC%99%80-typedef/", "categories": "C++", "tags": "C++", "date": "2023-01-08 00:00:00 +0900", "snippet": "타입 앨리어스 타입을 새로 정의하지 않고 기존 타입 선언에 대한 동의어를 선언하는 문법using IntPtr = int*; // IntPtr은 int*와 동일하게 사용int* p1;IntPtr p2; // int* p2와 같다// 두 타입이 완전히 같다p1 = p2;p2 = p1; 타입 앨리어스는 너무 복잡하게 선언된 타입 표현을 좀 더 간편하게 만들기 위한 용도using StringVector = std::vector&lt;std::string&gt;;int main(){ StringVector MyVector; // std::vector&lt;std::string&gt; MyVector; 와 동일 return 0;}함수 포인터에 대한 타입 앨리어스 함수도 내부적으로 특정한 메모리 주소가 지정되어 C++에서는 함수의 주소를 변수로 사용할 수 있다. 함수 포인터의 타입은 매개변수 타입과 리턴 타입에 따라 결정된다. 함수포인터의 형식 반환타입 (*식별자) (매개변수) 식별자 앞에 *가 붙는 이유는 함수 포인터도 결국 포인터 변수이므로 주소값을 저장하기 위해 // 함수 포인터using MatchFunctions = bool(*)(int, int);void findMatches(int value1[], int value2[], size_t numValues, MatchFunctions matcher){ for (size_t i = 0; i &lt; numValues; ++i) { // 함수 포인터를 이용해서 변수처럼 전달하더라도 일반 함수처럼 호출할 수 있다. if (matcher(value1[i], value2[i])) { cout &lt;&lt; \"Match found at position\" &lt;&lt; endl; } }} 함수 포인터와 같은 타입을 인수로도 전달할 수 있다. 문법에 따르면 &amp;를 붙여야 하지만 함수 이름만 적어도 컴파일러는 이 값을 주소로 판단한다. bool intEqual(int item1, int item2){\treturn item1 == item2;}...int arr1[] = { 1,2,3,4,5 };int arr2[] = { 9,8,7,6,5 };int arrsize = sizeof(arr1);findMatches(arr1, arr2, arrsize, &amp;intEqual);메서드와 데이터 멤버 포인터에 대한 앨리어스 C++에서는 클래스의 데이터 멤버와 메서드에 대한 주소를 가져오는 기능도 지원한다. non-static 데이터 멤버나 메서드는 반드시 객체를 통해 접근해야만 한다 객체마다 데이터 멤버나 메서드를 소유하게 하기 위함 메서드나 데이터 멤버를 포인터로 접근하려면 객체의 문맥에서 포인터를 역참조 해야한다 // 클래스 선언Employee employee;// methodPtr란 변수를 선언, 타입은 non-static const 메서드를 가리키고 int를 반환하는 포인터// methodPtr 변수를 Emplyoee 클래스의 getSalary() 메서드에 대한 포인터로 초기화, &amp;를 반드시 붙여야함int (Employee::*methodPtr) () const = &amp;Employee::getSalary;// 메서드 뒤에 나오는 ()는 *보다 연산자 우선순위가 높기 때문에 employee.*methodPtr를 괄호로 묶어줘야 한다.cout &lt;&lt; (employee.*methodPtr) () &lt;&lt; endl;======================================// 타입 앨리어스를 이용한 코드Employee employee;using PtrToGet = int (Employee::*methodPtr) () const;PtrToGet methodPtr = &amp;Employee::getSalary;cout &lt;&lt; (employee.*methodPtr) () &lt;&lt; endl;// auto를 이용하면 더욱 간결해진다Employee employee;auto methodPtr = &amp;Employee::getSalary;cout &lt;&lt; (employee.*methodPtr) () &lt;&lt; endl;typedef 타입 앨리어스는 C++11부터 도입됐기 때문에 그 전에는 typedef로 구현했었다. typedef도 타입 앨리어스와 마찬가지로 기존에 선언된 타입에 다른 이름을 붙여준다. // 타입 앨리어스using IntPtr = int*;// typedeftypedef int* IntPtr; 함수 포인터의 typedef// 타입 앨리어스using FunctionType = int(*)(char,double);// typedeftypedef int(*FunctionType)(char,double); 타입 앨리어스와 typedef는 완전히 같은것이 아니다. 템플릿에서 활용할 때는 typedef보다 타입 앨리어스를 사용하는 것이 더 유리하다." }, { "title": "static과 extern", "url": "/posts/static%EA%B3%BC-extern/", "categories": "C++", "tags": "C++", "date": "2023-01-07 00:00:00 +0900", "snippet": "static 데이터 멤버와 메서드 클래스의 데이터 멤버와 메서드를 static으로 선언할 수 있다. static으로 지정하지 않은 멤버와 달리 객체에 속하지 않는다. static 데이터 멤버는 객체 외부에 단 하나만 존재 static 메서드도 객체가 아닌 클래스에 속하고 특정 객체를 통해 실행되지 않는다. static 링크 C++에서 링크를 처리하는법 C++는 코드를 소스 파일 단위로 컴파일 해서 그 결과로 나온 오브젝트 파일들을 링크 단계에서 연결 외부 링크로 연결되면 다른 소스 파일에서 이름을 사용할 수 있고, 내부 링크로 연결되면 같은 파일 에서만 사용할 수 있다. 선언문 앞에 static 키워드를 붙이면 내부 링크(정적 링크)가 적용된다.FirstFile.cpp---------------void f(); // f()를 선언만 하고 정의는 Xint main(){ f(); return 0;}AnotherFile.cpp---------------#include &lt;iostream&gt;void f(); // 선언과 정의void f(){ std::cout&lt;&lt;\"f\\n\";} f()가 외부 링크로 처리되어 main()에서 다른 파일에 있는 함수를 호출하기 때문에 에러없이 컴파일되고 링크된다 만약 AnotherFile.cpp의 f()의 앞에 static을 붙인다면 컴파일 과정에서 에러는 발생하지 않지만 링크 단계에서 에러가 발생한다. static 대신 익명 네임스페이스를 이용하여 내부 링크가 적용되게 할 수도 있다. AnotherFile.cpp---------------#include &lt;iostream&gt;static void f(); // static 메서드로, 내부 링크가 적용void f(){ std::cout&lt;&lt;\"f\\n\";}/*namespace{ void f(); // 네임 스페이스로 인한 내부 링크 적용 void f() { std::cout&lt;&lt;\"f\\n\"; }}*/extern static과 반대로 외부 링크를 지정할 때 사용 const와 typedef는 기본적으로 내부 링크로 처리되지만, extern을 붙이면 외부 링크가 적용된다. extern 적용 과정 extern으로 지정하면 컴파일러는 이를 정의가 아닌 선언문으로 취급한다 변수를 extern으로 지정하면 컴파일러는 그 변수에 대해 메모리를 할당하지 않는다. 따라서 그 변수를 정의하는 문장은 따로 작성해야 한다. extern이 필요한 경우는 다른 소스 파일의 변수를 접근하게 만들 때이다.FirstFile.cpp===========int x = 3;// 기본적으로 전역 변수는 extern 변수로 간주// 하지만 상수 (const) 전역 변수는 static 변수로 간주 한다main.cpp=================#include &lt;iostream&gt;extern int x;int main(){ std::cout&lt;&lt; x &lt;&lt; std::endl; // 3 출력}함수 안의 static 변수 static은 특정한 스코프 안에서만 값을 유지하는 로컬 변수로도 만들 수 있다. 함수 안에서 static으로 지정한 변수는 그 함수만 접근할 수 있는 전역 변수 주로 함수에서 초기화 작업 수행 여부를 기억하는 용도로 많이 사용void Func(){ static int i = 0; ++i; cout &lt;&lt; i &lt;&lt; endl;}int main(){ Func(); // 1 출력 Func(); // static 변수는 첫 초기화만 실행하므로 i가 1인 상태에서 ++i가 실행되어 2 출력}함수 링크 함수는 변수와 같이 링크 속성을 가진다. 함수는 기본적으로 외부 링크가 기본 설정이지만, static 키워드를 통해 내부 링크로 적용할 수 있다.static int add(int x, int y){ return x+y;}" }, { "title": "const", "url": "/posts/const/", "categories": "C++", "tags": "C++", "date": "2023-01-06 00:00:00 +0900", "snippet": "const 상수를 의미하는 ‘constant’의 줄임말로서 변경되면 안 될 대상을 선언할 때 사용 컴파일러는 const로 지정한 대상을 변경하는 코드를 발견하면 에러를 발생시킨다. const로 지정된 대상을 최적화할 대 효율을 더욱 높일 수 있다.const 변수와 매개변수 함수나 메서드에 대한 매개변수도 그 값이 변하지 않도록 const로 지정가능하다void func(const int param){ ... // param을 변경할 수 없다.}const 포인터 const의 위치에 따라 변경할 수 없는 값을 지정할 수 있다.// 포인터로 가리키는 값이 수정되지 않게 적용const int* ip;ip = new int[10];// ip[4] = 5; 컴파일 에러 발생// ip(포인터) 자체를 변경할 수 없기 때문에 선언과 동시에 초기화를 해야한다.int* const ip = new int[10];ip[4] = 5;const 레퍼런스 레퍼런스에 const를 적용하는 것이 포인터에 const를 적용하는 것보다 간단하다. 이유는 첫째, 레퍼런스는 기본적으로 const 속성을 갖고 있다. 둘째, 레퍼런스에 대한 레퍼런스를 만들 수 없기 때문에 참조가 한 단계뿐이다. const 레퍼런스는 주로 매개변수에 적용한다. 인수의 복사본이 만들어지지 않아 메모리가 낭비되지 않고 const로 값을 변경할 수 없게 만든다. void doSomeThing(const Class&amp; arg){ ...}const 메서드 메서드 안에서 데이터 멤버를 변경하지 않도록 보장하고 싶을 떄 const 키워드를 붙인다. 그 클래스에서 mutable로 선언하지 않은 데이터 멤버는 변경할 수 없다.class ExClass{private: mutable int a; int b;public: int getValue() const { a++; // b++; 컴파일 에러 }};constexpr 키워드 일반화된 상수 표현식을 사용할 수 있게 해주며, 일반화된 상수 표현식을 통해 변수나 함수, 생성자 함수에 대하여 컴파일 타임에 평가될 수 있도록 처리해 줄 수 있다.const int getArraySize() {return 32;}int main(){ int myArray[getArraySize()]; // C++에서 허용되지 않는 표현 return 0;} constexpr 키워드를 사용하면 getAraySize() 함수를 상수 표현식으로 다시 정의할 수 있다.constexpr int getArraySize() {return 32;}int main(){ int myArray[getArraySize()]; // Ok // int myArray[getArraySize() + 1]; 이렇게도 작성이 가능하다. return 0;}constexpr 함수 함수에 constexpr를 적용하면 상당히 많은 제약사항이 적용된다. 함수 본문에는 goto문, try/catch 블록 , 초기화하지 않은 변수, 리터럴 타입이 아닌 변수 정의등이 없어야 하고, 익셉션을 던져도 안된다. 다른 constexpr 함수를 호출할 수는 있다. 리턴 타입이 반드시 리터럴 타입이어야 한다. 클래스 멤버가 constexpr 함수 일 때는 virtual로 선언할 수 없다. constexpr 함수의 매개변수는 반드시 리터럴 타입이어야 한다. 컴파일러는 항상 모든 정의를 완전히 알아야 컴파일할 수 있으므로 constexpr 함수의 구현 코드를 컴파일러가 해석하기 전에는 호출할 수 없다. dynamic_cast()와 reinterpret_cast()를 사용할 수 없다. new와 delete도 사용할 수 없다. constexpr 생성자 사용자 정의 타입으로 된 상수 표현식 변수를 만들고 싶다면 constexpr 생성자를 정의 생성자에 constexpr를 적용하면 함수와 마찬가지로 여러가지 제약사항이 생긴다 가상 베이스 클래스를 가질 수 없다 생성자의 매개변수가 모두 리터럴타입이어야 한다 생성자 본문을 함수 try 블록(function-try-block)으로 만들 수 없다. 생성자 본문을 명시적으로 디폴트를 지정하거나, constexpr 함수의 본문과 똑같은 요구사항을 만족해야한다. 모든 데이터 멤버를 상수 표현식으로 초기화해야 한다. class Rect{public: constexpr Rect(size_t width, size_t height) : mWidth(width), mHeight(height) {} constexpr size_t getArea() const { return mWidth * mHeight; }private: size_t mWidth, mHeight;}" }, { "title": "RayCasting", "url": "/posts/RayCasting/", "categories": "DirectX3D", "tags": "directx3d", "date": "2022-09-27 00:00:00 +0900", "snippet": "RayCasting 가상의 공간에 보이지 않는 빛(Ray)을 투사해 빛에 닿는 표면을 파악하는 기술 카메라를 기준으로 카메라와 카메라와 바라보는 방향쪽의 오브젝트의 거리값을 계산 RayCasting을 이용하여 카메라가 바라보는 지형(LandScape)쪽의 값을 변경하여 높이를 실시간으로 높이를 변경할 수 있다. ComputeShader를 이용쉐이더 // Raycast 결과를 받을 구조체 struct tRaycastOut { Vec2 vUV; // 지형 전체 기준의 UV int iDist; // 클릭 지점과 카메라 간의 거리 int bSuccess; // 성공여부 }; ------------------------------------------------- #ifndef _RAYCAST #define _RAYCAST #include \"value.fx\" #include \"func.fx\" RWStructuredBuffer&lt;tRaycastOut&gt; OUTPUT : register(u0); // 결과를 받을 구조화버퍼 // 리소스 #define HEIGHT_MAP g_tex_0 // 높이맵 #define CAM_POS g_vec4_0 // 카메라 위치 #define CAM_DIR g_vec4_1 // 카메라 방향 #define FACE_X g_int_0 // x축의 면 개수 #define FACE_Z g_int_1 // z축의 면 개수 [numthreads(32, 32, 1)] void CS_Raycast(int3 _iThreadID : SV_DispatchThreadID) { int2 id = _iThreadID.xy; // LandScape 밖으로 나갔다면 return if (FACE_X * 2 &lt;= id.x || FACE_Z &lt;= id.y) { return; } float3 vPos[3] = { (float3) 0.f, (float3) 0.f, (float3) 0.f }; if (0 == id.x % 2) { // 아래쪽 삼각형 // 2 // | \\ // 0--1 vPos[0].x = id.x / 2; vPos[0].z = id.y; vPos[1].x = vPos[0].x + 1; vPos[1].z = id.y; vPos[2].x = vPos[0].x; vPos[2].z = id.y + 1; } else { // 윗쪽 삼각형 // 1--0 // \\ | // 2 vPos[0].x = (id.x / 2) + 1; vPos[0].z = id.y + 1; vPos[1].x = vPos[0].x - 1; vPos[1].z = id.y + 1; vPos[2].x = vPos[0].x; vPos[2].z = id.y; } // uv를 계산해서 높이맵에서 해당 지점의 높이값을 추출 for (int i = 0; i &lt; 3; ++i) { float2 uv = float2(saturate(vPos[i].x / (float)FACE_X), saturate(1.f - vPos[i].z / (float)FACE_Z)); vPos[i].y = HEIGHT_MAP.SampleLevel(g_sam_0, uv, 0).x; } float3 vCrossPoint = (float3) 0.f; float fDist = 0.f; // IntersectsLay : 수학을 이용한 광선 충돌 체크 if (IntersectsLay(vPos, CAM_POS.xyz, CAM_DIR.xyz, vCrossPoint, fDist)) { int iDist = (int)(10000.f * fDist); int iDistOut = 0; InterlockedMin(OUTPUT[0].iDist, iDist, iDistOut); if (iDistOut &lt; iDist) { // 실패 return; } OUTPUT[0].vUV = float2(saturate(vCrossPoint.x / (float)FACE_X), saturate(1.f - vCrossPoint.z / (float)FACE_Z)); OUTPUT[0].success = 1; } }IntersectsLay 함수 int IntersectsLay(float3 _vertices[3], float3 _vStart, float3 _vDir, out float3 _vCrossPoint, out float _fResult) { float3 edge[2] = { (float3) 0.f, (float3) 0.f }; edge[0] = _vertices[1].xyz - _vertices[0].xyz; edge[1] = _vertices[2].xyz - _vertices[0].xyz; float3 normal = normalize(cross(edge[0], edge[1])); float b = dot(normal, _vDir); float3 w0 = _vStart - _vertices[0].xyz; float a = -dot(normal, w0); float t = a / b; _fResult = t; float3 p = _vStart + t * _vDir; _vCrossPoint = p; float uu, uv, vv, wu, wv, inverseD; uu = dot(edge[0], edge[0]); uv = dot(edge[0], edge[1]); vv = dot(edge[1], edge[1]); float3 w = p - _vertices[0].xyz; wu = dot(w, edge[0]); wv = dot(w, edge[1]); inverseD = uv * uv - uu * vv; inverseD = 1.0f / inverseD; float u = (uv * wv - vv * wu) * inverseD; if (u &lt; 0.0f || u &gt; 1.0f) { return 0; } float v = (uv * wu - uu * wv) * inverseD; if (v &lt; 0.0f || (u + v) &gt; 1.0f) { return 0; } return 1; } #endif" }, { "title": "3DCollision", "url": "/posts/3DCollision/", "categories": "DirectX3D", "tags": "directx3d", "date": "2022-09-22 00:00:00 +0900", "snippet": "3D Collision 3차원에서의 두 물체간의 충돌체크 AABB 충돌과 OBB 충돌이 있다.AABBSphere Sphere의 AABB는 두 물체의 중심점으로부터의 거리와 두 물체의 반지름을 비교하여 충돌체크 두 물체의 중심점으로부터의 거리가 두 물체의 반지름의 합보다 크다면 충돌X bool CCollisionMgr::IsCollision_Sphere(CCollider3D* _pLeftCol, CCollider3D* _pRightCol) { Vec3 vCenter = _pLeftCol-&gt;GetWorldPos() - _pRightCol-&gt;GetWorldPos(); float fDist = vCenter.Length(); float fRadius = fabsf(_pLeftCol-&gt;GetWorldScale().x) * 0.5f + fabsf(_pRightCol-&gt;GetWorldScale().x) * 0.5f; if (fRadius &lt; fDist) { return false; } return true; }Cube Cube의 AABB는 각 축 모서리의 길이와 두 물체의 거리를 비교하여 충돌체크 Sphere처럼 두 물체의 반지름(모서리의 절반)의 합과 거리를 비교함 두 물체의 거리와 모서리의 길이를 비교하여 만약 한 축이라도 물체의 거리가 멀다면 그 축에서 두 물체가 만나지 않으므로 충돌X bool CCollisionMgr::IsCollision_Cube(CCollider3D* _pLeftCol, CCollider3D* _pRightCol) { Vec3 vCenter = _pRightCol-&gt;GetWorldPos() - _pLeftCol-&gt;GetWorldPos(); float fXDist =_pRightCol-&gt;GetWorldPos().x - _pLeftCol-&gt;GetWorldPos().x; float fYDist = _pRightCol-&gt;GetWorldPos().y - _pLeftCol-&gt;GetWorldPos().y; float fZDist = _pRightCol-&gt;GetWorldPos().z - _pLeftCol-&gt;GetWorldPos().z; //float fDist = vCenter.Length(); Vec3 vLeftScale = _pLeftCol-&gt;GetWorldScale(); Vec3 vRightScale = _pRightCol-&gt;GetWorldScale(); if (abs(_pLeftCol-&gt;GetWorldScale().x * 0.5f + _pLeftCol-&gt;GetWorldScale().x * 0.5f) &lt; abs(fXDist) || abs(_pLeftCol-&gt;GetWorldScale().y * 0.5f + _pLeftCol-&gt;GetWorldScale().y * 0.5f) &lt; abs(fYDist) || abs(_pLeftCol-&gt;GetWorldScale().z * 0.5f + _pLeftCol-&gt;GetWorldScale().z * 0.5f) &lt; abs(fZDist)) { return false; } return true; }OBB 충돌 둘다 CubeMesh를 사용했을 때만 비교 두 물체의 거리와 면끼리의 비교 , 두 물체의 축끼리의 외적을 구해서 거리를 비교한 다음 거리 체크하여 구한다 두 물체사이의 분리축이 있는지를 체크하고 만약 있다면 충돌하지 않는다. bool CCollisionMgr::IsCollision_OBB(CCollider3D* _pLeftCol, CCollider3D* _pRightCol) { // 충돌체가 사용하는 기본 도형(사각형) 로컬 정점위치를 알아낸다. // 0 ㅡ 1 // /| /| // 3 ㅡ 2 |\t // | 7 '|'/6 // |____|/ // 4 5 // // Cube 메쉬의 정점위치 // 메쉬로부터 정점의 로컬 위치를 저장 static CMesh* pCubeMesh = CResMgr::GetInst()-&gt;FindRes&lt;CMesh&gt;(L\"CubeMesh\").Get(); static Vtx* pVtx = pCubeMesh-&gt;GetVtxSysMem(); static Vec3 vLocalPos[8] = { pVtx[0].vPos, pVtx[1].vPos, pVtx[2].vPos, pVtx[3].vPos, pVtx[4].vPos, pVtx[5].vPos, pVtx[6].vPos, pVtx[7].vPos }; Matrix matLeft = _pLeftCol-&gt;GetWorldMat(); Matrix matRight = _pRightCol-&gt;GetWorldMat(); // Local 스페이스의 여섯 개의 정점을 각 충돌체의 월드행렬을 곱해서 월드 위치로 보낸다. Vec3 vAsix[6] = {}; // (Vector3, 1.f) X Matirx(4x4) // 월드로 보낸 정점을 통해서 각 투영 축 이면서 투영시킬 벡터 성분 6개를 구한다. vAsix[0] = XMVector3TransformCoord(vLocalPos[1], matLeft) - XMVector3TransformCoord(vLocalPos[0], matLeft); vAsix[1] = XMVector3TransformCoord(vLocalPos[3], matLeft) - XMVector3TransformCoord(vLocalPos[0], matLeft); vAsix[2] = XMVector3TransformCoord(vLocalPos[1], matRight) - XMVector3TransformCoord(vLocalPos[0], matRight); vAsix[3] = XMVector3TransformCoord(vLocalPos[3], matRight) - XMVector3TransformCoord(vLocalPos[0], matRight); vAsix[4] = XMVector3TransformCoord(vLocalPos[7], matLeft) - XMVector3TransformCoord(vLocalPos[0], matLeft); vAsix[5] = XMVector3TransformCoord(vLocalPos[7], matRight) - XMVector3TransformCoord(vLocalPos[0], matRight); // 월드에 배치된 두 충돌체의 중심을 이은 벡터 //Vec3 vCenter = XMVector3TransformCoord(Vec3::Zero, matRight) - XMVector3TransformCoord(Vec3::Zero, matLeft);\t // 두 물체의 중심간의 거리 Vec3 vCenter = _pRightCol-&gt;GetWorldPos() - _pLeftCol-&gt;GetWorldPos(); // 각 물체의 면에 해당하는 축에 투영하여 중심간의 거리와 거리값을 비교 for (int i = 0; i &lt; 6; ++i) { Vec3 vProj = vAsix[i]; vProj.Normalize(); float fDist = 0.f; for (int j = 0; j &lt; 6; ++j) { // vProj 에 vAsix[j] 를 투영시킨 길이\t\t fDist += abs(vAsix[j].Dot(vProj)); } fDist *= 0.5f; float fCenterDist = abs(vCenter.Dot(vProj)); if (fDist &lt; fCenterDist) return false; } // 왼쪽 충돌체의 축과 오른쪽 충돌체의 축을 설정 Vec3 _LeftAxis[3] = { XMVector3TransformCoord(vLocalPos[1], matLeft) - XMVector3TransformCoord(vLocalPos[0], matLeft) ,\t // x축 XMVector3TransformCoord(vLocalPos[3], matLeft) - XMVector3TransformCoord(vLocalPos[0], matLeft) ,\t // z축 XMVector3TransformCoord(vLocalPos[7], matLeft) - XMVector3TransformCoord(vLocalPos[0], matLeft) }; // y축 Vec3 _RightAxis[3] = { XMVector3TransformCoord(vLocalPos[1], matRight) - XMVector3TransformCoord(vLocalPos[0], matRight) , // x축 XMVector3TransformCoord(vLocalPos[3], matRight) - XMVector3TransformCoord(vLocalPos[0], matRight) , // z축 XMVector3TransformCoord(vLocalPos[7], matRight) - XMVector3TransformCoord(vLocalPos[0], matRight) }; // y축 // 두 물체의 축을 하나씩 받아와서 외적으로 수직인 벡터를 구하고 그 벡터에 투영해서 중심간의 거리와 거리값을 비교 for (int i = 0; i &lt; 3; ++i) { for (int j = 0; j &lt; 3; ++j) { float fCenterDist; float fDist = 0.f; Vec3 Left = _LeftAxis[i]; Vec3 Right = _RightAxis[j]; Vec3 vCross = Left.Cross(Right);\t fDist += abs(vCross.Dot(_LeftAxis[0])); fDist += abs(vCross.Dot(_LeftAxis[1])); fDist += abs(vCross.Dot(_LeftAxis[2])); fDist += abs(vCross.Dot(_RightAxis[0])); fDist += abs(vCross.Dot(_RightAxis[1])); fDist += abs(vCross.Dot(_RightAxis[2])); fCenterDist = abs(vCenter.Dot(vCross)); if (fDist &lt; fCenterDist) return false; } } return true; }" }, { "title": "LandScape", "url": "/posts/LandScape/", "categories": "DirectX3D", "tags": "directx3d", "date": "2022-09-20 00:00:00 +0900", "snippet": "LandScape 3d 지형을 형성하는 컴포넌트 LOD 디자인을 사용 LOD(Level Of Detail) : 카메라의 거리에 따라 정점의 개수가 달라지는 방식 테셀레이션을 이용하여 정점을 만들고 높이맵을 이용하여 각 정점에 대한 높이를 적용시킨다. 높이맵을 저장하는 텍스쳐에서 추출해서 정점에 적용시키는 방식 만약 정점이 호출될 때 정점 자신만의 노말을 계산한다면 모든 정점의 노말이 비슷해져서 명암이 구분이 되지 않는다 그렇기에 uv로 주변의 높이를 받아와서 주변의 정점에 적용 시키고 난뒤 탄젠트,바이노말을 구하고 그 둘을 외적해서 현재 정점의 노말값을 구한다 주변의 정점과 비교해서 노말값이 들어가기 때문에 명암이 구분된다. 메쉬 및 쉐이더 생성코드 void CLandScape::CreateMesh() { // 지형 메쉬 설정 Ptr&lt;CMesh&gt; pMesh = CResMgr::GetInst()-&gt;FindRes&lt;CMesh&gt;(L\"LandscapeMesh\"); // ResMgr은 리소스를 관리하는 매니저 // 메쉬 만들기 // 기존에 참조하던 메쉬는 삭제 if (nullptr != pMesh) { // 삭제 CResMgr::GetInst()-&gt;ForceDeleteRes&lt;CTexture&gt;(L\"LandscapeMesh\"); pMesh = nullptr; } vector&lt;Vtx&gt; vecVtx; vector&lt;UINT&gt; vecIdx; Vtx v; // 정점 배치 for (UINT row = 0; row &lt; m_iZFaceCount + 1; ++row) { for (UINT col = 0; col &lt; m_iXFaceCount + 1; ++col) { v.vPos = Vec3((float)col, 0.f, (float)row); v.vUV = Vec2(col, m_iZFaceCount - row); v.vNormal = Vec3(0.f, 1.f, 0.f); v.vTangent = Vec3(1.f, 0.f, 0.f); v.vBinormal = Vec3(0.f, 0.f, -1.f); v.vColor = Vec4(1.f, 0.f, 1.f, 1.f); vecVtx.push_back(v); } } // 인덱스 for (UINT row = 0; row &lt; m_iZFaceCount; ++row) { for (UINT col = 0; col &lt; m_iXFaceCount; ++col) { // 0 // | \\ // 2- 1 vecIdx.push_back(row * (m_iXFaceCount + 1) + col + m_iXFaceCount + 1); vecIdx.push_back(row * (m_iXFaceCount + 1) + col + 1); vecIdx.push_back(row * (m_iXFaceCount + 1) + col); // 1- 2 // \\ | // 0 vecIdx.push_back(row * (m_iXFaceCount + 1) + col + 1); vecIdx.push_back(row * (m_iXFaceCount + 1) + col + m_iXFaceCount + 1); vecIdx.push_back(row * (m_iXFaceCount + 1) + col + m_iXFaceCount + 1 + 1); } } // 0 // | \\ // 2- 1 // 1- 2 // \\ | // 0 /* 위와 같이 회전해도 같은 인덱스가 나오도록 만들어야 쉐이더에서 패치 안의 정점 번호에 대응시키기 때문에 크랙 (위 패치의 정점과 아래 패치의 정점의 개수가 달라 높이가 달라지는 현상)이 생기지 않음 */ pMesh = new CMesh; pMesh-&gt;Create(vecVtx.data(), (UINT)vecVtx.size(), vecIdx.data(), (UINT)vecIdx.size()); CResMgr::GetInst()-&gt;AddRes&lt;CMesh&gt;(L\"LandscapeMesh\", pMesh.Get(), true); SetMesh(pMesh); } void CLandScape::CreateShaderMaterial() { // ====================== // 전용 쉐이더 및 재질 생성 // ======================\t\t Ptr&lt;CGraphicsShader&gt; pShader = CResMgr::GetInst()-&gt;FindRes&lt;CGraphicsShader&gt;(L\"LandScapeShader\"); if (nullptr == pShader) { pShader = new CGraphicsShader; pShader-&gt;CreateVertexShader(L\"shader\\\\LandScape.fx\", \"VS_LandScape\"); pShader-&gt;CreateHullShader(L\"shader\\\\LandScape.fx\", \"HS_LandScape\"); pShader-&gt;CreateDomainShader(L\"shader\\\\LandScape.fx\", \"DS_LandScape\"); pShader-&gt;CreatePixelShader(L\"shader\\\\LandScape.fx\", \"PS_LandScape\"); pShader-&gt;SetTopology(D3D11_PRIMITIVE_TOPOLOGY::D3D11_PRIMITIVE_TOPOLOGY_3_CONTROL_POINT_PATCHLIST); pShader-&gt;SetShaderDomain(SHADER_DOMAIN::DOMAIN_DEFERRED); pShader-&gt;SetRSType(RS_TYPE::CULL_BACK); //pShader-&gt;SetRSType(RS_TYPE::WIRE_FRAME); pShader-&gt;SetBSType(BS_TYPE::DEFAULT); pShader-&gt;SetDSType(DS_TYPE::LESS); CResMgr::GetInst()-&gt;AddRes&lt;CGraphicsShader&gt;(L\"LandScapeShader\", pShader.Get(), true); } Ptr&lt;CMaterial&gt; pMtrl = CResMgr::GetInst()-&gt;FindRes&lt;CMaterial&gt;(L\"material\\\\LandScapeMtrl.mtrl\"); if (nullptr == pMtrl) { pMtrl = new CMaterial; pMtrl-&gt;SetShader(pShader); CResMgr::GetInst()-&gt;AddRes&lt;CMaterial&gt;(L\"material\\\\LandScapeMtrl.mtrl\", pMtrl.Get(), true); } SetSharedMaterial(pMtrl); // 재질 설정 }쉐이더 코드 #ifndef _LANDSCAPE #define _LANDSCAPE #include \"value.fx\" #include \"func.fx\" // ================ // Landscape Shader #define FaceXCount g_int_0 #define FaceZCount g_int_1 #define HeightMapResolution g_vec2_0 #define HeightMap g_tex_0 // ================ struct VTX_IN { float3 vPos : POSITION; float2 vUV : TEXCOORD; }; struct VS_OUT { float3 vPos : POSITION; float2 vUV : TEXCOORD; float2 vFullUV : TEXCOORD1; float3 vViewPos : POSITION1; }; VS_OUT VS_LandScape(VTX_IN _in) { VS_OUT output = (VS_OUT) 0.f; output.vPos = _in.vPos; output.vUV = _in.vUV; output.vFullUV = _in.vUV / float2(FaceXCount, FaceZCount); // uv를 면개수로 나눠서 지형 전체기준의 uv를 저장 output.vViewPos = mul(float4(output.vPos, 1.f), g_matWV).xyz; return output; } // Hull Shader (덮개 쉐이더) struct PatchTessFactor // 패치 당 분할 레벨 값 { float EdgeParam[3] : SV_TessFactor; float InsideParam : SV_InsideTessFactor; }; // 패치 상수 함수(Patch Constant Function) - 패치당 한번씩 실행되는 함수, // 패치를 어떻게 분할 할 것인지를 반환해 줘야 한다. PatchTessFactor HS_PatchConstant(InputPatch&lt;VS_OUT, 3&gt; _Patch, uint _PatchIdx : SV_PrimitiveID) { PatchTessFactor param = (PatchTessFactor) 0.f; float3 vViewSidePos = (_Patch[0].vViewPos + _Patch[2].vViewPos) / 2.f; float3 vViewUpDownPos = (_Patch[1].vViewPos + _Patch[2].vViewPos) / 2.f; float3 vViewSlidePos = (_Patch[0].vViewPos + _Patch[1].vViewPos) / 2.f; param.EdgeParam[0] = GetTessFactor(vViewUpDownPos, 1.f, 32.f, 2000.f, 10000.f); param.EdgeParam[1] = GetTessFactor(vViewSidePos, 1.f, 32.f, 2000.f, 10000.f); param.EdgeParam[2] = GetTessFactor(vViewSlidePos, 1.f, 32.f, 2000.f, 10000.f); param.InsideParam = param.EdgeParam[2]; return param; } [domain(\"tri\")] [outputtopology(\"triangle_cw\")] [outputcontrolpoints(3)] [patchconstantfunc(\"HS_PatchConstant\")] [maxtessfactor(64.0)] //[partitioning(\"integer\")] [partitioning(\"fractional_odd\")] VS_OUT HS_LandScape(InputPatch&lt;VS_OUT, 3&gt; _Patch, uint _Idx : SV_OutputControlPointID, uint _PatchIdx : SV_PrimitiveID) { VS_OUT output = (VS_OUT) 0.f; output.vPos = _Patch[_Idx].vPos; output.vUV = _Patch[_Idx].vUV; output.vViewPos = _Patch[_Idx].vViewPos; output.vFullUV = _Patch[_Idx].vFullUV; return output; } // -----&gt; Tessellator // Domain Shader struct DS_OUT { float4 vPosition : SV_Position; float2 vUV : TEXCOORD; float2 vFullUV : TEXCOORD1; float3 vViewPos : POSITION; float3 vViewTangent : TANGENT; float3 vViewBinormal : BINORMAL; float3 vViewNormal : NORMAL; }; [domain(\"tri\")] DS_OUT DS_LandScape(float3 _vLocation : SV_DomainLocation, const OutputPatch&lt;VS_OUT, 3&gt; _Patch, PatchTessFactor _param) { DS_OUT output = (DS_OUT) 0.f; float3 vLocalPos = _Patch[0].vPos * _vLocation[0] + _Patch[1].vPos * _vLocation[1] + _Patch[2].vPos * _vLocation[2]; output.vUV = _Patch[0].vUV * _vLocation[0] + _Patch[1].vUV * _vLocation[1] + _Patch[2].vUV * _vLocation[2]; output.vFullUV = _Patch[0].vFullUV * _vLocation[0] + _Patch[1].vFullUV * _vLocation[1] + _Patch[2].vFullUV * _vLocation[2]; // 지형 전체기준 UV 로 전환 // UV단위값을 구함 float2 vLandscapeUVStep = float2(1.f / HeightMapResolution.x, 1.f / HeightMapResolution.y); // 상하좌우 uv값을 구함 float2 vLandscapeUV = float2(output.vUV.x / (float)FaceXCount, output.vUV.y / (float)FaceZCount); float2 vLandScapeUpUV = float2(vLandscapeUV.x, vLandscapeUV.y - vLandscapeUVStep.y); float2 vLandScapeDownUV = float2(vLandscapeUV.x, vLandscapeUV.y + vLandscapeUVStep.y); float2 vLandScapeLeftUV = float2(vLandscapeUV.x - vLandscapeUVStep.x, vLandscapeUV.y); float2 vLandScapeRightUV = float2(vLandscapeUV.x + vLandscapeUVStep.x, vLandscapeUV.y); // 각 정점들이 자기 위치에 맞는 높이값을 높이맵에서 추출 한 후, 자신의 로컬 높이로 지정 vLocalPos.y = HeightMap.SampleLevel(g_sam_0, vLandscapeUV, 0).r; output.vViewPos = mul(float4(vLocalPos, 1.f), g_matWV); float2 vLandscapeLocalposStep = float2(FaceXCount / HeightMapResolution.x, FaceZCount / HeightMapResolution.y); // vLandscapeLocalposStep는 로컬에서의 1픽셀만큼의 이동을 함. float3 vLocalUpPos = float3(vLocalPos.x, HeightMap.SampleLevel(g_sam_0, vLandScapeUpUV, 0).r, vLocalPos.z + vLandscapeLocalposStep.y); float3 vLocalDownPos = float3(vLocalPos.x, HeightMap.SampleLevel(g_sam_0, vLandScapeDownUV, 0).r, vLocalPos.z - vLandscapeLocalposStep.y); float3 vLocalLeftPos = float3(vLocalPos.x - vLandscapeLocalposStep.x, HeightMap.SampleLevel(g_sam_0, vLandScapeLeftUV, 0).r, vLocalPos.z); float3 vLocalRightPos = float3(vLocalPos.x + vLandscapeLocalposStep.x, HeightMap.SampleLevel(g_sam_0, vLandScapeRightUV, 0).r, vLocalPos.z); // Tangent, Binormal, Normal 재계산 output.vViewTangent = normalize(mul(float4(vLocalRightPos - vLocalLeftPos, 0.f), g_matWV).xyz); output.vViewBinormal = normalize(mul(float4(vLocalUpPos - vLocalDownPos, 0.f), g_matWV).xyz); output.vViewNormal = normalize(cross(output.vViewBinormal, output.vViewTangent).xyz); // 투영좌표계까지 연산 output.vPosition = mul(float4(vLocalPos, 1.f), g_matWVP); return output; } struct PS_OUT { float4 vColor : SV_Target0; float4 vViewNormal : SV_Target1; float4 vViewPos : SV_Target2; float4 vData : SV_Target3; }; PS_OUT PS_LandScape(DS_OUT _in) { PS_OUT output = (PS_OUT) 0.f; output.vColor = float4(0.8f, 0.8f, 0.8f, 1.f); float3 vViewNormal = _in.vViewNormal; output.vViewPos = float4(_in.vViewPos, 1.f); output.vViewNormal = float4(vViewNormal, 1.f); return output; } #endif" }, { "title": "다중 상속-1", "url": "/posts/%EB%8B%A4%EC%A4%91%EC%83%81%EC%86%8D-1/", "categories": "C++", "tags": "C++", "date": "2022-09-19 00:00:00 +0900", "snippet": "다중 상속 객체지향 프로그래밍에서의 다중 상속은 쓸데없이 복잡하기만한 개념이라 여기는 사람도 많다 좋고 나쁜지는 각자의 판단에 맡기기로 하고, C++ 다중 상속 매커니즘을 소개한다. 여러 클래스 상속하기 다중 상속을 정의하는 방법은 클래스 이름 옆에 상속할 베이스 클래스를 나열하기만 하면 된다.class Baz : public Foo, public Bar{ // 클래스 선언 코드}; Baz가 여러 부모를 동시에 상속하면 다음과 같은 속성을 지니게 된다.1 : Baz 객체는 Foo와 Bar에 있는 데이터 멤버와 public 메서드를 갖게 된다.2 : Baz 객체는 Foo와 Bar에 있는 protected 데이터 멤버와 메서드에 접근할 수 있다.3 : Baz 객체를 Foo나 Bar로 업캐스팅할 수 있다.4 : Baz 객체를 생성하면 Foo와 Bar의 디폴트 생성자가 호출된다. 이때 호출 순서는 첫 줄에 정의한 순서이다.5 : Baz 객체를 삭제하면 Foo와 Bar의 소멸자가 자동으로 호출된다. 이때 호출 순서는 클래스 정의에 나열한 클래스 순서와 반대다. Dog과 Bird를 동시에 상속하는 DogBird 클래스를 만들어 본다class Dog{ public: virtual void bark() { cout &lt;&lt; \"Woof!\" &lt;&lt; endl; }};class Bird{ public: virtual void chirp() { cout &lt;&lt; \"Chirp!\" &lt;&lt; endl; }};class DogBird : public Dog, public Bird{};int main(){ DogBird myAnimal; myAnimal.bark(); myAnimal.chirp(); return 0;}/* 결과Woof!Chirp!*/ 다중 상속 클래스 객체는 단일 상속 클래스 객체와 크게 다르지 않다 단일 상속 클래스 객체처럼 다중 상속 클래스 객체는 베이스 클래스의 public 메서드를 제공한다 이름 충돌과 모호한 베이스 클래스 다중 상속에서 문제가 발생하는 사례이다.모호한 이름 Dog 클래스와 Bird 클래스 둘 다 eat() 메서드를 지닌다고 가정한다. Dog과 Bird는 서로 관련이 없기 때문에 어느 한쪽이 다른쪽의 메서드를 오버라이딩할 수 없다 eat() 메서드를 호출하지 않는다면 컴파일이나 에러가 발생하지 않는다. 하지만 클라이언트 코드에서 eat() 메서드를 호출하면 어느 버전을 호출해야 하는지에 대해 모호하다는 에러가 발생한다 class Dog{ public: virtual void bark() { cout &lt;&lt; \"Woof!\" &lt;&lt; endl; } virtual void eat() { cout &lt;&lt; \"The dog ate\" &lt;&lt; endl; }};class Bird{ public: virtual void chirp() { cout &lt;&lt; \"Chirp!\" &lt;&lt; endl; } virtual void eat() { cout &lt;&lt; \"The bird ate\" &lt;&lt; endl; }};class DogBird : public Dog, public Bird{};int main(){ DogBird myAnimal; myAnimal.eat(); // 에러! eat 메서드의 소속이 모호하다. return 0;} 이렇게 모호한 상황이 발생하지 않게 하기 위해서는 dynamic_cast()로 객체를 명시적으로 업캐스팅해서 원하지 않는 버전을 컴파일러가 볼 수 없게 가리거나 스코프 지정 연산자로 원하는 버전을 구체적으로 지정한다.dynamic_cast&lt;Dog&amp;&gt;(myAnimal).eat(); // Dog::eat()을 호출myAnimal.Dog::eat(); // Dog::eat()을 호출 파생 클래스 사이에 이름이 같은 메서드가 있을 때도 앞에서 본 부모 메서드 접근 방식처럼 스코프 지정 연산자로 원하는 메서드를 명확히 지정한다. DigBird 클래스는 이렇게 모호한 상황이 발생하지 않도록 다음과 같이 eat() 메서드를 별도로 정의한다 구체적으로 어느 부모의 메서드를 호출할지는 메서드 안에서 결정한다. class DogBird : public Dog, public Bird{ public: void eat() override;};void DogBird::eat(){ Dog::eat(); // Dog 버전의 eat() 호출} 아니면 다음과 같이 using문으로 DogBird가 상속할 eat() 버전을 구체적으로 지정한다.class DogBird : public Dog, public Bird{ public: using Dog::eat; // Dog 버전의 eat()를 상속한다.};모호한 베이스 클래스 같은 클래스를 두 번 상속할 때도 모호한 상황이 발생한다. 예를 들어 Bird 클래스가 Dog을 상속하면 DogBird 코드에서 컴파일 에러가 발생한다. 베이스 클래스가 모호하기 때문이다. class Dog {};class Bird : public Dog {};class DogBird : public Bird, public Dog {}; // 에러가 발생한다 베이스 클래스가 모호한 경우는 상속관계가 이상하거나 클래스 계층이 정리되지 않는다. C++에서는 위 코드처럼 클래스 계층을 구성할 수 있지만, 이름의 모호함은 발생할 수 있다. Animal / \\ / \\ Dog Bird \\ / \\ / DogBird 클래스 계층이 이렇게 다이아몬드 형태로 구성됐을 때는 최상단의 클래스를 순수 가상 메서드로만 구성된 추상 클래스로 만들면 된다. 메서드를 선언만하고 정의하지 않았기 때문에 베이스 클래스에서 호출할 메서드가 없어 모호함이 발생하지 않는다. 이 방법에 따라 eat()를 순수 가상 메서드로 선언하여 Animal을 추상 베이스 클래스로 만들었다. class Animal{ public: virtual void eat() = 0;}class Dog{ public: virtual void bark() { cout &lt;&lt; \"Woof!\" &lt;&lt; endl; } virtual void eat() { cout &lt;&lt; \"The dog ate\" &lt;&lt; endl; }};zclass Bird{ public: virtual void chirp() { cout &lt;&lt; \"Chirp!\" &lt;&lt; endl; } virtual void eat() { cout &lt;&lt; \"The bird ate\" &lt;&lt; endl; }};class DogBird : public Dog, public Bird{ public: using Dog::eat;};다중 상속 활용법 다중 상속을 왜 쓰는지 궁금할 것이다. 다중 상속을 활용하는 가장 간단한 예는 is-a 관계를 맺는 대상이 하나 이상인 객체에 대한 클래스를 정의하기 위해서다. 다중 상속의 가장 적합하면서 간단한 예는 믹스인 클래스를 구현할 때다. 컴포넌트 기반으로 클래스를 모델링할 때도 다중 상속을 사용한다 하지만 has-a 관계가 복잡해지기 때문에 이 방식보다는 데이터 멤버로 정의하는 편이 좋다. " }, { "title": "Tessellation", "url": "/posts/Tessellation/", "categories": "DirectX3D", "tags": "directx3d", "date": "2022-09-18 00:00:00 +0900", "snippet": "Tessellation 훌, 도메인 쉐이더를 이용하여 정점 사이에 다른 정점을 대량 생산한다. 훌 쉐이더 정점이 호출되는 수만큼 호출되는 쉐이더 만약 RectMesh라면 정점은 4개지만 총 6번 호출 (인덱스버퍼만큼) InputPatch를 사용 훌 쉐이더에서 입력으로 사용할 수 있는 제어점 배열 테셀레이터 패치 상수 함수와 정점의 포지션, uv로 정점을 생성 도메인 쉐이더 테셀레이터에서 만들어진 정점 + 기존의 정점(메쉬의 정점) 사이에 또 다른 정점을 대량 생산하는 쉐이더 테셀레이터에서 만들어진 정점들이 보간되서 들어와야 하지만 보간되지 않기 때문에 패치와 패치 안의 정점에 대한 거리비율을 이용하여 정점의 위치를 정해준다. 새로 생기는 정점은 이 정점을 생성하는데 사용한 패치안의 3개의 정점에서 비율이 높은 정점에 가깝다. 도메인 쉐이더 이후에 래스터라이저로 가야하기 떄문에 이 때 SV_Position 사용해야함 패치 상수 함수의 반환값도 매개변수로 사용할 수 있다. 훌 쉐이더 -&gt; 테셀레이터 -&gt; 도메인 쉐이더 순.테셀레이션 쉐이더 생성 // Tessellation Test Shader pShader = new CGraphicsShader; pShader-&gt;SetShaderDomain(SHADER_DOMAIN::DOMAIN_FORWARD); pShader-&gt;CreateVertexShader(L\"Shader\\\\tessellation.fx\", \"VS_Tess\"); pShader-&gt;CreateHullShader(L\"Shader\\\\tessellation.fx\", \"HS_Tess\"); pShader-&gt;CreateDomainShader(L\"Shader\\\\tessellation.fx\", \"DS_Tess\"); pShader-&gt;CreatePixelShader(L\"Shader\\\\tessellation.fx\", \"PS_Tess\"); pShader-&gt;SetRSType(RS_TYPE::WIRE_FRAME); pShader-&gt;SetTopology(D3D11_PRIMITIVE_TOPOLOGY::D3D11_PRIMITIVE_TOPOLOGY_3_CONTROL_POINT_PATCHLIST); // 테셀레이션 전용 탑폴로지인 patchlist , 숫자 3은 제어점 개수 AddRes&lt;CGraphicsShader&gt;(L\"TessShader\", pShader, true);코드 #ifndef _TESS #define _TESS #include \"value.fx\" // ======================== // Tessellation Test Shader // DOMAIN : Forward // RS_TYPE : Wire Frame // DS_TYPE : Default // BS_TYPE : Default // ======================== struct VTX_IN { float3 vPos : POSITION; float2 vUV : TEXCOORD; }; struct VTX_OUT { float3 vPos : POSITION; float2 vUV : TEXCOORD; }; VTX_OUT VS_Tess(VTX_IN _in) { VTX_OUT output = (VTX_OUT) 0.f; output.vPos = _in.vPos; output.vUV = _in.vUV; return output; } // 패치 상수 함수 // 패치 당 수행되는 함수 struct PatchTessFactor { float EdgeFactor[3] : SV_TessFactor; // 삼각형을 사용하므로 3 float InsideFactor : SV_InsideTessFactor; // 내부에서 분할값 }; PatchTessFactor PatchConstFunc(InputPatch&lt;VTX_OUT, 3&gt; _in, uint _patchID : SV_PrimitiveID) { PatchTessFactor factor = (PatchTessFactor) 0.f; factor.EdgeFactor[0] = 2.f; // 정점 0과 마주하는 변을 2등분 factor.EdgeFactor[1] = 2.f; // 정점 1과 마주하는 변을 2등분 factor.EdgeFactor[2] = 2.f; // 정점 2와 마주하는 변을 2등분 factor.InsideFactor = 4.f; // 내부 꼭짓점 개수 return factor; } // 훌 쉐이더 // 정점 당 수행되는 함수 // 한 정점에서 수행되면 그 정점이 사용된 패치(삼각형)의 정보가 같이 들어온다 // 대괄호를 이용하여 쉐이더에서 필요한 정보들을 세팅 [domain(\"tri\")] // 삼각형을 사용 [outputtopology(\"triangle_cw\")] // 시계방향으로 인덱스 구분 [outputcontrolpoints(3)] // 제어점 개수 [patchconstantfunc(\"PatchConstFunc\")] // 사용할 패치 상수 함수 [maxtessfactor(64.f)] // 한 면에서 최대 몇개까지 분할 [partitioning(\"integer\")] // 분할을 정수단위로 끊을지 실수단위로 끊을지 // [partitioning(\"fractional_odd\")] --&gt; 실수 단위로 끊을 때 사용 VTX_OUT HS_Tess(InputPatch&lt;VTX_OUT, 3&gt; _in // 패치 구조체 , uint _VtxID : SV_OutputControlPointID // 패치 안에서의 정점 ID , uint _patchID : SV_PrimitiveID) // 패치의 ID, { VTX_OUT output = (VTX_OUT) 0.f; output.vPos = _in[_VtxID].vPos; output.vUV = _in[_VtxID].vUV; return output; } // Tessellator // HullShader 에서 전달한 정보를 토대로 정점을 생성 시키는 단계 // 생성된 정점을에 대해서 Domain Shader 를 호출 시킨다. struct DS_OUT { float4 vPosition : SV_Position; float2 vUV : TEXCOORD; }; // 도메인 쉐이더 후 래스터라이저로 넘겨야 하기 전에 보간을 해줘야 하지만 테셀레이터가 그러한 처리를 해주지 않음. // 그렇기에 정점이 만들어지기 위해 사용할 패치와 각 정점의 거리비율값을 이용한다. // 도메인에서 받아온 정점의 좌표는 각각의 원본정점* 비율의 합 // 3개의 비율의 합은 1 [domain(\"tri\")] // 삼각형 사용 DS_OUT DS_Tess(OutputPatch&lt;VTX_OUT, 3&gt; _OriginPatch, float3 _Ratio : SV_DomainLocation, PatchTessFactor _factor) { DS_OUT output = (DS_OUT) 0.f; float3 vLocalPos = _OriginPatch[0].vPos * _Ratio[0] + _OriginPatch[1].vPos * _Ratio[1] + _OriginPatch[2].vPos * _Ratio[2]; float2 vUV = _OriginPatch[0].vUV * _Ratio[0] + _OriginPatch[1].vUV * _Ratio[1] + _OriginPatch[2].vUV * _Ratio[2]; output.vPosition = mul(float4(vLocalPos, 1.f), g_matWVP); output.vUV = vUV; return output; } float4 PS_Tess(VTX_OUT _in) : SV_Target { float4 vOutColor = float4(1.f, 0.f, 1.f, 1.f); return vOutColor; } #endif" }, { "title": "가상 소멸자", "url": "/posts/%EA%B0%80%EC%83%81-%EC%86%8C%EB%A9%B8%EC%9E%90/", "categories": "C++", "tags": "C++", "date": "2022-09-18 00:00:00 +0900", "snippet": "가상 소멸자(virtual 소멸자) 기본 클래스의 소멸자를 만들 때 소멸자를 가상 함수로 작성해야 한다. 이유는 파생 클래스의 객체가 기본 클래스에 대한 포인터로 delete 되는 상황에서도 정상적인 소멸이 되도록 하기 위함 가상 소멸자는 그 클래스에 가상 함수가 하나라도 들어있는 경우로만 한정해야 한다. // Base는 기본 클래스, Derived는 파생 클래스 Base *p = new Derived(); delete p; // 결과 ~Base() p가 Base타입이므로 컴파일러는 ~Base()소멸자를 호출한다. 그러면 ~Base만 살행되고 ~Derived()가 실행되지 않는다. 소멸자를 가상함수로 선언하면 ~Base()에 대한 호출은 실행 중에 동적 바인딩에 의해 ~Derived()에 대한 호출로 변하게 되어 ~Derived가 실행된다. class Base{ public: virtual ~Base() { cout &lt;&lt; \"~Base()\" &lt;&lt; endl; } }; class Derived : public Base { public: virtual ~Derived() { cout &lt;&lt; \"~Derived()\" &lt;&lt; endl; } }; int main() { Derived *dp = new Derived(); Base* bp = new Derived(); delete dp; // Derived 의 포인터로 소멸 delete bp; // Base의 포인터로 소멸 } // 결과 ~Derived() ~Base() ~Derived() ~BasE() 파생 클래스의 소멸자는 자신이 실행된 후 기본 클래스의 소멸자를 호출하도록 컴파일된다. 소멸자 또한 자식 클래스에서 오버로딩된 함수이기 때문에 부모 포인터로 객체를 삭제하면 부모 클래스의 소멸자가 호출된다." }, { "title": "오버라이딩", "url": "/posts/%EC%98%A4%EB%B2%84%EB%9D%BC%EC%9D%B4%EB%94%A9/", "categories": "C++", "tags": "C++", "date": "2022-09-17 00:00:00 +0900", "snippet": "상속 관계에서 함수 재정의 C++에서 자식클래스에서 부모클래스의 멤버함수와 동일한 이름과 원형으로 함수를 재정의 할 수 있다.예제class Base{ public: void f() { cout &lt;&lt; \"Base::f() called\" &lt;&lt; endl; }};class Derived{ public: void f() { cout &lt;&lt; \"Derived::f() called\" &lt;&lt; endl; }};void main(){ Derived d, *pDer; pDer = &amp;d; pDer-&gt;f(); // Derived 의 멤버 f()호출 Base* pBase; pBase = pDer; // 업캐스팅 pBase-&gt;f(); // Base의 멤버 f()호출}결과===============Derived::f() calledBase::f() called pDer이 가리키는 객체 d에는 Base의 f()와 Derived의 f() 둘다 가지고 있지만 pDer은 Derived에 대한 포인터이므로 Derived의 f()를 호출한다. pBase는 Base에 대한 포인터 이므로 Base의 f()를 호출한다. 가상 함수 가상함수란 virtual 키워드로 선언된 멤버 함수 virtual는 컴파일러에게 자신에 대한 호출 바인딩을 실행 시간까지 미루도록 지시하는 키워드 바인딩(Binding)이란 프로그램의 어떤 기본 단위가 가질 수 있는 구성요소의 구체적인 값, 성격을 확정하는 것을 말한다. 예제class Base{public: virtual void f(); // f는 가상함수};오버라이딩 자식 클래스에서 부모 클래스의 가상 함수를 재정의하는 것을 함수 오버라이딩이라고 한다. 함수 재정의와 오버라이딩의 차이 함수 재정의는 컴파일 시간에 결정된 함수가 단순히 호출되는 정적바인딩 오버라이딩은 호출 바인딩을 실행 시간까지 미루는 동적바인딩 예제// 함수 재정의class Base{ public: void f() { cout &lt;&lt; \"Base::f() called\" &lt;&lt; endl; }};class Derived : public Base { public: void f() { cout &lt;&lt; \"Derived::f() called\" &lt;&lt; endl; }};// 오버라이딩class Base{ public: virtual void f() { cout &lt;&lt; \"Base::f() called\" &lt;&lt; endl; }};class Derived : public Base { public: virtual void f() { cout &lt;&lt; \"Derived::f() called\" &lt;&lt; endl; }}; 함수 재정의로 만들어진 객체 a에는 동등한 호출 기회를 가진 함수 f()가 두개 존재 오버라이딩으로 만들어진 객체 b는 두개의 함수 f()가 존재하지만, Base의 f()는 존재감을 잃고, 항상 Derived의 f()가 호출됨 Base의 f()에 대한 모든 호출은 실행 시간 중에 Derived의 f()함수로 동적 바인딩이 된다. 함수 재정의가 컴파일 시간 다형성이라면, 오버라이딩은 실행 시간 다형성이다.오버라이딩의 목적 부모 클래스에 가상 함수를 만드는 목적은 자식 클래스들이 자신의 목적에 맞게 가상 함수를 재정의 하는것 부모 클래스의 가상 함수는 상속받는 자식 클래스에서 구현해야 할 일종의 함수 인터페이스 즉, 가상함수는 “하나의 인터페이스에 대해 서로 다른 모양의 구현” 이라는 객체 지향 언어의 다형성을 실형하는 도구 예제class Shape{ protected: virtual void draw() {} // 가상 함수 선언, 자식 클래스에서 재정의할 함수에 대한 인터페이스 역할};class Circle{ protected: virtual void draw() { .... } // Circle을 그린다.};class Rect{ protected: virtual void draw() { .... } // Rect를 그린다};void paint(Shape* p){ p-&gt;draw(); //Shape의 draw()가 호출되지 않고 p가 가리키는 객체 내에 오버라이딩된 draw 호출}paint(new Circle() ); // Circle을 그린다.paint(new Rect()); // Rect를 그린다.동적 바인딩 동적 바인딩은 오버라이딩된 함수가 무조건 호출 동적 바인딩은 실행 시간 바인딩(run-time binding) 혹은 늦은 바인딩 (late binding)이라고도 부른다. 과정 가상 함수를 호출하는 코드를 컴파일할 때, 컴파일러는 바인딩을 실행 시간에 결정하도록 미룬다. 나중에 가상 함수가 호출되면, 실행 중에 객체 내의 오버라이딩된 가상 함수를 동적으로 찾아 호출 동적 바인딩이 발생하는 구체적인 경우 자식 클래스의 객체에 대해 부모 클래스의 포인터로 가상 함수가 호출될 때 일어난다. 부모 클래스 내의 멤버 함수가 가상 함수 호출 자식 클래스 내의 멤버 함수가 가상 함수 호출 main()과 같은 외부 함수에서 부모 클래스의 포인터로 가상 함수 호출 다른 클래스에서 가상 함수 호출 동적 바인딩 사례Shape *pShape = new Shape();pShape-&gt;paint(); // Shape의 draw 함수 호출Shape *pShape = new Circle(); // 업캐스팅pShape-&gt;paint(); // Circle의 draw 함수 호출C++11 에서 추가된 override와 final지시어override 지시어 자식 클래스의 가상함수 가장 뒤에 붙이는 키워드 실수를 방지하기 위해 사용한다예제class Shape{public: virtual void draw(); //가상함수};class Rect : public Shape{public: // draw()를 오버라이딩하려고 했지만 이름이 틀린 경우, // 컴파일러는 새로운 멤버함수 drow()를 작성하는 것으로 인식하고 컴파일 오류를 발생시키지 않음 void drow(); };class Rect : public Shape{public: // override 지시어를 붙여줌으로써 가상함수라는 것을 의미하지만 // draw가아닌 drow를 작성했으므로 컴파일 오류 발생 void drow() override; };final 지시어 자식 클래스에서 오버라이딩을 할 수 없게 하거나, 클래스의 상속 자체를 금지할 수 있다. final 지시어를 가상 함수의 원형 바로 뒤에 작성하면, 자식 클래스는 이 가상 함수를 오버라이딩 할 수 없다. class Shape{public: virtual void draw() final; // draw()의 오버라이딩 금지 선언};class Rect : public Shape{public: void draw(); // 컴파일 오류.}; 클래스 이름 바로뒤에 final를 작성하면 다른 클래스는 이 클래스를 상속받을 수 없다.class Shape final { // Shape 클래스의 상속 금지 선언 .....};class Rect : public Shape { // 컴파일 오류. .....}; 자식클래스 Rect도 final로 선언할 수 있다.class Shape { .....};class Rect final : public Shape { // Rect 클래스 상속 금지 선언 .....};class RoundRect : public Rect { // 컴파일 오류 .....};C++ 오버라이딩의 특징 오버라이딩의 성공 조건과 실패 가상 함수의 이름과 매개 변수 타입, 개수뿐 아니라 리턴타입도 일치해야함 가상 함수의 virtual 속성은 상속되는 성질이 있어, 자식 클래스에서 virtual 키워드를 생략해도 자동으로 가상함수가 된다. 가상 함수의 접근지정은 보통 함수와 마찬가지로 private,protected,public 자유롭게 사용 가능하다오버라이딩과 범위 지정 연산자(::) 오버라이딩에 의해 무시되고 존재감을 상실한 부모 클래스의 가상 함수는 범위 지정 연산자로 호출가능 범위 지정 연산자를 통해 부모 클래스 Shape의 가상 함수를 정적 바인딩으로 호출 Circle circle;Shape *pShape = &amp;circle;pShape-&gt;Shape::draw(); // 정적 바인딩 . Shape의 멤버 함수 draw() 호출 클래스의 멤버 함수에서도 범위 지정 연산자를 이용하여 부모 클래스의 가상 함수를 호출할 수 있다. 이경우에도 정적 바인딩 class Circle : public Shape {public: virtual void draw() { Shape::draw(); // 부모 클래스 Shape의 draw() 실행 // 필요한 기능 추가 }};" }, { "title": "Frustum Culling", "url": "/posts/Frustum_Culling/", "categories": "DirectX3D", "tags": "directx3d", "date": "2022-09-14 00:00:00 +0900", "snippet": "Frustum culling(절두체 컬링) 카메라의 시야범위 안에 있는 오브젝트들에 한해 렌더링을 돌려 최적화를 하는 방법 절두체는 사각뿔에서 밑면에 평행한 면을 잘라서 만든 도형으로 총 6면이 있다. 6면 NEAR : 카메라에서 가장 가까운 곳의 시야 범위 면 FAR : 카메라에서 가장 먼 곳의 시야 범위 면 LEFT : 카메라의 좌측 시야 범위 면 RIGHT : 카메라의 우측 시야 범위 면 UP : 카메라의 상단 시야 범위 면 DOWN : 카메라의 하단 시야 범위 면 원리 평면의 방정식 ax by + cz + d = 0 에서 법선벡터(a,b,c)와 평면까지의 거리 d를 이용하여 임의의 점이 절두체 안에 들어있는지 확인하는 방식 오브젝트의 중심 점에서 평면의 법선벡터와 내적하여 평면까지의 거리를 구한 후 그 거리값을 이용하여 모든 면에 대해 통과한다면 렌더링을 진행한다. 내적을 이용하여 오브젝트의 중심점이 절두체 안에 있는지 확인하는 방법 PointCheck함수 만약 오브젝트의 중심은 절두체 밖으로 빠져나갔지만 오브젝트의 끝쪽이 절두체에 들어올 경우 렌더링이 되지 않는다. 이럴 경우에는 오브젝트를 감싸는 구(Bounding Box)의 반지름만큼 보정하면 중심점은 밖에 있어도 반지름만큼 안에 들어간다면 오브젝트는 렌더링이 되는 방식이다. BoundigBox : 오브젝트를 완전히 감싸는 구, 완전히 감싸야 하기 때문에 중심점에서 반지름값만큼 더한값이 항상 오브젝트의 크기보다 크거나 같다. SphereCheck함수 과정 미리 투영된 좌표를 준비 투영된 좌표를 절두체 컬링을 적용할 카메라의 투영 역행렬, 뷰 역행렬을 곱해 월드로 보냄 그렇게 월드좌표로 보내진 좌표들을 이용하여 카메라의 절두체 면에 사용할 평면을 만듦 그렇게 만들어진 6개의 면으로 오브젝트의 중심점과 내적하여 절두체 안에 있으면 렌더링하고 하나라도 면에서 밖에 있다면 렌더링하지 않는다.코드 CFrustum::CFrustum() : m_ProjPos{} , m_WorldPos{} , m_arrPlane{} , m_pCam(nullptr) { // 4 ---- 5 // /| / | // 0 -- 1 | // | 6 -|-- 7 // 2 -- 3/ // 미리 투영 좌표를 설정 m_ProjPos[0] = Vec3(-1.f, 1.f, 0.f); m_ProjPos[1] = Vec3(1.f, 1.f, 0.f); m_ProjPos[2] = Vec3(-1.f, -1.f, 0.f); m_ProjPos[3] = Vec3(1.f, -1.f, 0.f); m_ProjPos[4] = Vec3(-1.f, 1.f, 1.f); m_ProjPos[5] = Vec3(1.f, 1.f,\t1.f); m_ProjPos[6] = Vec3(-1.f, -1.f,1.f); m_ProjPos[7] = Vec3(1.f, -1.f, 1.f); } CFrustum::~CFrustum() { } void CFrustum::finalupdate() { // Frustum 을 소유하고 있는 카메라의 Proj 역행렬, View 역행렬 을 가져온다. const Matrix&amp; matViewInv = m_pCam-&gt;GetViewInvMat(); const Matrix&amp; matProjInv = m_pCam-&gt;GetProjInvMat(); // VP 역행렬을 곱해서 WorldPos 를 구한다. Matrix matVPInv = matProjInv * matViewInv; for (int i = 0; i &lt; 8; ++i) { m_WorldPos[i] = XMVector3TransformCoord(m_ProjPos[i], matVPInv); } // 8개의 월드 좌표를 이용해서 월드상에서 절두체를 구성하는 6개의 평면을 정의한다. // 4 ---- 5 // /| / | // 0 -- 1 | // | 6 -|-- 7 // 2 -- 3/ m_arrPlane[(UINT)PLANE::PL_LEFT] = XMPlaneFromPoints(m_WorldPos[4], m_WorldPos[0], m_WorldPos[2]); m_arrPlane[(UINT)PLANE::PL_RIGHT] = XMPlaneFromPoints(m_WorldPos[1], m_WorldPos[5], m_WorldPos[7]); m_arrPlane[(UINT)PLANE::PL_UP] = XMPlaneFromPoints(m_WorldPos[0], m_WorldPos[4], m_WorldPos[5]); m_arrPlane[(UINT)PLANE::PL_DOWN] = XMPlaneFromPoints(m_WorldPos[2], m_WorldPos[3], m_WorldPos[7]); m_arrPlane[(UINT)PLANE::PL_NEAR] = XMPlaneFromPoints(m_WorldPos[2], m_WorldPos[0], m_WorldPos[1]); m_arrPlane[(UINT)PLANE::PL_FAR] = XMPlaneFromPoints(m_WorldPos[7], m_WorldPos[5], m_WorldPos[4]); } bool CFrustum::PointCheck(Vec3 _vPos) { for (int i = 0; i &lt; (UINT)PLANE::END; ++i) { // N dot P = D float fDot = _vPos.Dot(m_arrPlane[i]); if (fDot + m_arrPlane[i].w &gt; 0) { return false; } } return true; } bool CFrustum::SphereCheck(Vec3 _vPos, float _fRadius) { for (int i = 0; i &lt; (UINT)PLANE::END; ++i) { // N dot P = D float fDot = _vPos.Dot(m_arrPlane[i]); if (fDot + m_arrPlane[i].w &gt; _fRadius) { return false; } } return true; }" }, { "title": "업캐스팅과 다운캐스팅", "url": "/posts/%EC%97%85%EC%BA%90%EC%8A%A4%ED%8C%85%EA%B3%BC_%EB%8B%A4%EC%9A%B4%EC%BA%90%EC%8A%A4%ED%8C%85/", "categories": "C++", "tags": "C++", "date": "2022-09-12 00:00:00 +0900", "snippet": "캐스팅(Casting) 타입을 변환하는 것 형변환이라고도 한다.업캐스팅 자식 클래스의 객체를 부모 클래스의 포인터로 가리키는 것을 업캐스팅이라고 한다.Base* pBase = pDerived; pBase는 부모 클래스의 포인터이므로 pBase 포인터로는 자식 클래스의 멤버나 함수에 접근하지 못한다. 업 캐스팅한 부모 클래스의 포인터로는 기본 클래스의 멤버만 접근할 수 있다. 업 캐스팅는 명시적 타입 변환이 필요 없다.Base* pBase = (Base*)pDerived; // (Base*) 생략 가능다운 캐스팅 부모 클래스 포인터가 가리키는 객체를 자식 클래스의 포인터로 가리키는 것을 다운캐스팅이라고 한다. 다운 캐스팅은 업 캐스팅과 달리 명시적으로 타입 변환을 지정해야 한다. Derived temp;Derived* pDer;Base* pBase = &amp;temp; // 업캐스팅pDerived = (Derived*)pBase; // 다운 캐스팅. 강제 타입 변환 필요 pBase 포인터는 부모 클래스의 public 멤버만 접근가능 pDer 포인터는 객체 temp의 모든 public 멤버 접근가능다운캐스팅시 주의 해야 하는 상황Derived* pDer;Base *pBase , po;pBase = &amp;po;pDer = (Derived*)pBase;pDer-&gt;DerivedFunction(); // 에러 발생 , DerivedFunction()은 Derived의 멤버함수이므로 컴파일 오류는 없음 pDer은 Derived 클래스의 객체이므로 Derived 클래스의 함수를 사용할 수 있지만, po는 부모 클래스 타입이므로 pDer이 가리키는 객체 공간 (po) 에는 DerivedFunction()함수가 없어 실행중에 오류가 발생하여 비정상 종료가 된다.슬라이싱(Slicing) 객체를 부모 클래스 타입으로 캐스팅하거나 대입할 수 있다. 그럴 경우 슬라이싱(자식 클래스의 특성이 사라짐)이 발생한다. Base myBase = myDerived; // 슬라이싱 발생 Base 객체는 Derived 클래스의 정의된 부가기능이 없기 때문에 슬라이싱이 발생Base&amp; myBase = myDerived; // 슬라이싱이 발생하지 않음 하지만 자식 클래스타입의 객체를 부모 클래스 타입의 포인터나 레퍼런스로 대입하면 슬라이싱이 발생하지 않음" }, { "title": "생성자와 소멸자 호출순서", "url": "/posts/%EC%83%9D%EC%84%B1%EC%9E%90%EC%99%80_%EC%86%8C%EB%A9%B8%EC%9E%90%EC%9D%98_%ED%98%B8%EC%B6%9C%EC%88%9C%EC%84%9C/", "categories": "C++", "tags": "C++", "date": "2022-09-09 00:00:00 +0900", "snippet": "자식 클래스와 부모 클래스의 생성자 자식 클래스 객체가 생성되면 자식과 부모 클래스의 생성자와 소멸자가 전부 호출된다.생성자 호출 및 실행 순서 여기서 말하는 호출은 함수가 호출되는 그 시점을 의미 실행은 멤버 변수 초기화를 실행한다는 의미 순서 자식 클래스의 객체가 생성될 때 자식 클래스의 생성자가 호출된다. 자식 클래스의 이니셜라이저 안에 묵시적으로 실행되는 부모 클래스의 생성자가 호출된다. 만약 자식 생성자 이니셜라이저에 명시적으로 멤버 변수 뒤에 부모 클래스 생성자를 호출해도 부모 클래스 생성자가 먼저 실행된다. 부모 클래스의 생성자가 호출되면 부모 클래스의 생성자 안에 있는 코드를 모두 실행하고 난 후에 자식 클래스 생성자로 돌아간다. 그 다음 자식 클래스 생성자의 코드가 전부 실행된다. 결론 생성자의 호출 순서는 자식 -&gt; 부모 생성자의 실행 순서는 부모 -&gt; 자식 소멸자 호출 및 실행 순서 소멸자는 생성자와 달리 부모 클래스로 올라가지 않고 자식 클래스에서 호출이 되고 나면 실행까지 마치고 나서 부모 클래스의 소멸자로 넘어간다. 순서 자식 클래스의 객체가 소멸될 때 자식 클래스의 소멸자가 호출된다. 자식 클래스의 소멸자가 호출되면 실행까지 마치고 그 다음에 부모 클래스의 소멸자로 넘어간다. 부모 클래스의 소멸자도 호출되면 그 뒤에 바로 실행한다. 결론 소멸자의 호출 순서는 자식 -&gt; 부모 소멸자의 실행 순서는 자식 -&gt; 부모 예시class A {public: A() { cout &lt;&lt; \"생성자 A\" &lt;&lt; endl; } ~A() { cout &lt;&lt; \"소멸자 A\" &lt;&lt; endl; }};class B : public A{public: B() { cout &lt;&lt; \"생성자 B\" &lt;&lt; endl; } ~B() { cout &lt;&lt; \"소멸자 B\" &lt;&lt; endl; }};class C : public B{public: C() { cout &lt;&lt; \"생성자 C\" &lt;&lt; endl; } ~C() { cout &lt;&lt; \"소멸자 C\" &lt;&lt; endl; }};int main(){ C c; }/*실행 결과생성자 A생성자 B생성자 C소멸자 C소멸자 B소멸자 A*/" }, { "title": "그림자", "url": "/posts/%EA%B7%B8%EB%A6%BC%EC%9E%90/", "categories": "DirectX3D", "tags": "directx3d", "date": "2022-09-07 00:00:00 +0900", "snippet": "그림자 광원 시점에서의 렌더 타겟과 카메라 시점에서의 렌더 타겟의 깊이를 비교하여 그림자를 판정한다. 일반적으로 Directinal Light의 광원에 그림자를 적용시킨다. Point Light는 Point Light의 6면(상하좌우앞뒤)를 체크해야 하기 때문에 연산이 매우 큼. Spot Light는 Directional Light와 달리 직교 투영이 아닌 원근 투영으로 VolumeMesh를 사용해 적용 원리 카메라 시점과 광원 시점에서의 깊이값을 비교하여 그림자를 판정한다 만약 깊이값이 다르다면 광원 시점에서 바라본 것과 카메라 시점에서 바라 본 것이 달라진다는 뜻이다. 어떤 오브젝트 사이에 다른 오브젝트가 끼어있었다면 깊이값이 달라짐 과정 먼저 광원 오브젝트 안에 있는 카메라를 이용하여 ShadowMap 렌더타겟에 픽셀값을 저장한다. 깊이 텍스쳐를 사용하지 않은 이유는 깊이 텍스쳐는 ShaderResource나 RenderTarget과 공유가 안되기 때문에 다른 쉐이더에서 사용하지 못하기 때문에 렌더타겟에 저장해서 사용함. 그래서 리소스로써 넘기기 위해서 깊이 텍스쳐가 아닌 렌더타겟을 사용해서 넘긴다. 여기서 깊이 텍스쳐는 픽셀의 깊이값을 비교하여 깊이 판정만 한다. 그 후에 광원을 렌더링할 때 ShadowMap에 있는 렌더타겟과 광원 카메라의 View,Proj 행렬을 가져온다. 메인 카메라의 Proj행렬 상태에서 역행렬을 곱해 World 행렬까지 보내고, 광원 카메라의 View ,Proj 행렬을 통해 광원 카메라로 보낸다. ShadowMap과 카메라 시점에서의 깊이값을 비교하고 카메라 시점에서의 깊이가 더 멀다면, 그림자 판정 그 후에 Merge Shader에서 그림자값을 받아서 그림자 진 부분은 빛을 약하게 비춘다.ShadowMap MRT 생성 ShadowMap은 화면 해상도와 같을 필요가 없기 때문에 크기를 크게 잡는다. 렌더 타겟에 깊이값을 저장하기 위해 R32_FLOAT을 사용// =============// ShadowMap MRT// ============={\tPtr&lt;CTexture&gt; arrTex[8] =\t{\t\tCResMgr::GetInst()-&gt;CreateTexture(L\"ShadowMapTex\" , 4096, 4096\t\t\t, DXGI_FORMAT_R32_FLOAT, D3D11_BIND_RENDER_TARGET | D3D11_BIND_SHADER_RESOURCE, true),\t};\t// Depth Stencil Texture 만들기\tPtr&lt;CTexture&gt; pDepthStencilTex = CResMgr::GetInst()-&gt;CreateTexture(L\"ShadowMapDSTex\", 4096, 4096\t\t, DXGI_FORMAT_D32_FLOAT, D3D11_BIND_DEPTH_STENCIL, true);\tm_arrMRT[(UINT)MRT_TYPE::SHADOWMAP] = new CMRT;\tm_arrMRT[(UINT)MRT_TYPE::SHADOWMAP]-&gt;Create(1, arrTex, pDepthStencilTex);}ShadowMap Shader // =============== // ShdowMap Shader // MRT : ShadowMap MRT // RS : CULL_BACK // BS : Default // DS : Less // =============== struct VS_SHADOW_IN { float3 vPos : POSITION; }; struct VS_SHADOW_OUT { float4 vPosition : SV_Position; float4 vProjPos : POSITION; }; VS_SHADOW_OUT VS_ShadowMap(VS_SHADOW_IN _in) { VS_SHADOW_OUT output = (VS_SHADOW_OUT) 0.f; output.vPosition = mul(float4(_in.vPos, 1.f), g_matWVP); output.vProjPos = output.vPosition; return output; } float PS_ShadowMap(VS_SHADOW_OUT _in) : SV_Target { float fOut = 0.f; fOut = _in.vProjPos.z / _in.vProjPos.w; return fOut; }Directioanl Light // ======================== // Directional Light Shader // MRT : Light // mesh : RectMesh // RS : CULL_BACK // DS : NO_TEST_NO_WRITE // BS : ONE_ONE #define LightIdx g_int_0 #define PositionTarget g_tex_0 #define NormalTarget g_tex_1 #define ShadowMap g_tex_2 #define LightVP g_mat_0 // ======================== struct VS_DIR_IN { float3 vPos : POSITION; }; struct VS_DIR_OUT { float4 vPosition : SV_Position; }; VS_DIR_OUT VS_Directional(VS_DIR_IN _in) { VS_DIR_OUT output = (VS_DIR_OUT) 0.f; output.vPosition = float4(_in.vPos * 2.f, 1.f); return output; } struct PS_DIR_OUT { float4 vDiffuse : SV_Target0; float4 vSpecular : SV_Target1; float4 vShadowPow : SV_Target2; }; PS_DIR_OUT PS_Directional(VS_DIR_OUT _in) { PS_DIR_OUT output = (PS_DIR_OUT) 0.f; float2 vUV = _in.vPosition.xy / vResolution.xy; float3 vViewPos = PositionTarget.Sample(g_sam_0, vUV).xyz; float3 vViewNormal = NormalTarget.Sample(g_sam_0, vUV).xyz; float fShadowPow = 0.f; // 물체가 그려지지 않은 영역은 빛을 받을 수 없다. if (vViewPos.z == 0.f) clip(-1); tLightColor color = (tLightColor) 0.f; CalculateLight3D(vViewPos, vViewNormal, LightIdx, color); // 그림자 판정 // ViewPos -&gt; WorldPos float3 vWorldPos = mul(float4(vViewPos, 1.f), g_matViewInv).xyz; // WorldPos -&gt; Light 투영 float4 vLightProj = mul(float4(vWorldPos, 1.f), LightVP); // w 로 나눠서 실제 xy 투영좌표를 구함 vLightProj.xyz /= vLightProj.w; // 샘플링을 하기 위해서 투영좌표계를 UV 좌표계로 변환 float2 vShadowMapUV = float2((vLightProj.x / 2.f) + 0.5f, -(vLightProj.y / 2.f) + 0.5f); float fShadowMapDepth = ShadowMap.Sample(g_sam_0, vShadowMapUV).r; // 광원에 기록된 깊이보다, 물체의 깊이가 더 멀 때, 그림자 판정 if (vLightProj.z &gt;= fShadowMapDepth + 0.00001f) { fShadowPow = 0.9f; } output.vDiffuse = (color.vDiff + color.vAmb); output.vSpecular = color.vSpec; output.vShadowPow = fShadowPow; output.vDiffuse.a = 1.f; output.vSpecular.a = 1.f; output.vShadowPow.a = 1.f; return output; }Merge Shader // ============================== // Merge Shader // Mesh : RectMesh #define ColorTarget g_tex_0 #define DiffuseTarget g_tex_1 #define SpecularTarget g_tex_2 #define ShadowPowTarget g_tex_3 // ============================== struct VS_MERGE_IN { float3 vPos : POSITION; }; struct VS_MERGE_OUT { float4 vPosition : SV_Position; }; VS_MERGE_OUT VS_Merge(VS_MERGE_IN _in) { VS_MERGE_OUT output = (VS_MERGE_OUT) 0.f; output.vPosition = float4(_in.vPos * 2.f, 1.f); return output; } float4 PS_Merge(VS_MERGE_OUT _in) : SV_Target0 { float4 vOutColor = (float4) 0.f; float2 vUV = _in.vPosition.xy / vResolution.xy; float3 vColor = ColorTarget.Sample(g_sam_0, vUV).xyz; float3 vDiffuse = DiffuseTarget.Sample(g_sam_0, vUV).xyz; float3 vSpecular = SpecularTarget.Sample(g_sam_0, vUV).xyz; float fShadowPow = ShadowPowTarget.Sample(g_sam_0, vUV).x; vOutColor = float4(vColor * vDiffuse * (1.f - fShadowPow) + vSpecular * (1.f - fShadowPow), 1.f); return vOutColor; }" }, { "title": "회전 행렬 분해 함수", "url": "/posts/%ED%9A%8C%EC%A0%84%ED%96%89%EB%A0%AC%EB%B6%84%ED%95%B4%ED%95%A8%EC%88%98/", "categories": "DirectX3D", "tags": "directx3d", "date": "2022-09-06 00:00:00 +0900", "snippet": "회전 행렬 분해 함수 Vec3 DecomposeRotMat(const Matrix&amp; _matRot) { // _mat 을 분해 후 다시 행렬 만들기\t Vec4 vMat[4]; vMat[0] = Vec4(_matRot._11, _matRot._12, _matRot._13, _matRot._14); vMat[1] = Vec4(_matRot._21, _matRot._22, _matRot._23, _matRot._24); vMat[2] = Vec4(_matRot._31, _matRot._32, _matRot._33, _matRot._34); vMat[3] = Vec4(_matRot._41, _matRot._42, _matRot._43, _matRot._44); /*XMStoreFloat4(&amp;vMat[0], _matRot._11); XMStoreFloat4(&amp;vMat[1], _matRot.r[1]); XMStoreFloat4(&amp;vMat[2], _matRot.r[2]); XMStoreFloat4(&amp;vMat[3], _matRot.r[3]);*/ Vec3 vNewRot; if (closeEnough(vMat[0].z, -1.0f)) { float x = 0; //gimbal lock, value of x doesn't matter float y = XM_PI / 2; float z = x + atan2f(vMat[1].x, vMat[2].x); vNewRot = Vec3{ x, y, z }; } else if (closeEnough(vMat[0].z, 1.0f)) { float x = 0; float y = -XM_PI / 2; float z = -x + atan2f(-vMat[1].x, -vMat[2].x); vNewRot = Vec3{ x, y, z }; } else { //two solutions exist float y1 = -asinf(vMat[0].z); float y2 = XM_PI - y1; float x1 = atan2f(vMat[1].z / cosf(y1), vMat[2].z / cosf(y1)); float x2 = atan2f(vMat[1].z / cosf(y2), vMat[2].z / cosf(y2)); float z1 = atan2f(vMat[0].y / cosf(y1), vMat[0].x / cosf(y1)); float z2 = atan2f(vMat[0].y / cosf(y2), vMat[0].x / cosf(y2)); //choose one solution to return //for example the \"shortest\" rotation if ((std::abs(x1) + std::abs(y1) + std::abs(z1)) &lt;= (std::abs(x2) + std::abs(y2) + std::abs(z2))) { vNewRot = Vec3{ x1, y1, z1 }; } else { vNewRot = Vec3{ x2, y2, z2 }; } } return vNewRot; }" }, { "title": "상속의 종류", "url": "/posts/%EC%83%81%EC%86%8D%EC%9D%98-%EC%A2%85%EB%A5%98/", "categories": "C++", "tags": "C++", "date": "2022-09-06 00:00:00 +0900", "snippet": "상속의 종류 상속을 이용하면 부모 클래스의 멤버들이 자식 클래스의 멤버로 확장할 때 기본 클래스 멤버의 접근 지정은 상속 조건에 따라 달라진다.예시 자식클래스(Derived)와 부모클래스(Base)를 이용한 확인// 부모 클래스class Base{private: int a;protected: int b;public: int c;} public 상속 부모 클래스를 public으로 받으면, 기본 클래스의 protected, public 멤버들은 접근 지정 변경 없이 자식 클래스에 그대로 상속 확장된다. // public 상속class Derived : public Base{ .... // Derived 멤버}// 상속후 Derived안에서의 Base 멤버 변수 접근지정 상태private: int a; // private은 그대로 privateprotected: int b; // protected는 public 상속에서는 그대로 protectedpublic: int c; // public은 public 상속에서는 그대로 public protected 상속 부모 클래스를 protected로 받으면, 부모 클래스의 protected, public 멤버들은 모두 protected 접근 지정으로 변경되어 자식 클래스에 상속 확장된다. // protected 상속class Derived : protected Base{ .... // Derived 멤버}// 상속후 Derived안에서의 Base 멤버 변수 접근지정 상태private: int a; // private은 그대로 privateprotected: int b; // protected는 protected 상속에서는 그대로 protected int c; // public은 protected으로 변경 private 상속 부모 클래스를 private으로 상속받으면 기본 클래스의 protected, public 멤버들은 모두 private 접근 지정으로 변경되어 자식 클래스에 상속 확장된다. // private 상속class Derived : private Base{ .... // Derived 멤버}// 상속후 Derived안에서의 Base 멤버 변수 접근지정 상태private: int a; // private은 그대로 private// protected와 public 멤버들은 private 상속에서 private으로 변경 int b; int c; 상속 접근 지정자가 생략되면 private 상속으로 처리한다class Derived : Base{...}; // 접근지정자 생략은 아래와 같이 private으로 자동으로 처리한다.class Derived : private Base{...};" }, { "title": "상속", "url": "/posts/%EC%83%81%EC%86%8D/", "categories": "C++", "tags": "C++", "date": "2022-08-31 00:00:00 +0900", "snippet": "상속 기존에 정의된 클래스를 바탕으로 새로운 클래스를 정의하여 재사용하거나 확장 가능한 컴포넌트로 만들 수 있다. 기존에 정의된 클래스는 상속한 클래스로 부모 클래스(혹은 기본 클래스)라고한다. 상속받아 새로 만들어진 클래스를 자식 클래스(혹은 파생 클래스)라고 한다. 예시 자식 클래스는 부모 클래스의 데이터 멤버와 함수를 물려받는다. 상속받을 클래스를 콜론(:) 뒤에 접근 지정자와 상속할 부모 클래스를 작성한다 class 자식클래스 : 접근지정자 부모클래스 만약 접근지정자가 없다면 private으로 상속된다. class Base{public: void someMethod();}class Derived : public Base // Base 클래스를 물려받은 Derived 클래스{public: void someOtherMethod();}void main(){ Derived myDerived; myDerived.someMethod(); // Base의 someMethod 함수 호출 myDerived.someOtherMethod(); // Derived의 someOtherMethod 함수 호출}상속은 반드시 한 방향으로만 진행 Derived 클래스는 Base 클래스를 알지만 Base 클래스를 정의하는 시점에서는 Derived를 모른다. 따라서 Base 타입 객체는 Derived 객체의 메서드나 데이터 멤버를 사용하지 못한다.Base myBase;myBase.someOtherMethod(); // 컴파일 에러, Base는 Derived에 접근 X부모 클래스의 private 멤버의 상속과 접근 부모 클래스의 private멤버도 자식 클래스에 상속되며, 자식 클래스의 객체가 생길 때 자식 클래스의 객체 내에 생성된다. 다만 private으로 선언된 부모클래스의 멤버는 부모 클래스의 다른 멤버에서만 접근이 가능하다.class MyClass {private: int m_Int;public: void SetInt(int _i) { m_Int = _i; } int GetInt() { return m_Int; }};class Derived : public MyClass{};int main(){ Derived A; A.SetInt(5); // 부모클래스의 m_Int는 private이지만 부모 클래스의 public 함수로 접근. cout&lt;&lt; A.GetInt();}상속의 목적과 장점(1) 간결한 클래스 작성 동일한 코드가 여러개 중복된다면 클래스의 유지보수가 번거롭다.class Student{public: void Walk(); void Eat(); void Study();}class Teacher{public: void Walk(); void Eat(); void Teach();} Student 클래스와 Teacher의 클래스에서 Walk와 Eat 함수가 중복된다. 클래스마다 공통기능을 묶어 사용한다면 클래스가 간결해진다. class Person{ public: void Walk(); void Eat();}class Student : public Person{ public: void Study();}class Teacher : public Person{ public: void Teach();}(2) 클래스 간의 계층적 분류 및 관리의 용이함 상속은 서로 관련된 클래스를 계층 관계로 표현함으로써 클래스의 구조적인 관계 파악이 쉽다.(3) 클래스 재사용과 확장을 통한 소프트웨어의 생산성 향상 상속의 가장 큰 장점은 소프트웨어의 생산성을 향상시킨다는 점이다. 상속을 이용하면 새로운 소프트웨어를 만드는 것이 아닌 기존의 클래스를 이용하여비슷한 소프트웨어를 만들거나 기존에서 기능을 추가한 소프트웨어를 만들 수 있다." }, { "title": "이동 의미론 및 이동 생성자", "url": "/posts/%EC%9D%B4%EB%8F%99-%EC%9D%98%EB%AF%B8%EB%A1%A0-%EB%B0%8F-%EC%9D%B4%EB%8F%99-%EC%83%9D%EC%84%B1%EC%9E%90/", "categories": "C++", "tags": "C++", "date": "2022-08-30 00:00:00 +0900", "snippet": "이동의미론으로 이동 처리하기 객체에 이동 의미론을 적용하려면 이동 생성자와 이동 대입 연산자를 정의해야 한다. 그러면 컴파일러는 원본 객체를 임시 객체로 만들어서 대입 연산을 수행한 뒤 임시 객체를 제거한다. 이 과정에서 이동 생성자와 이동 대입 연산자를 활용 이동 생성자와 이동 대입 연산자는 원본 객체에 있는 데이터 멤버를 새 객체로 이동시키기 때문에 원본 객체는 정상적이지만 미확정된 상태로 남게된다. 이러한 원본 객체의 데이터 멤버는 대부분 널 값으로 초기화된다. 이렇게 함으로써 메모리를 비롯한 리소스의 소유권을 다른 객체로 “이동”시킨다. 이 과정은 멤버 변수애 대한 얕은 복제와 비슷하다. 또한 할당된 메모리나 다른 리소스에 대한 소유권을 전환함으로써 댕글링 포인터나 메모리 누수를 방지한다.이동 의미론 구현 방법 이동 생성자와 이동 대입 연산자 구현 이동 생성자와 이동 대입 연산자를 noexcept로 지정해서 두 메서드에서 익셉션이 절대로 발생하지 않는다고 컴파일에 알려줘야 한다. 특히 표준라이브러리와 호환성을 유지하려면 반드시 이렇게 해야 한다. class Spreadsheet{ public: Spreadsheet(Spreadsheet&amp;&amp; src) noexcept; // 이동 생성자 Spreadsheet&amp; operator=(Spreadsheet&amp;&amp; rhs) noexcept; // 이동 대입 연산자 private: void cleanup() noexcept; // 소멸자와 이동 대입 연산자에서 사용 // 원본 객체의 멤버 변수를 대상 객체로 이동시킨 뒤 원본 객체를 리셋 void moveFrom(Spreadsheet&amp; src) noexcept; // 나머지 코드 생략}void Spreadsheet::cleanup noexcept{ for(size_t i = 0; i&lt; mWidth; i++) { delete[] mCells[i]; } delete[] mCells; mCells = nullptr; mWidth = mHeight = 0;}void Spreadsheet::moveFrom(Spreadsheet&amp; src) noexcept{ // 데이터에 대한 얕은 복제 mWidth = src.mWidth; // float mHeight = src.mHeight; // float mCells = src.mCells; // 포인터 변수 // 소유권이 이전됐기 때문에 소스 객체를 리셋한다. src.mWidth = 0; src.mHeight = 0; // 포인터 변수는 새로운 객체(src)의 포인터 변수에 주소를 옮기고 // 원본 객체(*this)에서는 주소를 nullptr로 지정 src.mCells = nullptr; }// 이동 생성자Spreadsheet::Spreadsheet(Spreadsheet&amp;&amp; src) noexcept{ moveFrom(src);}// 이동 대입 연산자Spreadsheet&amp; Spreadsheet::operator=(Spreadsheet&amp;&amp; rhs) noexcept{ // 자기 자신을 대입하는지 확인 if(this == &amp;rhs) { return *this; } cleanup(); moveFrom(rhs); return *this;} 이동 생성자와 이동 대입 연산자는 모두 mCells에 대한 메모리 소유권을 원본 객체에서 새로운 객체로 이동한다. 그리고 원본 객체의 소멸자가 이 메모리를 해제하지 않도록 원본 객체의 mCells 포인터를 널 포인터로 리셋한다. 이 시점에는 이미 메모리에 대한 소유권이 새 객체로 이동했기 때문 이동 생성자와 이동 대입 연산자도 일반 생성자와 복제 대입 연산자와 마찬가지로 명시적으로 삭제하거나 디폴트를 만들 수 있다. 클래스에 복제 생성자, 복제 대입 연산자, 이동 대입 연산자, 소멸자를 직접 선언하지 않았다면 컴파일러가 디폴트 이동 생성자를 만들어준다. 클래스에 복제 생성자, 이동 생성자,복제 대입 연산자, 소멸자를 직접 선언하지 않았다면 컴파일러는 디폴트 이동 대입 연산자를 만들어 준다. 클래스에 동적할당 메모리를 사용하는 코드를 작성했다면소멸자,복제 생성자, 이동 생성자, 복제 대입 연산자,이동 대입 연산자를 반드시 구현한다.이를 5의 규칙(Rule of Five)이라 부른다.객체 데이터 멤버 이동하기 데이터 멤버가 객체라면 std::move로 이를 객체로 이동시켜야 한다. Spreadsheet 클래스에 mName이란 이름의 std::string타입 데이터 멤버가 있다고 가정한다면 다음과 같이 구현한다. void Spreadsheet::moveFrom(Spreadsheet&amp; src) noexcept{ mName = std::move(src.mName); // 나머지 코드 생략} std::move 함수는 이동을 수행하지 않는다. 그냥 인자로 받은 객체를 우측값으로 변환할 뿐이다.swap() 함수로 구현한 이동 생성자와 이동 대입 연산자 데이터 멤버를 얕은 복제로 이동시키는 작업을 moveFrom() 헬퍼 메서드로 처리했다. 이렇게 구현하면 Spreadsheet 클래스에 데이터 멤버를 추가할 때마다 swap()함수와 moveFrom()메서드를 동시에 수정해야 한다. 하나라도 수정하지 않으면 버그가 발생한다. 이런 버그가 발생하지 않게 이동 생성자와 이동 대입 연산자를 디폴트 생성자와 swap() 함수로 구현한다. class Spreadsheet{ private: Spreadsheet() = default; // 직접 사용할 일이 없기 때문에 private로 지정 // 나머지 코드 생략}// 이동 생성자Spreadsheet::Spreadsheet(Spreadsheet&amp;&amp; src) noexcept : Spreadsheet() // 디폴트 생성자에 작업을 위임{ swap(*this,src);}// 이동 대입 연산자Spreadsheet&amp; Spreadsheet::operator=(Spreadsheet&amp;&amp; rhs) noexcept{ Spreadsheet temp(std::move(rhs)); swap(*this, temp); return *this;} 이동 생성자 과정 이동 생성자는 먼저 디폴트 생성자에 작업을 위임한다. 그런 다음 디폴트 생성자가 만든 *this를 원본 객체와 맞바꾼다. 이동 대입 연산자 과정 이동 대입 연산자는 먼저 rhs로 이동 생성해서 Spreadsheet에 대한 로컬 인스턴스를 만든다. 그러고 나서 이동 생성된 로컬 Spreadsheet 인스턴스를 *this로 맞바꾼다. 이동 생성자와 이동 대입연산자를 디폴트 생성자와 swap()함수로 구현하면 moveFrom()으로 구현했던 것보다 효율성이 떨어지지만 코드가 줄고, 클래스에 데이터 멤버를 새로 추가할 때 swap()만 수정하면 되기 때문에 버그 발생 확률을 낮출 수 있다는 장점이 있다.이동 의미론으로 swap 함수 구현하기 이동 의미론으로 성능을 높이는 예제로 두 객체를 스왑하는 함수 구현// 이동 의미론 적용 Xvoid swapCopy(T&amp; a, T&amp; b){ T temp(a); a = b; b = temp;} 먼저 a를 temp에 복제한 뒤, b를 a에 복제하고, 마지막으로 temp를 b에 복제한다. 만약 T가 복제하기에 상당히 무거우면 성능이 크게 떨어진다. 이럴 때 이동 의미론을 적용해서 복제가 발생하지 않도록 구현한다. // 이동 의미론 적용 O// 표준 라이브러리의 std::swap이 이렇게 구현됨void swapCopy(T&amp; a, T&amp; b){ T temp(std::move(a)); a = std::move(b); b = std::move(temp);}0의 규칙 0의 규칙이란 다섯 가지 특수 멤버 함수를 구현할 필요가 없도록 클래스를 디자인해야 한다는 것이다. 특수 멤버 함수란 C++ 이 스스로 작성하는 멤버 함수들을 가리킨다 소멸자,복제 생성자, 이동 생성자, 복제 대입 연산자,이동 대입 연산자 이렇게 하려면 먼저 예전 방식대로 메모리를 동적으로 할당하지 말고 표준 라이브 컨테이너와 같은 최신 구문을 활용해야 한다. ex) Spreadsheet 클래스는 SpreadsheetCell** 대신 vector&lt;vector&lt;SpreadsheetCell&gt;&gt;을 사용한다. 벡터는 메모리를 자동으로 관리하기 때문에 다섯가지 특수 멤버 함수가 필요없다. " }, { "title": "우측값", "url": "/posts/%EC%9A%B0%EC%B8%A1%EA%B0%92/", "categories": "C++", "tags": "C++", "date": "2022-08-30 00:00:00 +0900", "snippet": "우측값 C++에서 좌측값(lvalue)은 변수처럼 이름과 주소를 가진 대상 대입문에서 왼쪽에서 나온다고 해서 좌측값이라 부른다. 우측값(rvalue)은 리터럴,임시객체,값처럼 좌측값이 아닌 모든 대상을 의미한다. 일반적으로 우측값은 대입문의 오른쪽에 나온다 int a = 4 * 2; a는 좌측값 4 * 2 는 우측값 우측값은 임시값이라서 문장이 실행되고 나면 제거된다. 임시 변수에 있는 값의 복사본을 a란 이름의 변수에 저장한다.우측값 레퍼런스 우측값 레퍼런스 우측값이 임시 객체일 때 적용되는 개념 임시 객체에 대해 적용할 함수를 컴파일러가 선택하기 위한 용도로 사용한다. 우측값 레퍼런스로 구현하면 크기가 큰 값(객체)을 복사하는 연산이 나오더라도 컴파일러는 나중에 삭제될 임시 객체라는 점을 이용해 그 값에 우측값에 대한 포인터를 복사하는 방식으로 실행할 수 있다. 함수의 매개변수에 &amp;&amp;를 붙여 우측값 레퍼런스로 만들 수 있다. 일반적으로 임시객체는 const type&amp;로 취급하지만 함수 오버로딩 버전중에서 우측값 레퍼런스를 사용하는 것이 있다면 그 버전으로 임시 객체를 처리한다. void handleMessage(std::string&amp; message) { cout&lt;&lt; \"handleMessage with lvalue reference: \" &lt;&lt; message &lt;&lt; endl; } void handleMessage(std::string&amp;&amp; message) { cout&lt;&lt; \"handleMessage with rvalue reference: \" &lt;&lt; message &lt;&lt; endl; } /// std::string a = \"Hello\"; std::string b = \"World\"; handleMessage(a); // a는 변수이므로 handleMessage(std::string&amp; message) 호출 handleMessage(a+b); // a+b라는 임시 변수이므로 handleMessage(std::string&amp;&amp;message) 호출 여기서 좌측값 레퍼런스를 받는 handleMessage()함수를 삭제한 뒤 handleMessage(b)처럼 이름 있는 변수를 전달해서 호출하면 컴파일 에러가 발생한다. 이때 좌측값을 우측값으로 캐스팅하는 std::move()를 사용하면 컴파일러가 우측값 레퍼런스 버전의 handleMessage()를 호출하게 만들 수 있다. handleMessage(std::move(b)); //handleMessage(string&amp;&amp; value)를 호출 handleMessage() 함수 안에 우측값 레퍼런스 타입인 message 매개변수 자체는 이름이 있기 때문에 좌측값이다. 이처럼 타입이 우측값 레퍼런스인 매개변수를 다른 함수에 우측값으로 전달하려면 std::move()을 이용하여 좌측값을 우측값으로 캐스팅해야 한다. void helper(std::string&amp;&amp; message){ ...}void handleMessage(std::string&amp;&amp; message){ // 우측값 레퍼런스로 들어온 message는 이름있는 \"좌측값\"으로 들어온다 // 그렇기 때문에 우측값 레퍼런스를 받는 helper에 그대로 전달하면 컴파일 에러가 발생한다. // helper(message); // 좌측값인 message를 우측값으로 캐스팅하기 위해 std::move를 사용한다. helper(std::move(message));} 함수의 매개변수 말고도 변수를 우측값 레퍼런스 타입으로 선언해서 값을 할당할 수도 있다.// 에러int&amp; i = 2; // 에러 : 상수에 대한 레퍼런스int a = 2, b = 3;int&amp; j = a + b; // 에러 : 임시 객체에 대한 레퍼런스// 성공int&amp;&amp; i = 2;int a = 2, b = 3;int&amp;&amp; j = a + b;" }, { "title": "복사 생성자", "url": "/posts/%EB%B3%B5%EC%82%AC%EC%83%9D%EC%84%B1%EC%9E%90/", "categories": "C++", "tags": "C++", "date": "2022-08-29 00:00:00 +0900", "snippet": "복사 생성자 한 객체를 다른 객체로 복사하는 생성자. 복사 생성자의 매개변수는 오직 하나이며 자기 클래스에 대한 참조로 선언된다. 복사 생성자가 정의되지 않았다면 디폴트 복사 생성자가 생성된다. 복사 생성자에는 얕은 복사와 깊은 복사가 있다. 예시 복사 생성자 선언 및 구현class Circle{private: int radius;public: Circle(const Circle&amp; c); // 복사 생성자 선언 Circle() { radius = 1; } Circle(int radius) { this-&gt;radius = radius;} double getArea() { return 3.14*radius*radius; }};Circle::Circle(const Circle&amp; c){ // 복사 생성자 구현 this-&gt;radius = c.radius; cout &lt;&lt; \"복사 생성자 실행 radius = \" &lt;&lt; radius &lt;&lt; endl;}int main(){ Circle src(30); // src 객체의 Circle(int radius) 생성자 호출 Circle dest(src); // dest 객체의 Circle(const Circle&amp; c) 복사 생성자 호출 cout &lt;&lt; \" 원본의 면적 = \" &lt;&lt; src.getArea() &lt;&lt; endl; cout &lt;&lt; \" 사본의 면적 = \" &lt;&lt; dest.getArea() &lt;&lt; endl;} 디폴트 복사 생성자class Circle{ int radius;public: Circle(int r); double getArea();};/* 디폴트 복사 생성자가 없어도 컴파일러가 자동 생성Circle::Circle(const Circle&amp; c){ // 디폴트 복사 생성자 this-&gt;radius = c.radius; // 원본 객체 c의 각 멤버를 사본(this)에 복사한다.}*/int main(){ Circle src(30); Circle dest(src); // 디폴트 복사 생성자 호출} 디폴트 복사 생성자는 얕은 복사를 실행. 얕은 복사는 원본 객체의 모든 멤버를 일대일로 사본에 복사하는 구성 얕은 복사의 문제점 포인터 타입의 멤버 변수가 없는 클래스의 경우, 얕은 복사는 문제가 생기지 않는다. 모든 멤버 변수를 일대일로 복사해도 공유의 문제가 발생하지 않기 때문 포인터 타입의 멤버 변수가 있는 클래스의 경우, 얕은 복사는 심각한 문제가 생긴다. 원본 객체의 포인터 멤버가 사본 객체의 포인터 멤버에 복사되어 같은 메모리(주소)를 가지기 때문 class Person{ char* name; int id;public: Person(int id, const char* name); Person(const Person&amp; p); ~Person(); void changeName(const char* name);}Person::Person(int id, const char* name){ // 생성자 this-&gt;id = id; int len = strlen(name); this-&gt;name = new char[len+1]; strcpy(this-&gt;name,name);}Person::Person(const Person&amp; p){ // 복사 생성자 (얕은 복사) this-&gt;id = p.id; this-&gt;name = p.name;}void Person::changeName(const char* name){ //이름 변경 함수 if(strlen(name) &gt; strlen(this-&gt;name)) return; strcpy(this-&gt;name,name);}Person::~Person(){ //소멸자 if(name) // name이 동적할당 되어 있다면 delete [] name; // 동적 할당 메모리 소멸}int main(){ Person father(1, \"Kitae\"); Person daughter(father); // 복사 생성자 호출 dauther.changeName(\"Grace\"); // father의 name과 daughter의 name은 Grace로 변경} // main이 끝나고 나서 프로그램 비정상 종료 위에서 얕은 복사의 문제점은 father과 daughter의 name이 서로 같은 주소를 참조하기 때문이다. 문제점으로 인한 결과 같은 주소를 참조함으로써 changeName 함수를 호출하면 서로 같은 이름으로 변경된다. 그뿐만 아니라 소멸자에서 동적할당된 name을 daughter에서 해제하고 father의 name이 같은 주소를 참조하고 있어서 해제된 메모리를 한번 더 해제하기 때문에 프로그램이 비정상 종료가 된다. 깊은 복사 얕은 복사와 다른 점은 클래스의 포인터 멤버만 따로 동적할당해준다.class Person{ char* name; int id;public: Person(int id, const char* name); Person(const Person&amp; p); ~Person(); void changeName(const char* name);}Person::Person(int id, const char* name){ // 생성자 this-&gt;id = id; int len = strlen(name); this-&gt;name = new char[len+1]; strcpy(this-&gt;name,name);}Person::Person(const Person&amp; p){ // 복사 생성자 (깊은 복사) this-&gt;id = p.id; int len = strlen(p.name); this-&gt;name = new char [len+1]; strcpy(this-&gt;name, p.name);}void Person::changeName(const char* name){ //이름 변경 함수 if(strlen(name) &gt; strlen(this-&gt;name)) return; strcpy(this-&gt;name,name);}Person::~Person(){ //소멸자 if(name) // name이 동적할당 되어 있다면 delete [] name; // 동적 할당 메모리 소멸}int main(){ Person father(1, \"Kitae\"); Person daughter(father); dauther.changeName(\"Grace\"); // father의 name은 Kitae, daughter의 name은 Grace} // 프로그램 정상 종료 깊은 복사 생성자에서 daughter의 name은 메모리를 새로 동적할당하고 father의 name의 주소가 아닌 값을 복사함. father과 daughter의 name은 서로 다른 메모리를 참조하고 있어서 main함수가 끝나도서로 다른 메모리를 삭제하기 때문에 정상 종료묵시적 복사 생성자 위에서는 명시적으로 복사 생성자를 선언하여 사용했지만 묵시적으로 복사생성자가 호출되는 경우도 있다.(1) 객체가 초기화 하여 객체가 생성될 때// 대입 연산자가 아닌 복사 생성자 호출Person son = father; // 컴파일러가 다음과 같이 변환하여 호출Person son(father); // 초기화 하지않고 대입연산을 하면 복사생성자 호출 XPerson son;son = father; // 복사 생성자가 호출되지 않음(2) ‘값에 의한 호출’로 객체가 전달될 때 함수의 매개 변수 객체가 생성될 때 복사생성자가 자동 호출void f(Person person){ // 매개변수 person이 생성될 때 복사생성자 호출 .....}Person father(1,\"Kitae\");f(father); // '값에 의한 호출'로 father 객체 전달(3)함수가 객체를 리턴할 때 함수가 객체를 리턴할 때, return문은 리턴 객체의 복사본을 생성하여 호출한 곳으로 전달Person g(){ Person mother(2, \"Jane\"); // mother의 복사본을 생성하여 복사본 리턴. 사본이 만들어 질때 복사본 호출 return mother; }" }, { "title": "this", "url": "/posts/this/", "categories": "C++", "tags": "C++", "date": "2022-08-28 00:00:00 +0900", "snippet": "this 객체 자신에 대한 포인터로서 클래스의 멤버 함수 내에서만 사용된다. this는 객체의 멤버 함수가 호출될 때, 컴파일러에 의해 보이지 않게 전달되는 객체에 대한 주소class Circle{ int radius;public: Circle() { this-&gt;radius = 1; } Circle(int radius) { this-&gt;radius = radius; } void SetRadius(int radius) { this-&gt;radius = radius; }}int main(){ Circle c1; Circle c2(2); Circle c3(3); c1.SetRadius(10); // 객체 c1의 radius를 10으로 변환 c2.SetRadius(20); // 객체 c2의 radius를 20으로 변환 c3.SetRadius(30); // 객체 c3의 radius를 30으로 변환}this가 필요한 경우필요하지 않은 경우———– 다음 생성자 함수의 경우 this-&gt;를 생략해도 된다.Circle() { this-&gt;radius = 1; }필요한 경우 멤버 변수의 이름과 동일한 이름으로 매개 변수 이름을 짓고자 하는 경우// 가능Circle(int radius){ this-&gt;radius = radius;}// 불가능Circle(int radius){ radius = radius;} 객체의 멤버 함수에서 객체 자신의 주소를 리턴할 때 보통 연산자 오퍼레이터를 구현할 때 많이 사용한다.class Sample{public: Sample* f(){ .... return this; // 현재 객체의 주소 리턴 }}this의 제약 조건 this는 클래스의 멤버 함수에서만 사용할 수 있다. 멤버가 아닌 함수에서는 this를 사용할 수 없다. 그 함수들은 어떤 객체에도 속하지 않기 때문 멤버 함수라도 정적(static) 멤버 함수는 this를 사용할 수 없다. 정적 멤버 함수는 객체가 생성되기 전에 호출될 수 있다.정적 멤버 함수가 실행되는 시점에서 현재 객체는 존재하지 않을 수 있기 때문이다. 컴파일러의 this 처리 this는 컴파일러에 의해 탄생하는 변수이다. 밑에 코드는 컴파일러가 this를 생성시키는 과정이다.// 개발자가 작성한 클래스class Sample{ int a;public: void SetA(int x){ this-&gt;a = x; }};// 컴파일러에 의해 변환된 클래스class Sample{ int a;public: void SetA(Sample* this, int x){ this-&gt;a = x; }};// Sample* this는 컴파일러에 의해 묵시적으로 삽입된 매개 변수 클래스를 컴파일할 때 모든 멤버 함수에 대해 컴파일러는 묵시적으로 this 매개변수를 삽입한다. 멤버 함수를 호출할 때도 컴파일러에 의해 변환된다.// ob의 주소가 this 매개변수에 전달Sample ob; Sample ob;ob.SetA(5); -----&gt; ob.SetA(&amp;ob,5); 마찬가지로 객체의 멤버 함수를 호출할 때도 컴파일러가 오른쪽과 같이 변환한다." }, { "title": "접근 지정자", "url": "/posts/%EC%A0%91%EA%B7%BC%EC%A7%80%EC%A0%95%EC%9E%90/", "categories": "C++", "tags": "C++", "date": "2022-08-27 00:00:00 +0900", "snippet": "접근지정자 클래스의 멤버를 어디까지 접근허용할지 구분시켜주는 키워드 종류 public 외부의 모든 접근을 허용 protected 클래스 내의 멤버와 이 클래스를 상속받은 자식 클래스의 멤버만 접근 허용 상속은 뒤에 작성. private 외부의 모든 접근을 허용하지 않음 내부의 멤버에서만 접근 가능 예시 접근 지정은 여러 번 사용될 수 있고 접근 지정자가 선언되면 다른 접근 지정자가 선언될 때까지 모든 멤버에 대해 적용한다.class Sample{ private: // private 멤버 변수 선언 public: // public 멤버 변수 선언 private: // private 멤버 변수 선언}; 디폴트 접근 지정자는 privateclass Circle{ int radius; // privatepublic: Circle(); ~Circle();};" }, { "title": "소멸자", "url": "/posts/%EC%86%8C%EB%A9%B8%EC%9E%90/", "categories": "C++", "tags": "C++", "date": "2022-08-26 00:00:00 +0900", "snippet": "소멸자 생성자와 형태는 같지만 앞에 ~를 붙인 함수를 소멸자라고 한다. 소멸자의 목적은 객체가 사라질 때 필요한 마무리 작업을 하기 위함이다. 생성자와 같이 리턴타입이 없고 어떤 값도 리턴해서는 안된다. 소멸자는 생성자와 달리 한 클래스에 한 개만 존재하며 매개변수를 가지지 않는다. 만약 클래스안에 소멸자가 없으면 컴파일러가 자동으로 디폴트 소멸자를 생성한다. 예시// MyClass.hclass MyClass {private: int m_iData;public: MyClass(int _i); // 생성자 ~MyClass(); // 소멸자};// MyClass.cppMyClass::MyClass(int _i) :m_iData(_i){}MyClass::~MyClass(){ cout &lt;&lt; m_iData &lt;&lt; endl;}int main(){ MyClass A(5); MyClass B(6);} // A와 B는 스택 객체들이므로 main이 끝나면서 B와 A의 소멸자가 호출되면서 6,5 출력 객체 a와 b는 블록이 끝나면 각 객체의 소멸자가 자동으로 호출된다. 객체가 삭제되는 순서는 선언 및 생성 순서와 반대이다. a, b가 순서대로 생성되고 main 함수가 끝나면 b, a 순으로 삭제된다 그러므로 b의 m_iData값인 6이 호출되고 그다음 a의 m_iData인 5가 호출된다. 소멸자에서 동적할당 삭제// MyClass.hclass MyClass {public: int* m_iData; // 동적할당할 int* 변수 int m_iLength; // 배열의 길이public: MyClass(int _i); ~MyClass();};// MyClass.cppMyClass::MyClass(int _i){ m_iLength = _i; m_iData = new int[m_iLength]; //m_iLengh만큼 동적할당}MyClass::~MyClass(){ for (int i = 0; i &lt; m_iLength; ++i) { cout &lt;&lt; m_iData[i] &lt;&lt; endl; // 소멸자가 호출될 때 출력 } delete[] m_iData; // 동적할당한 메모리 삭제}int main(){ MyClass A(5); // int 5개의 크기만큼 동적할당하고 순서대로 i값으로 초기화 for (int i = 0; i &lt; A.m_iLength; ++i) { A.m_iData[i] = i; }} // main이 끝나고 나서 A의 소멸자가 호출되면서 0,1,2,3,4 출력 클래스안에 동적할당한 멤버변수가 있다면 소멸자에서 delete 혹은 delete[]로 삭제할 수 있다." }, { "title": "생성자", "url": "/posts/%EC%83%9D%EC%84%B1%EC%9E%90/", "categories": "C++", "tags": "C++", "date": "2022-08-25 00:00:00 +0900", "snippet": "생성자 클래스와 이름이 같고 리턴 타입이 없는 함수를 생성자라고 한다. 객체가 생성되는 시점에 한 번만 자동으로 실행된다. 생성자의 목적은 객체가 생성될 때 필요한 초기작업을 위함 멤버변수의 값을 특정 값으로 설정 메모리를 동적할당하거나 생성되면서 실행해야 할 함수 네트워크를 연결 만약 클래스안에 생성자가 없으면 컴파일러가 자동으로 디폴트 생성자를 생성한다. 생성자도 접근지정자를 사용할 수 있다. 대부분의 경우, 다른 파일에서 이 클래스를 사용하기 위해 public으로 생성한다. 예시 생성자는 오버로딩을 이용하여 여러 생성자를 생성할 수 있다.// MyClass.hclass MyClass {public: int m_iData;public: MyClass(); // 디폴트 생성자 선언 MyClass(int _i) // int 인자를 받는 생성자 선언};// MyClass.cpp#include \"MyClass.h\"MyClass::MyClass() // 디폴트 생성자 구현{ m_iData = 1;}MyClass::MyClass(int _i) // int 인자를 받는 생성자 구현{ m_iData = _i; // 인자값을 받아서 멤버 변수를 초기화}생성자 이니셜라이저 생성자에서 콜론(:)을 이용하여 클래스의 멤버변수를 초기화한다 이때 세미콜론(;)는 사용하지 않는다. {} 또는 ()를 이용하여 배열은 모든 원소를 0(NULL)으로 초기화하고 포인터는 nullptr로 초기화할 수 있다.class MyClass {public: int m_iData; float m_fArr[5]; int* m_pData;public: MyClass(); // 디폴트 생성자 선언 // .h에서는 선언하고 .cpp에서 구현};// MyClass.cpp#include \"MyClass.h\"MyClass::MyClass() // 생성자 이니셜라이저 사용 : m_iData(1) // m_Data를 1로 생성 , m_fArr{} // m_fArr 배열을 0으로 초기화 , m_pData{} // 포인터는 nullptr로 초기화{}디폴트 생성자 디폴트 생성자란 매개 변수가 없는 생성자를 의미한다. 기본 생성자가 자동으로 생성되는 경우 생성자가 하나도 없는 클래스의 경우 컴파일러가 보이지 않게 자동으로 디폴트 생성자를 생성한다. 디폴트 생성자를 호출할 때는 ()를 빼고 호출해야한다. 만약 ()를 붙이고 호출한다면 함수의 호출로 판단함. // 밑의 Class는 생성자가 없지만 컴파일러가 자동으로 생성class MyClass { public: int m_Data;};int main(){ MyClass A; // 디폴트 생성자 호출 // MyClass A(); 디폴트 생성자를 호출할때는 ()를 사용하지 않는다.} 디폴트 생성자가 자동으로 생성되지 않을 경우 생성자가 하나라도 선언된 클래스의 경우 컴파일러는 생성자가 있으므로 자동으로 디폴트 생성자를 생성하지 않음. // 생성자가 있으므로 디폴트 생성자는 Xclass MyClass { public: int m_Data; MyClass(int _i) // 생성될 때 int인자를 받으면서 멤버변수로 초기화 { m_Data = _i; }};int main(){ // MyClass A; 디폴트 생성자가 없고 디폴트 생성자를 호출했으므로 컴파일 에러 MyClass A(1); // 생성될 때 int를 받는 생성자가 호출되면서 m_Data에 1를 넣는다.}명시적으로 삭제된 생성자 C++에서는 컴파일러가 디폴트를 생성자를 만들면 안될 경우에 명시적으로 삭제할 수 있다.class MyClass{ public: MyClass() = delete;}위임 생성자 중복된 초기화코드를 하나의 생성자로 몰고, 생성자에서 다른 생성자를 호출하는 생성자 C++11부터 지원Circle::Circle() : Circle(1) {} // Circle(int r)의 생성자 호출Circle::Circle(int r){ radius = r;} 객체의 초기화가 코딩된 Circle(int r)를 타겟 생성자라고 한다. Circle() 생성자는 객체의 초기화를 다른 생성자에 위임한다고 해서 위임 생성자라고 한다." }, { "title": "클래스", "url": "/posts/%ED%81%B4%EB%9E%98%EC%8A%A4/", "categories": "C++", "tags": "C++", "date": "2022-08-24 00:00:00 +0900", "snippet": "클래스 객체를 생성하기 위해 데이터(변수)와 기능(함수)를 포함하여 만든 일종의 틀 주로 선언하는 코드는 헤더파일(.h)에 작성하고 구현하는 코드는 소스 파일(.cpp)에 작성한다. 클래스는 자료형의 크기를 가져야 하기 때문에 멤버가 없어도 1byte를 가진다. 내부에 아무것도 없어도 메모리에 올려야 하기 때문에 최소단위 1byte로 잡힌다 클래스가 1byte면 내부에는 1byte의 변수 or 아무 것도 없다 객체 클래스를 이용하여 만든 메모리상에 존재하는 실체(instance) 생성되는 객체들은 독립적인 메모리를 가지고 있으므로 객체의 변수는 서로 다른 값을 가진다. 예외적으로는 static 변수를 사용하면 다른 객체에서 공통으로 접근할 수 있는 변수가 된다. 예시class MyClass {public: int m_Data;public: int GetData() { return m_Data; } void SetData(int _i) { m_Data = _i; }};int main(){ // MyClass의 변수와 함수를 가진 객체 생성 MyClass A; MyClass B; // 객체들은 각자의 m_Data값을 세팅할 수 있다. A.m_Data = 1; B.m_Data = 2; // MyClass의 함수로도 이용가능 A.SetData(1); B.SetData(2); cout &lt;&lt; A.GetData() &lt;&lt; endl; cout &lt;&lt; B.GetData() &lt;&lt; endl;}클래스와 구조체의 차이 C++에 와서 구조체안에 함수를 선언하고 접근지정자도 생기면서 차이가 거의 없어졌다. 큰 차이는 없지만 보통 멤버 변수로만 이루어져 있다면 구조체, 함수까지 사용한다면 클래스를 사용한다. 단지 다른점이 있다면 기본 접근 지정자가 다르다는 것뿐이다. 클래스의 기본 접근 지정자는 private 구조체의 기본 접근 지정자는 public " }, { "title": "함수인자 전달방식", "url": "/posts/%ED%95%A8%EC%88%98%EC%9D%B8%EC%9E%90_%EC%A0%84%EB%8B%AC%EB%B0%A9%EC%8B%9D/", "categories": "C++", "tags": "C++", "date": "2022-08-23 00:00:00 +0900", "snippet": "함수인자 전달 방식 함수의 매개변수가 포인터나 레퍼런스인지에 따라 전달하는 방식이 다르다. 포인터나 레퍼런스가 아닌 일반 자료형을 사용하면 Call By Balue로 값을 전달한다. 포인터나 레퍼런스를 사용한 자료형이라면 Call By Reference로 주소값을 전달한다. Call By Balue vs Call By Reference Call By Balue 함수의 인자가 포인터나 레퍼런스를 사용하지 않았을 때의 방식 함수를 호출한 시점에서 전달한 인자의 값을 복사하여 함수 내부의 입력 인자의 초기값을 설정한다. 함수를 호출한 시점의 인자값과 함수 내부의 인자값은 같지만, 메모리는 독립적으로 서로 다르다. // 함수 내부void swap(int first, int second){ int temp = first; first = second; second = temp;}int a = 3 , b = 4;swap(a,b); // 함수를 호출한 시점결과 -&gt; a = 3 , b = 4 함수의 인자가 포인터나 레퍼런스가 아니므로 Call By Balue의 방식이다. a, b의 값이 first, second에 복사가 되지만 값만 복사하여 전달한 것이어서 a,b와 first,second는 서로 다른 개체이므로 a,b가 바뀌지 않는다. Call By Reference 함수의 인자가 포인터나 레퍼런스로 전달되었을 때의 방식 함수를 호출한 시점의 인자를 함수 내부의 입력 인자가 참조하여 사용하는 방식 함수를 호출한 시점의 인자와 함수 내부의 입력 인자가 같은 개체가 된다. // 함수 내부void swap(int* first, int* second){ int temp = *first; *first = *second; *second = temp;}int a = 3 , b = 4;int *pa = &amp;a;int *pb = &amp;b;swap(pa,pb); // 함수를 호출한 시점결과 -&gt; a = 4 , b = 3 함수의 인자가 포인터나 레퍼런스이므로 Call By Reference의 방식이다. a,b의 주소를 가지고 있는 pa,pb의 값이 first,second에 주소값이 그대로 복사되어 들어간다(엄밀히 말하면 주소값을 복사하는 방식) 함수 내부에서 a와 b의 주소값을 가지고 있는 first와 second를 역참조(*)하여 값을 바꾸고 나면 a와 b의 값이 서로 바뀌게 된다." }, { "title": "3D Point Light", "url": "/posts/Point_Light/", "categories": "DirectX3D", "tags": "directx3d", "date": "2022-08-22 00:00:00 +0900", "snippet": "3D Point Light Light의 타입중 한 종류로, Sphere Mesh를 사용한 구 형태의 빛을 비춘다.3D Point Light 특징 Point Light의 Mesh는 VolumeMesh로 사용하여, VolumeMesh 안에 있는 픽셀을 검사한다. VolumeMesh : 영역을 체크하기 위한 Mesh Point Light의 영역안에 들어와도 어떤 픽셀이 호출될지에 대한 검사를 해야한다. 만약 어떤 오브젝트가 범위안에 있어도 광원쪽에 가까운 오브젝트의 단면이 보여야하고 반대쪽은 보이면 안되기 때문. 이 픽셀에 대한 검사는 방법이 2가지 Decal을 이용한 영역 체크 Stencil를 이용한 영역 체크 여기서는 Stencil은 이론과 Stencil 생성만을 작성하고 Decal을 이용하여 Shader 작성.Stencil 과정 후면 Stencil, 전면 Stencil, 사용할 Stencil를 3개 준비한다. 먼저 후면 Stencil을 이용하여 깊이가 Sphere의 뒷면보다 앞에 있는 픽셀들을 검출한다. 검출한 픽셀들을 1로 대체한다.(여기서는 설명을 위해 1로 대체, 다른값이여도 상관X) 전면 Stencil을 이용하여 깊이가 Sphere 앞면보다 뒤에 있고 후면 Stencil에서 스텐실을 1로 변경한 픽셀인지를 검출한다. 검출한 픽셀들은 유지한다.(결국 후면Stencil에서 통과한 픽셀들이므로 1로 유지) 전면,후면 둘다 통과한 픽셀들은 Stencil값이 1로 채워져 있다. 그 값으로 다른 Stencil에서 Stencil이 1인 픽셀을 검출하고 통과된 픽셀이면 Light RenderTarget에 빛의 영역을 받는 픽셀임을 알리고 0으로 초기화시킨다. 주의해야할점 후면 Stencil과 전면 Stencil의 순서가 바뀌면 안된다. 만약 전면 Stencil을 먼저 사용한다면, 카메라가 그 Mesh안에 들어갔을 때 Mesh의 앞면이 카메라보다 뒤쪽에 있으므로 래스터라이저에서 깊이통과자체를 하지 못한다. Stencil 생성D3D11_DEPTH_STENCIL_DESC desc = {};// 후면 체크// RS_TYPE::CULL_FRONTdesc.DepthEnable = true; // 깊이 검사 0desc.DepthFunc = D3D11_COMPARISON_GREATER;\t\t\t// Sphere의 뒷면이 통과되고 그 뒷면으로 픽셀을 체크하는 것이기 때문에 Greater로 설정해야함. 헷갈리기 쉬움desc.DepthWriteMask = D3D11_DEPTH_WRITE_MASK_ZERO;\t// 깊이 기록 X\tdesc.StencilEnable = true;desc.BackFace.StencilFunc = D3D11_COMPARISON_ALWAYS; // 깊이를 통과하면 Stencil도 통과desc.BackFace.StencilPassOp = D3D11_STENCIL_OP_REPLACE; // 통과한 값은 다른 값으로 대체desc.BackFace.StencilDepthFailOp = D3D11_STENCIL_OP_ZERO; // 깊이 통과하지 못하면 0으로 초기화desc.BackFace.StencilFailOp = D3D11_STENCIL_OP_ZERO; // 스텐실 통과하지 못하면 0으로 초기화// 전면 체크// RS_TYPE::CULL_BACKdesc.DepthEnable = true; // 깊이 검사 0desc.DepthFunc = D3D11_COMPARISON_LESS;\t\t\t\t// Sphere의 앞면이 통과되기 위해 LESSdesc.DepthWriteMask = D3D11_DEPTH_WRITE_MASK_ZERO;\t// 깊이 기록 X\tdesc.StencilEnable = true;desc.FrontFace.StencilFunc = D3D11_COMPARISON_EQUAL; // 후면에서 통과한 값을 이용하기 위해 EQUA desc.FrontFace.StencilPassOp = D3D11_STENCIL_OP_KEEP; // 통과했다면 Stencil값 유지desc.FrontFace.StencilDepthFailOp = D3D11_STENCIL_OP_ZERO; // 깊이 통과하지 못하면 0으로 초기화desc.FrontFace.StencilFailOp = D3D11_STENCIL_OP_ZERO; // 스텐실 통과하지못하면 0으로 초기화// 지정된 스텐실 영역만 렌더링desc.DepthEnable = false;\t // 스텐실의 값을 체크해서 영역 체크할 것이기 때문에 깊이사용 Xdesc.DepthWriteMask = D3D11_DEPTH_WRITE_MASK_ZERO;\t// 깊이 기록 X\tdesc.StencilEnable = true;desc.FrontFace.StencilFunc = D3D11_COMPARISON_EQUAL; // 후면,전면 둘다 통과한 스텐실을 사용desc.FrontFace.StencilPassOp = D3D11_STENCIL_OP_ZERO; // 통과한 Stencil을 Light Target에 저장하고 0으로 초기화desc.FrontFace.StencilDepthFailOp = D3D11_STENCIL_OP_ZERO; // 깊이 통과하지 못하면 0으로 초기화desc.FrontFace.StencilFailOp = D3D11_STENCIL_OP_ZERO; // 스텐실 통과하지못하면 0으로 초기화Stencil의 특징 Depth Stencil 텍스쳐를 이용한 검사 RenderTarget을 사용하지 않고 Depth Stencil 텍스쳐에서의 Stencil값을 이용하여 영역을 검사한다. 그렇기 때문에 RenderTarget을 빼도 된다. Stencil의 장점 어떤 형태의 Mesh든 상관없이 영역을 체크할 수 있다. Stencil의 단점 렌더링 파이프라인을 3번 돌기 때문에 비용값이 꽤 크다 VolumeMesh의 영역체크는 RenderTarget을 사용하지 않아 비용이 크지 않지만,기본적인 렌더링 파이프라인을 돌기 위한 연산비용이 2번 더 들기 때문에 비용이 커진다. Decal 특징 기하학적 계산이 가능한 Mesh에서만 사용이 가능 과정 사용하는 Mesh의 World,View 역행렬을 가져온다.(현재 ViewSpace 기준) 광원 영역인지를 검사할 픽셀을 Mesh의 World,View 역행렬을 곱하여 Mesh의 Local Space로 보낸다. Local Space로 들어온 픽셀이 Local Space의 Mesh의 내부에 있는지를 체크하여 안에 있다면 Volume Mesh안에 있는 것이므로 빛을 연산한다 // ================== // Point Light Shader // MRT : Light // Mesh : Sphere // RS_TYPE : CULL_FRONT, 광원영역(Volume Mesh) 안으로 들어왔을 때를 대비 (카메라의 뒤에 Mesh의 앞면이 있으면 안되므로) // BS_TYPE : ONE_ONE, 기존에 그려진 빛(타겟) 을 누적 // DS_TYPE : NO_TEST_NO_WRITE //#define LightIdx g_int_0 //#define PositionTarget g_tex_0 //#define NormalTarget g_tex_1 // ================== VS_DIR_OUT VS_Point(VS_DIR_IN _in) { VS_DIR_OUT output = (VS_DIR_OUT) 0.f; output.vPosition = mul(float4(_in.vPos, 1.f), g_matWVP); return output; } PS_DIR_OUT PS_Point(VS_DIR_OUT _in) { PS_DIR_OUT output = (PS_DIR_OUT) 0.f; float2 vUV = _in.vPosition.xy / vResolution.xy; float3 vViewNormal = NormalTarget.Sample(g_sam_0, vUV).xyz; // Position이 있는 픽셀의 ViewPos를 가져온다. float3 vViewPos = PositionTarget.Sample(g_sam_0, vUV).xyz; // 픽셀에 역행렬을 계산하여 Local Space로 보낸다 float3 vWorldPos = mul(float4(vViewPos, 1.f), g_matViewInv); float3 vLocalPos = mul(float4(vWorldPos, 1.f), g_matWorldInv); // 여기서는 반지름이 0.5인 Sphere Mesh를 사용하므로 0.5로 내부에 있는지 체크 if (length(vLocalPos) &lt; 0.5f) { tLightColor color = (tLightColor) 0.f; CalculateLight3D(vViewPos, vViewNormal, LightIdx, color); output.vDiffuse = color.vDiff + color.vAmb; output.vSpecular = color.vSpec; output.vShadowPow = (float4) 0.f; output.vDiffuse.a = 1.f; output.vSpecular.a = 1.f; output.vShadowPow.a = 1.f; } else // 밖에 있다면 계산X clip(-1); return output; }Decal의 장단점 장점 한번의 렌더링 파이프라인을 사용하기 때문애 Stencil 보단 적은 비용이 든다 단점 만약 메쉬가 계산하기 어려운 그런 메쉬라면 어려워지거나 못할 정도가 되기 때문에복잡한 모양이라면 못할 수 도 있다. " }, { "title": "레퍼런스", "url": "/posts/%EB%A0%88%ED%8D%BC%EB%9F%B0%EC%8A%A4/", "categories": "C++", "tags": "C++", "date": "2022-08-22 00:00:00 +0900", "snippet": "레퍼런스 일종의 변수에 대한 별칭(alias) 변수의 주소를 가져오거나 변수에 대한 역참조 연산을 수행하는 작업을 자동으로 처리하는 특수한 포인터레퍼런스 변수 레퍼런스 변수는 반드시 생성하자마자 초기화 해야한다 초기화 // xRef는 x에 또 다른 이름으로 xRef를 사용하는것은 x를 사용하는것과 같다int x = 3;int&amp; xRef = x;xRef = 10; // x = 10; 과 같음 초기화 하지 않을 경우int&amp; xRef; // 컴파일 에러 정수 리터럴처럼 이름없는 값에 대해서는 레퍼런스를 생성하지 못한다(non-const 레퍼런스) 단, const 값에 대해서는 레퍼런스 생성가능. int&amp; unnamedRef1 = 5; // 컴파일 에러const int&amp; unnamedRef2 = 5; // 정상 작동 임시객체에 대한 non-const 레퍼런스는 만들수없다 단,const 레퍼런스는 만들 수 있다. std::string getString() { return \"Hello World!\"; }std::string&amp; string1 = getString(); // 컴파일 에러const std::string&amp; string2 = getString(); // 정상 작동레퍼런스 대상 변경하기 레퍼런스는 한 번 생성되고 나면 가리키는 대상을 바꿀 수 없다. 한 번 선언된 레퍼런스에 다른 변수를 대입하면 레퍼런스가 가리키는 대상이 바뀌는 것이 아닌, 레퍼런스가 원래 가리키던 변수의 값이 새로 대입한 변수의 값으로 바뀌게 된다.int x = 3, y = 4;int&amp; xRef = x;xRef = y; // xRef가 y를 가리키는 것이 아니라 x의 값이 4로 바뀐다. y의 주소를 대입한다고 해도 대상을 바꿀 순 없다. y의 주소는 포인터지만 xRef는 포인터에 대한 레퍼런스가 아닌 int에 대한 레퍼런스이기 때문이다. xRef = &amp;y // 컴파일 에러 레퍼런스에 레퍼런스를 대입하는 방식으로도 레퍼런스 대상을 바꿀 수 없다int x = 3; , z = 5;int&amp; xRef = x;int&amp; zRef = z;zRef = xRef; // 레퍼런스가 아닌 값이 대입된다.// z의 값이 x의 값이 대입되어 3이 된다.포인터에 대한 레퍼런스와 레퍼런스에 대한 포인터 레퍼런스는 포인터를 포함해 모든 타입에 대해 만들 수 있다.int* intP;int*&amp; ptrRef = intP;ptrRef = new int;*ptrRef = 5; ptrRef는 intP에 대한 레퍼런스이다. intP는 int에 대한 포인터이다. ptrRef를 수정하면 intP가 바뀐다. 레퍼런스가 가져온 주소는 레퍼런스가 가리키는 변수의 주소와 같다int x = 3;int&amp; xRef = x;int* xPtr = &amp;xRef; // 레퍼런스의 주소는 값의 주소와 같다.*xPtr = 100; x에 대한 레퍼런스의 주소를 가져와서 xPtr이 x를 가리키도록 설정 조심해야할 점은 xPtr과 xRef는 타입이 다르다 if(xPtr == xRef) // 오류xPtr는 int에 대한 포인터 타입이고, xRef는 int에 대한 레퍼런스 타입if(xPtr == &amp;xRef) // 정상 작동if(xPtr == &amp;x) // 정상 작동 그리고 레퍼런스에 대한 레퍼런스를 선언할 수 없다int&amp;&amp; // 선언 Xint&amp;* // 선언 X레퍼런스 데이터 멤버 클래스의 데이터 멤버 또한 레퍼런스 타입으로 정의할 수 있다. 레퍼런스는 반드시 초기화를 해야 하므로 반드시 생성자 이니셜라이저에서 초기화해야한다.class MyClass{public: MyClass(int&amp; Ref) : mRef(ref) {}private: int&amp; mRef;}레퍼런스 매개변수 매개변수는 값 전달 방식에 따르기 때문에 함수는 인수의 복사본들 받는다. 하지만 매개변수를 레퍼런스 타입으로 선언하면 인수를 레퍼런스 전달 방식으로 처리한다.// 매개 변수가 레퍼런스 타입이므로 서로의 값이 바뀐다.void swap(int&amp; first, int&amp; second){ int temp = first; first = second; second = temp;}int x = 5 ,int y =6;swap(x,y); 레퍼런스 전달 방식은 함수안에서 인수로 전달한 값을 수정하면 원본 변수에 반영이 되기도 하지만,인수에 대한 복제본을 만들지 않아 다른 장점도 있다. 효율성 : 크기가 큰 객체나 struct,class는 복제 오버헤드가 크다.    레퍼런스 전달 방식은 레퍼런스만 함수에 전달한다. 정확성 : 값 전달 방식을 지원하지 않는 객체가 있다. 지원하더라도 깊은 복사가 적용되지 않을 수도 있다. 포인터를 레퍼런스로 전달하기 매개변수가 레퍼런스 타입인 함수나 메서드에 포인터를 전달하면 난감해진다. 이 때는 포인터를 역참조해서 전달하면 포인터를 레퍼런스로 ‘변환’할 수 있다. 포인터가 가리키는 값을 가져와서 레퍼런스 매개변수를 초기화하기 때문이다. int x = 5, y = 6;int *xp = &amp;x, *yp = &amp;y;swap(*xp, *yp);레퍼런스 리턴값 함수의 리턴값을 레퍼런스로 전달하면 레퍼런스 전달 방식으로 처리한다. 함수의 인자와 마찬가지로 객체 전체를 리턴하지 않고 객체에 대한 레퍼런스만 리턴하면 복제 연산을 줄일 수 있다. 주의 함수안의 지역변수는 레퍼런스로 리턴하면 안된다 함수가 끝나면 지역변수는 스택에서 사라지는데 레퍼런스로 참조하고 있기 때문에 오류가 발생할 수 있다. rvalue 레퍼런스(우측값 레퍼런스) lvalue는 변수처럼 이름과 주소를 가지면서 대입문의 왼쪽에 나온다. rvalue는 lvalue가 아닌 나머지를 말한다.(상숫값,임시 객체) rvalue 레퍼런스는 임시 객체에 대해 적용할 함수를 컴파일러가 선택하기 위한 용도로 사용한다.// 좌측값 레퍼런스 매개변수void handleMessage(string&amp; messssage){ cout&lt;&lt; \"handleMessage with lvalue reference: \" &lt;&lt; message &lt;&lt; endl;}// 우측값 레퍼런스 매개변수void handleMessage(string&amp;&amp; messssage){ cout&lt;&lt; \"handleMessage with rvalue reference: \" &lt;&lt; message &lt;&lt; endl;}string a = \"Hello\";string b = \"World\";handleMessage(a); // handleMessage(string&amp; messssage) 호출handleMessage(a+b); // handleMessage(string&amp;&amp; messssage) 호출레퍼런스와 포인터의 선택 기준 레퍼런스로 할 수 있는 일은 모두 포인터로 처리할 수 있으니 레퍼런스가 필요없다고 느껴질 수도 있다.void swap(int* first, int* second){ int temp=*first; *first = *second; *second = temp;} 이렇게 하면 코드가 복잡해지지만 레퍼런스를 사용한다면 코드가 깔끔해지고 레퍼런스의 값은 널이 될 수없고 레퍼런스를 명시적으로 역참조 할 수 없기 때문에 포인터보다 안전하다. (단 포인터가 하나도 없을 경우에만 레퍼런스가 더 안전하다고 말할 수 있다.) 하지만 반드시 포인터를 사용해야하는 경우도 있다. 대표적인 예로 가리키는 위치를 변경해야 할 때가 있다. 레퍼런스는 한번 초기화하면 변경할 수 없기 때문에 동적 할당 메모리의 주소는 레퍼런스가 아닌 포인터로 저장해야한다. 주소값이 nullptr이 될 수도 있는 optional 타입은 반드시 포인터를 사용해야한다. 컨테이너에 다형성 타입을 저장할 때도 포인터를 사용해야 한다. 결국 매개변수나 리턴값을 포인터나 레퍼런스중 어느것이 적합한지를 따질려면 메모리의 소유권이 어디있는지를 따져보는 것이다. 소유권을 이전할 필요가 있다면 항상 스마트 포인터를 사용하는것이 좋지만,메모리 소유권이 변수를 받는 코드에 없어서 메모리를 해제할 일이 없다면 레퍼런스로 전달한다. " }, { "title": "핸들 테이블과 핸들의 상속", "url": "/posts/%ED%95%B8%EB%93%A4_%ED%85%8C%EC%9D%B4%EB%B8%94%EA%B3%BC_%ED%95%B8%EB%93%A4%EC%9D%98_%EC%83%81%EC%86%8D/", "categories": "윈도우즈시스템프로그래밍, 운영체제", "tags": "windows", "date": "2022-08-21 00:00:00 +0900", "snippet": "핸들 생성 과정 메일 슬롯으로 핸들 생성하는 과정 0x2400번지에 메일슬롯 정보를 저장하는 커널 오브젝트가 생성 256은 커널 오브젝트를 가리키는(지시하는) 용도로 사용되는 핸들 핸들 256을 통해서 0x2400번지에 할당되어 있는 메일슬롯에 접근이 가능하다. 그런데 위의 그림을 보았을 때 핸들 256이 0x2400번지에 존재하는 커널오브젝트를 의미한다는 정보가 없다. 그러한 정보들은 사실 핸들이 가리키는 핸들테이블에 저장되어 있다. 핸들 테이블 핸들 테이블이 포함된 생성 과정 핸들 테이블에 등록되어 있는 데이터들로 핸들256에 주소 0x2400번지가 저장되었음을 알 수 있다. 프로세스가 함수 호출을 통해서 리소스 생성을 요구한 결과로 핸들 정보를 얻을 경우 프로세스 자신에게 속해 있는 핸들 테이블에 해당 정보가 등록된다. 핸들 테이블 핸들 정보를 저장하고 있는 테이블로서 프로세스별로 독립적이다. 각각의 프로세스가 자신만의 핸들 테이블을 하나씩 구성하고 관리한다. 핸들의 상속 CreateProcess 함수를 호출하면 자식프로세스가 생성되고 자식 프로세스의 핸드 테이블도 생성한다. CreateProcess 함수 호출시 전달되는 인자가 무엇이냐에 따라 부모 프로세스의 핸들 정보는 자식프로세스에게 상속될 수 있다. 자식 프로세스는 부모 프로세스의 핸들 테이블에 등록돼 있는 핸들을 상속받을 수 있지만, 필연적으로 상속받는 것은 아니다. 상속 여부에 따른 핸들의 상속 자식 프로세스가 부모 프로세스로부터 상속받은 핸들은 상속 여부에 대한 정보도 변경없이 상속된다. 위의 그림과 같이 자식에 상속받은 핸들들은 부모의 상속여부를 그대로 상속받았다. 핸들의 상속과 커널 오브젝트의 Usage Count 핸들과 UsageCount관계 커널 오브젝트를 참조하는 프로세스 개수만큼 커널 오브젝트의 Usage Count는 참조(공유)하는 프로세스의 수만큼 증가한다. 그렇다면 커널 오브젝트를 참조하는 프로세스가 되기 위한 조건은 무엇인가? -&gt; 핸들을 얻은 프로세스가 커널 오브젝트를 참조하는 프로세스가 된다. 프로세스가 핸들을 얻게 된다는 것은 무엇을 의미하는가? -&gt; 프로세스가 핸들을 얻게 되었다는 의미는 핸들 테이블에 해당 핸들에 대한 정보가 갱신(추가) 되었음을 의미한다. CreateMailSlot함수의 호출을 통한 메일슬롯의 예시* 과정1. 메일슬롯 리소스 생성2. 커널 오브젝트 생성3. 핸들 정보가 핸들 테이블에 갱신4. CreateMailSlot함수를 빠져 나오면서 핸들값 반환 프로세스가 핸들을 얻게 되었다고 한다면, 4번째에 초점을 맞추지만 실은 3번째에서 프로세스가 핸들을 얻게 되었다고 말할 수 있다. 즉, 핸들 테이블에 핸들에 대한 정보가 등록되면, 그 순간 핸들을 얻었다고 말할 수 있다. 핸들 테이블과 Usage Count(1) UC (Usage Count)를 보면 부모 프로세스의 핸들 테이블에만 핸들 정보가 등록 되어 있는 관계로 1로 되어 있다. CloseHandle를 호출한다면 UC가 0이 되면서 해당 커널 오브젝트와 리소스는 소멸된다. 핸들 테이블과 Usage Count(2) 자식프로세스를 생성하면서 상속했더니 핸들정보가 갱신되면서 UC가 2가 된 모습이다.상속이 되기 위한 핸들의 조건 핸들의 상속 여부는 리소스가 생성되는 순간에 프로그래머에 의해서 결정된다// 메일 슬롯의 예시HANDLE CreateMailslot(LPCTSTR lpName,                DWORD nMaxMessageSize,    DWORD lReadTimeout,           LPSECURITY_ATTRIBUTES lpSecurityAttributes, // 핸들 상속 여부}; CreateMailSlot에서는 4번째 인자를 통해서 상속여부를 결정할 수 있다. LPSECURITY_ATTRIBUTES는 SECURITY_ATTRIBUTES 구조체의 포인터타입이다. 이 값에 NULL이 들어가면 전달되지 않고,구조체 변수의 주소값을 전달하면 상속될 수 있다. 대부분의 리소스 생성방식에 위와 같이 구조체의 멤버를 통해서 상속여부를 결정할 수 있다.Pseudo 핸들과 핸들의 중복 현재 실행 중에 있는 프로세스 자신의 핸들을 얻는 방법으로써 GetCurrentProcess 함수가 있다. 이 함수를 통해 얻은 핸들을 가리켜 가짜 핸들(Pseudo 핸들)이라 한다. 이렇게 얻은 핸들은 핸들 테이블에 등록되어 있지 않은 핸들이고, 현재 실행 중인 프로세스를 참조하기 위한 용도로 정의해 놓은, 약속된 상수가 반환되기 때문이다. 따라서 자식 프로세스로 상속되지 않으며, CloseHandle함수를 사용할 필요가 없다. " }, { "title": "Light RenderTarget", "url": "/posts/Light_RenderTarget/", "categories": "DirectX3D", "tags": "directx3d", "date": "2022-08-19 00:00:00 +0900", "snippet": "Light RenderTarget MRT의 한 종류로 광원 렌더링이다. 과정 Deferred에서 필요한 데이터들을 저장한 텍스쳐들을 Light Shader에 가져온다. 가져온 Deferred 텍스쳐를 이용하여 각각의 광원을 연산한다. 각각 광원을 연산한 후, 기존의 색상과 곱해서 빛을 누적한 다음 최종색상을 SwapChain의 RenderTarget에 보낸다. Forward 에서는 Lighting을 처리할 때는 물체가 기준이므로 각 물체의 Shader에서 광원 개수만큼 빛을 처리했지만,Deferred 에서는 광원이 기준이므로 Deferred의 텍스쳐들을 이용하여 빛의 영역을 따져서 영역 안에 있는 픽셀이 호출되는지를 검사하고 빛을 처리한다. Light RenderTarget 종류 Diffuse(자연광) Specular(반사광) ShadowPower(그림자 세기) Light RenderTarget 생성 Deferred와 마찬가지로 렌더타겟 및 리소스로 사용(D3D11_BIND_RENDER_TARGET D3D11_BIND_SHADER_RESOURCE) Diffuse,Specular는 빛의 색상을 저장하기 위해 R8G8B8A8_UNORM 사용 ShadowPower는 그림자의 세기를 저장하기 위해 R32_Float를 사용\tPtr&lt;CTexture&gt; arrTex[8] =\t{\t\tCResMgr::GetInst()-&gt;CreateTexture(L\"DiffuseTargetTex\" , (UINT)vResolution.x, (UINT)vResolution.y\t\t\t, DXGI_FORMAT_R8G8B8A8_UNORM, D3D11_BIND_RENDER_TARGET | D3D11_BIND_SHADER_RESOURCE, true),\t\tCResMgr::GetInst()-&gt;CreateTexture(L\"SpecularTargetTex\", (UINT)vResolution.x, (UINT)vResolution.y\t\t\t, DXGI_FORMAT_R8G8B8A8_UNORM, D3D11_BIND_RENDER_TARGET | D3D11_BIND_SHADER_RESOURCE, true),\t\tCResMgr::GetInst()-&gt;CreateTexture(L\"ShadowPowerTargetTex\", (UINT)vResolution.x, (UINT)vResolution.y\t\t\t, DXGI_FORMAT_R32_FLOAT, D3D11_BIND_RENDER_TARGET | D3D11_BIND_SHADER_RESOURCE, true),\t};Light Shader 빛의 종류에 맞춰 Shader 생성 Light는 SrcRgb와 DestRgb가 1:1 비율인 Blend를 사용한다. LightType종류 Directional(태양광) RectMesh로 화면 전체 픽셀을 호출한다. Point (전구,횃불같은 빛) SphereMesh를 이용한다. Spot (손전등) ConeMesh를 이용한다. Directional Light 3D Light의 종류중 하나로, 태양처럼 모든 곳에 빛을 비추는 타입. Directional Light는 화면에 있는 모든 픽셀을 호출 하기 위해 RectMesh를 사용한다. // ========================// Directional Light Shader// MRT : Light// mesh : RectMesh// RS : CULL_BACK// DS : NO_TEST_NO_WRITE// BS : ONE_ONE#define LightIdx g_int_0 // 체크할 광원의 인덱스#define PositionTarget g_tex_0 // 빛의 영역이 받는지 체크하기 위한 위치값(Position)#define NormalTarget g_tex_1 // 빛의 색상 계산을 위한 Normal Vector// ========================struct VS_DIR_IN{ float3 vPos : POSITION;};struct VS_DIR_OUT{ float4 vPosition : SV_Position;};VS_DIR_OUT VS_Directional(VS_DIR_IN _in){ VS_DIR_OUT output = (VS_DIR_OUT) 0.f; output.vPosition = float4(_in.vPos * 2.f, 1.f); // 원점으로부터 길이가 0.5인 RectMesh를 사용하기 때문에 *2를 해서 1로 화면 전체로 비춰준다. return output;}struct PS_DIR_OUT{ float4 vDiffuse : SV_Target0; // 자연광 float4 vSpecular : SV_Target1; // 반사광 float4 vShadowPow : SV_Target2; // 그림자의 세기};PS_DIR_OUT PS_Directional(VS_DIR_OUT _in){ PS_DIR_OUT output = (PS_DIR_OUT) 0.f; float2 vUV = _in.vPosition.xy / vResolution.xy; float3 vViewPos = PositionTarget.Sample(g_sam_0, vUV).xyz; float3 vViewNormal = NormalTarget.Sample(g_sam_0, vUV).xyz; // 물체가 그려지지 않은 영역은 빛을 받을 수 없다. if (vViewPos.z == 0.f) clip(-1); tLightColor color = (tLightColor) 0.f; CalculateLight3D(vViewPos, vViewNormal, LightIdx, color); // 3DLighting에 있는 함수 output.vDiffuse = color.vDiff + color.vAmb; output.vSpecular = color.vSpec; output.vShadowPow = (float4) 0.f; // ImGUI가 AlphaBlend를 지원하기 때문에 맞춰주기 위해 알파값을 1로 설정 output.vDiffuse.a = 1.f; output.vSpecular.a = 1.f; output.vShadowPow.a = 1.f; return output;} " }, { "title": "포인터", "url": "/posts/%ED%8F%AC%EC%9D%B8%ED%84%B0/", "categories": "C++", "tags": "C++", "date": "2022-08-19 00:00:00 +0900", "snippet": "포인터 다른 변수의 메모리 주소를 저장하기 위한 변수 32bit 환경에서는 포인터 변수의 크기는 4byte, 64bit 환경에서는 8byte이다.포인터관련 연산자 주소연산자 ( &amp; ) 변수의 이름 앞에 사용하여, 해당 변수의 주소값을 반환 참조연산자 ( * ) 포인터의 이름이나 주소 앞에 사용하여, 포인터에 가리키는 주소에 저장된 값을 반환 int a = 5; // 일반변수 aint* b = &amp;a; // 포인터 변수b에 a의 주소를 저장cout &lt;&lt; a &lt;&lt; endl; // a의 값을 반환cout &lt;&lt; &amp;a &lt;&lt; endl; // a의 주소를 반환cout&lt;&lt; b &lt;&lt; endl; // b는 a의 주소를 가지고있는 포인터변수이므로 a의 주소를 반환cout&lt;&lt; &amp;b &lt;&lt; endl; // &amp;b는 b의 주소를 반환cout&lt;&lt; *b &lt;&lt; endl; // *b는 a의 값을 반환 (b는 a의 주소이고 *로 역참조)동적할당 C에서는 malloc/free를 사용하고 C++에서는 new/delete를 사용한다 메모리 힙 영역에 할당한다. 힙에 저장함으로써 함수가 끝나도 동적할당한 변수는 해제하지 않는 한 사용할 수 있다. 프로그래머가 따로 관리하기 때문에 메모리를 관리하는데 용이하다. 메모리를 해제하지 않으면 메모리 누수가 발생하기에 조심해야한다. // C언어 동적할당, malloc은 void*이므로 타입에 맞게 변환시켜야함.free로 메모리해제int* pInteger = (int*)malloc(sizeof(int));free(pInteger);// C++ 동적할당, new로 동적할당, delete로 메모리해제int* pInteger2 = new int;delete pInteger2; 동적으로 배열 할당하기 new[]와 delete[]를 사용 // new[]를 사용 , arraySize만큼 메모리 할당 int arraySize = 8; int* myVariableSizedArray = new int[arraySize]; // delete[]를 사용해서 메모리 해제 // new[]를 사용한다면 메모리 누수 방지를 위해 반드시 delete[]로 해제(delete로 하면 전부 다 해제되지 않음) delete[] myVariableSizedArray; myVariableSizedArray = nullptr; nullptr 포인터 변수에 메모리를 할당하지 않고 싶을 때 nullptr를 이용한다. 부울 표현식에서는 false로 취급한다 int* myIntegerPointer= nullptr; // 아무런 주소도 저장하고 있지 않음if(myIntegerPointer) // myIntegerPointer는 nullptr값을 가지고 있으므로 false" }, { "title": "반복문", "url": "/posts/%EB%B0%98%EB%B3%B5%EB%AC%B8/", "categories": "C++", "tags": "C++", "date": "2022-08-18 00:00:00 +0900", "snippet": "반복문 프로그램 내에서 똑같은 명령을 일정 횟수만큼 반복하여 수행하도록 제어하는 명령문 종류 while문 do/while문 for문 범위 기반 for문 while while문은 주어진 조건이 맞지 않을 때까지 일정한 코드블록을 반복한다.int i = 0;while (i &lt; 5){ cout&lt;&lt; i &lt;&lt; endl; ++i;} break 반복문을 즉시 빠져나와 뒤에 있는 코드를 진행한다. continue 즉시 반복문의 첫 문장으로 돌아가서 while문의 조건부터 다시 검사한다. do/while while문과 비슷하지만 형태가 조금 다르고 do/while은 한번 실행을 하고 난 뒤 조건을 검사한다.// i가 5보다 크지만 do/while문이므로 한번은 실행된다.int i = 100;do{ cout&lt;&lt; i &lt;&lt; endl; ++i;} while (i &lt; 5)for문 while문과 달리 조건만 있는 것이 아니라 초기값, 반복문이 끝나고 실행할 문장이 들어 있다.for(int i = 0 ; i &lt; 5 ; ++i){ cout&lt;&lt; i &lt;&lt; endl;}범위기반 for문 범위기반 for문은 컨테이너에 담긴 원소에 대해 반복문을 실행한다. 이니셜라이저 리스트, array, vector, 반복자등 여러 타입에 적용된다. 범위기반 for문은 이 배열의 모든 원소에 대한 복제본을 화면에 출력한다. 복제하지 않기 위해서는 레퍼런스 변수를 활용하면 된다 std::array&lt;int, 4&gt; arr = {1,2,3,4};for(int i : arr){ cout&lt;&lt; i &lt;&lt; endl;}" }, { "title": "Deferred RenderTarget", "url": "/posts/Deferred_RenderTarget/", "categories": "DirectX3D", "tags": "directx3d", "date": "2022-08-17 00:00:00 +0900", "snippet": "Deferred MRT의 한종류로 지연 렌더링이라고도 한다. Deferred는 Depth Stencil를 가지고 있지 않고 SwapChain의 DepthStencil를 가져와서 사용한다. Deferred에서는 각 텍스쳐의 rgba를 저장하고 Merge과정에서 그 텍스쳐들의 rgba를 이용한다. 종류 텍스쳐 기존색상을 가지고 있는 ColorRenderTexture 텍스쳐의 픽셀이 자기의 노말벡터를 RGB에 저장하고 있는 NormalRenderTexture 텍스쳐의 픽셀의 자기의 좌표정보를 RGB에 저장하고 있는 PositionRenderTexture 그 외 나머지를 저장할 DataRenderTexture MRT 생성 Deferred Texture D3D11_BIND_RENDER_TARGET D3D11_BIND_SHADER_RESOURCE : 렌더타겟 및 리소스로 사용 ColorTargetTex는 색상이므로 0~1까지 표현 DXGI_FORMAT_R8G8B8A8_UNORM 그 외 Texture들은 -1 ~ 1까지 부동소수점으로 자세히 표현하기 위해 DXGI_FORMAT_R32G32B32A32_FLOAT void CRenderMgr::CreateMRT() { // ============= // SwapChain MRT // ============= m_arrMRT[(UINT)MRT_TYPE::SWAPCHAIN] = new CMRT; Ptr&lt;CTexture&gt; pRTTex = CResMgr::GetInst()-&gt;FindRes&lt;CTexture&gt;(L\"RenderTargetTex\"); Ptr&lt;CTexture&gt; pDSTex = CResMgr::GetInst()-&gt;FindRes&lt;CTexture&gt;(L\"DepthStencilTex\"); m_arrMRT[(UINT)MRT_TYPE::SWAPCHAIN]-&gt;Create(1, &amp;pRTTex, pDSTex); Vec2 vResolution = CDevice::GetInst()-&gt;GetRenderResolution(); // ============ // Deferred MRT // ============ { Ptr&lt;CTexture&gt; arrTex[8] = { CResMgr::GetInst()-&gt;CreateTexture( L\"ColorTargetTex\" , (UINT)vResolution.x, (UINT)vResolution.y , DXGI_FORMAT_R8G8B8A8_UNORM, D3D11_BIND_RENDER_TARGET | D3D11_BIND_SHADER_RESOURCE, true), CResMgr::GetInst()-&gt;CreateTexture(L\"NormalTargetTex\", (UINT)vResolution.x, (UINT)vResolution.y , DXGI_FORMAT_R32G32B32A32_FLOAT, D3D11_BIND_RENDER_TARGET | D3D11_BIND_SHADER_RESOURCE, true), CResMgr::GetInst()-&gt;CreateTexture(L\"PositionTargetTex\", (UINT)vResolution.x, (UINT)vResolution.y , DXGI_FORMAT_R32G32B32A32_FLOAT, D3D11_BIND_RENDER_TARGET | D3D11_BIND_SHADER_RESOURCE, true), CResMgr::GetInst()-&gt;CreateTexture(L\"DataTargetTex\", (UINT)vResolution.x, (UINT)vResolution.y , DXGI_FORMAT_R32G32B32A32_FLOAT, D3D11_BIND_RENDER_TARGET | D3D11_BIND_SHADER_RESOURCE, true) }; m_arrMRT[(UINT)MRT_TYPE::DEFERRED] = new CMRT; m_arrMRT[(UINT)MRT_TYPE::DEFERRED]-&gt;Create(4, arrTex, nullptr); } }Shader Deferred Shader에는 각각의 텍스쳐 색상값을 저장함 Merge Shader에서는 Deferred Shader에서 저장한 텍스쳐 색상을 이용하여 샘플링함. #ifndef _STD3D_DEFERRED #define _STD3D_DEFERRED #include \"value.fx\" struct VTX_IN { float3 vPos : POSITION; float2 vUV : TEXCOORD; float3 vTangent : TANGENT; float3 vNormal : NORMAL; float3 vBinormal : BINORMAL; }; struct VTX_OUT { float4 vPosition : SV_Position; float2 vUV : TEXCOORD; float3 vViewPos : POSITION; float3 vViewTangent : TANGENT; float3 vViewNormal : NORMAL; float3 vViewBinormal : BINORMAL; }; // ========================= // Std3D_Deferred // g_tex_0 : Output Texture // g_tex_1 : Normal Map // DOMAIN : Deferred // Rasterizer : CULL_BACK // DepthStencilState : LESS // BlendState : DEFAULT // ========================= VTX_OUT VS_Std3D_Deferred(VTX_IN _in) { VTX_OUT output = (VTX_OUT) 0.f; output.vPosition = mul(float4(_in.vPos, 1.f), g_matWVP); return output; } // PS_OUT이라는 구조체 안에 각각 텍스쳐 색상을 저장. // 이대로 병합(Merge)하지 않고 사용한다면 SwapChain의 Depth Stencil에 깊이만 남기고 // 색상은 사용되지 않아 깊이통과가 된다면 검은색의 메쉬모양이 뜬다. struct PS_OUT { float4 vColor : SV_Target0; // 컬러 텍스쳐 float4 vNormal : SV_Target1; // 노말 텍스쳐 float4 vPosition : SV_Target2; // 포지션 텍스쳐 float4 vData : SV_Target3; // 데이터 텍스쳐 }; PS_OUT PS_Std3D_Deferred(VTX_OUT _in) { PS_OUT output = (PS_OUT) 0.f; output.vColor = float4(1.f, 0.f, 0.f, 1.f); output.vNormal = float4(0.f, 1.f, 0.f, 1.f); output.vPosition = float4(0.f, 0.f, 1.f, 1.f); output.vData = float4(1.f, 0.f, 1.f, 1.f); return output; } // =============== // Merge Shader // Mesh : RectMesh // g_int_0 : Target Index // g_tex_0 : Color Target // g_tex_1 : Norma lTarget // g_tex_2 : Position Target // g_tex_3 : Data Target // =============== struct VS_MERGE_IN { float3 vPos : POSITION; }; struct VS_MERGE_OUT { float4 vPosition : SV_Position; }; VS_MERGE_OUT VS_Merge(VS_MERGE_IN _in) { VS_MERGE_OUT output = (VS_MERGE_OUT) 0.f; // SV_Position은 픽셀의 위치를 그대로 받아옴 // 한 정점의 길이가 0.5인 RectMesh를 사용하므로 *2를 해서 -1 ~ 1로 만듦 output.vPosition = float4(_in.vPos * 2.f, 1.f); return output; } float4 PS_Merge(VS_MERGE_OUT _in) : SV_Target0 { float4 vOutColor = (float4) 0.f; float2 vUV = _in.vPosition.xy / vResolution.xy; if(0 == g_int_0) { vOutColor = g_tex_0.Sample(g_sam_0, vUV); } else if(1 == g_int_0) { vOutColor = g_tex_1.Sample(g_sam_0, vUV); } else if(2 == g_int_0) { vOutColor = g_tex_2.Sample(g_sam_0, vUV); } else { vOutColor = g_tex_3.Sample(g_sam_0, vUV); } return vOutColor; } #endifForward와 Deffered Forward (단일 렌더타겟) 하나의 RenderTarget으로 한번에 렌더링해서 SwapChain의 RenderTarget으로 설정하는 방식 Deferred (다중 렌더타겟 , 지연렌더링이라고도 함) 별도의 RenderTarget Texture를 생성해서 각각 렌더링을 하고 메인 RenderTarget (SwapChain의 RenderTarget)에 복사하는 방식 Deferred 의 장점 지연 처리를 통한 얻어온 데이터들을 다양한 렌더링효과로 사용할 수 있다. Forward렌더링과 다르게 훨씬 많은 광원을 사용해도 최적화가 좋음 ( 적게 쓰면 Forward가 좋다.) Forward는 광원을 많이쓰면 Light3DBuffer가 늘어나면서 Lighting을 한번에 처리하기위해 반복문을 도는데 Lighting을 한두개만 받아도 전체Lighting 개수만큼 거리값체크하고 등등해야함. Deferred는 Shader에서 라이팅연산을 하지 않고 각 텍스쳐(렌더타겟)에 값만 저장한다.그 값으로 Lighting RenderTarget에서 연산한다. Forward는 물체가 기준(물체가 광원의 빛을 받는지), Deferred는 광원이 기준( 광원이 어떤 물체에 영향을주는지) 광원의 영역을 오브젝트 취급해서 렌더링(빛들을 도식화해서 절도체, 영역안에 들어오지않은 물체는 렌더링X) 결국 광원이 기준이 되어 광원의 영역 안에 있는 픽셀만 렌더링한다. (광원이 영향을 주는 픽셀에 Deferred Position 렌더타겟를 가져와서 값이 있는지 체크) Deferred의 단점 광원을 많이 쓰지 않으면 의미가 없음. ( 여러 렌더타겟을 그릴 이유가 없음) 알파처리가 힘들다 (반투명한 물체의 포지션을 사용하면 뒤에있는 물체들이 이상해진다.) 그래서 완전히 불투1명한 물체를 Deferred렌더링하고 Forward 렌더링할 때 반투명을 Blend 처리)" }, { "title": "배열", "url": "/posts/%EB%B0%B0%EC%97%B4/", "categories": "C++", "tags": "C++", "date": "2022-08-17 00:00:00 +0900", "snippet": "배열 같은 자료형의 변수를 메모리에 나열하는 구조특징 인덱스는 0부터 시작하기 때문에 배열의 마지막 원소의 위치는 배열의 크기-1 이다. 배열의 이름은 배열의 첫번째 원소의 주소값과 같다. 배열 원소들의 주소값은 첫번째 원소의 주소 + (자료형*인덱스)이다. 메모리에 ‘나열’ 하는 구조이기 때문 int Arr[3] = {1,2,3};int Arr[0] // 첫번째 원소의 주소가 1000 이라면int Arr[1] // 두번째 원소의 주소는 1000 + 4(int의 크기) * 1(인덱스) =1004int Arr[2] // 1000 + 4 * 2 = 1008;배열 초기화int Arr[3]; // 선언, 쓰레기값이 들어있음int Arr[3] = {1,2,3}; // 선언+초기화int Arr[3] = {0}; // 배열의 모든 원소를 0으로 초기화 , 0빼도 된다.int Arr[] = {1,2,3}; // 컴파일러가 3개의 원소를 가진 배열을 생성int Arr[3] = {2}; // 첫번째 원소만 2로 초기화가 되고 나머지는 0으로 초기화배열의 크기 배열의 크기는 컴파일 시간때 결정된다. 변수는 런타임에 결정되기 때문에 변수를 인덱스로 사용하지 못함.int a=5;//int Arr[a]; -&gt;오류 상수 or const변수는 인덱스에 사용 가능하다.// 상수int Arr[5];// constconst int a=5;int Arr[a];" }, { "title": "Multi RenderTarget", "url": "/posts/Multi_RenderTarget/", "categories": "DirectX3D", "tags": "directx3d", "date": "2022-08-16 00:00:00 +0900", "snippet": "다중 렌더 타겟 (Multi-RenderTarget, MRT) 단일 드로우 콜(Draw Call)에서 픽셀 셰이더(Pixel Shader)의 출력을 여러 개의 렌더 타겟 텍스처에 동시에 쓰는 DirectX 11의 기능 즉, 같은 씬을 한 번 렌더링하면서 각 렌더 타겟에는 서로 다른 종류의 픽셀 데이터를 저장할 수 있음 일반적으로 스왑 체인(SwapChain)에 연결된 렌더 타겟은 최종적으로 화면에 표시될 색상 정보를 담음 하지만 MRT를 사용하면, 스왑 체인에 연결되지 않은 추가적인 렌더 타겟들에 다양한 중간 데이터(예: 월드 공간 법선, 깊이 값, 재질 ID, 반사율 등)를 저장할 수 있음 이렇게 저장된 정보들은 이후 후처리(Post-processing) 단계나 다른 렌더링 기법(예: 지연 렌더링)에 활용되어 더욱 풍부하고 효율적인 그래픽 효과를 구현하는 데 사용MRT의 주요 특징 및 용도동시 출력 하나의 픽셀 셰이더 실행으로 최대 8개의 렌더 타겟 텍스처(Render Target Texture)와 하나의 깊이/스텐실 버퍼(Depth/Stencil Buffer)에 동시에 데이터를 쓸 수 있음 (DirectX 11 기준).데이터 분리 최종 색상 외에 다양한 중간 데이터를 각각의 텍스처에 분리하여 저장함으로써, 복잡한 셰이딩 계산을 여러 단계로 나누어 처리할 수 있음주요 활용 기법지연 렌더링 (Deferred Shading) MRT를 사용하여 G-버퍼(Geometry Buffer)를 생성. G-버퍼에는 각 픽셀의 위치, 법선, 알베도, 스페큘러 강도 등의 지오메트리 및 재질 정보를 여러 렌더 타겟에 나누어 저장. 이후 이 G-버퍼를 사용하여 화면 공간에서 조명 계산을 수행.특수 효과용 버퍼 특정 효과(예: 외곽선 감지, 모션 블러용 속도 버퍼, SSAO용 깊이/법선 버퍼)에 필요한 데이터를 별도의 렌더 타겟에 저장깊이/스텐실 버퍼 공유 여러 렌더 타겟을 동시에 사용할 때, 일반적으로 하나의 깊이/스텐실 버퍼를 공유. OMSetRenderTargets 함수 호출 시 깊이/스텐실 뷰(DSV)를 nullptr로 지정하면, 이전에 바인딩된 DSV를 계속 사용하거나, 만약 아무것도 없다면 깊이/스텐실 테스트가 비활성화된 것처럼 동작할 수 있음.MRT 설정을 캡슐화하는 간단한 C++ 클래스 예시CMRT.h#pragma once#include \"CEntity.h\" // 사용자 정의 기본 엔티티 클래스 (가정)#include \"CTexture.h\" // 사용자 정의 텍스처 클래스 (Ptr&lt;CTexture&gt; 사용 가정)#include &lt;vector&gt;#include &lt;wrl/client.h&gt; // ComPtr 사용// (Vec4, Ptr 등의 사용자 정의 타입이 있다고 가정)// struct Vec4 { float x, y, z, w; /* ... 생성자 등 ... */ };// template&lt;typename T&gt; using Ptr = Microsoft::WRL::ComPtr&lt;T&gt;; // 예시class CMRT : public CEntity{private: Ptr&lt;CTexture&gt; m_arrRT[D3D11_SIMULTANEOUS_RENDER_TARGET_COUNT]; // 최대 8개의 렌더 타겟 텍스처 포인터 UINT m_iRTCount; // 현재 그룹에 포함된 실제 렌더 타겟 개수 Ptr&lt;CTexture&gt; m_pDSTex; // 깊이/스텐실 텍스처 포인터 Vec4 m_arrClearColor[D3D11_SIMULTANEOUS_RENDER_TARGET_COUNT]; // 각 렌더 타겟을 클리어할 색상public: // 생성자 및 소멸자 CMRT(); ~CMRT(); // MRT 그룹 생성 void Create(UINT _iRTCount, Ptr&lt;CTexture&gt;* _arrRTTextures, Ptr&lt;CTexture&gt; _pDepthStencilTexture); // 특정 렌더 타겟의 클리어 색상 설정 void SetClearColor(UINT _iRTIndex, const Vec4&amp; _color); // 모든 렌더 타겟의 클리어 색상 일괄 설정 void SetClearColors(UINT _iCount, const Vec4* _pColors); // 이 MRT 그룹을 파이프라인의 출력 병합기(OM) 단계에 설정 void BindTargets(ID3D11DeviceContext* _pContext); // 이 MRT 그룹의 모든 렌더 타겟과 깊이/스텐실 버퍼를 클리어 void ClearTargets(ID3D11DeviceContext* _pContext);public: // 복제 방지 매크로 (사용자 정의) // CLONE_DISABLE(CMRT);};CMRT.cpp#include \"CMRT.h\"// #include \"CDevice.h\" // 전역 디바이스 컨텍스트 접근용 (CONTEXT 매크로 등)// (CDevice::GetInst()-&gt;CONTEXT() 와 같이 디바이스 컨텍스트를 가져온다고 가정)// ID3D11DeviceContext* GetContext() { return CDevice::GetInst()-&gt;CONTEXT(); }CMRT::CMRT() : m_iRTCount(0) , m_pDSTex(nullptr){ // 기본 클리어 색상 초기화 (예: 검은색) for (int i = 0; i &lt; D3D11_SIMULTANEOUS_RENDER_TARGET_COUNT; ++i) { m_arrClearColor[i] = Vec4(0.0f, 0.0f, 0.0f, 1.0f); }}CMRT::~CMRT(){}void CMRT::Create(UINT _iRTCount, Ptr&lt;CTexture&gt;* _arrRTTextures, Ptr&lt;CTexture&gt; _pDepthStencilTexture){ assert(_iRTCount &lt;= D3D11_SIMULTANEOUS_RENDER_TARGET_COUNT); // 최대 8개 확인 m_iRTCount = _iRTCount; for (UINT i = 0; i &lt; m_iRTCount; ++i) { m_arrRT[i] = _arrRTTextures[i]; assert(m_arrRT[i] != nullptr &amp;&amp; m_arrRT[i]-&gt;GetRTV() != nullptr); // 렌더 타겟 뷰가 유효한지 확인 } m_pDSTex = _pDepthStencilTexture; if (m_pDSTex) { assert(m_pDSTex-&gt;GetDSV() != nullptr); // 깊이/스텐실 뷰가 유효한지 확인 }}void CMRT::SetClearColor(UINT _iRTIndex, const Vec4&amp; _color){ if (_iRTIndex &lt; m_iRTCount) { m_arrClearColor[_iRTIndex] = _color; }}void CMRT::SetClearColors(UINT _iCount, const Vec4* _pColors){ UINT count = min(_iCount, m_iRTCount); for (UINT i = 0; i &lt; count; ++i) { m_arrClearColor[i] = _pColors[i]; }}void CMRT::BindTargets(ID3D11DeviceContext* _pContext){ ID3D11RenderTargetView* arrRTVs[D3D11_SIMULTANEOUS_RENDER_TARGET_COUNT] = { nullptr, }; for (UINT i = 0; i &lt; m_iRTCount; ++i) { if (m_arrRT[i]) // 유효한 텍스처인지 확인 { arrRTVs[i] = m_arrRT[i]-&gt;GetRTV().Get(); // Ptr&lt;CTexture&gt;가 GetRTV() ComPtr&lt;ID3D11RenderTargetView&gt;를 반환하고, .Get()으로 원시 포인터 가져옴 } } ID3D11DepthStencilView* pDSV = nullptr; if (m_pDSTex) // 이 MRT 그룹에 지정된 DSV가 있다면 사용 { pDSV = m_pDSTex-&gt;GetDSV().Get(); } else // 없다면, 현재 파이프라인에 바인딩된 DSV를 그대로 사용 (또는 nullptr로 설정하여 깊이/스텐실 테스트 안함) { // 사용자 코드의 로직: 현재 바인딩된 DSV를 가져와서 다시 설정 // 이는 OMGetRenderTargets의 비용과 참조 카운팅 문제를 고려해야 함. // 더 간단하게는, 이 MRT에 DSV가 없다면 nullptr을 전달하여 깊이/스텐실을 사용하지 않거나, // 또는 이 MRT는 항상 특정 DSV와 함께 사용되어야 한다는 규칙을 정할 수 있음. // 여기서는 사용자 코드의 의도를 따라 현재 DSV를 유지하는 로직을 주석으로 남김. // Microsoft::WRL::ComPtr&lt;ID3D11DepthStencilView&gt; pCurrentDSV; // _pContext-&gt;OMGetRenderTargets(0, nullptr, pCurrentDSV.GetAddressOf()); // pDSV = pCurrentDSV.Get(); // ComPtr이 자동으로 참조 카운트 관리 // 주의: OMGetRenderTargets는 참조 카운트를 증가시키므로, ComPtr이 아니면 수동 Release 필요. } _pContext-&gt;OMSetRenderTargets(m_iRTCount, arrRTVs, pDSV);}void CMRT::ClearTargets(ID3D11DeviceContext* _pContext){ // 각 렌더 타겟 클리어 for (UINT i = 0; i &lt; m_iRTCount; ++i) { if (m_arrRT[i] &amp;&amp; m_arrRT[i]-&gt;GetRTV()) { _pContext-&gt;ClearRenderTargetView(m_arrRT[i]-&gt;GetRTV().Get(), (float*)&amp;m_arrClearColor[i]); } } // 깊이/스텐실 버퍼 클리어 (지정된 경우) if (m_pDSTex &amp;&amp; m_pDSTex-&gt;GetDSV()) { _pContext-&gt;ClearDepthStencilView(m_pDSTex-&gt;GetDSV().Get(), D3D11_CLEAR_DEPTH | D3D11_CLEAR_STENCIL, 1.0f, 0); }}HLSL에서의 MRT 사용 픽셀 셰이더에서 여러 렌더 타겟으로 출력하려면, 출력 구조체의 각 멤버에 해당하는 SV_Target[N] 시맨틱을 사용합니다. N은 0부터 7까지의 렌더 타겟 인덱스struct PS_OUTPUT_MRT{ float4 target0 : SV_Target0; // 첫 번째 렌더 타겟으로 출력 (예: 최종 색상) float4 target1 : SV_Target1; // 두 번째 렌더 타겟으로 출력 (예: 월드 공간 법선) float4 target2 : SV_Target2; // 세 번째 렌더 타겟으로 출력 (예: 스페큘러 정보) // ... 최대 SV_Target7 까지 가능};PS_OUTPUT_MRT MyPixelShader_MRT(VS_OUTPUT input){ PS_OUTPUT_MRT output; // ... 픽셀 셰이더 로직 ... // 예시: 각 타겟에 다른 정보 기록 output.target0 = float4(finalLitColor, materialAlpha); output.target1 = float4(normalize(input.worldNormal), materialID); // 법선과 재질 ID output.target2 = float4(specularColor, roughness, metallic, 0.0f); // 스페큘러, 거칠기, 금속성 return output;} 이후 다른 셰이더(예: 조명 계산용 전체 화면 셰이더 또는 후처리 셰이더)는 이렇게 저장된 텍스처들을 입력(SRV)으로 받아 사용하여 최종 이미지를 생성하거나 다양한 효과를 적용" }, { "title": "함수", "url": "/posts/%ED%95%A8%EC%88%98/", "categories": "C++", "tags": "C++", "date": "2022-08-16 00:00:00 +0900", "snippet": "함수 특별한 목적의 작업을 수행하기 위해 독립적으로 설계된 코드의 집합 함수를 사용하기 위해선 사용하려는 위치보다 앞에서 선언을 해야한다. 특정 파일안에서만 사용할 함수는 선언과 구현 모두 소스파일안에서 작성하지만,함수를 다른 모듈이나 파일에서도 사용하려면 선언은 헤더파일,구현은 소스파일에 작성한다.선언과 구현 함수 선언void myFunction(int i, char c);위와 같이 함수를 선언만하고 구체적인 동작은 구현하지 않은 채 이 함수를 호출한 문장이 담긴 코드를 컴파일하면실제로 코드에 존재하지 않는 함수를 호출하기 때문에 링크과정에서 에러가난다. 함수 구현// 두 매개변수를 출력void myFunction(int i, char c){ std::cout &lt;&lt; i &lt;&lt; std::endl; std::cout &lt;&lt; c &lt;&lt; std::endl;}함수의 형태반환타입 함수명(매개변수){ // 호출 시 작동될 코드 // 반환타입이 void가 아니라면 return으로 반환타입에 맞는 값을 반환해야한다. // 반환타입이 void였다면 return;을 이용하여 함수를 즉시 끝낼 수 있다.}함수 리턴 타입 추론 C++14부터는 함수의 리턴 타입을 컴파일러가 알아서 지정할 수 있다. 이 기능을 적용하려면 리턴타입자리에 auto키워드를 적는다. auto addNum(int num1,int num2){ return num1 + num2;} 그러면 컴파일러는 return문값의 타입에 따라 리턴 타입을 추론한다. 함수 안에 return문이 여러 개 있을 수 있는데, 모두 타입이 같아야 한다. 현재 함수 이름 함수마다 내부적으로 _func_라는 로컬변수가 정의돼 있다. 이 변수는 현재 함수 이름을 값으로 갖고 있고 주로 로그를 남기는데 활용한다.auto addNum(int num1,int num2){ std::cout &lt;&lt; \"Entering function \" &lt;&lt; _func_ &lt;&lt; std::endl; return num1 + num2;}함수 오버로딩 매개변수의 타입이나 개수만 다르게 지정해서 이름이 같은 함수를 정의하는 것을 오버로딩이라고 한다.void Function(){ return 1;}int Function(){ return 10;} 많이 착각하는 점은 return 타입값이 다르다고 해서 오버로딩이 되지 않는다.// 아래 코드는 컴파일러가 return문 타입으로 오버로딩을 확인할 수 없기 때문에 에러가 난다.void GetData(int _i){ cout &lt;&lt; 1;}int GetData(int _i){ return _i;}int main(){ GetData(10);}" }, { "title": "스카이박스 (SkyBox)", "url": "/posts/SkyBox/", "categories": "DirectX3D", "tags": "directx3d", "date": "2022-08-15 00:00:00 +0900", "snippet": "스카이박스 (SkyBox) 3D 게임이나 애플리케이션에서 배경 역할을 하는 커다란 가상의 공간 주로 하늘, 먼 산, 도시 풍경 등 원거리 환경을 표현하여 플레이어가 마치 거대한 월드 안에 있는 듯한 느낌을 주며, 씬의 전반적인 분위기를 설정스카이박스의 종류 스카이박스를 구현하는 지오메트리(도형)의 형태에 따라 주로 두 가지 타입이 있음 구 형태 (Sphere SkyBox / SkySphere): 커다란 구의 안쪽 면에 하늘 이미지를 매핑합니다. 정육면체 형태 (Cube SkyBox / SkyCube): 정육면체의 각 6개 안쪽 면에 각각의 방향에 해당하는 이미지를 매핑합니다.스카이박스 셰이더 (SkyBox Shader) 주요 설정 스카이박스는 일반적인 3D 오브젝트와는 다른 특별한 렌더링 설정이 필요렌더링 순서 (Shader Domain) 스카이박스는 일반적으로 불투명(Opaque) 오브젝트로 간주되어 그려짐 렌더링 순서는 중요한데, 보통 가장 먼저 그리거나(깊이 버퍼를 채우기 전 또는 깊이 쓰기 비활성화) 또는 모든 불투명 오브젝트를 그린 후 가장 마지막에 그림(깊이 테스트 특별 처리).래스터라이저 상태 (Rasterizer State - RS)CULL_FRONT (앞면 컬링) 카메라는 항상 스카이박스 지오메트리 안에 위치 따라서 우리가 보게 되는 것은 스카이박스 도형의 안쪽 면 일반적인 컬링(뒷면 컬링, CULL_BACK)을 사용하면 스카이박스의 안쪽 면이 그려지지 않음 이를 해결하기 위해, 스카이박스 지오메트리의 삼각형 와인딩 순서(winding order)를 반대로 하거나, 래스터라이저 상태에서 앞면을 컬링하는 CULL_FRONT를 사용.깊이/스텐실 상태 (Depth/Stencil State - DS)LESS_EQUAL (깊이 테스트 함수) 및 특별한 Z 처리 스카이박스는 항상 다른 모든 오브젝트들 뒤에 그려진 것처럼 보여야 합니다. 즉, 깊이 버퍼에서 가장 먼 값(일반적으로 1.0)을 가져야 함 이를 위해 HLSL Vertex Shader에서 최종 클립 공간 좌표의 z 값을 w 값과 같게 만드는 기법(output.vPosition.z = output.vPosition.w;)을 사용. 이렇게 하면 원근 나누기(perspective divide) 후 NDC(Normalized Device Coordinates) 공간에서 z 값이 항상 1.0이 됨 깊이 버퍼가 일반적으로 0.0(가까움)에서 1.0(멈)의 범위를 가지고, 1.0으로 초기화된다면, 깊이 테스트 함수가 LESS일 경우 Z가 1.0인 스카이박스는 그려지지 않음. 따라서 LESS_EQUAL을 사용하여 Z가 1.0인 스카이박스가 그려질 수 있도록 함 대안: 깊이 쓰기를 비활성화하고 가장 먼저 그리기, 또는 깊이 테스트 함수를 ALWAYS로 설정하고 가장 먼저 그리는 방법 등도 있음C++ 셰이더 객체 설정 예시// (CGraphicsShader 클래스가 있다고 가정)// pShader = new CGraphicsShader;// pShader-&gt;CreateVertexShader(L\"Shader\\\\std3d.fx\", \"VS_SkyBox\");// pShader-&gt;CreatePixelShader(L\"Shader\\\\std3d.fx\", \"PS_SkyBox\");// pShader-&gt;SetShaderDomain(SHADER_DOMAIN::DOMAIN_FORWARD); // 또는 DOMAIN_SKY// pShader-&gt;SetRSType(RS_TYPE::CULL_FRONT);// pShader-&gt;SetDSType(DS_TYPE::LESS_EQUAL); // 깊이 테스트 함수 설정// pShader-&gt;SetBSType(BS_TYPE::DEFAULT); // 기본 블렌드 상태// // 사용할 텍스처 파라미터 정보 추가// pShader-&gt;AddTexParamInfo(L\"Output Texture\", TEX_PARAM::TEX_0); // 구형 스카이박스용 2D 텍스처// pShader-&gt;AddTexParamInfo(L\"Cube Texture\", TEX_PARAM::TEX_CUBE_0); // 큐브 스카이박스용 큐브 텍스처스카이박스 위치 고정 (항상 멀리 있는 효과) 스카이박스는 배경 역할을 하므로, 카메라가 월드 공간에서 아무리 이동해도 플레이어에게 가까워지거나 멀어지는 느낌을 주어서는 안 됨. 항상 무한히 멀리 있는 것처럼 보여야 함문제점 일반적인 3D 오브젝트처럼 스카이박스를 월드에 배치하고 카메라가 이동하면, 카메라와 스카이박스 표면 사이의 거리가 변하여 배경이 움직이는 것처럼 보임해결 방법1. 오브젝트 위치 고정 스카이박스 오브젝트의 월드 위치를 매 프레임 카메라의 월드 위치와 동일하게 업데이트합니다. 이렇게 하면 카메라는 스카이박스에 대해 상대적으로 항상 중앙에 있게 됨2. 셰이더를 이용한 트릭 Vertex Shader에서 카메라의 이동(Translation) 변환은 무시하고 회전(Rotation) 변환만 스카이박스에 적용. 이렇게 하면 카메라는 제자리에서 회전하는 것처럼 스카이박스를 둘러볼 수 있지만, 카메라가 이동해도 스카이박스는 따라오지 않고 항상 같은 거리에 있는 것처럼 보임 구현: 스카이박스 정점의 로컬 위치를 뷰 변환할 때, 뷰 행렬의 이동 성분을 제거하거나, 정점의 동차 좌표 w를 0으로 설정하여 뷰 행렬과 곱함. 이렇게 하면 뷰 행렬의 이동 부분이 곱셈 결과에 영향을 주지 않게 됨 구 형태 스카이박스 (Sphere SkyBox / SkySphere)지오메트리 구(Sphere) 메시를 사용합니다. 사용자 코드에서는 반지름 0.5로 설정된 구 메시를 사용한다고 가정Vertex Shader (VS_SkyBox 로직 중 구 관련 부분)1. 크기 조절 입력 정점 위치(_in.vPos, 로컬 공간, 반지름 0.5 가정)에 2.0을 곱하여 반지름 1인 단위 구로 만듭니다. 이 위치는 카메라 기준의 상대적 위치로 사용float3 vLocalPos = _in.vPos * 2.0f; // 반지름 1로 스케일링2. 카메라 회전만 적용 스케일링된 로컬 위치의 w를 0으로 하여 뷰 행렬과 곱셈. 이렇게 하면 뷰 행렬의 이동 성분은 무시되고 회전만 적용float3 vViewRotatedPos = mul(float4(vLocalPos, 0.0f), g_matView).xyz;3. 투영 변환 및 Z-트릭 변환된 위치를 투영 행렬과 곱하고, z 값을 w 값으로 설정하여 깊이 값을 강제로 1.0 (NDC 기준)으로 만듦float4 vProjPos = mul(float4(vViewRotatedPos, 1.0f), g_matProj);vProjPos.z = vProjPos.w; // 깊이를 최대로 설정 (NDC에서 z = 1.0)output.vPosition = vProjPos;4. UV 좌표 전달 구형 맵(Spherical Map / Equirectangular Map) 텍스처를 샘플링하기 위한 UV 좌표를 픽셀 셰이더로 전달. 이는 구 메시 생성 시 계산된 UV 값output.vUV = _in.vUV; // 스피어 매핑용 2D UVPixel Shader (PS_SkyBox 로직 중 구 관련 부분) g_int_0 값이 0일 때 (구 타입 스카이박스를 의미하는 것으로 보임) 실행 정점 셰이더에서 전달받은 2D UV 좌표(_in.vUV)를 사용하여 일반 2D 텍스처(g_tex_0)를 샘플링. 이 텍스처는 펼쳐진 구 형태의 이미지여야 함 if (0 == g_int_0) // Sphere Type{ if (g_btex_0) // 텍스처 사용 여부 플래그 { vOutColor = g_tex_0.Sample(g_sam_0, _in.vUV); }}정육면체 형태 스카이박스 (Cube SkyBox / SkyCube)지오메트리 정육면체(Cube) 메시를 사용. 예: 중심이 원점이고 각 변의 길이가 2인 단위 큐브. 사용자 코드의 24개 정점 큐브는 각 면에 고유한 법선을 가지도록 펼쳐진 형태로, 스카이박스에도 사용할 수 있음 Vertex Shader (VS_SkyBox 로직 중 큐브 관련 부분) 위치 변환 로직은 구형 스카이박스와 동일. 즉, 로컬 정점 위치를 스케일링하고, 카메라 회전만 적용한 후, 투영 변환 및 Z-트릭을 적용// (위의 Sphere SkyBox Vertex Shader 로직과 동일한 위치 처리)// output.vPosition = vProjPos; 방향 벡터 전달: 큐브맵 텍스처를 샘플링하기 위해서는 3D 방향 벡터가 필요함. 로컬 공간에서의 정점 위치 자체가 원점에서의 방향을 나타내므로, 이를 정규화하여 픽셀 셰이더로 전달합니다. output.vDirUV = normalize(_in.vPos); // 큐브맵 샘플링용 3D 방향 벡터Pixel Shader (PS_SkyBox 로직 중 큐브 관련 부분) g_int_0 값이 1일 때 (큐브 타입 스카이박스를 의미하는 것으로 보임) 실행 정점 셰이더에서 전달받은 3D 방향 벡터(_in.vDirUV)를 사용하여 큐브 텍스처(g_texcube_0)를 샘플링함else if (1 == g_int_0) // Cube Type{ if (g_btexcube_0) // 큐브 텍스처 사용 여부 플래그 { // vDirUV는 정점에서 큐브 중심으로의 방향 벡터 (보간됨) vOutColor = g_texcube_0.Sample(g_sam_0, _in.vDirUV); }}텍스처 큐브 (TextureCube) TextureCube는 HLSL에서 큐브맵 텍스처를 위한 특별한 타입 큐브맵은 6개의 2D 텍스처(정육면체의 각 면: +X, -X, +Y, -Y, +Z, -Z)로 구성된 하나의 리소스 C++에서 텍스처 생성 시 D3D11_RESOURCE_MISC_TEXTURECUBE 플래그를 설정하여 만들며, 6개의 이미지 데이터를 제공해야 함 HLSL에서 샘플링할 때는 3D 방향 벡터를 사용하며, 이 벡터가 가리키는 큐브의 면과 해당 면에서의 2D 위치가 자동으로 계산되어 해당 텍셀 값이 반환됨스카이박스 HLSL 전체 코드 예시// 상수 버퍼 (C++에서 설정)cbuffer CB_CameraInfo : register(b0) // 예시 이름{ matrix g_matView; matrix g_matProj;};cbuffer CB_SkyBoxParams : register(b1) // 예시 이름{ int g_int_0; // 스카이박스 타입 (0: Sphere, 1: Cube) bool g_btex_0; // Sphere 텍스처 사용 여부 bool g_btexcube_0; // Cube 텍스처 사용 여부 // ... 기타 패딩 또는 파라미터 ...};// 텍스처 및 샘플러Texture2D g_tex_0 : register(t0); // Sphere용 2D 텍스처TextureCube g_texcube_0 : register(t1); // Cube용 큐브 텍스처SamplerState g_sam_0 : register(s0); // 공용 샘플러// Vertex Shader 입력 구조체struct VTX_SKY_IN{ float3 vPos : POSITION; // 로컬 위치 (반지름 0.5 또는 한 변 길이 1.0의 단위 도형 가정) float2 vUV : TEXCOORD0; // 구형 스카이박스용 UV};// Vertex Shader 출력 / Pixel Shader 입력 구조체struct VTX_SKY_OUT{ float4 vPosition : SV_Position; // 클립 공간 위치 float2 vUV : TEXCOORD0; // SphereMap용 UV float3 vDirUV : TEXCOORD1; // CubeMap용 3D 방향 벡터};VTX_SKY_OUT VS_SkyBox(VTX_SKY_IN _in){ VTX_SKY_OUT output = (VTX_SKY_OUT)0.0f; // 1. 로컬 위치를 단위 크기로 가정하고 카메라 기준 상대 위치로 만듦 // 사용자 코드에서는 _in.vPos가 이미 -0.5 ~ 0.5 범위의 로컬 좌표라고 가정하고 *2를 함. // 만약 _in.vPos가 이미 -1 ~ 1 범위의 단위 도형 정점이라면 *2는 필요 없음. // 여기서는 사용자 코드의 의도를 따라 반지름 0.5를 1로 만드는 것으로 가정. float3 vNormalizedLocalPos = _in.vPos * 2.0f; // 2. 뷰 변환 시 이동(Translation)은 무시하고 회전만 적용 // w를 0으로 설정하면 행렬 곱셈 시 이동 성분이 영향을 주지 않음. float3 vViewSpaceRotatedPos = mul(float4(vNormalizedLocalPos, 0.0f), g_matView).xyz; // 3. 투영 변환 float4 vProjPos = mul(float4(vViewSpaceRotatedPos, 1.0f), g_matProj); // 4. 깊이 값을 최대로 설정 (NDC에서 z = 1.0) // 이렇게 하면 다른 모든 오브젝트 뒤에 그려짐 (DepthStencilState의 DepthFunc = LESS_EQUAL 필요) vProjPos.z = vProjPos.w; output.vPosition = vProjPos; output.vUV = _in.vUV; // SphereMap용 UV 전달 output.vDirUV = normalize(vNormalizedLocalPos); // CubeMap용 방향 벡터 전달 (로컬 위치 자체가 방향) return output;}float4 PS_SkyBox(VTX_SKY_OUT _in) : SV_Target{ float4 vOutColor = float4(0.3f, 0.3f, 0.3f, 1.0f); // 기본 배경색 (텍스처 없을 시) // Sphere Type 스카이박스 if (0 == g_int_0) { if (g_btex_0) // Sphere 텍스처 사용이 활성화되어 있다면 { vOutColor = g_tex_0.Sample(g_sam_0, _in.vUV); } } // Cube Type 스카이박스 else if (1 == g_int_0) { if (g_btexcube_0) // Cube 텍스처 사용이 활성화되어 있다면 { // 보간된 3D 방향 벡터를 사용하여 큐브맵 샘플링 vOutColor = g_texcube_0.Sample(g_sam_0, _in.vDirUV); } } return vOutColor;}" }, { "title": "조건문", "url": "/posts/%EC%A1%B0%EA%B1%B4%EB%AC%B8/", "categories": "C++", "tags": "C++", "date": "2022-08-14 00:00:00 +0900", "snippet": "조건문 어떤 값이 참 또는 거짓인지 주어진 코드를 실행할지 결정할 수 있다. 종류 if/else문 switch문 조건 연산자 if / else문 조건이 참이면 if문에 속한 코드를 실행하고 조건이 참이 아니면 if 블록을 빠져나와 뒤에 else문이 있다면 else문에 속한 코드를 실행한다. if( i &gt; 4){ // 코드}else if( i &gt; 2){ // 코드}else{ // 코드} if문 뒤의 소괄호 안에는 반드시 bool 타입값을 지정하거나 평가 결과가 bool값인 표현식을 지정해야한다. 0은 false를 의미하고 , 0이 아닌 값은 true를 의미한다. if문 이니셜라이저 C++17부터 if문 안에 이니셜라이져(초기자)를 넣는 기능이 추가됐다.if( 이니셜라이저 ; 조건문 ) { 본문 }&lt;이니셜라이저&gt;에서 정의한 변수는 &lt;조건문&gt;과 &lt;본문&gt;안에서만 사용할 수 있고 if문 밖에서 사용할 수 없다.switch문 조건으로 지정한 표현식의 결과에 따라 수행할 동작을 선택한다. C++에서 switch문에 조건으로 지정할 수 있는 표현식 정수 정수 타입으로 변환할 수 있는 타입 enum enum class이며 상수와 비교할 수 있어야함. 예시 switch문 안에는 다양한 경우를 표현하는 상숫값들을 case문으로 지정할 수 있다. switch문에 지정한 표현식의 결과와 일치하는 case 가 있다면 그 case문을 실행하다 break문을 만나면 멈춘다. 그리고 default란 키워드로 case를 작성할 수 있는데 이 구문은 하나도 case문에 걸리지 않았을 때 실행된다. switch(menuItem){ case OpenMenuItem: //코드 break; case SaveMenuItem: //코드 break; default: //코드 break;}switch문의 Fallthroughswitch문에서 조건의 결과와 일치하는 case문이 있다면 break문을 만날 때까지 실행한다.이때 break문이 없다면 다음에 나오는 case문도 실행한다. 이것을 Fallthrough(흘려보내기)라고 한다.switch(backgroundColor){ case Color::DarkBlue: case Color::Black: // backgroundColor의 값이 DarkBlue 또는 Black일때 실행 break; case Color::Red: // backgroundColor의 값이 Red일 때 실행 break;}C++17부터는 [[fallthrough]] 속성을 지정해서 의도적으로 fallthrough방식으로 작성했다고 컴파일러에게 알려줄 수 있다.switch(backgroundColor){ case Color::DarkBlue: // backgroundColor의 값이 DarkBlue일 때 실행 [[fallthrough]] case Color::Black: // backgroundColor의 값이 DarkBlue 또는 Black일때 실행 break;}switch문의 이니셜라이저 C++17부터는 if문처럼 switch문도 이니셜라이저를 지정할 수 있다.switch( 이니셜라이저 ; 표현식 ) {본문}조건연산자 삼항 연산자 인수를 3 개를 받는다. 조건 을 만족하면 동작1 을 수행하고 그렇지않으면 동작2 를 수행한다. 예시 std::cout&lt;&lt; (i &gt; 2 ? \"Yes\" : \"No\" );// i가 2보다 크다면 Yes, 그렇지 않다면 No를 출력" }, { "title": "타입", "url": "/posts/%ED%83%80%EC%9E%85/", "categories": "C++", "tags": "C++", "date": "2022-08-13 00:00:00 +0900", "snippet": "열거 타입(enum) 숫자를 나열하는 방식과 범위를 마음대로 정의해서 변수를 선언하는데 활용할 수 있다. 열거타입을 사용하지 않았을 때const int PieceTypeKing = 0;const int PieceTypeQueen = 1;const int PieceTypeRook = 2;const int PieceTypePawn = 3;// 기타int myPiece = PieceTypeKing; 위와 같은 방식으로 한다면 myPiece에서 문제가 생길 수 도 있다. myPiece가 일반 int이기 때문에 다른 프로그래머가 myPiece에 대한 값을 수정해버린다면의도치 않은 상황이 나와버린다. 열거타입으로 사용할 때enum PieceType { PieceTypeKing, PieceTypeQueen, PieceTypeRook, PieceTypePawn};PieceType myPiece;// myPiece = 0; -&gt; myPiece는 PieceType이 자료형이기 때문에 일반 int처럼 사용할 수 없다.myPiece = PieceType::PieceTypeKing; enum 타입을 사용하면 변수에 지정할 수 있는 값의 범위를 엄격하게 제한하기 때문에 위와 같은 상황을 방지 할 수 있다.enum을 사용할 때 주의점 enum타입을 구성하는 멤버는 내부적으로 int로 자동으로 값을 초기화한다. 만약 enum타입에 값을 지정해주지 않으면 처음값은 0으로 초기화되고 그 다음값은 이전 타입값에 1을 더해준 정수값을 가진다. enum의 정수값enum PieceType { PieceTypeKing, // 초기화해주지 않았으므로 0 PieceTypeQueen, // 초기화하지 않고 이전 enum값이 0이므로 1 PieceTypeRook = 10, // 10으로 초기화 했으므로 10 PieceTypePawn // 초기화하지 않고 이전 enum값이 10이므로 11}; 서로 다른 enum의 멤버 이름이 중복될 수 없다.enum Color{ RED=100,};enum Color2{ RED=101,};int main(){ cout &lt;&lt; RED &lt;&lt; endl;} 위와 같은 상황이 발생했을 때 어느 enum의 RED인지 모르게 되기 때문이다.엄격한 열거 타입(enum class) enum과 달리 enum class로 정의하면 스코프가 자동으로 확장되지 않는다. 자동으로 확장되지 않기 때문에 스코프 지정연산자(::)를 붙여줘야 한다. enum class Color{ RED = 100,}int main(){ // cout &lt;&lt; RED &lt;&lt; endl; -&gt; 자동으로 확장되지 않기 때문에 RED라고 바로 접근하지 못함. cout &lt;&lt; Color::RED &lt;&lt; endl;} 그리고 또 스코프 지정연산자를 붙여줘야만 사용할 수 있으므로 다른 enum class와의 멤버이름의 중복이 가능하다.* enum class는 자동으로 정수 타입으로 변환하지 않는다. enum Color{ RED = 100,};enum class Color2{ RED = 100,}int main(){ if(RED == 1) // enum이므로 정수값이라 성공 // if(Color2::RED == 1) // enum class이므로 실패} enum class의 값은 enum과 마찬가지로 내부적으로 int값을 가지긴 하지만 내부 표현타입을 변경할 수 있다.enum class Color : unsigned long{ RED = 100,}구조체 기존에 정의된 타입을 한 개 이상 묶어서 새로운 타입으로 정의 구조체 타입의 변수는 구조체의 멤버를 전부 가지는 형태 구조체 멤버를 접근하기 위해서 도트(.) 연산자를 사용한다 struct Employee{ int employeeNumber; int salary;};int main(){ Employee anEmployee; anEmployee.employeeNumber = 12; // 구조체의 anEmployee의 멤버 employeeNumber에 12를 저장. anEmployee.salary = 100; // 구조체의 anEmployee의 멤버 salary에 100를 저장.}" }, { "title": "상수와 리터럴", "url": "/posts/%EC%83%81%EC%88%98%EC%99%80-%EB%A6%AC%ED%84%B0%EB%9F%B4/", "categories": "C++", "tags": "C++", "date": "2022-08-12 00:00:00 +0900", "snippet": "상수 값을 변경할 수 없는 변수 C++에는 두가지 타입의 상수가 있다. 리터럴 상수 심볼릭 상수 리터럴 상수 데이터가 저장된 메모리 공간을 가리키는 이름을 가지고 있지 않는 문자 그대로의 값. 리터럴 상수에는 정수형, 실수형 , 문자형 리터럴 상수가 있다. 정수형 ( bool, int , long ) 실수형 ( float, double ) 실수는 f키워드를 붙이지 않으면 기본 8byte인 double형으로 임시 메모리 공간을 잡음.(3.14f / 3.14) 문자열 ( ex) “Hello World”) 문자열 상수를 제외한 지역변수에 할당되는 리터럴 상수는 Code영역에 저장된다. 문자열 상수는 Data영역에 있는 read only data에 저장된다. 심볼릭 상수 문자로된 이름을 가진 상수 const ex) const int PI = 3.14; #define 전처리 과정에서 치환되므로 메모리 공간이 할당되지 않음. ex) #define PI 3.14 enum 값에 이름을 붙인 형태 예시 enum Color{Red=100,Green=200,Blue=300,}cout&lt;&lt; RED &lt;&lt;endl; // 100이 나옴cout&lt;&lt; Green &lt;&lt;endl; // 200이 나옴 상수와 리터럴의 차이 상수는 위에 적힌 것처럼 값을 변경 할 수 없는 ‘변수’ 이므로 고정된 값을 가진 변수를 의미한다. 리터럴은 상수에서 말하는 고정된 값(데이터 그 자체)을 의미한다." }, { "title": "네임스페이스", "url": "/posts/%EB%84%A4%EC%9E%84%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4/", "categories": "C++", "tags": "C++", "date": "2022-08-12 00:00:00 +0900", "snippet": "네임 스페이스 코드에서 이름이 서로 충돌하는 문제를 해결하기 위해 나온 개념만약 Func()이라는 함수를 만들어 사용하다가 외부 라이브러리가 필요해서 추가했는데 거기에도 Func()이라는 함수가 있다면 컴파일러는 어느 함수를 가리키는지 모른다. 이럴 때 네임스페이스를 이용하여문제를 해결 할 수 있다. 어떤 이름이 어디에 속해있는지 문맥을 정의할 수 있기 때문이다. 예시namespace mycode{ void Func();}// 함수의 선언뿐만 아니라 구현 부분도 묶을 수 있다.(2가지 방법)1. void mycode::Func(){ std::cout &lt;&lt; \"Func() called in the mycode namespace\" &lt;&lt; std::endl;}2. namespace mycode{ void Func() { std::cout &lt;&lt; \"Func() called in the mycode namespace\" &lt;&lt; std::endl; }} 스코프 지정 연산자(::)를 이용하여 네임 스페이스 안에 있는 함수를 호출 할 수 있다.mycode::Func(); // mycode 네임스페이스에 정의된 Func() 함수를 호출using 지시어네임스페이스 블록 안에서 접근할 때는 네임스페이스를 접두어로 붙이지 않아도된다.하지만 바깥쪽에서 사용할 때는 네임스페이스를 붙여줘야 하지만 using을 이용하여 접두어를 생략할 수 있다.컴파일러는 using 지시자를 보면 그 뒤에 나오는 문장부터는 using에 지정된 네임 스페이스에 속하는 것으로 처리한다.using namespace mycode;int main(){ Func(); // -&gt; mycode::Func() return 0;} 주의 using 지시자는 여러 개 지정 할 수 있지만 남용한다면 결국 모두 접근할 수 있게 되어 네임스페이스를 사용하지 않는 것처럼 된다. 네임스페이스 안에 있는 특정 항목만 가리키도록 using을 사용할 수 있다.using std::cout; // 네임스페이스 std 안에 있는 cout만 접두어를 생략하고 다른 std 항목은 생략X중첩된 네임스페이스 중첩된 네임스페이스 네임스페이스 안에 있는 네임스페이스를 의미. C++17에서는 중첩된 네임스페이스를 좀더 쉽게 사용할 수 있다.// 기존 방식namespace MyLibraries{ namespace Networking{ namespace FTP{ /*...*/ } }}// C++17이후namespace MyLibraries::Networking::FTP{ /*...*/}네임스페이스 앨리어스를 사용하면 네임 스페이스의 이름을 다르게 표현하거나 기존 이름을 좀 더 짧게 만들 수 있다//예시namespace ublas = boost::numeric::ublas;ublas::vector&lt;double&gt; v;" }, { "title": "커널오브젝트의 상태", "url": "/posts/%EC%BB%A4%EB%84%90%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8%EC%9D%98%EC%83%81%ED%83%9C/", "categories": "윈도우즈시스템프로그래밍, 운영체제", "tags": "windows", "date": "2022-08-11 00:00:00 +0900", "snippet": "커널 오브젝트의 상태 Windows 운영체제에 의해서 생성되는 커널오브젝트도 두가지 상태를 지님. 리소스에 특정 상황이 발생되었음을 알리기 위한 용도로 사용된다. 커널 오브젝트의 상태 종류 Signaled 상태(신호를 받은 상태) Non-Signaled 상태 (신호를 받지 않은 상태) 커널 오브젝트의 상태는 커널 오브젝트를 구성하는 멤버 변수중 하나가 저장하고 있다.프로세스 커널 오브젝트의 상태에 대한 이해 프로세스 커널 오브젝트는 프로세스 실행 중에는 Non-Signaled 상태로 놓인다. 그러다 프로세스가 종료되면 운영체제에 의해서 자동적으로 Signaled 상태가 된다. 다시 Signaled 상태에서 Non-Signaled 상태로 가는것은 불가능하다. 결국 Non-Signaled 상태가 Signaled 상태로 갔다는 말이 프로세스가 종료되어 없어졌다는 뜻이기 때문 커널 오브젝트의 두가지 상태를 확인하는 용도 커널 오브젝트의 상태 정보를 알아보기 위한 대표적인 함수 WaitForSingleObject //WaitForSingleObject 함수는 커널 오브젝트가 Signaled 상태가 될 때까지 기다리는 함수. DWORD WaitForSingleObject( HANDLE hHandle, // 상태 확인을 원하는 커널 오브젝트의 핸들 DWORD dwMilliseconds // Signaled 상태가 될 때까지 기다릴 수 있는 최대 시간, 상수라면 무한정 기다리게 됨.) WaitForSingleObject 함수의 반환종류 WAIT_OBJECT_0 : 커널 오브젝트가 Signaled 상태가 되었을 때 반환값 WAIT_TIMEOUT : 커널 오브젝트가 dwMilliseconds 인자를 통해서 설정된 시간보다 지났을 때 반환값 WAIT_ABANDONED : 소유 관계와 관련하여 함수가 정상적이지 못한 오류 발생에 의해 반환하는 경우 WaitForMultipleObjects 상태를 확인하고자 하는 커널 오브젝트가 둘 이상이고, 이들의 핸들이 배열로 묶였을 때 사용하는 함수 DWORD WaitForMultipleObjects(DWORD nCount, // 배열에 저장되어 있는 핸들 개수const HANDLE* lpHandles, // 핸들을 저장하고 있는 배열의 시작주소를 전달BOOL bWaitAll, // 관찰 대상이 모두 Signaled 상태가 되기를 기다리면 TRUE , 하나라도 Signaled 상태가 되기를 기다리면 FALSEDWORD dwMilliseconds // 최대 시간) 커널 오브젝트의 상태 확인이 필요한 상황의 연출 두개의 자식 프로세스를 생성해서 각각 1부터 5까지, 그리고 6부터 10까지 덧셈을 시킨다음 반환하고 부모 프로세스는 반환한 값을 더해서 그 결과를 출력하는 형태의 예제 자식 프로세스 코드#include &lt;stdio.h&gt;#include &lt;windows.h&gt;#include &lt;tchar.h&gt;int _tmain(int argc, TCHAR* argv[]){ if(argc!=3) return -1; DWORD start=_ttoi(argv[1]); DWORD end=_ttoi(argv[2]); DWORD total=0; for(DWORD i=start; i&lt;=end; i++) total+=i; return total;} 커널 오브젝트에 존재하는 종료코드 프로세스의 return이 종료되는 프로세스의 커널 오브젝트에 저장되므로이 값을 통해 부모 프로세스가 자식 프로세스의 total값을 알 수 있다. 부모 프로세스가 GetExitCodeProcess 함수 호출을 통해 자식 프로세스의 종료코드 (return값) 를 알 수 있다. 부모 프로세스 코드 #include &lt;stdio.h&gt;#include &lt;windows.h&gt;#include &lt;tchar.h&gt;int _tmain(int argc, TCHAR* argv[]){ STARTUPINFO si1={0,}; STARTUPINFO si2={0,}; PROCESS_INFORMATION pi1; PROCESS_INFORMATION pi2; DWORD return_val1; DWORD return_val2; TCHAR command1[]=_T(\"PartAdder.exe 1 5\"); TCHAR command2[]=_T(\"PartAdder.exe 6 10\"); DWORD sum=0; si1.cb=sizeof(si1); si2.cb=sizeof(si2);CreateProcess(NULL, command1, NULL,NULL,TRUE, 0,NULL,NULL, &amp;si1,&amp;pi1); //CreateProcess 1CreateProcess(NULL,command2, NULL,NULL,TRUE, 0,NULL,NULL, &amp;si2,&amp;pi2); //CreateProcess 2CloseHandle(pi1.hThread);CloseHandle(pi2.hThread);GetExitCodeProcess(pi1.hProcess, &amp;return_val1);GetExitCodeProcess(pi2.hProcess, &amp;return_val2);if(return_val1==-1 || return_val2==-1) return -1; //비정상적 종료sum+=return_val1;sum+=return_val2;_tprintf(_T(\"total : %d \\n\"), sum);CloseHandle(pi1.hProcess);CloseHandle(pi2.hProcess); return 0;} 위의 코드를 실행하게 되면 1부터 10까지의 합인 55가 출력되지 않고 엉뚱한 값이 출력된다. 그 이유는 GetExitCodeProcess함수가 호출되기 이전에 두개의 자식 프로세스가연산결과에 해당하는 종료코드를 반환하고 종료하지 못했기 때문 해결 하기 위해서는 GetExitCodeProcess 함수가 호출되기 전에 WaitForSingleObject 함수로(최대 시간은 상수값) 자식프로세스가 종료 될 때까지 기다려야 함. " }, { "title": "Normal Mapping", "url": "/posts/Normal_Mapping/", "categories": "DirectX3D", "tags": "directx3d", "date": "2022-08-11 00:00:00 +0900", "snippet": "노멀 매핑 (Normal Mapping) 상대적으로 적은 수의 폴리곤(Low-poly)으로 구성된 3D 모델 표면에 마치 많은 폴리곤(High-poly)으로 만들어진 것처럼 세밀한 요철과 질감을 표현하는 컴퓨터 그래픽 기술 실제 지오메트리를 변경하지 않고, 빛의 반사를 조작하여 시각적으로 디테일을 추가 핵심 원리1. 노멀 맵 텍스처 (Normal Map Texture) 노멀 맵은 각 텍셀(texel)이 표면의 법선 벡터(Normal Vector) 방향 정보를 담고 있는 특수한 텍스처 이 법선 벡터의 X, Y, Z 성분은 주로 텍스처의 R, G, B 채널에 각각 매핑되어 저장. 일반적으로 X, Y는 -1에서 +1 범위, Z는 0에서 +1 범위의 값을 0-255 범위로 변환하여 저장 이 법선 벡터는 대부분 탄젠트 공간(Tangent Space)을 기준으로 정의2. 탄젠트 공간 (Tangent Space) 각 정점(vertex) 또는 표면의 특정 지점에서 정의되는 국소적인 3차원 좌표계 주로 세 개의 축으로 구성 법선 (Normal - N): 표면에 수직인 방향 (원래 지오메트리의 법선). 탄젠트 (Tangent - T): 표면에 접하면서 주로 텍스처의 U 좌표 방향과 일치하는 벡터. 바이노멀 (Binormal / Bitangent - B): 법선(N)과 탄젠트(T)에 모두 수직인 벡터 (N과 T의 외적으로 계산 가능), 주로 텍스처의 V 좌표 방향과 일치. 노멀 맵에 저장된 법선 벡터는 이 탄젠트 공간을 기준으로 “위쪽”(파란색 계열, (0,0,1)에 해당)을 향하는 것이 일반적3. 계산 과정정점 셰이더 (Vertex Shader) 모델의 정점 데이터로부터 법선(N), 탄젠트(T), 바이노멀(B) 벡터를 가져와 월드 공간 또는 뷰 공간으로 변환. 바이노멀은 N과 T로부터 계산할 수도 있음 이 세 벡터를 사용하여 TBN 행렬(탄젠트 공간에서 월드/뷰 공간으로 변환하는 행렬)을 만들거나, 반대로 광원 방향과 시선 방향 같은 벡터들을 탄젠트 공간으로 변환하여 픽셀 셰이더로 전달픽셀 셰이더 (Pixel Shader) 노멀 맵 텍스처에서 현재 픽셀에 해당하는 탄젠트 공간 법선 벡터를 샘플링 샘플링된 값(보통 0~1 범위)을 원래의 벡터 범위(-1~1)로 변환 예: normal_ts = sampledColor.rgb * 2.0 - 1.0; 옵션 A (탄젠트 공간 조명 계산): 월드/뷰 공간의 광원 방향과 시선 방향을 TBN 행렬의 역행렬(또는 전치행렬, TBN이 직교한다면)을 사용하여 탄젠트 공간으로 변환. 그런 다음, 노멀 맵에서 읽은 탄젠트 공간 법선을 사용하여 조명 계산(난반사, 정반사 등)을 수행 옵션 B (월드/뷰 공간 조명 계산): 노멀 맵에서 읽은 탄젠트 공간 법선을 TBN 행렬을 사용하여 월드 공간 또는 뷰 공간으로 변환. 그런 다음, 월드/뷰 공간의 광원 방향, 시선 방향, 그리고 변환된 법선을 사용하여 조명 계산을 수행 정점 데이터 요구 사항 Vertex_Data 노멀 매핑을 사용하려면 정점 데이터에 다음 정보가 포함되어야 함 위치 (Position) 텍스처 좌표 (Texture Coordinates - UV) 법선 (Normal) 탄젠트 (Tangent) (선택적) 바이노멀/바이탄젠트 (Binormal/Bitangent) 탄젠트와 법선으로부터 계산 가능 탄젠트와 바이노멀 벡터는 모델링 도구나 전처리 과정에서 생성HLSL 구현 예시 (픽셀 셰이더 중심) Shader_Example// 정점 셰이더 출력 / 픽셀 셰이더 입력 구조체struct PS_INPUT{ float4 positionH : SV_Position; float2 texCoord : TEXCOORD0; float3 normal_ws : NORMAL0; // 월드 공간 법선 (원래 지오메트리) float3 tangent_ws : TANGENT0; // 월드 공간 탄젠트 // float3 binormal_ws : BINORMAL0; // 필요시 바이노멀도 전달 (또는 픽셀 셰이더에서 계산) float3 position_ws : POSITION0; // 월드 공간 위치};// 텍스처 및 샘플러Texture2D normalMapTexture : register(t1); // 노멀 맵 텍스처SamplerState linearSampler : register(s0);// 상수 버퍼 (예: 광원 정보, 카메라 위치)cbuffer LightParams : register(b1){ float3 lightDirection_ws; // 월드 공간에서의 광원 방향 (방향성 광원 예시) float3 eyePosition_ws; // 월드 공간에서의 카메라 위치 // ... 기타 조명 파라미터 ...};float4 PS_NormalMapping(PS_INPUT input) : SV_Target{ // 1. 노멀 맵에서 탄젠트 공간 법선 샘플링 및 변환 float3 normal_ts_from_map = normalMapTexture.Sample(linearSampler, input.texCoord).rgb; normal_ts_from_map = normalize(normal_ts_from_map * 2.0f - 1.0f); // [0,1] 범위를 [-1,1] 범위로 // 2. TBN 행렬 구성 또는 필요한 벡터들을 탄젠트 공간으로 변환 float3 N_ws = normalize(input.normal_ws); float3 T_ws = normalize(input.tangent_ws - dot(input.tangent_ws, N_ws) * N_ws); // Gram-Schmidt 과정으로 T를 N에 직교하게 만듦 float3 B_ws = normalize(cross(N_ws, T_ws)); // 바이노멀 계산 (탄젠트와 법선의 외적) // TBN 행렬 (탄젠트 공간 -&gt; 월드 공간 변환용) float3x3 TBN_ws = float3x3(T_ws, B_ws, N_ws); // 또는 월드 공간 -&gt; 탄젠트 공간 변환용 TBN 행렬 (위 행렬의 전치) // float3x3 worldToTangentSpace = transpose(TBN_ws); // 옵션 A: 탄젠트 공간에서 조명 계산 // float3 lightDir_ts = mul(normalize(lightDirection_ws), worldToTangentSpace); // float3 viewDir_ts = mul(normalize(eyePosition_ws - input.position_ws), worldToTangentSpace); // float3 finalNormal_ts = normal_ts_from_map; // ... finalNormal_ts, lightDir_ts, viewDir_ts로 조명 계산 ... // 옵션 B: 노멀 맵의 법선을 월드 공간으로 변환하여 조명 계산 (더 일반적) float3 finalNormal_ws = normalize(mul(normal_ts_from_map, TBN_ws)); // 3. 월드 공간에서 조명 계산 (예: 간단한 디퓨즈) float3 lightDir_ws_norm = normalize(lightDirection_ws); // 방향성 광원은 방향 자체가 주어짐 float diffuseFactor = saturate(dot(finalNormal_ws, -lightDir_ws_norm)); // 광원을 향하는 방향으로 계산 float3 baseColor = float3(0.8f, 0.8f, 0.8f); // 임시 기본 색상 float3 finalColor = baseColor * diffuseFactor; return float4(finalColor, 1.0f);}장점 시각적 디테일 향상: 적은 폴리곤으로도 매우 디테일한 표면 질감을 표현할 수 있어, 모델링 및 렌더링 비용을 절감 성능 효율성: 실제 지오메트리를 늘리는 것보다 훨씬 적은 연산량과 메모리를 사용고려사항 실루엣(Silhouette) 불변: 노멀 매핑은 빛의 반사만을 조작하므로, 모델의 외곽선(실루엣)은 원래의 저폴리곤 메시 형태를 그대로 따름. 외곽선까지 변화시키려면 변위 매핑(Displacement Mapping)과 같은 기법이 필요함 탄젠트 공간 정밀도: 탄젠트, 바이노멀 벡터 계산 및 보간 시 정밀도 문제가 발생할 수 있으며, 이는 노멀 매핑 결과에 영향을 줄 수 있음. 예: MikkTSpace와 같은 표준화된 탄젠트 생성 방식 사용 노멀 맵 압축: 노멀 맵은 보통 X, Y 성분만 저장하고 Z 성분은 sqrt(1 - x*x - y*y)로 복원하는 방식(BC5/3Dc 압축 포맷 등)으로 압축하여 메모리를 절약하기도 함" }, { "title": "전처리기", "url": "/posts/%EC%A0%84%EC%B2%98%EB%A6%AC%EA%B8%B0/", "categories": "C++", "tags": "C++", "date": "2022-08-11 00:00:00 +0900", "snippet": "전처리기 단계 C++로 작성된 소스코드를 프로그램으로 만드는 빌드 작업은 세단계로 전처리 단계에서는 소스 코드에 담긴 메타 정보를 처리한다. 이어서 컴파일 단계에서는 소스코드를 머신이 읽을 수 있는 오브젝트(목적)파일로 변환한다. 마지막 링크 단계에서는 앞에서 변환한 여러 오브젝트 파일을 애플리케이션으로 엮는다. 지시자 지시자란 전처리기에 전달할 사항을 표현하며 #문자로 시작함 흔히 사용하는 #include도 지시자중 하나로 헤더 파일에 있는 내용을 현재 파일에서 사용할 수 있게 모두 가져오도록 전처리기에 지시 헤더 파일은 주로 나중에 소스 파일에서 구현할 함수를 선언하는 용도 함수 선언부는 함수의 호출방식, 매개변수의 개수와 타입, 리턴 타입 등만 컴파일러에 알려주고, 그 함수가 실제로 수행할 동작은 구현부(defenition)에서 작성함. 결론: C++에서 선언은 확장자가 .h인 헤더파일에 작성하고, 구현은 확장자가 .cpp인 소스파일에서 작성 iostream 헤더파일은 c++에서 제공하는 입력 및 출력 메커니즘을 선언. 전처리 지시자 표 전처리지시자 기능 사용 예 #include [파일] 지정한 파일의 내용을 지시자 위치에 넣는다. 다른 곳에 정의된 함수를 사용할 목적으로 해당 함수의 선언문이 담긴 헤더파일을 가져옴 #define [키] [값] 코드에서 ‘키’에 해당하는 부분을 값으로 바꿈 상숫값,매크로 정의 #ifdef [키]#endif#ifndef [키]#endif ‘키’가 #define문으로 정의 됐는지에 따라 포함하거나 제외 주로 인클루드 문장이 중복해서 추가되는것을 방지 #pragma [xyz] xyz에 대한 동작은 컴파일러마다 다름,주로 경고 or 에러메세지 밑에 예제 중복 인클루드를 막는 용도 1. #ifndef MYHEADER_H #define MYHEADER_H //... 헤더 파일에 담을 내용 #endif 2. 위와 같은 표현 #pragma once // ... 헤더 파일에 담을 내용C와 C++ 확장자C의 표준 라이브러리의 헤더파일은 대부분 .h를 사용하고 네임스페이스를 사용하지 않음반면 C++의 표준 라이브러리는 .h를 생략하고 std 네임스페이스 또는 std 하위 네임스페이스 아래에 정의함C에서 사용하던 표준 라이브러리 헤더를 C++에서도 사용하는데 형태가 다름. 새로 제공되는 권장버전은 접두어c가 붙음 예전버전은 .h 그대로 사용" }, { "title": "프로세스간 통신", "url": "/posts/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EA%B0%84%ED%86%B5%EC%8B%A0/", "categories": "윈도우즈시스템프로그래밍, 운영체제", "tags": "windows", "date": "2022-08-10 00:00:00 +0900", "snippet": "IPC IPC는 Inter-Process Communication의 약자로서 프로세스 사이의 통신라는 뜻을 가진다. 프로세스들이 서로 통신한다는 것은 둘 이상의 프로세스가 데이터를 주고 받는 행위라고 할 수 있다. 프로세스 사이에서 통신이 이뤄지기 위한 조건 프로세스들이 서로 만날 수 없는 이유 프로세스들은 각자 자기의 영역(데이터,힙,스택,코드)을 가지고 있다. 그렇기에 프로세스들은 자신에게 할당된 메모리 공간 이외에는 접근이 불가능 프로세스들이 서로 만나지 못하게 디자인한 이유 만약 프로세스가 자신에게 할당된 메모리 공간 이외의 다른 영역에 접근이 가능하게 만들었다면, 프로세스가 서로에게 영향을 끼치면서 안전성이 낮아지기 때문에 접근하지 못하게 만듦.메일슬롯 방식의 IPC Mail Slot 프로세스끼리 서로 데이터를 주고 받기 위한 공간 데이터를 전달하고자 하는 프로세스를 Sender(발송인) 데이터를 수신하는 프로세스를 가리켜 Receiver(수신인) Mail Slot의 구성1 - Receiver Receiver는 데이터를 받을 메일슬롯을 생성한다HANDLE CreateMailslot(LPCTSTR lpName,                 // 메일슬롯 주소DWORD nMaxMessageSize,    // 메일슬롯의 버퍼 크기DWORD lReadTimeout,            // 최대 블로킹 시간(밀리 세컨드로 단위를 지정)LPSECURITY_ATTRIBUTES lpSecurityAttributes, // 핸들 상속 여부};반환타입은 커널 오브젝트의 핸들로 메일슬롯도 커널에 의해서 관리되는 리소스이기 때문에 커널 오브젝트가 생성되고, 이 커널 오브젝트의 핸들이 반환됨 메일슬롯을 읽기 위한 ReadFile 함수BOOL ReadFile(HANDLE hFile, // 해당 메일슬롯에 존재하는 데이터를 읽어들인다LPCVOID lpBuffer,    // 읽어 들인 데이터를 저장할 버퍼 지정하는 용도DWORD nNumberOfBytesToWrite,       // 읽어 들일 데이터의 최대 크기 지정  LPDWORD lpNumberOfBytesWritten,    // 함수 호출 완료 후 읽어 들인 실제 데이터의 크기를 바이트 단위로 얻기 위한 변수의 주소 지정LPOVERLAPPED lpOverlapped          );2 -Sender Receiver이 만들어 놓은 메일슬롯의 주소를 알아야 한다. 메일슬롯은 파일이 아니지만 메일슬롯은 Windows 파일 시스템을 기반으로 구현되어 있기 때문에 파일 입출력 함수를 사용하여 데이터를 주고받는다. 메일슬롯 생성을 위한 CreateFile 함수 HANDLE CreateFile(LPCTSTR lpFileName,       // 개방(open)할 파일 이름DWORD dwDesiredAccess,    // 읽기/쓰기 모드를 지정한다.or (l) 연산으로 결합 가능하다.⦁ GENERIC_READ : 읽기 모드⦁ GENERIC_WRITE : 쓰기 모드DWORD dwShareMode,        // 파일 공유방식 ⦁ 0 : 다른 프로세스에 절대 공유 불가. 이미 개방된 파일은 중복 개방 불가⦁ FILE_SHARE_READ : 다른 프로세스에서 이 파일에 동시 읽기 접근 가능⦁ FILE_SHARE_WRITE : 다른 프로세스에서 이파일에 동시 쓰기 접근 가능,단 동시에 같은 영역에 데이터를 쓰는 문제를 피해야 한다.LPSECURITY_ATTRIBUTES lpSecurityAttributes, // 보안 속성DWORD dwCreationDisposition,    // 파일의 생성되는 방법을 지정⦁ CREATE_ALWAYS : 항상 새 파일을 생성⦁ CREATE_NEW : 새 파일 생성, 같은 이름의 파일이 존재하면 생성 실패⦁ OPEN_ALWAYS : 기존 파일 개방. 없으면 새로 생성⦁ OPEN_EXISTING : 기존 파일 개방, 존재하지 않으면 함수 호출 실패TRUNCATE_EXISTING : 기존 파일의 내용 지우고 개방.DWORD dwFlagsAndAttributes,    // 파일의 특성 정보를 설정 (기본적 FILE_ATTRIBUTE_NORMAL 사용)HANDLE hTemplateFile             // 기존에 존재하는 파일과 동일한 특성을 가지는 새 파일을 만들때 사용); 메일슬롯에 데이터 전송을 위한 WriteFile 함수BOOL WriteFile(HANDLE hFile,             // 데이터를 읽어 들일 파일을 지정(Mail Slot)LPCVOID lpBuffer,             // 전송할 데이터가 저장되어 있는 버퍼 지정DWORD nNumberOfBytesToWrite,    // 전송할 데이터 크기를 지정한다  LPDWORD lpNumberOfBytesWritten, // 함수 호출 완료 후 전송된 실제 데이터의 크기를 바이트 단위로 얻기 위한 변수의 주소 지정LPOVERLAPPED lpOverlapped        );메일 슬롯의 고찰 메일 슬롯은 단반향 통신이기 때문에 한쪽 방향으로만 메세지를 전달한다. 두 프로세스가 서로 메세지를 주고 받기 위한 채팅프로그램을 구현하려면 두개의 메일슬롯을 생성해야한다. 양쪽 방향으로 메세지를 주고 받는 IPC기법도 있다. Anonymouse 파이프 Named 파이프 메일슬롯은 브로드캐스팅 방식의 통신을 지원한다( 하나의 Sender로 한번에 여러 Receiver에게 메세지를 동시에 전송할 수 있음.) 로컬 컴퓨터를 가리키는 “.”을 모든 컴퓨터를 의미하는 “*“로 변경해줘야 하고 MailReceiver의 컴퓨터들은 네트워크로 연결되어 있어야 테스트가 가능하다." }, { "title": "CubeMesh && SphereMesh", "url": "/posts/CubeMesh-&&-SphereMesh/", "categories": "DirectX3D", "tags": "directx3d", "date": "2022-08-10 00:00:00 +0900", "snippet": "큐브 메시 (Cube Mesh) 큐브는 6개의 면을 가진 정육면체. 각 면은 사각형이며, 두 개의 삼각형으로 구성큐브 메시의 정점 구성 단순히 생각하면 큐브는 8개의 고유한 꼭짓점을 가짐 하지만, 각 면(face)이 고유한 법선 벡터(normal vector)를 가져야 하고, 텍스처 UV 좌표가 면마다 다르게 매핑될 수 있기 때문에, 각 면에 속한 정점들은 별도로 정의하는 것이 일반적 이렇게 하면 각 면의 평평한 셰이딩(flat shading)이 가능해지고, 텍스처를 각 면에 올바르게 입힐 수 있음 큐브는 6개의 면을 가지고, 각 면은 4개의 정점으로 구성되므로, 총 6 * 4 = 24개의 정점이 필요 각 정점은 위치(Position), 색상(Color), UV 좌표(Texture Coordinate), 법선(Normal) 등의 정보를 가짐정점 데이터 정의 (C++ 예시) 다음은 24개의 정점을 정의하는 코드의 일부입니다. 각 면(윗면, 아랫면, 왼쪽, 오른쪽, 뒷면, 앞면)마다 4개의 정점이 있으며, 각 정점은 해당 면의 법선 벡터를 가짐// (Vtx 구조체는 이전 메시 생성 가이드의 정의를 따른다고 가정)// struct Vtx { Vec3 vPos; Vec4 vColor; Vec2 vUV; Vec3 vNormal; /* Vec3 vTangent, vBinormal; */ };std::vector&lt;Vtx&gt; vecVertices;Vtx v;float halfSize = 0.5f; // 큐브의 한 변 길이의 절반// 윗면 (Y = +halfSize, Normal = (0, 1, 0))v.vPos = Vec3(-halfSize, halfSize, halfSize); v.vColor = Vec4(1,1,1,1); v.vUV = Vec2(0,0); v.vNormal = Vec3(0,1,0); vecVertices.push_back(v); // 0v.vPos = Vec3( halfSize, halfSize, halfSize); v.vColor = Vec4(1,1,1,1); v.vUV = Vec2(1,0); v.vNormal = Vec3(0,1,0); vecVertices.push_back(v); // 1v.vPos = Vec3( halfSize, halfSize, -halfSize); v.vColor = Vec4(1,1,1,1); v.vUV = Vec2(1,1); v.vNormal = Vec3(0,1,0); vecVertices.push_back(v); // 2v.vPos = Vec3(-halfSize, halfSize, -halfSize); v.vColor = Vec4(1,1,1,1); v.vUV = Vec2(0,1); v.vNormal = Vec3(0,1,0); vecVertices.push_back(v); // 3// 아랫면 (Y = -halfSize, Normal = (0, -1, 0)) - UV 좌표는 윗면과 동일하게 설정하거나 다르게 할 수 있음v.vPos = Vec3(-halfSize, -halfSize, -halfSize); v.vColor = Vec4(1,0,0,1); v.vUV = Vec2(0,0); v.vNormal = Vec3(0,-1,0); vecVertices.push_back(v); // 4v.vPos = Vec3( halfSize, -halfSize, -halfSize); v.vColor = Vec4(1,0,0,1); v.vUV = Vec2(1,0); v.vNormal = Vec3(0,-1,0); vecVertices.push_back(v); // 5v.vPos = Vec3( halfSize, -halfSize, halfSize); v.vColor = Vec4(1,0,0,1); v.vUV = Vec2(1,1); v.vNormal = Vec3(0,-1,0); vecVertices.push_back(v); // 6v.vPos = Vec3(-halfSize, -halfSize, halfSize); v.vColor = Vec4(1,0,0,1); v.vUV = Vec2(0,1); v.vNormal = Vec3(0,-1,0); vecVertices.push_back(v); // 7// 왼쪽 면 (X = -halfSize, Normal = (-1, 0, 0))v.vPos = Vec3(-halfSize, halfSize, halfSize); v.vColor = Vec4(0,1,0,1); v.vUV = Vec2(0,0); v.vNormal = Vec3(-1,0,0); vecVertices.push_back(v); // 8v.vPos = Vec3(-halfSize, halfSize, -halfSize); v.vColor = Vec4(0,1,0,1); v.vUV = Vec2(1,0); v.vNormal = Vec3(-1,0,0); vecVertices.push_back(v); // 9v.vPos = Vec3(-halfSize, -halfSize, -halfSize); v.vColor = Vec4(0,1,0,1); v.vUV = Vec2(1,1); v.vNormal = Vec3(-1,0,0); vecVertices.push_back(v); // 10v.vPos = Vec3(-halfSize, -halfSize, halfSize); v.vColor = Vec4(0,1,0,1); v.vUV = Vec2(0,1); v.vNormal = Vec3(-1,0,0); vecVertices.push_back(v); // 11// 오른쪽 면 (X = +halfSize, Normal = (1, 0, 0))v.vPos = Vec3( halfSize, halfSize, -halfSize); v.vColor = Vec4(0,0,1,1); v.vUV = Vec2(0,0); v.vNormal = Vec3(1,0,0); vecVertices.push_back(v); // 12v.vPos = Vec3( halfSize, halfSize, halfSize); v.vColor = Vec4(0,0,1,1); v.vUV = Vec2(1,0); v.vNormal = Vec3(1,0,0); vecVertices.push_back(v); // 13v.vPos = Vec3( halfSize, -halfSize, halfSize); v.vColor = Vec4(0,0,1,1); v.vUV = Vec2(1,1); v.vNormal = Vec3(1,0,0); vecVertices.push_back(v); // 14v.vPos = Vec3( halfSize, -halfSize, -halfSize); v.vColor = Vec4(0,0,1,1); v.vUV = Vec2(0,1); v.vNormal = Vec3(1,0,0); vecVertices.push_back(v); // 15// 뒷면 (Z = +halfSize, Normal = (0, 0, 1)) - UV 방향은 보는 방향에 따라 조정v.vPos = Vec3( halfSize, halfSize, halfSize); v.vColor = Vec4(1,1,0,1); v.vUV = Vec2(0,0); v.vNormal = Vec3(0,0,1); vecVertices.push_back(v); // 16v.vPos = Vec3(-halfSize, halfSize, halfSize); v.vColor = Vec4(1,1,0,1); v.vUV = Vec2(1,0); v.vNormal = Vec3(0,0,1); vecVertices.push_back(v); // 17v.vPos = Vec3(-halfSize, -halfSize, halfSize); v.vColor = Vec4(1,1,0,1); v.vUV = Vec2(1,1); v.vNormal = Vec3(0,0,1); vecVertices.push_back(v); // 18v.vPos = Vec3( halfSize, -halfSize, halfSize); v.vColor = Vec4(1,1,0,1); v.vUV = Vec2(0,1); v.vNormal = Vec3(0,0,1); vecVertices.push_back(v); // 19// 앞면 (Z = -halfSize, Normal = (0, 0, -1)) - UV 방향은 보는 방향에 따라 조정v.vPos = Vec3(-halfSize, halfSize, -halfSize); v.vColor = Vec4(1,0,1,1); v.vUV = Vec2(0,0); v.vNormal = Vec3(0,0,-1); vecVertices.push_back(v); // 20v.vPos = Vec3( halfSize, halfSize, -halfSize); v.vColor = Vec4(1,0,1,1); v.vUV = Vec2(1,0); v.vNormal = Vec3(0,0,-1); vecVertices.push_back(v); // 21v.vPos = Vec3( halfSize, -halfSize, -halfSize); v.vColor = Vec4(1,0,1,1); v.vUV = Vec2(1,1); v.vNormal = Vec3(0,0,-1); vecVertices.push_back(v); // 22v.vPos = Vec3(-halfSize, -halfSize, -halfSize); v.vColor = Vec4(1,0,1,1); v.vUV = Vec2(0,1); v.vNormal = Vec3(0,0,-1); vecVertices.push_back(v); // 23 UV 좌표: 위 예시에서는 각 면의 UV를 (0,0), (1,0), (1,1), (0,1) (또는 유사한 방식)로 설정하여 해당 면 전체에 텍스처가 매핑되도록 해야 함. 원본 코드의 모든 UV가 (0,0)인 것은 텍스처링 시 문제가 됨. 여기서는 예시로 각 면의 첫 번째 정점을 (0,0)으로 시작하도록 표현. 실제 텍스처 아틀라스나 UV 언래핑 방식에 따라 조정이 필요 법선 벡터: 각 면의 법선은 해당 면이 바라보는 방향을 나타냄 (예: 윗면은 (0,1,0), 앞면은 (0,0,-1) - 왼손 좌표계 기준). 인덱스 데이터 정의 (C++ 예시) 각 면(4개의 정점으로 구성된 사각형)은 두 개의 삼각형으로 나뉨. 총 6개의 면이 있으므로 12개의 삼각형이 필요하며, 각 삼각형은 3개의 인덱스를 가지므로 총 36개의 인덱스가 필요 이 인덱스 순서(와인딩 순서)는 컬링(culling) 및 법선 방향에 중요. Direct3D는 기본적으로 시계 방향(CW)을 앞면으로 간주 std::vector&lt;UINT&gt; vecIndices;for (int i = 0; i &lt; 6; ++i) // 6개의 면에 대해 반복{ UINT baseIndex = i * 4; // 각 면의 시작 정점 인덱스 // 첫 번째 삼각형 (예: 0-1-2) vecIndices.push_back(baseIndex + 0); vecIndices.push_back(baseIndex + 1); vecIndices.push_back(baseIndex + 2); // 두 번째 삼각형 (예: 0-2-3) vecIndices.push_back(baseIndex + 0); vecIndices.push_back(baseIndex + 2); vecIndices.push_back(baseIndex + 3);}구 메시 (Sphere Mesh) 구 메시는 극점(pole)과 위도선(stack, 수평 링), 경도선(slice, 수직 분할)을 이용하여 생성구 메시의 원리1. 극점 정의 구의 가장 위쪽(북극)과 가장 아래쪽(남극)에 정점을 하나씩 정의2. 스택(Stack) 생성 북극과 남극 사이에 여러 개의 수평 원형 선(스택 또는 링)을 만듦. 각 스택은 특정 위도에 해당 3. 슬라이스(Slice) 분할 각 스택(링)을 여러 개의 수직 선분(슬라이스)으로 나누어 정점들을 생성. 각 슬라이스는 특정 경도에 해당 4. 삼각형 구성 극점과 첫 번째/마지막 스택의 정점들을 연결하여 부채꼴 모양의 삼각형들을 만듦 인접한 스택 사이의 정점들을 연결하여 사각형 띠를 만들고, 각 사각형을 두 개의 삼각형으로 나눔 법선 벡터: 원점이 중심인 구의 표면에서 특정 정점의 법선 벡터는 원점에서 해당 정점을 향하는 방향 벡터를 정규화한 것과 같음 (normalize(vertexPosition)). 정점 데이터 정의 (C++ 예시)std::vector&lt;Vtx&gt; vecVertices;std::vector&lt;UINT&gt; vecIndices;Vtx v;float fRadius = 0.5f;UINT iStackCount = 20; // 구를 감싸는 수평 링의 개수 (극점 제외)UINT iSliceCount = 20; // 각 링을 구성하는 수직 분할 개수// 1. 북극점 (Top Pole)v.vPos = Vec3(0.0f, fRadius, 0.0f);v.vColor = Vec4(1.f, 1.f, 1.f, 1.f);v.vUV = Vec2(0.5f, 0.0f); // UV 좌표의 상단 중앙v.vNormal = Vec3(0.f, 1.f, 0.f);// (구의 경우 탄젠트/바이노멀은 조금 더 복잡하게 계산되거나, 셰이더에서 필요시 생성)// 간단한 예시: v.vTangent = Vec3(1.f, 0.f, 0.f); v.vBinormal = Vec3(0.f, 0.f, 1.f);vecVertices.push_back(v);// 2. 몸통 (Body Stacks and Slices)float phiStep = XM_PI / (float)(iStackCount + 1); // 극점에서 극점까지의 각도 단계float thetaStep = XM_2PI / (float)iSliceCount; // 한 바퀴를 도는 각도 단계for (UINT i = 1; i &lt;= iStackCount; ++i) // 스택 루프 (북극 바로 아래부터 남극 바로 위까지){ float phi = i * phiStep; // 현재 스택의 수직 각도 (Y축 기준) for (UINT j = 0; j &lt;= iSliceCount; ++j) // 슬라이스 루프 (한 바퀴 + 중복 정점 1개_UV 끊김 처리용) { float theta = j * thetaStep; // 현재 슬라이스의 수평 각도 // 구면 좌표계를 사용하여 정점 위치 계산 v.vPos.x = fRadius * sinf(phi) * cosf(theta); v.vPos.y = fRadius * cosf(phi); v.vPos.z = fRadius * sinf(phi) * sinf(theta); v.vColor = Vec4(1.f, 1.f, 1.f, 1.f); v.vUV = Vec2(theta / XM_2PI, phi / XM_PI); // (j / iSliceCount, i / (iStackCount+1)) v.vNormal = normalize(v.vPos); // 원점 중심 구의 법선은 위치 벡터 정규화 // 탄젠트, 바이노멀 계산 (정확한 계산은 셰이더 또는 모델링 도구에서) // 예시: (phi에 대한 편미분 -&gt; 탄젠트, theta에 대한 편미분 -&gt; 바이노멀 근사) // v.vTangent = Vec3(-fRadius * sinf(phi) * sinf(theta), 0, fRadius * sinf(phi) * cosf(theta)); // v.vTangent.Normalize(); // v.vBinormal = cross(v.vNormal, v.vTangent); // 오른손 좌표계 기준, 또는 반대 // v.vBinormal.Normalize(); vecVertices.push_back(v); }}// 3. 남극점 (Bottom Pole)v.vPos = Vec3(0.0f, -fRadius, 0.0f);v.vColor = Vec4(1.f, 1.f, 1.f, 1.f);v.vUV = Vec2(0.5f, 1.0f); // UV 좌표의 하단 중앙v.vNormal = Vec3(0.f, -1.f, 0.f);// v.vTangent = Vec3(1.f, 0.f, 0.f); v.vBinormal = Vec3(0.f, 0.f, -1.f);vecVertices.push_back(v);인덱스 데이터 정의 (C++ 예시) UV 좌표 및 중복 정점: 구의 몸통 부분에서 각 링(스택)의 시작점과 끝점은 3D 공간에서는 동일한 위치이지만, 텍스처 UV 좌표에서는 U값이 0과 1로 달라야 텍스처가 올바르게 감싸짐. 이를 위해 각 링마다 iSliceCount + 1개의 정점을 생성하고, j가 0부터 iSliceCount까지 반복 인덱싱: 극점, 몸통, 다른 극점을 연결하는 인덱스를 정확히 계산하는 것이 중요. 정점 배열의 인덱스 오프셋을 주의 깊게 다뤄야 함 // 1. 북극 캡 인덱스 구성// 첫 번째 정점(vecVertices[0])이 북극점for (UINT j = 0; j &lt; iSliceCount; ++j){ vecIndices.push_back(0); // 북극점 vecIndices.push_back(j + 2); // 첫 번째 링의 (j+1)번째 정점 vecIndices.push_back(j + 1); // 첫 번째 링의 j번째 정점}// 2. 몸통 인덱스 구성// 각 스택 링은 (iSliceCount + 1)개의 정점을 가짐 (UV 끊김 처리를 위해 시작점 중복)for (UINT i = 0; i &lt; iStackCount - 1; ++i) // 스택 링 사이를 연결{ for (UINT j = 0; j &lt; iSliceCount; ++j) { // 현재 링의 시작 인덱스: 1 (북극점 다음) + i * (iSliceCount + 1) // 다음 링의 시작 인덱스: 1 (북극점 다음) + (i + 1) * (iSliceCount + 1) UINT currentRowStart = 1 + i * (iSliceCount + 1); UINT nextRowStart = 1 + (i + 1) * (iSliceCount + 1); // 사각형을 두 개의 삼각형으로 나눔 // 삼각형 1: (현재 링 j, 다음 링 j, 다음 링 j+1) vecIndices.push_back(currentRowStart + j); vecIndices.push_back(nextRowStart + j); vecIndices.push_back(nextRowStart + j + 1); // 삼각형 2: (현재 링 j, 다음 링 j+1, 현재 링 j+1) vecIndices.push_back(currentRowStart + j); vecIndices.push_back(nextRowStart + j + 1); vecIndices.push_back(currentRowStart + j + 1); }}// 3. 남극 캡 인덱스 구성// 마지막 정점(vecVertices.back() 또는 vecVertices[vecVertices.size()-1])이 남극점UINT bottomPoleIndex = (UINT)vecVertices.size() - 1;// 마지막 링의 시작 인덱스: 1 (북극점 다음) + (iStackCount - 1) * (iSliceCount + 1)UINT lastRingStartIndex = 1 + (iStackCount - 1) * (iSliceCount + 1);for (UINT j = 0; j &lt; iSliceCount; ++j){ vecIndices.push_back(bottomPoleIndex); // 남극점 vecIndices.push_back(lastRingStartIndex + j); // 마지막 링의 j번째 정점 vecIndices.push_back(lastRingStartIndex + j + 1); // 마지막 링의 (j+1)번째 정점}" }, { "title": "3D Lighting", "url": "/posts/3DLighting/", "categories": "DirectX3D", "tags": "directx3d", "date": "2022-08-10 00:00:00 +0900", "snippet": "3D 조명 (3D Lighting) - HLSL 퐁 셰이딩 퐁 모델은 각 픽셀의 최종 색상을 계산하기 위해 다음 세 가지 주요 광원 요소를 조합1. 주변광 (Ambient Lighting) 장면 전체에 고르게 분산되어 모든 물체에 영향을 미치는 기본적인 빛 직접적인 광원이 없어도 물체가 완전히 검게 보이지 않도록 하며, 간접광(벽이나 다른 물체에 반사되어 들어오는 빛)을 간략하게 표현 계산 : Ambient = ObjectBaseColor * LightAmbientColor2. 난반사광 (Diffuse Lighting) 광원에서 나온 빛이 물체 표면에 부딪혀 여러 방향으로 고르게 흩어지는 반사 표면의 거칠기에 따라 발생하며, 보는 방향에 관계없이 표면이 광원을 향한 각도에 따라 밝기가 달라짐 (램버시안 반사 모델, Lambertian Reflectance). 계산 : Diffuse = ObjectBaseColor * LightDiffuseColor * saturate(dot(Normal, LightDirection))3. 정반사광 (Specular Lighting) 광원에서 나온 빛이 거울처럼 매끄러운 표면에 반사되어 특정 방향으로 강하게 빛나는 하이라이트(반짝임) 이 반사는 보는 사람의 시점 방향, 표면의 법선 벡터, 그리고 광원의 방향에 따라 크게 달라짐 계산: Specular = LightSpecularColor * pow(saturate(dot(ReflectionDirection, EyeDirection)), ShininessFactor)4. FinalColor 이 세 가지 요소를 합산하여 최종 픽셀 색상을 결정합니다 FinalColor = Ambient + Diffuse + SpecularHLSL 셰이더 구현 단계 퐁 조명 모델을 HLSL 셰이더로 구현하는 과정은 주로 정점 셰이더(Vertex Shader)와 픽셀 셰이더(Pixel Shader)에서 이뤄짐1. 정점 셰이더 (Vertex Shader) 정점 셰이더는 각 정점의 위치를 변환하고, 픽셀 셰이더에서 조명 계산에 필요한 데이터(예: 월드/뷰 공간에서의 위치, 법선 벡터, 텍스처 좌표 등)를 준비하여 전달역할 모델의 정점 위치를 로컬 공간에서 클립 공간으로 변환 (월드 변환 -&gt; 뷰 변환 -&gt; 투영 변환). 법선 벡터를 월드 공간 또는 뷰 공간으로 변환 (조명 계산 기준 공간에 맞춰서 변환). 텍스처 좌표 및 기타 필요한 정점 속성을 픽셀 셰이더로 보간(interpolate)될 수 있도록 전달.입력 구조체 정점 데이터struct VTX_IN{ float3 vPos : POSITION; // 정점의 로컬 위치 float2 vUV : TEXCOORD0; // 텍스처 UV 좌표 float3 vNormal : NORMAL; // 정점의 로컬 법선 벡터 // 노멀 매핑 등을 위해 추가될 수 있는 데이터 // float3 vTangent : TANGENT; // float3 vBinormal : BINORMAL;};출력 구조체 픽셀 셰이더로 전달될 보간될 데이터struct VTX_OUT{ float4 vClipPos : SV_Position; // 클립 공간에서의 정점 위치 (필수 출력) float3 vWorldPos : POSITION0; // 월드 공간에서의 정점 위치 (조명 계산용) float3 vWorldNormal: NORMAL0; // 월드 공간에서의 법선 벡터 (조명 계산용) float2 vUV : TEXCOORD0; // 텍스처 UV 좌표 // 뷰 공간 조명을 선호한다면 vViewPos, vViewNormal 등을 전달 // float3 vViewPos : POSITION1; // float3 vViewNormal : NORMAL1;};HLSL 코드 예시 (VS_Std3D)// 상수 버퍼 (C++에서 설정)cbuffer CB_Transformations : register(b0){ matrix g_matWorld; // 월드 변환 행렬 matrix g_matView; // 뷰 변환 행렬 matrix g_matProjection; // 투영 변환 행렬};VTX_OUT VS_Std3D(VTX_IN _in){ VTX_OUT output = (VTX_OUT)0.0f; // 1. 위치 변환 float4 worldPos = mul(float4(_in.vPos, 1.0f), g_matWorld); output.vWorldPos = worldPos.xyz; float4 viewPos = mul(worldPos, g_matView); output.vClipPos = mul(viewPos, g_matProjection); // 또는 WVP 행렬을 한 번에 곱함: // matrix WVP = mul(mul(g_matWorld, g_matView), g_matProjection); // output.vClipPos = mul(float4(_in.vPos, 1.0f), WVP); // 2. 법선 벡터 변환 (월드 공간으로) // 월드 행렬에 비균등 스케일링이 없다면 g_matWorld의 3x3 부분만 사용 가능. // 비균등 스케일링이 있다면 월드 행렬의 역전치 행렬(inverse transpose)의 3x3 부분을 사용해야 함. // 여기서는 간단히 월드 행렬의 3x3 부분으로 변환한다고 가정. output.vWorldNormal = normalize(mul(_in.vNormal, (float3x3)g_matWorld)); // 3. UV 좌표 전달 output.vUV = _in.vUV; return output;}2. 픽셀 셰이더 (Pixel Shader) 픽셀 셰이더는 래스터라이저에 의해 보간된 각 픽셀의 속성(월드 위치, 월드 법선, UV 등)을 입력받아, 최종 색상을 계산역할 텍스처에서 물체의 기본 색상(알베도)을 샘플링. 각 광원에 대해 주변광, 난반사광, 정반사광 기여도를 계산. 모든 광원의 기여도를 합산하여 최종 픽셀 색상 결정.입력 구조체 (PS_IN, 전역 변수 및 상수 버퍼) 정점 셰이더의 출력 구조체(VTX_OUT)와 동일한 멤버 및 시맨틱을 가짐// 텍스처 및 샘플러Texture2D g_texDiffuse : register(t0);SamplerState g_samplerLinear : register(s0);// 재질 정보 상수 버퍼cbuffer CB_Material : register(b1){ float4 g_materialAmbientColor; float4 g_materialDiffuseColor; // 텍스처 사용 시 이 값은 기본 색상 승수로 사용될 수 있음 float4 g_materialSpecularColor; float g_materialShininess;};// 광원 정보 상수 버퍼 (배열로 여러 광원 처리 가능)struct Light{ float4 ambient; float4 diffuse; float4 specular; float3 position_ws; // 점 광원/스포트라이트용 월드 공간 위치 int lightType; // 0: Directional, 1: Point, 2: Spot float3 direction_ws;// 방향성 광원/스포트라이트용 월드 공간 방향 float spotAngle; // 스포트라이트 내부 원뿔 각도 (코사인 값) float range; // 점 광원/스포트라이트 도달 범위 float spotExponent;// 스포트라이트 감쇠 지수 float3 attenuation; // 감쇠 계수 (constant, linear, quadratic) - x,y,z // bool enabled;};cbuffer CB_Lights : register(b2){ Light g_lights[MAX_LIGHTS]; // MAX_LIGHTS는 애플리케이션에서 정의 int g_numLights; float3 g_eyePosition_ws; // 카메라(시점)의 월드 공간 위치};HLSL// (위의 상수 버퍼 및 구조체 선언이 있다고 가정)float4 PS_Std3D(VTX_OUT _in) : SV_Target{ // 1. 물체 기본 색상 결정 (텍스처 또는 재질 색상) float4 objectBaseColor = g_materialDiffuseColor; // if (텍스처 사용 플래그) // { // objectBaseColor = g_texDiffuse.Sample(g_samplerLinear, _in.vUV); // } // 텍스처가 있다면 곱해주는 방식도 가능: objectBaseColor *= g_texDiffuse.Sample(g_samplerLinear, _in.vUV); // 2. 법선 정규화 (보간 과정에서 길이가 1이 아닐 수 있음) float3 normal_ws = normalize(_in.vWorldNormal); // 3. 최종 합산될 색상 초기화 (주변광은 기본적으로 적용) float3 finalColor = objectBaseColor.rgb * g_materialAmbientColor.rgb * g_lights[0].ambient.rgb; // 예시로 0번 광원의 주변광 사용 또는 전역 주변광 사용 // 4. 각 광원에 대해 난반사 및 정반사 계산 for (int i = 0; i &lt; g_numLights; ++i) { // 현재 광원 정보 가져오기 Light currentLight = g_lights[i]; // 빛의 방향 계산 및 정규화 float3 lightDir_ws; float lightDistance = 0.0f; // 점/스포트 라이트용 거리 float attenuation = 1.0f; // 감쇠 계수 if (currentLight.lightType == 0) // 방향성 광원 { lightDir_ws = normalize(-currentLight.direction_ws); // 광원을 향하는 방향 } else // 점 광원 또는 스포트라이트 { float3 toLight_ws = currentLight.position_ws - _in.vWorldPos; lightDistance = length(toLight_ws); lightDir_ws = normalize(toLight_ws); // 거리 감쇠 계산 if (lightDistance &lt; currentLight.range) { // 1 / (att.x + att.y * dist + att.z * dist^2) attenuation = 1.0f / (currentLight.attenuation.x + currentLight.attenuation.y * lightDistance + currentLight.attenuation.z * lightDistance * lightDistance); attenuation = saturate(attenuation); // 0~1 사이로 제한 } else { attenuation = 0.0f; // 범위 밖이면 빛이 도달하지 않음 } } // 감쇠가 0이면 더 이상 계산할 필요 없음 if (attenuation &lt;= 0.001f) continue; // 난반사광(Diffuse) 계산 float diffuseFactor = saturate(dot(normal_ws, lightDir_ws)); float3 diffuseColor = currentLight.diffuse.rgb * diffuseFactor * objectBaseColor.rgb * g_materialDiffuseColor.rgb; // 정반사광(Specular) 계산 float3 specularColor = float3(0.0f, 0.0f, 0.0f); if (diffuseFactor &gt; 0.0f) // 빛이 표면에 닿는 경우에만 정반사 계산 { float3 viewDir_ws = normalize(g_eyePosition_ws - _in.vWorldPos); // 시점 방향 float3 reflectDir_ws = reflect(-lightDir_ws, normal_ws); // 반사 방향 // 또는 Blinn-Phong 모델: // float3 halfwayDir_ws = normalize(lightDir_ws + viewDir_ws); // float specularFactor = pow(saturate(dot(normal_ws, halfwayDir_ws)), g_materialShininess); float specularFactor = pow(saturate(dot(viewDir_ws, reflectDir_ws)), g_materialShininess); specularColor = currentLight.specular.rgb * specularFactor * g_materialSpecularColor.rgb; } // 스포트라이트 효과 (lightType == 2 인 경우) if (currentLight.lightType == 2) // 스포트라이트 { float spotEffect = dot(normalize(-currentLight.direction_ws), -lightDir_ws); // 광원 방향과 실제 빛 방향 내적 if (spotEffect &gt; currentLight.spotAngle) // spotAngle은 cos(내부 원뿔 각도/2) { // 원뿔 내부, 감쇠 계산 (부드러운 가장자리를 위해 pow 사용) spotEffect = pow(saturate((spotEffect - currentLight.spotAngle) / (1.0f - currentLight.spotAngle)), currentLight.spotExponent); // 또는 간단히: spotEffect = pow(saturate(spotEffect), currentLight.spotExponent); } else { spotEffect = 0.0f; // 원뿔 바깥 } attenuation *= spotEffect; } // 최종 색상에 현재 광원의 기여도 추가 (감쇠 적용) finalColor += (diffuseColor + specularColor) * attenuation; } return float4(finalColor, objectBaseColor.a); // 최종 계산된 RGB와 물체의 알파 값}" }, { "title": "Output Merger", "url": "/posts/OutputMerger/", "categories": "DirectX", "tags": "directx", "date": "2022-07-10 00:00:00 +0900", "snippet": "출력 병합기 (Output Merger - OM) 출력 병합기(Output Merger, OM) 단계는 DirectX 그래픽스 렌더링 파이프라인의 거의 마지막 단계 이 단계는 픽셀 셰이더(Pixel Shader)에서 처리된 픽셀 조각(fragment)들의 최종 색상과 깊이 값을 받아, 현재 바인딩된 렌더 타겟(Render Target) 및 깊이/스텐실 버퍼(Depth/Stencil Buffer)와 병합하는 역할 OM 단계는 최종적으로 화면에 어떤 픽셀이 그려질지, 그리고 여러 픽셀 정보가 겹칠 때 어떻게 혼합될지를 결정 이 단계에서 깊이 테스트, 스텐실 테스트, 그리고 색상 블렌딩이 수행 출력 병합기의 주요 작업 및 기능깊이 테스트 (Depth Test / Z-Test)목적 3D 공간에서 어떤 물체가 다른 물체 뒤에 가려지는지(오클루전, Occlusion)를 판별하여, 보이지 않는 픽셀이 그려지는 것을 막음작동 방식 현재 처리 중인 픽셀 조각의 깊이 값(래스터라이저에서 보간되었거나 픽셀 셰이더에서 SV_Depth로 출력된 값)과, 깊이 버퍼의 같은 위치에 이미 저장된 깊이 값을 비교 비교 함수(예: LESS, LESS_EQUAL, GREATER 등)에 따라 테스트를 수행 예를 들어, LESS_EQUAL로 설정된 경우, 새 픽셀의 깊이가 기존 깊이보다 작거나 같으면 테스트를 통과 테스트를 통과하면 새 픽셀의 색상이 렌더 타겟에 기록될 수 있으며, 설정에 따라 새 픽셀의 깊이 값으로 깊이 버퍼가 업데이트 테스트를 실패하면 해당 픽셀 조각은 버려짐 제어 ID3D11DepthStencilState 객체와 D3D11_DEPTH_STENCIL_DESC 구조체의 DepthEnable, DepthWriteMask, DepthFunc 멤버를 통해 제어됨스텐실 테스트 (Stencil Test)목적 픽셀 단위로 렌더링을 제한하거나 특정 효과(예: 아웃라인, 그림자 볼륨, 미러, 포탈, 특정 영역 마스킹)를 만들기 위해 사용되는 고급 기법입니다.작동 방식 스텐실 버퍼(일반적으로 깊이 버퍼와 함께 생성됨)는 픽셀당 보통 8비트의 정수 값을 저장 애플리케이션은 기준 값(Reference Value)을 설정하고, 스텐실 테스트를 통과(또는 실패)하거나 깊이 테스트를 통과(또는 실패)했을 때 스텐실 버퍼의 값을 어떻게 업데이트할지(예: 증가, 감소, 0으로 설정, 유지) 지정할 수 있음 비교 함수(예: EQUAL, NOT_EQUAL, ALWAYS)를 사용하여 현재 픽셀의 스텐실 값과 기준 값을 비교하여 테스트를 수행 테스트를 실패하면 해당 픽셀 조각은 버려질 수 있음 제어 ID3D11DepthStencilState 객체와 D3D11_DEPTH_STENCIL_DESC 구조체의 StencilEnable 및 앞면/뒷면에 대한 StencilReadMask, StencilWriteMask, FrontFace (스텐실 연산), BackFace (스텐실 연산) 멤버들을 통해 제어됩니다.블렌딩 (Blending)목적 반투명 객체 표현, 색상 혼합 효과(예: 빛 효과 추가, 색상 곱하기), 안티에일리어싱 등 다양한 시각적 효과를 위해 픽셀 셰이더에서 나온 색상(원본 색상, Source Color)과 렌더 타겟에 이미 있는 색상(대상 색상, Destination Color)을 혼합작동 방식 깊이 및 스텐실 테스트를 통과한 픽셀에 대해 수행됨 (또는 이 테스트들이 비활성화된 경우). 혼합 공식은 일반적으로 다음과 같다: FinalColor = (SourceColor * SourceBlendFactor) BlendOp (DestinationColor * DestinationBlendFactor) BlendOp: 혼합 연산 (예: ADD, SUBTRACT, MIN, MAX) SourceBlendFactor, DestinationBlendFactor: 혼합 계수 (예: SRC_ALPHA, INV_SRC_ALPHA, ONE, ZERO) 제어 ID3D11BlendState 객체와 D3D11_BLEND_DESC 구조체의 BlendEnable, SrcBlend, DestBlend, BlendOp 등의 멤버를 통해 각 렌더 타겟별로 개별적인 블렌딩 설정을 할 수 있음.렌더 타겟 쓰기 (Render Target Writes) 위의 모든 테스트와 블렌딩 작업이 완료되면, 최종 계산된 픽셀 색상 값이 현재 바인딩된 하나 이상의 렌더 타겟(ID3D11RenderTargetView)에 기록됨 DirectX 11은 다중 렌더 타겟(Multiple Render Targets, MRT)을 지원하여, 하나의 픽셀 셰이더 실행으로 동시에 여러 렌더 타겟에 다른 데이터를 출력할 수 있습니다 (예: 디퓨즈 색상, 월드 노멀, 스페큘러 강도 등을 각각 다른 텍스처에 저장 - 지연 렌더링(Deferred Rendering)에 활용). 논리 연산 (Logic Operations - 선택 사항) 블렌딩 대신, 픽셀 셰이더의 출력 값과 렌더 타겟의 기존 값 사이에 비트 단위 논리 연산(AND, OR, XOR 등)을 수행할 수 있습니다. 흔히 사용되지는 않음. ID3D11BlendState의 RenderTarget[i].LogicOpEnable 및 LogicOp 멤버로 제어합니다.순서 없는 접근 뷰 (UAV) 작업 렌더 타겟과 함께 UAV가 출력 병합기 단계에 바인딩될 수 있음 주로 픽셀 셰이더에서 UAV에 쓰기 위한 고급 기법 이 경우, 픽셀 셰이더가 UAV에 기록한 데이터가 이 단계에서 최종적으로 처리될 수 있음상태 객체 (State Objects) 를 통한 제어 출력 병합기 단계의 동작은 주로 다음과 같은 상태 객체들에 의해 결정 ID3D11DepthStencilState: 깊이 테스트와 스텐실 테스트의 활성화 여부, 비교 함수, 쓰기 마스크, 스텐실 연산 등을 정의함. (D3D11_DEPTH_STENCIL_DESC 구조체로 생성) ID3D11BlendState: 색상 및 알파 블렌딩의 활성화 여부, 혼합 연산, 혼합 계수, 논리 연산 등을 정의함. (D3D11_BLEND_DESC 구조체로 생성) C++ 설정 간략1.렌더 타겟 뷰(RTV) 및 깊이/스텐실 뷰(DSV) 생성 스왑 체인의 백 버퍼로부터 RTV를 생성하거나, 별도의 텍스처로부터 RTV/DSV를 생성2.상태 객체 생성 D3D11_DEPTH_STENCIL_DESC를 채우고 ID3D11Device::CreateDepthStencilState()를 호출하여 ID3D11DepthStencilState 객체를 만듦 D3D11_BLEND_DESC를 채우고 ID3D11Device::CreateBlendState()를 호출하여 ID3D11BlendState 객체를 만듭니다.3.파이프라인에 상태 설정 (ID3D11DeviceContext 사용) OMSetRenderTargets() 또는 OMSetRenderTargetsAndUnorderedAccessViews(): 현재 사용할 RTV(들)와 DSV를 바인딩함 OMSetDepthStencilState(): 생성한 깊이/스텐실 상태 객체를 설정. 두 번째 인자로 스텐실 참조 값을 전달할 수 있음. OMSetBlendState(): 생성한 블렌드 상태 객체를 설정. 블렌드 팩터(blend factor)와 샘플 마스크(sample mask)도 인자로 전달할 수 있습니다. 결론 출력 병합기(OM) 단계는 렌더링 파이프라인의 최종 관문과 같다. 픽셀 셰이더에서 계산된 수많은 픽셀 후보들이 이곳에서 최종적으로 검증(깊이/스텐실 테스트)되고 혼합(블렌딩)되어, 우리가 화면에서 보는 최종 이미지를 형성합니다. 이 단계의 설정을 통해 매우 다양한 시각적 효과와 렌더링 최적화를 달성할 수 있다. " }, { "title": "연산자", "url": "/posts/%EC%97%B0%EC%82%B0%EC%9E%90/", "categories": "C++", "tags": "C++", "date": "2022-07-09 00:00:00 +0900", "snippet": "연산자 연산을 수행하기 위한 기호을 의미하고, 피연산자는 연산을 행해지는 대상을 의미한다. 산술 연산자 + : 왼쪽항에 오른쪽항을 더한다 - : 왼쪽항에 오른쪽항을 뺀다 * : 왼쪽항에 오른쪽항을 곱한다 / : 왼쪽항에 오른쪽항을 나눈다 % : 왼쪽항에 오른쪽항을 나눈 나머지 대입 연산자 = : 왼쪽항에 오른쪽항을 대입 += : 왼쪽항과 오른쪽항을 더한 값을 왼쪽항에 대입 -= : 왼쪽항과 오른쪽항의 뺀 값을 왼쪽항에 대입 *= : 왼쪽항과 오른쪽항의 값을 곱한 값을 왼쪽항에 대입 /= : 왼쪽항에 오른쪽항을 나눈 값을 왼쪽항에 대입 %= : 왼쪽항에 오른쪽항을 나누고 난후의 나머지를 왼쪽항에 대입 증감 연산자 x++ : 연산을 진행한 후에 x의 값에 1을 더한다 ++x : x의 값에 1을 더한 후에 연산을 진행한다 x– : 연산을 진행한 후에 x의 값에 1을 뺀다 –x : x의 값에 1을 뺀 후에 연산을 진행한다 연산자 우선순위연산자에서도 수학에서 +보다 *가 먼저 계산하듯이 우선순위가 있다. 연산자의 우선순위&lt;p align=\"center\"&gt;출처: https://blcan.tistory.com/16여기서 말하는 연산자 결합법칙의 의미는 연산자의 우선순위가 같을 때 연산자의 진행방향을 뜻한다" }, { "title": "Pixel Shader", "url": "/posts/Pixel-Shader/", "categories": "DirectX", "tags": "directx", "date": "2022-07-06 00:00:00 +0900", "snippet": "픽셀 셰이더 (Pixel Shader - PS) / 프래그먼트 셰이더 (Fragment Shader) DirectX 렌더링 파이프라인에서 프로그래밍 가능한 핵심 셰이더 스테이지 중 하나 (OpenGL과 Vulkan에서는 프래그먼트 셰이더(Fragment Shader)라고도 불림 이 단계는 래스터라이저(Rasterizer) 단계 이후, 그리고 출력 병합기(Output Merger) 단계 이전에 위치주요 역할 래스터라이저가 생성한 각 픽셀 조각(fragment) 또는 픽셀 후보(pixel candidate)의 최종 색상(및 선택적으로 깊이 값)을 계산 \"픽셀\"이라는 용어는 약간 오해의 소지가 있는데, 이 단계에서 처리되는 것은 아직 최종적으로 화면의 픽셀이 되기 전의 후보들이며, 이후 깊이/스텐실 테스트 등에 의해 버려질 수도 있음 픽셀 셰이더의 입력 (Inputs) 픽셀 셰이더는 다음과 같은 주요 입력들을 받음보간된 정점 속성 (Interpolated Vertex Attributes) 래스터라이저 단계에서 각 픽셀 위치에 맞게 보간된 값들 이는 이전 셰이더 스테이지(정점 셰이더, 도메인 셰이더, 또는 지오메트리 셰이더)의 출력 구조체와 일치하는 시맨틱(Semantic)을 가진 입력 구조체를 통해 전달받음 예: 텍스처 좌표 (TEXCOORD0), 정점 색상 (COLOR0), 월드 공간 위치 (WORLDPOS), 법선 벡터 (NORMAL) 등. 시스템 생성 값 (System-Generated Values) 파이프라인에 의해 자동으로 생성되는 값들 예: SV_Position (픽셀의 화면 공간 XY 좌표와 깊이 Z, 동차 W 값), SV_IsFrontFace (현재 픽셀이 기본 도형의 앞면에 속하는지 여부). 전역 변수 및 리소스 (Global Variables and Resources) 상수 버퍼(Constant Buffers)로부터 전달된 균일 변수(uniform variables) 텍스처(Textures) - 셰이더 리소스 뷰(SRV)와 샘플러 상태(SamplerState)를 통해 접근.(고급 기법) 순서 없는 접근 뷰(UAV) - 제한적인 읽기 접근.픽셀 셰이더의 주요 작업 및 기능 픽셀 셰이더 내에서는 각 픽셀의 최종 모습을 결정하기 위한 다양한 연산이 수행텍스처 샘플링 (Texture Sampling)보간된 텍스처 좌표와 샘플러 상태를 사용하여 텍스처로부터 색상이나 기타 데이터(예: 법선 맵, 스페큘러 맵)를 읽어옵니다.조명 계산 (Lighting Calculations) 픽셀 단위 조명(Per-Pixel Lighting)을 수행하여 훨씬 부드럽고 사실적인 명암 효과를 만듭니다. 보간된 법선 벡터, 광원의 정보(방향, 색상, 강도), 재질의 속성(반사율, 거칠기 등)을 사용하여 퐁(Phong), 블린-퐁(Blinn-Phong), 물리 기반 렌더링(PBR) 모델 등 다양한 조명 모델을 구현합니다.색상 계산 및 혼합 (Color Calculation and Combination) 텍스처에서 샘플링한 색상, 조명 계산 결과, 정점에서 보간된 색상, 재질 고유색 등을 조합하여 해당 픽셀의 최종 색상을 결정특수 효과 (Special Effects) 법선 매핑 (Normal Mapping) / 범프 매핑 (Bump Mapping): 표면의 미세한 요철을 표현하여 디테일을 높임 시차 매핑 (Parallax Mapping): 법선 매핑보다 더 향상된 깊이감을 제공 안개 (Fog): 거리에 따라 물체의 색상을 안개 색과 혼합 투명도 처리 (Transparency): 알파 값을 계산하여 이후 출력 병합기에서 블렌딩될 수 있도록 함 알파 테스팅 (Alpha Testing): 알파 값을 기준으로 특정 임계값보다 낮은 픽셀을 폐기(discard)깊이 값 수정 (Depth Value Modification - 선택 사항) 일반적으로 래스터라이저가 보간한 깊이 값을 사용하지만, 픽셀 셰이더에서 SV_Depth 시맨틱을 사용하여 픽셀의 깊이 값을 직접 출력할 수도 있습니다 (주의해서 사용해야 함).픽셀 폐기 (Pixel Discarding) HLSL의 discard 명령어를 사용하여 현재 처리 중인 픽셀 조각의 모든 처리를 중단하고, 렌더 타겟에 아무것도 쓰지 않도록 함. 주로 알파 테스팅이나 복잡한 모양의 클리핑에 사용 픽셀 셰이더의 출력 (Outputs) 일반적으로 float4 타입의 최종 색상 값을 하나 이상 출력 단일 렌더 타겟을 사용할 경우: SV_Target 또는 SV_Target0 시맨틱에 할당. 다중 렌더 타겟(Multiple Render Targets, MRT)을 사용할 경우: SV_Target0, SV_Target1, …, SV_TargetN 시맨틱에 각각 다른 색상 값을 출력 가능. 선택적으로 float 타입의 깊이 값을 SV_Depth 시맨틱에 출력할 수 있음 (DirectX 11.1 이상, 특정 조건 하) UAV가 바인딩되어 있다면, 픽셀 셰이더에서 UAV에 데이터를 쓸 수도 있음HLSL 예시: 간단한 텍스처 샘플링 및 출력// 입력 리소스Texture2D diffuseTexture : register(t0); // 디퓨즈 텍스처 (SRV)SamplerState linearSampler : register(s0); // 선형 필터링 샘플러// Vertex Shader에서 전달받는 입력 구조체struct PS_INPUT{ float4 position : SV_Position; // 화면 공간 위치 (픽셀 셰이더에서는 주로 XY 사용) float2 texCoord : TEXCOORD0; // 보간된 텍스처 좌표 float3 normal_ws : NORMAL; // 보간된 월드 공간 법선 (조명 계산용)};// Pixel Shader 메인 함수// SV_Target 시맨틱은 이 함수의 반환 값이 렌더 타겟 0번으로 출력됨을 의미float4 MyPixelShader(PS_INPUT input) : SV_Target{ // 1. 텍스처에서 기본 색상 샘플링 float4 baseColor = diffuseTexture.Sample(linearSampler, input.texCoord); // 2. 간단한 앰비언트 + 디렉셔널 라이팅 (예시) float3 ambientColor = float3(0.1f, 0.1f, 0.1f); float3 lightDirection = normalize(float3(0.5f, 1.0f, -0.5f)); // 고정된 광원 방향 float3 lightColor = float3(1.0f, 1.0f, 1.0f); // 흰색 광원 // 디퓨즈 반사율 계산 (램버시안 모델) float diffuseIntensity = saturate(dot(input.normal_ws, -lightDirection)); float3 diffuseColor = lightColor * diffuseIntensity * baseColor.rgb; // 최종 색상 = 앰비언트 + 디퓨즈 float3 finalColor = ambientColor + diffuseColor; return float4(finalColor, baseColor.a); // 최종 색상과 원본 텍스처의 알파 값 반환}C++ 설정 간략1단계 HLSL로 작성된 픽셀 셰이더 코드를 컴파일하여 ID3DBlob 객체(바이트코드)를 얻음.2단계 ID3D11Device::CreatePixelShader() 함수를 사용하여 컴파일된 바이트코드로부터 ID3D11PixelShader 객체를 생성3단계 렌더링 시 ID3D11DeviceContext::PSSetShader() 함수로 현재 사용할 픽셀 셰이더를 파이프라인에 설정4단계 필요한 리소스(상수 버퍼, SRV, 샘플러)를 PSSetConstantBuffers(), PSSetShaderResources(), PSSetSamplers() 함수로 바인딩 슬롯에 연결결론 픽셀 셰이더는 최종 이미지의 시각적 품질을 결정짓는 매우 중요한 단계로, 현대 그래픽스에서 다양한 시각 효과를 구현하는 핵심적인 역할을 담당" }, { "title": "래스터라이저 단계", "url": "/posts/%EB%9E%98%EC%8A%A4%ED%84%B0%EB%9D%BC%EC%9D%B4%EC%A0%80-%EB%8B%A8%EA%B3%84/", "categories": "DirectX", "tags": "directx", "date": "2022-07-04 00:00:00 +0900", "snippet": "래스터라이저 단계 (Rasterizer Stage) DirectX 렌더링 파이프라인에서 중요한 고정 기능(Fixed-Function, 프로그래밍은 불가능하지만 다양한 설정으로 동작 제어 가능) 스테이지 이 단계는 정점 셰이더(Vertex Shader) 및 선택적인 테셀레이션(Tessellation) 또는 지오메트리 셰이더(Geometry Shader) 단계를 거친 후, 그리고 픽셀 셰이더(Pixel Shader) 단계 이전에 위치 주요 역할 래스터라이저의 주요 역할은 3D 공간에 정의된 벡터 기반의 기본 도형(Primitive: 점, 선, 삼각형)들을 2차원 화면에 표시될 개별적인 픽셀(Pixel)들의 집합으로 변환하는 것 이렇게 생성된 픽셀 조각(Fragment) 또는 픽셀 후보(Pixel Candidate)들은 이후 픽셀 셰이더에서 최종 색상 계산을 위해 처리래스터라이저 단계의 주요 기능 및 연산 과정뷰포트 변환 (Viewport Transform) 및 Z-스케일링 (Depth Range / Z-Scaling) 이전 셰이더 단계에서 출력된 정점들의 정규화된 장치 좌표(Normalized Device Coordinates, NDC) (보통 X, Y는 -1에서 +1, Z는 0에서 +1 범위)를 현재 설정된 뷰포트(Viewport)에 맞춰 화면 공간 좌표(픽셀 좌표)로 변환 NDC의 Z 깊이 값(0~1)을 깊이 버퍼(Depth Buffer)가 사용하는 범위(보통 0~1)로 매핑클리핑 (Clipping) 투영 변환에 의해 정의된 시야 절두체(View Frustum) 또는 직교 투영 볼륨 바깥에 있는 기본 도형*(또는 그 일부)을 잘라내거나 폐기 이를 통해 화면에 보이지 않는 지오메트리가 불필요게 처리되는 것을 막음 기본 도형이 절두체와 부분적으로 교차하면, 교차 지점에 새로운 정점들이 생성되어 기본 도형이 잘림기본 도형 셋업 (Primitive Setup / Triangle Setup) 클리핑된 각 기본 도형(주로 삼각형)에 대해 픽셀 생성 및 속성 보간에 필요한 내부 데이터(예: 삼각형 변의 방정식, 면적, 정점 속성의 기울기 등)를 계산면 선별 (Face Culling) 삼각형의 앞면(Front-face) 또는 뒷면(Back-face)을 판별하여 선택적으로 폐기 판별 기준은 주로 화면 공간에서 삼각형 정점들이 감기는 순서(Winding Order: 시계 방향 또는 반시계 방향) 일반적으로 카메라를 등지고 있는 뒷면은 보이지 않으므로 컬링(제거)하여 렌더링 부하를 줄임. (예: D3D11_CULL_BACK) 이 기능은 래스터라이저 상태(Rasterizer State)를 통해 제어픽셀 생성 (Pixel Generation) / 스캔 변환 (Scan Conversion) 화면에 표시될 각 기본 도형(삼각형)이 실제로 어떤 스크린 픽셀들을 덮고 있는지를 결정. 이 과정을 스캔 변환이라고 함 덮고 있는 각 픽셀에 대해 \"픽셀 조각(fragment)\" 또는 \"픽셀 후보(pixel candidate)\"를 생성.속성 보간 (Attribute Interpolation) 각 픽셀 후보에 대해, 해당 픽셀 위치에서의 정점 속성 값들을 계산 이전 셰이더 스테이지(정점 셰이더, 도메인 셰이더, 또는 지오메트리 셰이더)에서 출력된 각 정점의 속성(예: 색상, 텍스처 좌표, 법선 벡터)들은 삼각형 표면 위에서 부드럽게 보간 3D 공간에서의 올바른 시각적 표현을 위해 원근 보정 보간(Perspective-Correct Interpolation)이 주로 사용됨 특히 텍스처 좌표, 색상 등 픽셀 셰이더 입력 준비 래스터라이저는 이렇게 생성되고 보간된 픽셀 데이터(픽셀 위치, 보간된 정점 속성 등)를 픽셀 셰이더의 입력으로 전달할 준비를 함래스터라이저 상태 설정 (Rasterizer State) 래스터라이저 단계의 동작 방식은 ID3D11RasterizerState 객체를 통해 세밀하게 제어할 수 있습니다. 이 상태 객체는 D3D11_RASTERIZER_DESC 구조체를 사용하여 생성D3D11_RASTERIZER_DESC의 주요 멤버 FillMode: 기본 도형의 내부를 채우는 방식을 결정합니다. D3D11_FILL_SOLID: 내부를 채웁니다 (기본값). D3D11_FILL_WIREFRAME: 외곽선만 그립니다. CullMode: 면 선별(컬링) 방식을 결정합니다. D3D11_CULL_NONE: 컬링을 수행하지 않습니다. D3D11_CULL_FRONT: 앞면을 컬링합니다. D3D11_CULL_BACK: 뒷면을 컬링합니다 (가장 일반적). FrontCounterClockwise (BOOL): TRUE이면 반시계 방향으로 감긴 삼각형을 앞면으로 간주합니다. FALSE이면 시계 방향을 앞면으로 간주합니다 (Direct3D의 기본값). DepthBias (INT): 픽셀의 깊이 값에 더해지는 상수 값입니다. Z-파이팅(Z-fighting) 현상을 줄이는 데 사용됩니다. SlopeScaledDepthBias (FLOAT): 픽셀의 깊이 기울기에 따라 스케일링되어 더해지는 값입니다. 역시 Z-파이팅 방지에 사용됩니다. DepthBiasClamp (FLOAT): 깊이 바이어스의 최대 한계값입니다. DepthClipEnable (BOOL): TRUE이면 깊이 값에 따라 근접(near) 및 원거리(far) 클리핑 평면 바깥의 픽셀을 잘라냅니다. 일반적으로 TRUE로 설정합니다. ScissorEnable (BOOL): TRUE이면 씨저 사각형(Scissor Rectangle) 테스트를 활성화합니다. 씨저 사각형 바깥의 픽셀은 폐기됩니다. MultisampleEnable (BOOL): TRUE이면 멀티샘플 안티에일리어싱(MSAA)을 위한 픽셀 커버리지 및 샘플 마스크 계산을 수행합니다. AntialiasedLineEnable (BOOL): TRUE이면 선(line) 기본 도형에 대해 안티에일리어싱을 적용하려고 시도합니다 (알파 블렌딩과 함께 사용될 수 있음).C++ 코드 예시: 래스터라이저 상태 생성// ID3D11Device* pDevice; // 이미 초기화되었다고 가정// ID3D11RasterizerState* pRasterizerState = nullptr;// 1. D3D11_RASTERIZER_DESC 구조체 채우기D3D11_RASTERIZER_DESC rasterDesc = {};rasterDesc.FillMode = D3D11_FILL_SOLID; // 내부 채움rasterDesc.CullMode = D3D11_CULL_BACK; // 뒷면 컬링rasterDesc.FrontCounterClockwise = false; // 시계 방향을 앞면으로 (Direct3D 기본)rasterDesc.DepthBias = 0;rasterDesc.SlopeScaledDepthBias = 0.0f;rasterDesc.DepthBiasClamp = 0.0f;rasterDesc.DepthClipEnable = true;rasterDesc.ScissorEnable = false;rasterDesc.MultisampleEnable = false; // MSAA 사용 안 함 (기본)rasterDesc.AntialiasedLineEnable = false;// 2. ID3D11Device::CreateRasterizerState() 함수로 래스터라이저 상태 객체 생성HRESULT hr = pDevice-&gt;CreateRasterizerState(&amp;rasterDesc, &amp;pRasterizerState);if (FAILED(hr)){ // 에러 처리 // pRasterizerState는 Release() 해야 함 (ComPtr이 아니라면) return;}// 3. 래스터라이저 상태 설정 (렌더링 시)// ID3D11DeviceContext* pImmediateContext; // 이미 초기화되었다고 가정// pImmediateContext-&gt;RSSetState(pRasterizerState);// 사용이 끝난 pRasterizerState는 Release() 해줘야 합니다 (ComPtr이 아니라면).래스터라이저 단계의 출력 래스터라이저 단계의 최종 출력은 다음과 같음 각 기본 도형이 덮고 있는 픽셀들의 집합 (픽셀 후보 또는 프래그먼트). 각 픽셀 후보에 대해 보간된 정점 속성 값들 (예: 텍스처 좌표, 색상, 월드 공간 위치 등). 이 정보들은 다음 단계인 픽셀 셰이더(Pixel Shader)로 전달되어 각 픽셀의 최종 색상을 결정하는 데 사용 래스터라이저 단계는 3D 지오메트리를 2D 픽셀 정보로 변환하는 핵심적인 다리 역할을 하며, 그 설정에 따라 렌더링 결과물의 모습과 성능에 큰 영향을 미침. " }, { "title": "변수", "url": "/posts/%EB%B3%80%EC%88%98/", "categories": "C++", "tags": "C++", "date": "2022-07-04 00:00:00 +0900", "snippet": "변수 데이터(값)를 저장하기 위해 프로그램에 의해 이름을 할당받은 메모리 공간를 의미한다. 변수를 사용하기 위해서는 선언 or 정의를 해야한다. 선언 : 컴파일러가 참조할 식별자와 이름을 알려주는 것 정의 : 식별자와 이름으로부터 코드를 생성하여, 함수가 호출되거나 변수를 사용할 때 생성된 코드를 참조하는것 변수 선언 지정자 변수타입 변수명; ex ) int a; 변수의 자료형 일정 크기(길이)의 메모리에 저장된 정보를 해석하는 방법 변수의 종류 정수형 변수 char형 int형 long형 long long형 실수형 변수 float형 double형 변수 이름규칙 변수의 이름은 영문자(대소문자), 숫자, 언더스코어(_)로만 구성됩니다. 변수의 이름은 숫자로 시작될 수 없습니다. 변수의 이름 사이에는 공백을 포함할 수 없습니다. 변수의 이름으로 C++에서 미리 정의된 키워드(keyword)는 사용할 수 없습니다. 변수 이름의 길이에는 제한이 없습니다. " }, { "title": "라이브러리", "url": "/posts/%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC/", "categories": "C++", "tags": "C++", "date": "2022-07-01 00:00:00 +0900", "snippet": "라이브러리(Library)라이브러리(Library)는 사용할 함수나 데이터를 실행 가능하면서 바이너리 코드화로 묶어놓은 파일을 말한다.보통 헤더파일과 같이 사용하는데 헤더파일은 함수들의 전방 선언역할을 하고 라이브러리는 바이너리 코드로 된 cpp와같은 역할을 한다.라이브러리는 #pragma comment(라이브러리 이름, 경로)의 형태로 #include처럼 사용할 수 있고이 때 프로젝트가 debug 또는 release모드에 따라 라이브러리도 같은 버전을 사용해야 오류가 발생하지 않는다. 그리고 바이너리 코드로 된 라이브러리는 직접 볼 수 없지만 Solution안에 사용할 라이브러리 Project를 넣으면 C++코드 형태의 라이브러리를 볼 수 있다.종류라이브러리의 종류에는 정적 라이브러리(lib)와 동적 라이브러리(dll)가 있다. 정적라이브러리정적 라이브러리는 코드의 집합체를 프로젝트에 넣어 파일안에 붙여넣기 한것처럼 되어 독립적으로 사용할 수 있는 장점이 있지만만약 여러개의 파일을 참조해야 한다면 모든 프로젝트에 넣어줘야 하고 그만큼 파일마다 중첩되는 코드가 늘어나서 그만큼 메모리 공간을 사용하게된다. 동적라이브러리동적 라이브러리는 윈도우 운영체제가 dll 코드들을 저장하는 메모리를 따로 만들어서 사용할 파일과 링크를 하는 형식으로 사용해서보통 범용적으로 사용하는 라이브러리를 만들 때 동적으로 만드는게 유리하다.특징정적 라이브러리는 컴파일된 파일이 lib하나 나오지만 동적 라이브러리는 dll과 lib 두 개의 파일이 나오고여기서 정적과 동적의 lib 파일은 다른 방식으로 작동된다.정적 라이브러리는 컴파일하면 lib파일이 나오고 이 파일안에 바이너리 코드가 전부 들어가 있지만,동적 라이브러리는 dll 파일에 바이너리 코드가 들어가 있고 lib에는 dll에서 사용할 수 있는 함수들에 대한 연결정보가 들어있다.동적 라이브러리동적 라이브러리에서 사용할 함수에는 공개를 해주어야만 다른 파일에서도 사용할 수 있다.함수의 반환타입 앞에 extern “C” _declspec(dllexport)를 붙이면 그 함수를 외부에 공개하겠다는 의미이다.하지만 외부 라이브러리를 사용할 때에는 dllexport가 아닌 dllimport를 사용해줘야만 사용할 수 있다.그래서 이 부분을 매번 함수를 만들 때 dllexport와 dllimport를 내가 수정해야하는 번거로운 일이 생기므로매크로를 이용하여 이부분에 대한 점을 해결할 수 있다.#ifdef DLL_EXPORTS #define DLL __declspec(dllexport) #else #define DLL __declspec(dllimport) #endif 속성이 export라면 dllexport를 출력하고 아니라면 dllimport를 출력한다동적 라이브러리 실시간 링크typedef int (*SUBFUNC)(int, int); HMODULE hModule = LoadLibrary(L\"Dll_debug.dll\"); if (nullptr == hModule) return 0; SUBFUNC pSub = (SUBFUNC)GetProcAddress(hModule, \"Sub\"); int a = pSub(600, 300); FreeLibrary(hModule); 먼저 내가 사용할 함수를 받기위해 반환타입과 매개변수 타입에 맞게 함수포인터(SUBFUNC)를 준비한다.(Delegate) LoadLibrary로 사용할 동적 라이브러리를 HMODULE형에 저장한다. HMODULE형의 변수에 저장하고 만약 없다면 nullptr으로 return시킨다. GetProcAdress에 HMODULE과 함수명을 받아 pSub에 저장한다. pSub는 받아온 함수처럼 사용하면되고 FreeLibrary로 실시간 연결을 해제할 수있다. 실시간 링크를 사용하면 그만큼 이점도 있지만 내가 사용할 함수의 타입,매개변수를 알아야 하고만약 함수가 많아진다면 많은 함수포인터를 준비해서 사용해야한다는 단점이 있다." }, { "title": "지오메트리 단계", "url": "/posts/%EC%A7%80%EC%98%A4%EB%A9%94%ED%8A%B8%EB%A6%AC-%EB%8B%A8%EA%B3%84/", "categories": "DirectX", "tags": "directx", "date": "2022-06-30 00:00:00 +0900", "snippet": "지오메트리 셰이더 (Geometry Shader) DirectX 10에서 처음 도입되어 DirectX 11에서도 사용 가능한 프로그래머블 셰이더 스테이지 렌더링 파이프라인에서 정점 셰이더(Vertex Shader) 또는 테셀레이션 단계(Hull &amp; Domain Shader) 이후, 그리고 래스터라이저(Rasterizer) 단계 이전에 위치 지오메트리 셰이더의 가장 큰 특징은 파이프라인의 다른 셰이더들과 달리 완전한 기본 도형(Primitive: 점, 선, 삼각형) 전체를 입력으로 받는다는 것 이를 바탕으로 지오메트리 셰이더는 다음과 같은 작업을 수행할 수 있음 입력된 기본 도형을 그대로 통과시킴 (Pass-through) 입력된 기본 도형을 수정함 입력된 기본 도형을 폐기(discard)하여 렌더링하지 않음 새로운 기본 도형을 생성하여 출력함 (가장 강력한 기능) 지오메트리 셰이더의 주요 기능 및 활용 사례 지오메트리 셰이더는 기본 도형 단위로 작동하는 특성 덕분에 다양한 효과와 최적화에 활용될 수 있음기본 도형 생성 (Primitive Generation) 포인트 스프라이트/빌보드 (Point Sprites/Billboarding): 정점 하나(점)를 입력받아 카메라를 향하는 사각형(quad)으로 확장하여 파티클이나 작은 2D 이미지를 표현 털/지느러미 생성 (Fur/Fin Generation): 모델의 삼각형 외곽선(edge)이나 표면에서 짧은 선이나 작은 면들을 돌출시켜 털이나 지느러미 같은 효과를 냅니다. 기하학적 외곽선 확장 (Normal Extrusion): 법선 벡터를 따라 정점을 밀어내어 물체의 외곽선을 시각화하거나 디버깅 용도로 사용기본 도형 수정 및 폐기 (Primitive Modification/Discarding) 하나의 기본 도형 스트립(예: 삼각형 스트립)을 여러 개의 개별 기본 도형(예: 독립된 삼각형 리스트)으로 변환 가능 특정 조건에 따라 입력된 기본 도형을 출력하지 않고 폐기하여 지오메트리 수준에서 컬링(culling)을 수행할 수 있습니다.계층적 렌더링 (Layered Rendering) 하나의 드로우콜(Draw Call)로 출력되는 기본 도형들을 텍스처 배열의 다른 슬라이스(slice)나 큐브맵의 다른 면(face)으로 보낼 수 있음 이는 SV_RenderTargetArrayIndex 또는 SV_ViewportArrayIndex 같은 시스템 값 시맨틱을 통해 제어됨기타 활용 그림자 볼륨(Shadow Volume) 생성 (최신 그림자 기법에서는 덜 사용됨) 동적 파티클 시스템에서 각 파티클에 대한 지오메트리 즉석 생성지오메트리 셰이더 입력 (Input) 지오메트리 셰이더는 앞선 파이프라인 단계(정점 셰이더 또는 도메인 셰이더)에서 출력된 정점들로 구성된 하나의 완전한 기본 도형을 입력으로 받음 HLSL에서 입력 기본 도형의 타입은 입력 조립기(Input Assembler)에서 설정된 토폴로지 또는 테셀레이션 스테이지의 출력 토폴로지에 따라 결정됨 점 (Point): Point&lt;VS_OUTPUT_TYPE&gt; inputPoint[1] 선 (Line): Line&lt;VS_OUTPUT_TYPE&gt; inputLine[2] (선분을 구성하는 2개의 정점) 삼각형 (Triangle): Triangle&lt;VS_OUTPUT_TYPE&gt; inputTriangle[3] (삼각형을 구성하는 3개의 정점) 인접성을 포함한 선 (Line with Adjacency): LineAdj&lt;VS_OUTPUT_TYPE&gt; inputLineAdj[4] (선분 정점 2개 + 인접 정점 2개) 인접성을 포함한 삼각형 (Triangle with Adjacency): TriangleAdj&lt;VS_OUTPUT_TYPE&gt; inputTriangleAdj[6] (삼각형 정점 3개 + 인접 정점 3개) 여기서 VS_OUTPUT_TYPE은 이전 셰이더 스테이지의 출력 구조체 타입 또한, 시스템 값 시맨틱인 SV_PrimitiveID를 통해 현재 처리 중인 기본 도형의 ID를 입력받을 수도 있습니다.지오메트리 셰이더 출력 (Output) 지오메트리 셰이더는 0개, 1개, 또는 여러 개의 새로운 기본 도형을 출력할 수 있음. 출력은 스트림 객체(Stream Object)를 통해 이루어지며, 이 객체에 새로운 정점들을 추가(Append)하고, 스트립 형태의 기본 도형일 경우 스트립을 재시작(RestartStrip)할 수 있음출력 스트림 타입 PointStream&lt;GS_OUTPUT_TYPE&gt; LineStream&lt;GS_OUTPUT_TYPE&gt; TriangleStream&lt;GS_OUTPUT_TYPE&gt; GS_OUTPUT_TYPE은 지오메트리 셰이더가 출력할 정점의 구조체 타입이며, 최소한 클립 공간 위치를 나타내는 SV_Position 멤버를 포함해야 함. 이 출력은 래스터라이저 단계의 입력이 됨 HLSL 함수 어트리뷰트 (Attribute) [maxvertexcount(N)]: 필수 어트리뷰트 지오메트리 셰이더의 단일 호출(하나의 입력 기본 도형에 대해)이 출력할 수 있는 최대 정점 수(N)를 지정 이 값은 드라이버가 리소스를 할당하고 최적화하는 데 도움을 줌 HLSL 사용 예시 1.(간단한 삼각형 패스스루) 다음은 입력된 삼각형을 아무런 변경 없이 그대로 통과시키는 간단한 지오메트리 셰이더 예시// Vertex Shader의 출력 / Geometry Shader의 입력 정점 구조체struct VS_OUTPUT{ float4 position : SV_Position; // 클립 공간 위치 float2 texCoord : TEXCOORD0; float3 normal : NORMAL;};// Geometry Shader의 출력 정점 구조체 (여기서는 VS_OUTPUT과 동일)// GS_OUTPUT은 래스터라이저의 입력이 됨struct GS_OUTPUT{ float4 position : SV_Position; float2 texCoord : TEXCOORD0; float3 normal : NORMAL;};// Geometry Shader 함수// 입력: 삼각형 하나 (정점 3개)// 출력: 삼각형 스트림, 최대 3개의 정점 출력 가능[maxvertexcount(3)]void GS_PassThrough(triangle VS_OUTPUT inputTriangle[3], // 입력 삼각형의 정점 배열 inout TriangleStream&lt;GS_OUTPUT&gt; outputStream){ GS_OUTPUT outputVertex; for (uint i = 0; i &lt; 3; ++i) { // 입력 정점 데이터를 그대로 출력 정점 데이터로 복사 outputVertex.position = inputTriangle[i].position; outputVertex.texCoord = inputTriangle[i].texCoord; outputVertex.normal = inputTriangle[i].normal; // 출력 스트림에 정점 추가 outputStream.Append(outputVertex); } // 삼각형 스트립을 사용한다면 여기서 새 스트립 시작 // outputStream.RestartStrip(); // 이 예제는 단일 삼각형이므로 필요 X}HLSL 사용 예시 2.포인트 스프라이트 (빌보드)struct VS_OUTPUT_POINT{ float4 centerW : POSITION0; // 월드 공간에서의 중심점 float2 size : SIZE0; // 빌보드의 크기 (가로, 세로)};struct GS_OUTPUT_BILLBOARD{ float4 positionH : SV_Position; // 클립 공간 위치 float2 texCoord : TEXCOORD0;};// 상수 버퍼 (뷰, 투영 행렬)cbuffer CameraParams : register(b0){ matrix viewMatrix; matrix projectionMatrix;};[maxvertexcount(4)] // 사각형은 4개의 정점void GS_CreateBillboard(point VS_OUTPUT_POINT inputPoint[1], inout TriangleStream&lt;GS_OUTPUT_BILLBOARD&gt; outputStream){ float3 centerW = inputPoint[0].centerW.xyz; float2 size = inputPoint[0].size; // 카메라의 월드 공간 위치 (뷰 행렬의 역행렬에서 추출하거나 따로 전달) // 간단하게 하기 위해 여기서는 카메라가 Y축을 Up으로 하고 원점에서 Z축 음의 방향을 본다고 가정 // 실제 빌보드는 뷰 행렬을 사용하여 카메라를 향하도록 축을 계산해야 함 // 빌보드 사각형의 4개 코너 오프셋 (로컬) float3 offsets[4] = { float3(-0.5f * size.x, 0.5f * size.y, 0.0f), // 좌상 float3( 0.5f * size.x, 0.5f * size.y, 0.0f), // 우상 float3(-0.5f * size.x,-0.5f * size.y, 0.0f), // 좌하 float3( 0.5f * size.x,-0.5f * size.y, 0.0f) // 우하 }; // 텍스처 좌표 float2 texCoords[4] = { float2(0.0f, 0.0f), // 좌상 float2(1.0f, 0.0f), // 우상 float2(0.0f, 1.0f), // 좌하 float2(1.0f, 1.0f) // 우하 }; // 카메라를 향하도록 빌보드 로컬 축 계산 (간단화된 예시) // 실제로는 뷰 행렬의 역행렬에서 카메라의 오른쪽(right), 위쪽(up) 벡터를 사용 float3 billboardRight = float3(viewMatrix._11, viewMatrix._21, viewMatrix._31); // 뷰 행렬의 첫 번째 행 (카메라의 X축) float3 billboardUp = float3(viewMatrix._12, viewMatrix._22, viewMatrix._32); // 뷰 행렬의 두 번째 행 (카메라의 Y축) GS_OUTPUT_BILLBOARD outputVertex; for (int i = 0; i &lt; 4; ++i) { float3 cornerPosW = centerW + billboardRight * offsets[i].x + billboardUp * offsets[i].y; outputVertex.positionH = mul(float4(cornerPosW, 1.0f), viewMatrix); outputVertex.positionH = mul(outputVertex.positionH, projectionMatrix); outputVertex.texCoord = texCoords[i]; outputStream.Append(outputVertex); } outputStream.RestartStrip(); // 사각형 하나 만들고 스트립 종료}성능 고려 사항 지오메트리 셰이더는 매우 유연하고 강력한 기능을 제공하지만, 잘못 사용하면 성능 병목을 일으키기 쉬움 특히 지오메트리 셰이더가 입력 기본 도형보다 훨씬 많은 수의 기본 도형을 출력하는 경우(이를 증폭(amplification)이라고 함), GPU의 부하가 크게 증가할 수 있음 많은 경우, 유사한 효과를 인스턴싱(instancing), 정점 셰이더에서의 텍스처 참조를 통한 데이터 확장, 또는 컴퓨트 셰이더(Compute Shader)를 이용한 사전 지오메트리 생성 등 다른 기법으로 더 효율적으로 구현할 수 있음 " }, { "title": "Graph Search", "url": "/posts/Graph_Search/", "categories": "자료구조, Tree", "tags": "data_structure", "date": "2022-06-29 00:00:00 +0900", "snippet": "그래프 탐색 한 정점에서 시작하여 그래프에 있는 모든 정점을 한 번씩 방문하여 처리하는 연산 탐색 종류 깊이 우선 탐색 (DFS) 너비 우선 탐색 (BFS) 깊이 우선 탐색(DFS) 시작 정점에서 한 방향으로 계속 가다가 더 이상 갈 수 없게 되면, 다시 가장 마지막 갈림길로 돌아와서 다른 방향으로 다시 탐색을 진행 과정 시작 정점v를 방문한다. 정점 v에 인접한 정점 중에서 (1) 방문하지 않은 정점 w가 있으면 정점v를 스택에 push하고 w를 방문한다. 그리고 w를 v로하여 다시 2번을 반복한다. (2) 방문하지 않은 정점이 없으면 스택을 pop하여 받은 가장 마지막에 방문한 정점을 v로 설정한뒤 다시 2번을 수행한다. 3. 스택이 공백이 될 때까지 2번을 반복한다. DFS Code#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;// dfs에 들어온 정점은 check에서 true로 설정(방문했다고 표시)// 방문한 정점 , 그래프 , 방문표시할 배열void dfs(int start, vector&lt;int&gt; graph[], bool check[]){ check[start]= true; //방문 printf(\"%d \", start); for(int i=0; i &lt; graph[start].size(); i++){ int next = graph[start][i]; // 방문하지 않았다면 if(check[next]==false){ // 다음 정점을 방문(재귀) dfs(next, graph, check); } }}int main (){ int n, m, start; cin &gt;&gt; n &gt;&gt; m &gt;&gt; start; vector&lt;int&gt; graph[n+1]; bool check [n+1]; fill(check, check+n+1, false); for(int i=0; i&lt;m; i++){ int u,v; cin &gt;&gt; u &gt;&gt; v; graph[u].push_back(v); graph[v].push_back(u); } //Sorting한 이유는 하나의 정점에서 다음을 탐색할 때 node 값에 순차적으로 접근해야하기 때문 for(int i=1; i&lt;=n; i++){ sort(graph[i].begin(), graph[i].end()); } //dfs dfs(start, graph, check); printf(\"\\n\"); return 0;}BFS 시작 정점에 인접한 정점을 모두 차례로 방문하고 나서 방문했던 정점을 시작으로 다시 인접한 정점을 차례로 방문하고 처리하는 연산 과정 시작 정점v를 결정하여 방문한다. 정점 v에 인접한 정점 중에서 방문하지 않은 정점을 차례로 방문하면서 큐에 enQueue한다. 방문하지 않은 인접한 정점이 없으면, 방문했던 정점에서 인접한 정점을 다시 차례로 방문하기 위해 큐에서 deQueue하여 받은 정점을 v로 설정하고 2번을 반복한다 큐가 공백이 될 때까지 2번,3번을 반복한다 BFS Code#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std; void bfs(int start, vector&lt;int&gt; graph[], bool check[]){ queue&lt;int&gt; q; // 다음번 방문할 정점을 저장하는 큐 q.push(start); // 처음 들어온 정점을 push check[start] = true; // 처음 들어온 정점 방문표시 while(!q.empty()){ int tmp = q.front(); // 다음번 방문할 정점인덱스 q.pop(); printf(\"%d \",tmp); for(int i=0; i&lt;graph[tmp].size(); i++){ // 방문하지 않았다면 if(check[graph[tmp][i]] == false){ // 큐에 넣어주고 방문표시 q.push(graph[tmp][i]); check[graph[tmp][i]] = true; } } }}int main (){ int n, m, start; cin &gt;&gt; n &gt;&gt; m &gt;&gt; start; vector&lt;int&gt; graph[n+1]; bool check [n+1]; fill(check, check+n+1, false); for(int i=0; i&lt;m; i++){ int u,v; cin &gt;&gt; u &gt;&gt; v; graph[u].push_back(v); graph[v].push_back(u); } //Sorting한 이유는 하나의 정점에서 다음을 탐색할 때 node 값에 순차적으로 접근해야하기 때문 for(int i=1; i&lt;=n; i++){ sort(graph[i].begin(), graph[i].end()); } //bfs bfs(start, graph, check); printf(\"\\n\"); return 0;}" }, { "title": "MergeSort", "url": "/posts/MergeSort/", "categories": "자료구조, Sort", "tags": "data_structure", "date": "2022-06-27 00:00:00 +0900", "snippet": "병합 정렬 여러 개의 정렬된 자료 집합을 병합하여 하나의 정렬된 집합으로 만드는 정렬 방법 전체 원소에 대해 수행하지 않고 부분집합으로 분할하고 각 부분집합에 대해서 정렬 작업을 정복한 후에 정렬된 부분집합들을 다시 결합하는 분할정복 2개의 정렬된 자료 집합을 결합하여 하나의 집합으로 만드는 병합 방법을 2-way 병합이라 한다. 시간복잡도 O(nlogn)으로 고정이지만 추가적인 저장 공간을 필요로 한다는 단점이 있다. 과정 자료들을 두 개의 부분집합으로 분할한다.(분할) 부분집합에 있는 원소를 정렬한다. (정복) 정렬된 부분집합들을 하나의 집합으로 정렬하여 결합한다.(결합) MergeSort Code#include &lt;stdio.h&gt;#define MAX 30extern int size;int sorted[MAX];\t\t\t\t// 원소를 병합하면서 정렬한 상태로 저장할 배열 선언void merge(int a[], int m, int middle, int n) { int i, j, k, t; i = m;\t\t\t\t\t\t\t// 첫 번째 부분집합의 시작 위치 설정 j = middle + 1;\t\t\t\t// 두 번째 부분집합의 시작 위치 설정 k = m;\t\t\t\t\t\t// 배열 sorted에 정렬된 원소를 저장할 위치 설정 while (i &lt;= middle &amp;&amp; j &lt;= n) { if (a[i] &lt;= a[j]) sorted[k++] = a[i++]; else sorted[k++] = a[j++]; } // while if (i &gt; middle) for (t = j; t &lt;= n; t++, k++) sorted[k] = a[t]; else for (t = i; t &lt;= middle; t++, k++)\tsorted[k] = a[t]; for (t = m; t &lt;= n; t++) \ta[t] = sorted[t]; printf(\"\\n 병합 정렬 &gt;&gt; \"); for (t = 0; t &lt; size; t++) printf(\"%4d \", a[t]);}void mergeSort(int a[], int m, int n) { int middle; if (m &lt; n) { middle = (m + n) / 2; mergeSort(a, m, middle);\t\t// 앞 부분에 대한 분할 작업 수행 mergeSort(a, middle + 1, n);\t// 뒷 부분에 대한 분할 작업 수행 merge(a, m, middle, n);\t\t\t// 부분집합에 대하여 정렬과 병합 작업 수행 }}" }, { "title": "Tessellation Stage", "url": "/posts/%ED%85%8C%EC%85%80%EB%A0%88%EC%9D%B4%EC%85%98-%EB%8B%A8%EA%B3%84/", "categories": "DirectX", "tags": "directx", "date": "2022-06-27 00:00:00 +0900", "snippet": "DirectX 11 테셀레이션 단계 3D 모델의 표면을 동적으로 더 작은 기본 도형(주로 삼각형)으로 세분화하여 훨씬 더 높은 수준의 디테일을 표현할 수 있게 하는 강력한 기능 “테셀레이트(tessellate)”라는 단어 자체가 “평면이나 공간을 특정 도형으로 빈틈없이 완벽하게 덮는 것”을 의미 렌더링 파이프라인에서 테셀레이션 단계는 입력된 비교적 단순한 메시(Low-poly mesh)의 기본 도형(패치, Patch)을 잘게 나누고, 새로 생성된 정점들의 위치를 조정하여 복잡하고 부드러운 표면을 만들어 냄 테셀레이션 사용 이유 처음부터 매우 상세한 고품질 메시(High-poly mesh)를 사용하는 대신 테셀레이션을 활용하는 이유는 다음과 같음 동적 디테일 조절 (Dynamic Level of Detail - LOD) 카메라와의 거리, 화면에서의 중요도 등 다양한 요소에 기반하여 실시간으로 메시의 디테일 수준을 조절할 수 있음. 가까이 있는 객체는 매우 상세하게, 멀리 있는 객체는 단순하게 표현하여 성능을 최적화 성능 향상 복잡한 물리 계산이나 애니메이션은 상대적으로 정점 수가 적은 저품질 제어 메시(Low-poly control mesh)를 기반으로 수행하고, 렌더링 시에만 GPU를 통해 고품질 메시로 테셀레이션하면 계산 부담을 줄일 수 있음 메모리 효율성 디스크, RAM, VRAM에는 저품질 메시만 저장하고, 필요할 때 GPU가 즉석에서 고품질 메시를 생성하므로 메모리 사용량을 절감할 수 있음 테셀레이션 기본 도형: 패치 (Patch)와 제어점 (Control Points) 테셀레이션 파이프라인을 사용할 때, 입력 조립기(Input Assembler, IA) 단계는 일반적인 삼각형 리스트(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST) 대신 패치 리스트(Patch List) 토폴로지로 설정되어야 함패치(Patch) 테셀레이션의 기본 단위로, 하나 이상의 제어점(Control Point)들로 구성제어점(Control Point) 패치의 형태를 정의하는 정점들입니다. 하나의 패치는 1개에서 최대 32개의 제어점을 가질 수 있음IA 단계에서 설정하는 토폴로지 예시// D3D11_PRIMITIVE_TOPOLOGY 열거형 값들D3D11_PRIMITIVE_TOPOLOGY_1_CONTROL_POINT_PATCHLIST = 8,D3D11_PRIMITIVE_TOPOLOGY_2_CONTROL_POINT_PATCHLIST = 9,D3D11_PRIMITIVE_TOPOLOGY_3_CONTROL_POINT_PATCHLIST = 10, // 삼각형 패치에 해당D3D11_PRIMITIVE_TOPOLOGY_4_CONTROL_POINT_PATCHLIST = 11, // 사각형 패치에 해당// ...D3D11_PRIMITIVE_TOPOLOGY_32_CONTROL_POINT_PATCHLIST = 39Vertex Shader와 테셀레이션의 관계 테셀레이션 파이프라인이 활성화되면, Vertex Shader는 입력 패치의 각 제어점에 대해 한 번씩 실행 Vertex Shader는 사실상 “제어점 셰이더(Control Point Shader)” 역할 제어점에 대한 초기 변환(예: 월드 변환), 애니메이션, 또는 헐 셰이더(Hull Shader)에서 필요로 하는 속성 계산 등을 수행할 수 있음 비용이 많이 드는 애니메이션이나 물리 관련 계산은 테셀레이션으로 정점 수가 늘어나기 전, 즉 Vertex Shader 단계에서 제어점들을 대상으로 수행하는 것이 효율적 테셀레이션 파이프라인의 주요 단계 테셀레이션은 다음과 같은 프로그래머블 셰이더 및 고정 기능 하드웨어 단계를 거침 1단계 헐 셰이더 (Hull Shader - HS): 프로그래머블 2단계 테셀레이터 (Tessellator Stage): 고정 기능 (프로그래밍 불가) 3단계 도메인 셰이더 (Domain Shader - DS): 프로그래머블 이 세 단계를 거쳐 Vertex Shader에서 처리된 제어점 패치가 세분화된 지오메트리로 변환 1. 헐 셰이더 (Hull Shader - HS) 헐 셰이더는 테셀레이션 파이프라인의 첫 번째 프로그래머블 스테이지로, 두 가지 주요 함수로 구성될 수 있음1.1. 패치 상수 함수 (Patch Constant Function / Constant Hull Shader)실행 시점 각 입력 패치당 한 번 실행역할 테셀레이션 인자(Tessellation Factors)를 계산 이 값들은 고정 기능 테셀레이터에게 패치를 얼마나 잘게 나눌지(세분화 정도)를 알려줌 SV_TessFactor: 패치의 각 외곽선(edge)을 얼마나 나눌지 지정 (예: 사각형은 4개의 외곽선 값, 삼각형은 3개의 외곽선 값) SV_InsideTessFactor: 패치의 내부를 얼마나 나눌지 지정 (예: 사각형은 2개의 내부 값 (U, V 방향), 삼각형은 1개의 내부 값) 패치 전체에 적용될 다른 상수 값들(예: 법선, UV 오프셋 등)을 계산하여 도메인 셰이더로 전달할 수 있음입력 현재 패치를 구성하는 제어점들의 배열(InputPatch&lt;VSOut, NumCtrlPts&gt;), 그리고 패치의 고유 ID (SV_PrimitiveID). VSOut은 Vertex Shader의 출력 구조체 타입입니다.출력 테셀레이션 인자들과 기타 패치 상수 데이터를 담는 구조체를 반환예시코드// Vertex Shader의 출력 구조체 (헐 셰이더 입력 제어점 타입)struct VS_OUTPUT{ float3 vPosL : POSITION; // 로컬 또는 월드 공간 위치 // ... 기타 필요한 데이터 (UV, Normal 등)};// 패치 상수 함수의 출력 구조체 (사각형 패치 예시)struct PatchTessFactors{ float EdgeTess[4] : SV_TessFactor; // 각 외곽선 테셀레이션 인자 float InsideTess[2] : SV_InsideTessFactor; // 내부 U, V 방향 테셀레이션 인자 // ... 기타 패치 상수 데이터 ...};// 패치 상수 함수 예시 (균일하게 3등분)PatchTessFactors MyPatchConstantFunction(InputPatch&lt;VS_OUTPUT, 4&gt; inputPatch, // 4개 제어점 사각형 패치 uint patchID : SV_PrimitiveID){ PatchTessFactors pt; // 예시: 카메라 거리에 따라 테셀레이션 인자 동적 조절 가능 // float distanceToCamera = ... ; // float tessLevel = CalculateTessLevel(distanceToCamera); float tessLevel = 3.0f; // 고정된 테셀레이션 수준 예시 pt.EdgeTess[0] = tessLevel; // 왼쪽 외곽선 pt.EdgeTess[1] = tessLevel; // 위쪽 외곽선 pt.EdgeTess[2] = tessLevel; // 오른쪽 외곽선 pt.EdgeTess[3] = tessLevel; // 아래쪽 외곽선 pt.InsideTess[0] = tessLevel; // 내부 U 방향 (열) pt.InsideTess[1] = tessLevel; // 내부 V 방향 (행) return pt;}1.2. (메인) 헐 셰이더 / 제어점 함수 (Control Point Hull Shader)실행 시점 패치의 각 출력 제어점(Output Control Point)에 대해 한 번씩 실행역할 입력 제어점들을 변환하거나 보간하여 출력 제어점들을 생성 이 출력 제어점들은 테셀레이터가 새로운 정점들을 생성하고, 도메인 셰이더가 이 정점들의 최종 속성을 계산할 때 사용되는 “뼈대”가 됨. 즉, 세분화될 곡면의 형태를 정의 입력 현재 패치의 모든 입력 제어점들(InputPatch&lt;VSOut, NumInputCtrlPts&gt;), 현재 생성 중인 출력 제어점의 ID (SV_OutputControlPointID), 그리고 패치의 고유 ID (SV_PrimitiveID).출력 단일 출력 제어점의 속성(예: 위치, UV 좌표 등)을 담는 구조체를 반환HLSL 어트리뷰트 (Attributes) 이 셰이더 함수에는 테셀레이션 스테이지의 동작을 정의하는 여러 어트리뷰트들이 반드시 명시되어야 함 [domain(\"quad\")] 패치의 기본 형태(도메인)를 지정 (“tri”, “quad”, “isoline”) [partitioning(\"integer\")] 테셀레이션 인자를 해석하여 분할하는 방식을 지정 (“integer”, “fractional_odd”, “fractional_even”, “pow2”) [outputtopology(\"triangle_cw\")] 테셀레이터가 생성할 기본 도형의 종류와 와인딩 순서(정점 순서)를 지정 (“triangle_cw”, “triangle_ccw”, “linestrip”) [outputcontrolpoints(4)] 이 헐 셰이더가 생성할 출력 제어점의 개수를 지정합니다. [patchconstantfunc(\"MyPatchConstantFunction\")]: 사용할 패치 상수 함수의 이름을 지정 [maxtessfactor(64.0f)]: 하드웨어가 지원해야 하는 최대 테셀레이션 인자 값을 지정합니다. (성능 힌트)예시코드// 헐 셰이더의 출력 제어점 구조체struct HS_OUTPUT{ float3 vPosL : POSITION; // 보통 입력 제어점의 속성을 그대로 전달하거나 변형 // ... 기타 필요한 데이터 ...};// 메인 헐 셰이더 함수 예시 (4개 제어점 사각형 패치, 입력 제어점을 그대로 출력)[domain(\"quad\")][partitioning(\"integer\")][outputtopology(\"triangle_cw\")][outputcontrolpoints(4)] // 입력과 동일한 4개의 출력 제어점[patchconstantfunc(\"MyPatchConstantFunction\")] // 위에서 정의한 패치 상수 함수[maxtessfactor(64.0f)]HS_OUTPUT MyHullShader(InputPatch&lt;VS_OUTPUT, 4&gt; inputPatch, uint outputCtrlPtID : SV_OutputControlPointID, uint patchID : SV_PrimitiveID){ HS_OUTPUT hout; // 입력 제어점의 데이터를 그대로 출력 제어점으로 전달 (패스스루) hout.vPosL = inputPatch[outputCtrlPtID].vPosL; // hout.uv = inputPatch[outputCtrlPtID].uv; // 필요시 다른 데이터도 전달 return hout;}2. 테셀레이터 (Tessellator Stage) - 고정 기능 프로그래밍이 불가능한 고정 기능 하드웨어 유닛입력 패치 상수 함수에서 계산된 테셀레이션 인자들 (SV_TessFactor, SV_InsideTessFactor).(메인) 헐 셰이더에서 정의한 어트리뷰트들 (도메인, 파티셔닝 방식, 출력 토폴로지).주요 역할 입력된 테셀레이션 인자와 파티셔닝 방식에 따라, 패치의 추상적인 영역(예: 삼각형 도메인이면 단위 삼각형, 사각형 도메인이면 단위 정사각형) 내에 새로운 점들의 위치(보통 UV 또는 UVW 좌표 형태의 도메인 위치(Domain Location))를 생성 이 점들을 연결하여 outputtopology 어트리뷰트에 지정된 기본 도형(주로 삼각형)들을 만듦출력 생성된 각 점의 도메인 위치 좌표(SV_DomainLocation)와, 이 점들로 구성된 새로운 기본 도형(삼각형)들의 목록을 도메인 셰이더로 전달3. 도메인 셰이더 (Domain Shader - DS) 테셀레이션 파이프라인의 두 번째 프로그래머블 스테이지 테셀레이터 자체는 (u,v,w) 좌표만 생성하고, 도메인 셰이더가 이 (u,v,w) 좌표를 사용하여 헐 셰이더의 출력 제어점들을 명시적으로 보간하여 최종 정점 속성을 계산해야 함 테셀레이터에서는 보간해주지 않기 때문에 RasterRizer에 넘기기전에 보간하는 것 실행 시점 테셀레이터가 생성한 각각의 새로운 정점에 대해 한 번씩 실행주요 역할 테셀레이터로부터 전달받은 도메인 위치 좌표(SV_DomainLocation)와 (메인) 헐 셰이더가 출력한 제어점들(OutputPatch&lt;HS_OUTPUT, NumOutputCtrlPts&gt;), 그리고 패치 상수 함수가 출력한 데이터들을 사용하여, 새로 생성된 정점의 최종 3D 위치 및 기타 속성들(UV, 노멀 등)을 계산 이 단계에서 실제적인 표면 변위(Displacement Mapping)나 곡면(베지어, N-Patches 등) 계산이 이뤄짐. 헐 셰이더의 출력 제어점들을 보간(interpolate)하여 최종 정점 위치를 결정하는 것이 일반적입력 패치 상수 함수가 출력한 데이터 (테셀레이션 인자 포함). 현재 처리 중인 정점의 도메인 위치 좌표 (float2 uv 또는 float3 uvw : SV_DomainLocation). (메인) 헐 셰이더가 생성한 모든 출력 제어점들의 배열 (const OutputPatch&lt;HS_OUTPUT, NumOutputCtrlPts&gt;).출력 최종적으로 렌더링될 정점의 속성들을 담는 구조체를 반환합니다. 가장 중요한 출력은 클립 공간 좌표인 SV_Position입니다." }, { "title": "vector", "url": "/posts/vector/", "categories": "STL, stl", "tags": "coding test", "date": "2022-06-26 00:00:00 +0900", "snippet": "Vector vector 는 자동으로 메모리가 할당되는 동적 배열헤더파일 #include &lt;vector&gt;선언 vector&lt;type&gt; name;성능 추가 연산 성능은 O(n) 삭제 연산 성능은 O(n) 조회 연산 성능은 O(1)예시#include &lt;vector&gt;using std::vector; // vector의 namespace , 있으면 std:: 생략가능int main(){ // 빈 int형 벡터 생성\tstd::vector&lt;int&gt; v1; // 기본값(0)으로 초기화된 n개(2)의 원소를 가진 vector 생성\tstd::vector&lt;int&gt; v2(2); // x값(3.5)으로 초기화된 n개(10)의 원소를 가진 vector 생성\tstd::vector&lt;float&gt; v3(3.5 , 10); // vector v3의 복사본 생성\tstd::vector&lt;float&gt; v4(v3);}함수 v.assign(x, y) 이전 벡터에 있던 데이터를 날리고 x번 만큼 y값을 넣는다 v.at(idx) idx의 원소를 참조를 반환 v[idx]보다 느리지만 범위를 점검하여 안전 v[idx] idx 번째 원소를 참조 범위를 점검하지 않으므로 v.at(idx)보다 빠름 v.front() 첫번째 원소를 참조 v.back() 마지막 원소를 참조 v.clear 모든 원소를 제거 size는 줄어들지만 capacity는 변하지 않음 v.push_back(x) 마지막 원소 뒤에 x를 삽입 v.pop_back() 마지막 원소를 제거 v.begin() 첫번째 원소의 반복자를 반환 iterator와 사용 v.end() 마지막 원소의 반복자를 반환 iterator와 사용 v.rbegin() 역방향으로 첫번째 원소의 반복자를 반환 iterator와 사용 v.rend() 역방향으로 마지막 원소의 반복자를 반환 iterator와 사용 v.reserve(n) 벡터의 크기를 n만큼 재할당 v.resize(n, x) 벡터의 크기를 n만큼 재할당하고 그 자리에 x값을 대입 이전 벡터의 크기보다 작으면 이전 벡터의 데이터를 날리고 전부 x값을 대입 이전 벡터의 크기보다 크면 이전 벡터의 데이터는 그대로 두고 증가한 자리에만 x값을 대입 v.size() 원소의 개수를 리턴 v.capacity() 할당된 공간의 크기를 리턴한다. v2.swap(v1) v2와 v1의 capacity를 바꾼다(전부 교환) 보통 capacity가 0인 임시벡터를 만들고 기존 벡터의 메모리를 없애려고 할 때 swap한다. v.insert(x,y) x번째 위치에 y값을 대입 v.erase(iter) iter가 가리키는 원소를 제거 size만 줄어들고 capacity(메모리공간)은 남아있다. v.erase(start,end) iter가 가리키는 원소(start부터 end값 이전)까지 지운다 [start, end) v.empty() 벡터가 비어있다면 리턴 (size == 0 ) size와 capacity의 차이점 v.size() 원소의 갯수를 반환 v.capacity() 할당된 공간의 크기를 반환 공간 할당의 기준은 점점 커지면서 capacity를 할당한다. 벡터의 크기가 늘어나는 방식1. 벡터에 할당된 공간의 크기(capacity)를 넘어서 값을 넣으면 재할당(realloocate)이 발생한다. * 재할당은 기존 공간의 크기의 1.5 ~ 2배로 컴파일러에 따라 다르다고 한다.2. 재할당이 발생한다면 모든 값들을 새로운 메모리 공간에 복사한 후 기존 백터를 파괴하고3. 여기서 복사 과정에서도 복사생성자가 발생하게 하면서 그렇게 되면 프로그램의 퍼포먼스가 저하된다4. std::move 라는 것이 도입되면서 복사하지 않고 이동하게 되어 메모리 증가에 따른 비용이 많이 들지 않게 됐다.push_back과 emplace_back의 차이push_back// push_back 원형void push_back( const T&amp; value );constexpr void push_back( const T&amp; value );void push_back( T&amp;&amp; value );constexpr void push_back( T&amp;&amp; value ); push_back은 메모리를 할당하지 않고 데이터를 삽입하는 함수. 그래서 삽입하기 전에 완성된 객체가 존재해야만 함수 호출이 이뤄진다. vector는 push_back을 할 때 인자값과 똑같은 임시 객체를 하나 더 만들어서 거기에 인자값으로 받은 값을 복사한다. 이 과정에서 해당 객체를 만들기 위한 생성자 호출 그리고 나서 임시 객체를 벡터에 추가한다. 이 과정에서 해당 객체가 소멸되기 때문에 소멸자 호출 emplace_backtemplate&lt; class... Args &gt;void emplace_back( Args&amp;&amp;... args );template&lt; class... Args &gt;reference emplace_back( Args&amp;&amp;... args );template&lt; class... Args &gt;constexpr reference emplace_back( Args&amp;&amp;... args ); 벡터에 메모리 할당을 하는 동시에 값을 삽입하는 것이 가능하다. 가변인자 템플릿을 사용해서 emplace_back 함수 내에서 자체적으로 객체를 생성할 수 있다. push_back vs emplace_back 일반적으로 emplace_back이 push_back보다 빠르지만 push_back을 많이 사용한다. 그 이유는 emplace_back 이 모든 유형의 생성자를 호출하고 push_back은 암시적인 생성자만 호출한다. " }, { "title": "Vertex Shader", "url": "/posts/VertexShader/", "categories": "DirectX", "tags": "directx", "date": "2022-06-24 00:00:00 +0900", "snippet": "Vertext Shader정의 Vertex마다 호출되는 프로그램 Input Assembler(입력 조립기) 단계에서 정점 데이터가 기본 도형(삼각형 등)으로 조립된 후, 각 정점은 Vertex Shader로 전달되어 처리가 가능 Vertex Shader는 모든 개별 정점에 대해 한 번씩 호출되는 함수 GPU에서 병렬로 실행되므로 매우 빠른 처리가 가능 1. 주요 역할 입력된 정점 데이터에 다양한 연산을 적용하여 특수 효과를 구현, 대표적인 역할은 다음과 같음변환 (Transformations) 정점의 위치를 다양한 좌표 공간으로 변환조명 (Lighting) 정점 단위의 조명 계산을 수행하여 명암을 표현할 수 있다 (Per-Vertex Lighting).텍스처 좌표 생성 및 변환 텍스처 매핑을 위한 UV 좌표를 생성하거나 애니메이션을 위해 변형스키닝 (Skinning) 캐릭터 애니메이션을 위해 정점을 뼈(bone)의 움직임에 따라 변형변위 매핑 (Displacement Mapping) 준비 정점의 위치를 높이 맵 등을 사용하여 실제로 이동시키는 고급 기법의 일부를 담당할 수 있다 (주로 Tessellation 단계와 연계).2. 변환 (Transformations) 과정 Vertex Shader의 가장 기본적인 역할 중 하나는 3D 모델의 정점들을 여러 좌표 공간을 거쳐 최종적으로 화면에 표시될 수 있는 형태로 변환하는 것 이 변환 과정은 일반적으로 다음과 같은 순서로 진행 로컬 공간 (Local Space) → 월드 공간 (World Space) → 뷰 공간 (View Space) → 투영 공간 (Projection Space / Clip Space) 1. 로컬 공간 (Local Space / 모델 공간, Model Space)정의 로컬 공간은 3D 모델링 소프트웨어에서 아티스트가 모델을 제작할 때 사용하는 객체 고유의 좌표계 각 객체는 자신만의 원점(0,0,0)과 축을 가지며, 이 객체의 정점들은 이 로컬 공간을 기준으로 정의됨.특징 모델의 피벗(pivot) 또는 중심점이 보통 로컬 공간의 원점이 됨 예를 들어, 사람 캐릭터 모델은 발바닥 사이를 (0,0,0)으로 하여 디자인될 수 있고, 자동차 모델은 차체 중앙 하단을 원점으로 가질 수 있습니다.HLSL 입력 Vertex Shader의 입력으로 들어오는 정점 위치 데이터(POSITION 시맨틱)는 이 로컬 공간 좌표입니다.2. 월드 공간 (World Space) 과 월드 변환 (World Transformation)정의 월드 공간은 게임이나 3D 장면 내의 모든 객체들이 함께 배치되는 공통된 전역 좌표계입니다. 이 공간에는 하나의 원점과 기준 축이 존재합니다. 월드 변환은 로컬 공간에 정의된 각 객체를 월드 공간의 특정 위치, 방향, 크기로 배치하는 과정월드 행렬 (World Matrix) 이 변환은 각 객체마다 고유한 월드 행렬을 로컬 공간 정점 좌표에 곱함으로써 이루어짐 월드 행렬은 일반적으로 이동(Translation), 회전(Rotation), 크기 조절(Scaling) 변환 행렬들의 조합으로 구성됩니다 (TRS 행렬). 월드 좌표 = 로컬 좌표 × 월드 행렬 결과 모든 개별 객체들이 하나의 동일한 월드 공간 좌표계 위에 존재하게 되어 서로의 상대적인 위치와 상태를 가늠할 수 있게 됩니다3. 뷰 공간 (View Space / 카메라 공간, Camera Space) 과 뷰 변환 (View Transformation)정의 뷰 공간은 카메라의 시점에서 장면을 바라보는 좌표계 이 공간에서는 일반적으로 카메라가 원점(0,0,0)에 위치하고, 카메라가 바라보는 방향이 특정 축(예: Z축)과 일치하도록 설정 뷰 변환은 월드 공간의 정점들을 이 카메라 기준의 뷰 공간으로 옮기는 과정뷰 행렬 (View Matrix) 이 변환은 월드 공간 정점 좌표에 뷰 행렬을 곱함으로써 수행됩니다. 뷰 공간 좌표 = 월드 좌표 × 뷰 행렬 뷰 행렬 구하는 방법 카메라도 월드 공간에 존재하는 하나의 객체로 생각할 수 있다. 즉, 카메라 자체도 월드 공간에서의 위치와 방향(회전)을 나타내는 변환 행렬(카메라의 월드 행렬)을 가짐 장면 전체를 카메라의 시점으로 옮기기 위해서는, 다른 모든 객체들을 카메라의 위치와 방향에 대해 상대적으로 변환해야 합니다. 이는 카메라의 월드 행렬의 역행렬(Inverse Matrix)을 사용하는 것과 같습니다. 이동: 만약 카메라가 월드 공간에서 (cx, cy, cz) 위치에 있다면, 다른 객체들은 카메라를 기준으로 (-cx, -cy, -cz)만큼 이동한 것처럼 보여야 합니다. 회전: 카메라가 특정 방향으로 회전했다면, 다른 객체들은 카메라를 기준으로 반대 방향으로 회전한 것처럼 보여야 합니다. (정확히는, 월드 공간의 축들이 카메라의 로컬 축에 정렬되도록 변환됩니다.) 결론적으로 뷰 행렬 = 카메라 월드 행렬의 역행렬 입니다. DirectX에서는 주로 카메라의 위치(Eye Position), 바라보는 지점(Look-At Target), 그리고 상단 방향 벡터(Up Vector)를 사용하여 뷰 행렬을 생성하는 헬퍼 함수(예: XMMatrixLookAtLH 또는 XMMatrixLookAtRH)를 사용4. 투영 공간 (Projection Space / 클립 공간, Clip Space) 과 투영 변환 (Projection Transformation)정의 투영 변환은 3차원 뷰 공간의 장면을 2차원 화면에 표시하기 위한 준비 단계로, 시야 볼륨(Viewing Volume 또는 Frustum) 내의 정점들을 클립 공간(Clip Space)이라는 특수한 4차원 동차 좌표계로 변환 이 단계에서 시야 볼륨 바깥의 지오메트리는 클리핑(잘라내기) 대상으로 표시됩니다. 투영 행렬 (Projection Matrix) 이 변환은 뷰 공간 정점 좌표에 투영 행렬을 곱함으로써 수행됩니다. 클립 공간 좌표 = 뷰 공간 좌표 × 투영 행렬 투영 방식 1.원근 투영 (Perspective Projection) 가장 일반적으로 사용되는 방식으로, 사람의 눈이나 카메라 렌즈처럼 가까이 있는 물체는 크게, 멀리 있는 물체는 작게 보이게 하여 깊이감과 원근감을 제공 시야 볼륨은 절두체(Frustum, 잘린 피라미드 모양) 형태를 가집니다. 생성 시 시야각(Field of View, FOV), 화면 종횡비(Aspect Ratio), 근접 클리핑 평면(Near Clip Plane), 원거리 클리핑 평면(Far Clip Plane) 등의 매개변수가 필요.투영 방식 2.직교 투영 (Orthographic Projection) 물체의 깊이(거리)에 관계없이 모든 물체가 동일한 크기로 보이게 합니다. 원근감이 없다. 시야 볼륨은 직육면체 형태를 가집니다. 2D 게임, UI 요소, 건축 도면 또는 특정 스타일의 3D 게임에서 사용됩니다. 생성 시 시야 볼륨의 가로, 세로 크기 및 근접/원거리 클리핑 평면 매개변수가 필요합니다.클립 공간 이후 (하드웨어 처리) Vertex Shader의 최종 출력 위치(SV_Position 시맨틱에 할당된 값)는 이 클립 공간 좌표 이후 렌더링 파이프라인의 고정 기능 하드웨어는 클립 공간 좌표의 각 성분(x, y, z)을 동차 성분인 w로 나누는 원근 나누기(Perspective Divide)를 수행 NDC_x = Clip_x / Clip_w NDC_y = Clip_y / Clip_w NDC_z = Clip_z / Clip_w 이 결과로 정점들은 정규화된 장치 좌표계 (Normalized Device Coordinates, NDC)로 변환됨. NDC 공간에서 X, Y 좌표는 보통 -1에서 +1 사이, Z 좌표는 0에서 +1 (Direct3D) 또는 -1에서 +1 (OpenGL) 사이의 값을 가집니다. 이 NDC 좌표가 최종적으로 화면 픽셀 좌표(스크린 공간)로 매핑 3. Vertex Shader의 최종 출력 Vertex Shader는 변환된 정점의 위치를 클립 공간 좌표로 SV_Position이라는 특별한 시스템 값 시맨틱을 가진 출력 변수에 할당해야 함 이외에도 텍스처 좌표, 정점 색상, 변환된 노멀 벡터 등 다른 계산된 값들을 다음 파이프라인 스테이지(주로 Rasterizer를 거쳐 Pixel Shader)로 전달하기 위해 출력 구조체에 담아 반환 " }, { "title": "QuickSort", "url": "/posts/QuickSort/", "categories": "자료구조, Sort", "tags": "data_structure", "date": "2022-06-23 00:00:00 +0900", "snippet": "QuickSort 퀵정렬 분할 정복 알고리즘중 하나인 정렬방법 합병정렬과 비슷하게 전체 리스트를 2개의 부분 리스트로 분할하고, 각각의 부분 리스트를 다시 퀵정렬 하는 분할-정복법을 사용한다 합병정렬과는 다르게 비균등하게(피벗을 기준으로) 분할한다. 시간 복잡도 평균적으로 O(nlogn) 최악의 경우 (배열이 오름차순이거나 내림차순일 경우) -&gt; O(n²) 과정 리스트에 있는 한 요소를 피벗으로 선택 피벗보다 작은 요소들은 피벗의 왼쪽으로 옮기고, 큰 요소들은 피벗의 오른쪽으로 옮긴다. 이 상태에서 피벗의 왼쪽 리스트와 오른쪽 리스트를 다시 퀵정렬한다. 위의 과정을 부분 리스트가 더이상 분할하지 못할 때까지 반복한다. QuickSort Code#include&lt;iostream&gt;void QuickSort(int* arr,int cnt){ if (cnt &lt; 2) return; int iPivot = arr[cnt - 1]; //가장 오른쪽을 피벗으로 선택 int L = 0; // 가장 왼쪽 int R = cnt - 2; // 피벗을 제외한 가장 오른쪽 // L과 R이 만나기전까지 반복문 while (1) { // 피벗의 왼쪽에 있는 요소가 피벗보다 크기 전까지 증가 while ((arr[L] &lt; iPivot) &amp;&amp; L &lt; R) L++; // 피벗의 오른쪽에 있는 요소가 피벗보다 작기 전까지 감소 while ((arr[R] &gt; iPivot) &amp;&amp; L &lt; R) R--; if (L == R) // L과 R이 만난다면 break { break; } else // 만나지 않았더라면 L과 R을 서로 교환 { int tmp = arr[L]; arr[L] = arr[R]; arr[R] = tmp; } } //왼쪽 리스트 정렬 if (arr[L] &gt; iPivot) // 멈춘 요소가 더 크다면 { //피벗과 자리를 교환한 후 int tmp = arr[L]; arr[L] = iPivot; arr[cnt - 1] = tmp; // 0부터 L까지 QuickSort(arr, L); } else // 멈춘 요소가 더 작다면 { // 0 부터 L+1 까지 QuickSort(arr, L + 1); } // 오른쪽 리스트 정렬 QuickSort(arr + L + 1, cnt - (L + 1));}int main(){ int arr[10] = { 10,5,9,8,6,1,3,4,2,7 }; QuickSort(arr, 10); for (int i = 0; i &lt; 10; ++i) { printf(\"arr[%d] = %d\\n\",i, arr[i]); }}" }, { "title": "Input layout", "url": "/posts/Input-layout/", "categories": "DirectX", "tags": "directx", "date": "2022-06-23 00:00:00 +0900", "snippet": "입력 레이아웃(Input Layout) GPU가 정점 버퍼(Vertex Buffer)로부터 정점 데이터를 어떻게 읽어들여 해석해야 하는지를 정의하는 “청사진” 또는 “설계도”와 같음 이는 렌더링 파이프라인의 가장 첫 번째 단계 중 하나인 입력 조립기(Input Assembler, IA) 스테이지에 매우 중요한 정보를 제공 입력 레이아웃은 Vertex Shader가 입력으로 받을 정점 데이터의 정확한 구조와 내용을 애플리케이션 코드(C++)와 HLSL 셰이더 코드 간에 일치시키는 다리 역할 정의 입력 레이아웃은 개별 정점을 구성하는 각 요소(특성)의 데이터 형식, 의미, 메모리 내 위치 등을 상세하게 기술역할 정점 버퍼에 저장된 연속적인 바이트 스트림을 의미 있는 정점 데이터(예: 위치, 색상, 텍스처 좌표, 법선)로 구조화하여 Vertex Shader의 입력으로 전달될 수 있도록 함입력 레이아웃의 주요 역할어떤 데이터인지 각 정점 요소가 어떤 의미를 가지는가 (예: 위치 정보인가, 색상 정보인가?). 이는 시맨틱(Semantic)을 통해 정의어떤 형식인지 각 정점 요소가 어떤 데이터 타입과 몇 개의 성분으로 구성되는가 (예: float3인가, byte4인가?). 이는 DXGI_FORMAT으로 정의어디에 있는지 여러 개의 정점 버퍼를 사용할 경우, 이 데이터가 몇 번째 정점 버퍼 슬롯에서 오는가? (InputSlot) 정점 데이터 구조체 내에서 이 요소가 몇 바이트 오프셋부터 시작하는가? (AlignedByteOffset) 어떻게 공급되는지 데이터가 각 정점마다 제공되는가, 아니면 여러 인스턴스에 걸쳐 한 번 제공되는가? (InputSlotClass, InstanceDataStepRate) D3D11_INPUT_ELEMENT_DESC 구조체 상세typedef struct D3D11_INPUT_ELEMENT_DESC { LPCSTR SemanticName; // 이 요소의 HLSL 시맨틱 이름 UINT SemanticIndex; // 동일 시맨틱 이름 사용 시 구분 인덱스 DXGI_FORMAT Format; // 이 요소의 데이터 형식 및 성분 수 UINT InputSlot; // 이 요소를 가져올 정점 버퍼 슬롯 번호 (0-15) UINT AlignedByteOffset; // 정점 시작부터 이 요소까지의 바이트 오프셋 D3D11_INPUT_CLASSIFICATION InputSlotClass; // 데이터가 정점별인지 인스턴스별인지 UINT InstanceDataStepRate; // 인스턴스별 데이터일 경우 몇 인스턴스마다 진행할지} D3D11_INPUT_ELEMENT_DESC;입력 레이아웃 객체 생성 (ID3D11Device::CreateInputLayout) D3D11_INPUT_ELEMENT_DESC 구조체의 배열을 정의한 후, 이 배열과 컴파일된 Vertex Shader의 바이트코드 포인터를 ID3D11Device::CreateInputLayout 함수에 전달하여 ID3D11InputLayout 객체를 생성 CreateInputLayout에 사용되는 Vertex Shader 바이트코드는 해당 입력 레이아웃과 정확히 일치하는 입력 시그니처(시맨틱 이름, 순서, 형식 등)를 가져야 함. 그렇지 않으면 CreateInputLayout 함수 호출이 실패 // 예시: 정점 구조체 (C++)struct MyVertex{ XMFLOAT3 Pos; // 위치 XMFLOAT2 Tex; // 텍스처 좌표 XMFLOAT4 Color; // 색상};// ID3D11Device* pDevice; // 이미 초기화되었다고 가정// ID3DBlob* pVSBlob; // 컴파일된 Vertex Shader 바이트코드를 담고 있다고 가정// ID3D11InputLayout* pInputLayout = nullptr;// 1. D3D11_INPUT_ELEMENT_DESC 배열 정의D3D11_INPUT_ELEMENT_DESC layoutDesc[] ={ { \"POSITION\", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0 }, { \"TEXCOORD\", 0, DXGI_FORMAT_R32G32_FLOAT, 0, 12, D3D11_INPUT_PER_VERTEX_DATA, 0 }, // Pos (12바이트) 이후 { \"COLOR\", 0, DXGI_FORMAT_R32G32B32A32_FLOAT,0, 20, D3D11_INPUT_PER_VERTEX_DATA, 0 } // Tex (8바이트) 이후, 12+8=20 // AlignedByteOffset에 D3D11_APPEND_ALIGNED_ELEMENT를 사용할 수도 있습니다. // { \"POSITION\", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, D3D11_APPEND_ALIGNED_ELEMENT, D3D11_INPUT_PER_VERTEX_DATA, 0 }, // { \"TEXCOORD\", 0, DXGI_FORMAT_R32G32_FLOAT, 0, D3D11_APPEND_ALIGNED_ELEMENT, D3D11_INPUT_PER_VERTEX_DATA, 0 }, // { \"COLOR\", 0, DXGI_FORMAT_R32G32B32A32_FLOAT,0, D3D11_APPEND_ALIGNED_ELEMENT, D3D11_INPUT_PER_VERTEX_DATA, 0 }};UINT numElements = ARRAYSIZE(layoutDesc);// 2. 입력 레이아웃 객체 생성HRESULT hr = pDevice-&gt;CreateInputLayout( layoutDesc, // D3D11_INPUT_ELEMENT_DESC 배열 포인터 numElements, // 배열의 요소 개수 pVSBlob-&gt;GetBufferPointer(), // 컴파일된 Vertex Shader 바이트코드 포인터 pVSBlob-&gt;GetBufferSize(), // Vertex Shader 바이트코드 크기 &amp;pInputLayout // 생성된 ID3D11InputLayout 객체를 받을 포인터의 주소);if (FAILED(hr)){ // 에러 처리 // pVSBlob는 Release() 해야 함 (ComPtr이 아니라면) // pInputLayout도 에러 시 Release() 또는 ComPtr 사용 시 자동 return;}// 3. 입력 레이아웃 설정 (렌더링 시)// ID3D11DeviceContext* pImmediateContext; // 이미 초기화되었다고 가정// pImmediateContext-&gt;IASetInputLayout(pInputLayout);// 사용이 끝난 pInputLayout은 Release() 해줘야 합니다 (ComPtr이 아니라면)." }, { "title": "String", "url": "/posts/String/", "categories": "STL, stl", "tags": "coding test", "date": "2022-06-22 00:00:00 +0900", "snippet": "std::string C++ STL에서 제공하는 클래스로, string(문자열)을 다루는 클래스헤더파일 #include &lt;string&gt;;특징 C언어의 char*, char[] 문자열과 달리, 문자열끝에 ‘\\0’이 들어가지 않고 , 동적으로 문자열의 길이를 할당한다.string str(\"Test\");string str;str = \"Test\";string str2(str); string 멤버 함수 함수이름 내용 str.at(index) index 위치의 문자 반환. 유효한 범위인지 체크 O str[index] index 위치의 문자 반환. 유효한 범위인지 체크 X. 따라서 at 함수보다 접근이 빠름 str.front() 문자열의 가장 앞 문자 반환 str.back() 문자열의 가장 뒤 문자 반환 str.length() 문자열 길이 반환 str.size() 문자열 길이 반환 (length와 동일) str.capacity() 문자열이 사용중인 메모리 크기 반환 str.resize(n) string을 n의 크기로 만듦. 기존의 문자열 길이보다 n이 작다면 남은 부분은 삭제하고, n이 크다면 빈공간으로 채움 str.resize(n, ‘0’) n이 string의 길이보다 더 크다면, 빈 공간을 ‘0’으로 채움 str.shrink_to_fit() string의 capacity가 실제 사용하는 메모리보다 큰 경우 낭비되는 메모리가 없도록 메모리를 줄여줌 str.reserve(n) n만큼의 메모리를 미리 할당해줌 str.empty() str이 빈 문자열인지 확인 str.append(str2) str 뒤에 str2 문자열을 이어 붙여줌 (‘+’ 와 같은 역할) str.append(str2, n, m) str 뒤에 ‘str2의 n index부터 m개의 문자’를 이어 붙여줌 str.append(n, ‘0’) str 뒤에 n개의 ‘0’를 이어 붙여줌 str.insert(n, str) n번째 index 앞에 str 문자열을 삽입함. str.replace(n, k, str2) n번째 index부터 k개의 문자를 str2로 대체 str.clear() 저장된 문자열을 모두 삭제 str.erase(n, m) n~m index의 문자열을 지움 str.erase() clear와 같은 동작 str.push_back(c) str의 맨 뒤에 c 문자를 붙여줌 str.pop_back() str의 맨 뒤의 문자를 제거 str.assign(str2) str에 str2 문자열을 할당. (변수 정의와 동일) str.find(“abcd”) “abcd”가 str에 포함되어있는지를 확인. 찾으면 해당 부분의 첫번째 index를 반환 str.find(“abcd”, n) n번째 index부터 “abcd”를 find str.substr() str 전체를 반환 str.substr(n) str의 n번째 index부터 끝까지의 문자를 부분문자열로 반환  str.substr(n, k) str의 n번째 index부터 k개의 문자를 부분문자열로 반환  str.compare(str2) str과 str2가 같은지를 비교. 같다면 0, str&lt;str2 인 경우 음수, str&gt;str2 인 경우 양수를 반환 swap(str1, str2) str1과 str2를 바꿔줌. reference를 교환하는 방식 isdigit(c) c 문자가 숫자이면 true, 아니면 false를 반환  isalpha(c) c 문자가 영어이면 true, 아니면 false를 반환 toupper(c) c 문자를 대문자로 변환 tolower(c) c 문자를 소문자로 변환 " }, { "title": "Map && UnMap", "url": "/posts/Map-&&-UnMap/", "categories": "DirectX", "tags": "directx", "date": "2022-06-22 00:00:00 +0900", "snippet": "Map &amp;&amp; Unmap GPU에 자원을 업데이트하기 위해 사용하는 함수 map은 read/write 하려는 GPU 메모리 영역에 Lock을 걸고 그 주소를 얻어와서 이 주소를 통해 하고 싶은 동작을 수행하는 것이다. 정확히는 GPU 메모리 영역을 복사한 CPU 메모리의 주소를 맵핑하여 사용한다 read가 필요한 경우, 해당되는 GPU 메모리 영역을 시스템 메모리에 copy 후 시스템 메모리의 주소를 반환하기 때문에 복사 및 mapping만큼의 오버헤드가 있다. write 용도일 경우 GPU 메모리 내용을 알 필요가 없기에 시스템 메모리에 copy할 이유가 없다. 따라서 그냥 업데이트할 내용을 시스템 메모리에 write하고 그 내용을 GPU 메모리에 copy하면 된다. 때문에 write 용도로 버퍼를 생성했을 경우 map으로 얻은 주소의 내용을 read하면 안된다. D3D11_BUFFER_DESC 버퍼를 생성할 때 D3D11_BUFFER_DESC라는 구조체 데이터를 채워야 하는데, Usage라는 옵션이 있다 기본적으로 보통 DEFAULT 혹은 DYNAMIC을 사용하게 된다. 만약 DEFAULT로 설정하게 되면 UpdateSubresource 함수를 사용하게 되고, DYNAMIC으로 설정하게 되면 map을 사용해야 한다. 또한 CPUAccessFlags라는 옵션이 있는데 usage가 DEFAULT일 경우 0을 주고, DYNAMIC일 경우 D3D11_CPU_ACCESS_WRITE를 준다.typedef enum D3D11_USAGE { D3D11_USAGE_DEFAULT\t= 0, D3D11_USAGE_IMMUTABLE\t= 1, D3D11_USAGE_DYNAMIC\t= 2, D3D11_USAGE_STAGING\t= 3 } \tD3D11_USAGE;UpdateResource와 Map UpdateSubresource는 애초에 CPU -&gt; GPU 메모리로의 단방향 연산이고, map은 양방향 모두 가능하다. 따라서 GPU메모리를 read해야 한다면 무조건 버퍼를 DYNAMIC으로 만들어 map을 사용하는 수 밖에 없다. 만약 업데이트 하려는 데이터 단위가 대응될 경우 UpdateSubresource를 사용하는 것이 좋다. 예를 들어 Constant buffer는 보통 updateSubresource를 사용하는 것 같다." }, { "title": "커널 오브젝트와 오브젝트 핸들", "url": "/posts/%EC%BB%A4%EB%84%90_%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8%EC%99%80_%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8_%ED%95%B8%EB%93%A4/", "categories": "윈도우즈시스템프로그래밍, 운영체제", "tags": "windows", "date": "2022-06-21 00:00:00 +0900", "snippet": "커널 컴퓨터 운영 체제의 핵심이 되는 컴퓨터 프로그램 커널은 인터페이스로써 응용 프로그램 수행에 필요한 여러가지 서비스를 제공하고, 여러가지 하드웨어(CPU, 메모리) 등의 리소스를 관리하는 역할 일반적으로 커널이라는 용어와 운영체제라는 용어를 같은 의미로 사용한다. 커널 오브젝트 커널 오브젝트 커널에서 관리하는 중요한 정보를 담아둔 데이터 블록을 가리켜 커널 오브젝트라고 한다. 커널 오브젝트의 이해 프로세스를 생성하고 관리하는 실질적인 주체는 운영체제 Windows 운영체제 개발자들은 운영체제가 프로세스를 관리하기 위해 프로세스에 관한 정보를 저장할 수 있는 프로세스 관리 구조체를 정의함 이 구조체는 프로세스를 관리하기 위해 필요한 구조체로 프로세스의 상태 정보,우선순위 정보를 담고 있다 프로세스가 생성될 때마다 프로세스 관리 구조체가 생기고 새롭게 생성된 프로세스 정보들로 초기화되는데, 이것이 커널 오브젝트의 정체 프로세스뿐만 아니라, 쓰레드,IPC를 위한 파이프나 메일슬롯,파일을 생성할 때도 커널오브젝트가 생성된다 커널오브젝트의 종류에 따라서 서로 다른 구조체를 기반으로 생성되고 그에 따라 구조체의 멤버도 달라진다. 정리 Windows 운영체제는 프로세스, 쓰레드 혹은 파일과 같은 리소스들을 원활히 관리하기 위해 필요한 정보를 저장해야 한다. 이때 데이터를 저장하는 메모리 블록을 가리켜 커널 오브젝트라 한다. 오브젝트 핸들을 이용한 커널오브젝트의 조작 Windows는 프로그래머가 직접 커널 오브젝트를 조작할 수 없고 함수 호출에 의한 간접적인 호출로 조작이 가능하다. Windows에서 관리하는 리소스의 특성을 변경시키기 위해서는 시스템 함수를 호출해야하는데 이 때 필요한 값이 핸들이다. 핸들이란 커널 오브젝트에 할당되는 숫자(아이디) 커널 오브젝트와 핸들의 종속관계 커널 오브젝트와 핸들의 관계 커널 오브젝트는 프로세스에 종속적인것이 아니라, 운영체제에 종속적인 관계로 커널 오브젝트의 소멸시점은 운영체제에 의해서 결정된다. 커널 오브젝트는 프로세스에 종속적인 것이 아니라 운영체제에 종속적인 관계로 여러 프로세스에 의해서 접근이(공유가) 가능하다. 예제를 통한 종속관계의 이해 A프로세스가 B프로세스를 생성한다. 그러자 B프로세스는 자신의 우선순위를 높인다.잠시 후 A프로세스는 B 프로세스의 우선순위를 돌려 놓는다. /* KerObjShaer.cpp 프로그램 설명 : 커널 오브젝트 공유 예제*/#include &lt;stdio.h&gt;#include &lt;tchar.h&gt;#include &lt;windows.h&gt;int _tmain(int argc, TCHAR* argv[]){ STARTUPINFO si={0,}; PROCESS_INFORMATION pi; si.cb=sizeof(si); TCHAR command[] = _T(\"Operation2.exe\"); CreateProcess ( NULL, command, NULL, NULL, TRUE, 0, NULL, NULL, &amp;si, &amp;pi ); DWORD timing=0; while(1) { for(DWORD i=0; i&lt;10000; i++) for(DWORD i=0; i&lt;10000; i++); _fputts(_T(\"Parent \\n\"), stdout); timing+=1; if(timing==2) SetPriorityClass(pi.hProcess, NORMAL_PRIORITY_CLASS); } return 0;}// 이 예제를 통해 커널오브젝트는 여러 프로세스에 의해 접근이 가능하다는걸 알 수 있다. 구조체 변수 pi의 멤버typedef struct _PROCESS_INFORMATION{ HANDLE hProcess; // 프로세스의 핸들 HANDLE hThread; // 쓰레드 핸들 DWORD dwProcessId; // 프로세스의 ID DWORD dwThreadId; // 쓰레드 ID} PROCESS_INFORMATION; ID와 핸들의 차이점 프로세스 핸들은 프로세스의 커널 오브젝트를 구분짓기 위한 것이고, 프로세스 ID는 커널 오브젝트가 아니라 프로세스 자체를 구분짓기 위한 것이다. CloseHandle함수에 대한 정확한 이해보통 커널 오브젝트를 생성한 주체가 커널 오브젝트를 소멸시킬 권한(소멸시킬 시점을 결정지을 권한)을 가지고 있다고 생각하지만, 그건 오해의 소지가 있다. CreateProcess함수를 호출하는 프로그래머가 커널오브젝트를 생성한게 아니라, 프로세스 생성에 대한 요청으로, 이 함수의 호출을 받은 운영체제가 커널 오브젝트 생성의 주체다.프로세스를 생성하면 그에 맞는 커널오브젝트가 생성된다.하지만 프로세스가 소멸된다고 해서 커널 오브젝트가 소멸된다고 할 수 없다.이와 관련해서 CloseHandle 함수를 소개한다. CloseHandle 함수와 프로세스 소멸 (KernelObjProb1.cpp)/*KernelObjProb1.cpp프로그램 설명 : CloseHandle 함수 이해 1*/#include &lt;stdio.h&gt;#include &lt;tchar.h&gt;#include &lt;windows.h&gt;int _tmain(int argc, TCHAR* argv[]){ STARTUPINFO si={0,}; PROCESS_INFORMATION pi; si.cb=sizeof(si); TCHAR command[]=_T(\"KernerlObjProb2.exe\"); CreateProcess( NULL, command, NULL, NULL ,TRUE, 0, NULL, NULL, &amp;si , &amp;pi ); CloseHandle(pi.hProcess); return 0;} CloseHandle 함수의 선언 BOOL CloseHandle( HANDLE hObject); CloseHandle은 함수 이름처럼 핸들을 닫는(반환) 기능이 있다. KernelObjProb2.cpp/*KernelObjProb2.cpp프로그램 설명 : CloseHandle 함수 이해 2*/#include &lt;stdio.h&gt;#include &lt;tchar.h&gt;#include &lt;windows.h&gt;int _tmain(int argc, TCHAR* argv[]){ DWORD n=0; while(n&lt;100) { for(DWORD i=0; i&lt;10000; i++) for(DWORD i=0; i&lt;10000; i++); _fputts(_T(\"KernerlObjProb2.exe \\n\"), stdout); n++; } return 0;}KernerlObjProb1.cpp를 실행하는 프로세스를 A프로세스,KernerlObjProb2.cpp를 실행하는 프로세스를 B프로세스라고 한다면,A프로세스는 실행과정에서 B프로세스를 생성하고나서 B프로세스의 핸들을 이용해 CloseHandle 함수를 호출하므로B프로세스는 CloseHandle 함수 호출에 의해서 프로세스가 종료되고 커널오브젝트도 소멸되어 전부 실행되지 않을거 같지만프로세스가 소멸된다고 커널오브젝트가 소멸되지 않기 때문에 출력된다. CloseHandle 함수와 프로세스 종료 코드/* OperationStateParent.cpp 프로그램 설명 : 프로그램 실행 결과에 따른 반환값 확인*/#include &lt;stdio.h&gt;#include &lt;tchar.h&gt;#include &lt;windows.h&gt; int _tmain(int argc, TCHAR* argv[]){ STARTUPINFO si ={0,}; PROCESS_INFORMATION pi; DWORD state; si.cb=sizeof(si); si.dwFlags=STARTF_USEPOSITION|STARTF_USESIZE; si.dwX=100; si.dwY=200; si.dwXSize=300; si.dwYSize=200; si.lpTitle=_T(\"return &amp; exit\"); TCHAR command[]=_T(\"OperationStateChild.exe\"); CreateProcess(NULL, command, NULL, NULL , TRUE , CREATE_NEW_CONSOLE, NULL, NULL, &amp;si, &amp;pi ); // CreateProcess for(DWORD i=0; i&lt;10000; i++) //Child Process의 우선종료 위해 for(DWORD i=0; i&lt;100000; i++); // WaitForSingleObject(pi.hProcess, INFINITE); GetExitCodeProcess(pi.hProcess, &amp;state); if(state == STILL_ACTIVE) _tprintf(_T(\"STILL_ACTIVE \\n\\n\")); else _tprintf(_T(\"state : %d \\n\\n\"), state); // CloseHandle(pi.hProcess); return 0;}/* OperationStateChild.cpp 프로그램 설명: 프로그램 실행결과에 따른 반환값*/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;tchar.h&gt;#include &lt;windows.h&gt;int _tmain(int argc, TCHAR* argv[]){ float num1, num2; _fputts(_T(\"Return Value Test \\n\"), stdout); _tscanf(_T(\"%f %f\"), &amp;num1, &amp;num2); if(num2 == 0) { exit(-1); // or return -1; } _tprintf(_T(\"Operation Result : %f \\n\"), num1/num2); return 1;}OperationStateChild는 두 개의 실수를 입력받아 나눗셈하는 프로그램이다.만약 num2에 0을 입력한다면 exit(-1)를 실행하고 문제 없을경우 return 1를 실행한다.종료 상태를 알리는 값들로, return문에 의해 반환되는 값, exit 함수 호출 시 전달되는 인자값들은 종료상황을 알리기 위해 사용된다.커널 오브젝트와 Usage Count 자식 프로세스 종료코드는 자식 프로세스의 커널오브젝트에 저장된다. 자식 프로세스가 종료될 때 커널오브젝트도 동시에 소멸된다면 부모 프로세스는 종료코드를 얻을 수 없기 때문이다. 때문에 프로세스가 종료되었다고 해서 커널 오브젝트까지 동시에 소멸시키지는 않는다. 그렇다면 언제 커널오브젝트를 소멸시키는게 좋다고 하면 해당 커널 오브젝트를 참조하는 대상이 하나도 없을 때 소멸시키는 것이 가장 이상적이고, 이것이 Windows가 커널 오브젝트 소멸시키기를 결정하는 방식이다. Windows는 이러한 정책을 기반으로 커널 오브젝트 소멸시기를 결정짓기 위해 Usage Count(참조 횟수)라는 것을 관리한다.이 Usage Count가 0이 되는 순간, 해당 커널 오브젝트는 소멸된다. 프로세스는 생성과 동시에 커널 오브젝트의 Usage Count가 1이 된다. 만약 생성과 동시에 Usage Count가 0으로 초기화된다면, 커널 오브젝트 소멸 원칙에 의해 생성과 동시에 소멸되고 만다.이를 막기 위해서는 자식 프로세스는 생성과 동시에 Usage Count가 1이 된다. 이렇게 초기화된 이후부터는 Usage Count가 하나씩 증가한다. 접근 가능 대상이 늘어난다는 것은 커널 오브젝트에 접근 가능한 핸들 개수의 증가를 의미한다. 자식 프로세스의 Usage Count는 1이아닌 2가 되어야 한다. 왜냐하면 부모 프로세스가 CreateProcess 함수 호출 과정에서 자식 프로세스의 핸들을 얻기 때문이다. CloseHandle 함수는 핸들을 반환하면서 커널 오브젝트의 Usage Count를 하나 감소시키는 기능을 지닌다" }, { "title": "COM", "url": "/posts/COM/", "categories": "DirectX", "tags": "directx", "date": "2022-06-21 00:00:00 +0900", "snippet": "1. COM (Component Object Model)과 DirectX정의 및 역할COM (Component Object Model)은 Microsoft가 개발한 기술로, 소프트웨어 구성 요소를 만들고 사용하는 표준화된 방법을 제공 DirectX에서는 다음과 같은 중요한 역할을 함 프로그래밍 언어 독립성: COM을 통해 C++, C#, VB 등 다양한 언어에서 DirectX API를 일관되게 사용할 수 있습니다. 하위 호환성: 새로운 버전의 DirectX가 나와도 기존 COM 인터페이스를 유지하거나 확장함으로써 이전 버전과의 호환성을 제공합니다. DirectX의 많은 핵심 기능들(예: 디바이스, 리소스, 뷰 등)은 COM 객체 또는 COM 인터페이스라는 형태로 제공됩니다. 이들은 내부적으로 클래스로 구현되어 있습니다. 사용 방식 DirectX 프로그래머는 일반적으로 COM 객체의 내부 구현을 직접 다루기보다는, COM 인터페이스 포인터를 얻어와서 사용 이 인터페이스 포인터를 통해 COM 객체가 제공하는 다양한 메서드(함수)를 호출하여 GPU를 제어하고 리소스를 관리 예시: 렌더 타겟 뷰(ID3D11RenderTargetView)를 생성하는 경우 DirectX 함수(예: ID3D11Device::CreateRenderTargetView)는 생성된 렌더 타겟 뷰 객체를 가리키는 인터페이스 포인터를 출력 매개변수로 반환 이 포인터를 저장할 변수의 주소를 해당 함수에 넘겨주어, 함수가 그 주소에 생성된 인터페이스 포인터 값을 써넣도록 함. (스마트 포인터 ComPtr 사용 시에는 GetAddressOf() 메서드가 이 역할을 합니다.) 주요 메서드 (ComPtr 사용 시) ComPtr&lt;InterfaceType&gt; myInterfacePtr myInterfacePtr.GetAddressOf(): ComPtr이 내부적으로 관리하는 원시 인터페이스 포인터의 주소 (InterfaceType)**를 반환 DirectX 생성 함수들이 인터페이스 포인터를 출력으로 반환할 때 이 메서드를 사용하여 ComPtr에 결과를 저장 myInterfacePtr.Get(): ComPtr이 관리하는 원시 인터페이스 포인터 (InterfaceType*)를 반환. 다른 함수에 인터페이스 포인터를 전달해야 할 때 사용 2. ComPtr (COM 스마트 포인터)COM 객체의 수명 관리: 참조 카운팅 (Reference Counting) COM 객체는 자체적으로 참조 카운트(Reference Count)라는 내부 값을 통해 수명을 관리. 이 참조 카운트는 해당 COM 객체를 현재 몇 군데에서 참조(사용)하고 있는지를 나타냄 새로운 인터페이스 포인터가 객체를 참조하기 시작하면 참조 카운트가 1 증가합니다 (내부적으로 AddRef() 메서드 호출). 인터페이스 포인터가 더 이상 객체를 참조하지 않게 되면 참조 카운트가 1 감소합니다 (내부적으로 Release() 메서드 호출). 참조 카운트가 0이 되면, COM 객체는 스스로 메모리에서 소멸합니다.ComPtr의 필요성 및 장점 전통적인 방식에서는 개발자가 직접 AddRef()와 Release()를 호출하여 참조 카운트를 관리해야 했습니다. 특히 Release() 호출을 잊어버리면 메모리 누수가 발생하고, 너무 많이 호출하면 객체가 아직 사용 중임에도 불구하고 소멸되어 프로그램 충돌을 일으킬 수 있습니다. ComPtr은 이러한 COM 객체의 참조 카운팅을 자동으로 관리해주는 스마트 포인터 클래스입니다. (주로 Windows Runtime C++ Template Library - WRL에 포함된 Microsoft::WRL::ComPtr을 사용합니다.)장점 RAII (Resource Acquisition Is Initialization) 패턴: ComPtr 객체가 생성될 때 (또는 새 COM 객체를 가리키도록 할당될 때) 자동으로 참조 카운트를 증가시키고, ComPtr 객체가 범위를 벗어나 소멸될 때 자동으로 참조 카운트를 감소시킵니다 (Release() 호출). 메모리 누수 방지: Release() 호출을 잊어버릴 위험을 크게 줄여줍니다. 코드 간결성 및 안정성 향상: 수동 참조 카운팅으로 인한 복잡성과 오류 가능성을 줄여줍니다. " }, { "title": "Binary Tree", "url": "/posts/Binary_tree/", "categories": "자료구조, Tree", "tags": "data_structure", "date": "2022-06-20 00:00:00 +0900", "snippet": "이진 트리 트리의 모든 노드를 차수 2 이하로 제한하여 전체 트리의 차수가 2 이하가 되도록 정의한 트리 이진 트리의 자식노드는 왼쪽 자식노드와 오른쪽 자식노드만 있다. 이진트리의 특성 노드가 n개인 이진 트리는 항상 간선이 (n-1)개이다 높이가 h인 이진 트리가 가질 수 있는 노드 개수는 최소(h+1)개이며, 최대(2^h-1)개이다. 높이가 3인 최소 노드를 갖는 트리(왼쪽)와 최대 노드를 갖는 트리(오른쪽) 이진 트리의 종류 포화 이진트리 모든 레벨에 노드가 꽉 차 더 이상 노드를 추가할 수 없는 트리 &lt;/p&gt; 완전 이진 트리 높이가 h이고 노드 수가 n일때, 노드 위치가 포화 이진 트리에서의 노드 1번부터 n번까지 위치가 완전히 일치하는 트리 &lt;img src=\"./../../assets/img/Compelete%20Binray%20Tree.jpg\"width=500 height =250&gt;&lt;/p&gt; 편향 이진 트리 높이가 h일 때, h+1개의 노드를 가지면서 모든 노드가 왼쪽이나 오른쪽중 한 방향으로만 서브 트리를 가지고 있는 트리 &lt;img src=\"./.../../../../assets/img/Skewed%20Binary%20Tree.png\"width=500 height =200&gt;&lt;/p&gt;이진 트리의 구성 배열을 이용한 이진트리와 구조체를 이용한 이진트리가 있다 배열로 구현한 이진트리 1차원 배열로 높이가 h인 포화 이진트리의 노드 번호를 배열의 인덱스로 사용한다. 인덱스 관계 노드 인덱스 성립조건 노드 i의 부모 노드 i/2 i&gt;1 노드 i의 왼쪽 자식 노드 2 x i (2 x i) ≤ n 노드 i의 오른쪽 자식 노드 (2 x i) + 1 (2 x i) + 1 ≤ n 루트 노드 1 n&gt;0 포인터가 포함된 노드(구조체)로 구현한 이진트리 데이터를 저장하는 변수와 왼쪽 자식노드를 연결하는 포인터,오른쪽 자식노드를 연결하는 포인터로 구성 typedef struct treeNode{ char data; struct treeNode *left; struct treeNode *right;} treeNode;이진 트리의 순회 순회란 모든 원소를 빠트리거나 중복하지 않고 처리하는 연산 선형 자료구조와 달리 비선형 계층 구조인 트리는 현재 노드를 처리한 후에 어떤 노드를 처리할지 결정하는 기준을 정해놓은 연산이 필요하다 이진트리의 순회 종류 전위 순회 현재노드 처리 -&gt; 왼쪽 자식노드 처리 -&gt; 오른쪽 자식노드 처리 중위 순회 왼쪽 자식노드 처리 -&gt; 현재 노드 처리 -&gt; 오른쪽 자식노드 처리 후위 순회 왼쪽 자식 노드 처리 -&gt; 오른쪽 자식노드 처리 -&gt; 현재 노드 처리 Code// 이진 트리에 대한 전위 순회 연산void preorder(treeNode* root) { if (root) { printf(\"%c\", root-&gt;data); //현재 노드 처리 preorder(root-&gt;left); //왼쪽 자식노드 처리 preorder(root-&gt;right);\t //오른쪽 자식노드 처리 }}// 이진 트리에 대한 중위 순회 연산void inorder(treeNode* root) { if (root) { inorder(root-&gt;left); //왼쪽 자식노드 처리 printf(\"%c\", root-&gt;data); //현재 노드 처리 inorder(root-&gt;right); //오른쪽 자식노드 처리 }}// 이진 트리에 대한 후위 순회 연산void postorder(treeNode* root) { if (root) { postorder(root-&gt;left); //왼쪽 자식노드 처리 postorder(root-&gt;right); //오른쪽 자식노드 처리 printf(\"%c\", root-&gt;data); //현재 노드 처리 }}" }, { "title": "컴퓨트 쉐이더", "url": "/posts/%EC%BB%B4%ED%93%A8%ED%84%B0-%EC%89%90%EC%9D%B4%EB%8D%94/", "categories": "DirectX", "tags": "directx", "date": "2022-06-17 00:00:00 +0900", "snippet": "컴퓨트 셰이더 (Compute Shader)정의 및 역할 컴퓨트 셰이더는 DirectX 11에서 도입된 프로그래머블 셰이더 스테이지로, 전통적인 그래픽스 렌더링 파이프라인(정점 처리, 픽셀 처리 등)과는 독립적으로 GPU를 사용하여 일반적인 목적의 병렬 계산(GPGPU - General-Purpose computing on Graphics Processing Units)을 수행하는 데 사용 그래픽스 렌더링 외에 물리 시뮬레이션, 이미지 및 비디오 처리, 인공 지능 알고리즘(예: 뉴럴 네트워크), 복잡한 데이터 분석, 암호화 등 다양한 분야에서 GPU의 강력한 병렬 처리 능력을 활용하기 위해 사용 주요 특징독립적인 파이프라인 그래픽스 파이프라인의 입력 조립기(IA), 정점 셰이더(VS), 래스터라이저(RS), 픽셀 셰이더(PS), 출력 병합기(OM) 단계와는 별도로 작동 (단, 그래픽스 리소스와 데이터를 공유하고 상호작용할 수 있음)데이터 입출력 주된 데이터 입력 및 출력은 버퍼와 텍스처의 SRV(읽기)와 UAV(읽기/쓰기)를 통해 이루어집니다. 특히 UAV를 통해 결과를 다시 GPU 메모리에 기록하는 것이 일반적스레드 기반 실행 HLSL 코드 내에서 [numthreads(X, Y, Z)] 속성을 사용하여 스레드 그룹(Thread Group) 내에 몇 개의 스레드를 동시에 실행할지 정의합니다 (X * Y * Z 개의 스레드). C++에서는 Dispatch(GroupX, GroupY, GroupZ) 함수를 호출하여 몇 개의 스레드 그룹을 실행할지 지정 총 실행 스레드 수는 (XYZ) * (GroupXGroupYGroupZ)병렬 처리 수천에서 수백만 개의 스레드를 동시에 실행하여 대규모 데이터 병렬 처리에 매우 효과적공유 메모리 및 동기화 스레드 그룹 내의 스레드들은 groupshared 키워드로 선언된 그룹 공유 메모리를 사용하여 데이터를 빠르고 효율적으로 공유할 수 있음 GroupMemoryBarrierWithGroupSync(), DeviceMemoryBarrierWithGroupSync()와 같은 배리어(barrier) 함수를 사용하여 스레드 그룹 내 또는 전체 디바이스 메모리 접근에 대한 동기화를 수행할 수 있음 유연성 특정 하드웨어 기능에 직접 접근하거나 복잡한 알고리즘을 구현하는 데 있어 그래픽스 셰이더보다 더 큰 유연성을 제공HLSL C++ 설정 간략 HLSL로 컴퓨트 셰이더 코드를 작성하고 컴파일하여 ID3DBlob 객체를 얻습니다. ID3D11Device::CreateComputeShader() 함수로 ID3D11ComputeShader 객체를 생성합니다. ID3D11DeviceContext::CSSetShader() 함수로 현재 사용할 컴퓨트 셰이더를 설정합니다. 필요한 SRV, UAV, 상수 버퍼, 샘플러 등을 CSSetShaderResources(), CSSetUnorderedAccessViews(), CSSetConstantBuffers(), CSSetSamplers() 함수로 각각의 바인딩 슬롯에 설정합니다. ID3D11DeviceContext::Dispatch(GroupX, GroupY, GroupZ) 함수를 호출하여 컴퓨트 셰이더를 실행시킵니다. 컴퓨트 셰이더 작업이 완료된 후, 필요에 따라 CPU와 GPU 간의 동기화를 수행하고 UAV로부터 결과를 다시 읽어오거나 다른 그래픽스 작업에 사용합니다. // 입력으로 사용할 텍스처 (읽기 전용)Texture2D&lt;float4&gt; sourceTexture : register(t0);// 출력으로 사용할 텍스처 (읽기/쓰기)RWTexture2D&lt;float4&gt; resultTexture : register(u0);// 스레드 그룹당 스레드 수 정의 (예: 16x16 = 256 스레드)[numthreads(16, 16, 1)]void ImageFilterCS(uint3 dispatchThreadID : SV_DispatchThreadID) // 디스패치 내 고유 스레드 ID{ uint2 pixelCoords = dispatchThreadID.xy; // 현재 스레드가 처리할 픽셀 좌표 // 간단한 반전 필터 예시 float4 originalColor = sourceTexture.Load(int3(pixelCoords, 0)); // Load는 정수 좌표 사용 float4 invertedColor = float4(1.0f - originalColor.rgb, originalColor.a); // 결과 텍스처에 쓰기 resultTexture[pixelCoords] = invertedColor;}" }, { "title": "에라토스테네스의 체", "url": "/posts/%EC%97%90%EB%9D%BC%ED%86%A0%EC%8A%A4%ED%85%8C%EB%84%A4%EC%8A%A4%EC%9D%98_%EC%B2%B4/", "categories": "코딩테스트, 수학", "tags": "coding test", "date": "2022-06-16 00:00:00 +0900", "snippet": "에라토스테네스의 체 소수 판별 알고리즘 시간복잡도는 O(NloglogN) 원리 모두 소수라고 가정하고, 만약 소수를 만난다면 그 소수의 배수는 소수가 아닌 합성수이므로 그 수를 check에서 false #define MAX 100; // 소수 판별 범위int arr[MAX];bool check[MAX];void primeNumber(){ memset(check,true,sizeof(check) // 모든 값 true for (int i = 2; i &lt;= MAX; i++) { arr[i] = i; // 배열 초기화 } // i는 범위의 제곱근까지 j에서 범위까지 체크 for (int i = 2; i &lt;= sqrt(MAX); i++) { if (check[i] == false) // 이미 체크한 변수는 continue continue; // i의 배수는 i가 약수이므로 j에서 모두 소수가 아님(false)를 체크 for (int j = i + i; j &lt;= MAX; j += i) { check[j] = false; // 소수의 배수들은 소수가 아니므로 모두 false } } // 소수 출력 for (int i = 2; i &lt;= MAX; i++) { if(check[i]) // 만약 체크해서 true면 소수이므로 출력 printf(\"%d\\n\", arr[i]); }}" }, { "title": "프로세스의 생성과 소멸", "url": "/posts/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4/", "categories": "윈도우즈시스템프로그래밍, 운영체제", "tags": "windows", "date": "2022-06-15 00:00:00 +0900", "snippet": "프로세스의 이해 프로세스 실행 중에 있는 프로그램을 의미 크롬의 실행파일 Chrome.exe은 프로그램이고 이 프로그램을 실행시켜 보게되는 창은 프로세스가 된다 프로세스를 구성하는 요소 메모리 공간 Data 영역 : 전역변수,static 변수를 할당하는 메모리 영역 Stack 영역 : 지역변수 할당과 함수 호출시 전달되는 인자값들을 저장하는 메모리 영역 Heap 영역 : 동적할당(malloc,new)을 받는 메모리 영역 Code 영역 : 실행파일을 구성하는 명령어들이 올라가는 메모리 영역 프로그램 실행시 만들어지는 메모리구조도 프로세스라고 한다. 레지스터 구성 프로세스가 실행되면 레지스터들도 필요한 데이터로 채워진다 따라서, 레지스터들의 상태도 프로세스의 일부로 포함시켜 말할 수 있다. 프로세스의 스케줄링과 상태 변화CPU는 하나인데 어떻게 여러개의 프로그램이 동시에 실행가능한 이유는 스케줄링 때문이다. 프로세스 스케줄링 하나의 CPU가 여러개의 프로세스들에 CPU 할당 시간을 나눠서 실행 CPU가 매우 빨라서 동시에 실행시킨다고 느껴짐. 스케줄링의 기본 원리 프로세스들에게 CPU를 할당하는 기준이 중요하다 프로세스의 CPU 할당 순서 및 방법을 결정짓는 일을 스케줄링이라고 한다 이 때 사용되는 알고리즘을 가리켜 스케줄링 알고리즘이라고 한다. 스케줄링 알고리즘을 적용해서 실제로 프로세스를 관리하는 운영체제 요소(모듈)을 가리켜 스케줄러라고 한다. 프로세스들이 실행되는 형태 고전 방식은 실행해야 할 일을 순차적으로 실행 A프로세스 실행 A프로세스가 종료되면 B프로세스 실행 B프로세스가 종료되면 C프로세스 실행 멀티 프로세서 기반은 동시에 실행되는 형태 A,B,C 프로세스를 모두 실행후, 멀티 프로세스 운영체제의 스케줄러에 의해서 프로세스들이 관리된다. 멀티 프로세스 운영체제가 효율적인 이유 일반적으로, 프로그램이 실행되는 과정에서 많은 시간을 I/O에 할당한다.(I/O는 입력과 출력 , 네트워크와 호스트사이 데이터 송수신등을 의미) 고전방식이라면 프로세스가 I/O관련 작업을 하고있다면 CPU는 아무일도 하지 못함 멀티 프로세서 기반은 프로세스가 I/O관련 작업도중이라면 다른 프로세스를 실행되도록 스케줄링을 시켜 CPU가 계속 일을 한다. 프로세스의 상태 변화여러 프로세스가 돌아가면서 실행되기 때문에, 프로세스의 각각의 상태는 시간 흐름에 따라 변화한다 S(Start)에서 Ready 상태로의 전이 S는 프로세스가 생성되었음을 의미 프로세스는 생성과 동시에 Ready 상태 Ready상태에 있는 프로세스는 CPU(스케줄러)에 의해 실행을 기다리는 상태 Ready 상태에서 Running 상태로의 전이 스케줄러는 Ready 상태에 있는 프로세스중 하나를 선택해서 CPU에 의해서 실행되도록 한다. 선택된 프로세스는 Ready상태에서 Running 상태가 되어 실행 Running 상태에서 Ready 상태로의 전이 프로세스들은 생성 시 중요도에 따라서 우선순위가 매겨진다 실행중인 프로세스보다 우선순위가 높은 프로세스가 있을 경우, 실행중인 프로세스는 Ready가 되고 우선순위가 높은 프로세스는 실행된다. Running 상태에서 Blocked 상태로의 전이 실행중에 있는 프로세스가 실행을 멈추는 상태 , 일반적으로 데이터 입,출력 관련된 일을 하는경우에 발생한다 데이터 입출력동안에는 CPU에 의해 프로세스가 더이상 실행될수 없어서 Blocked상태로 만들고 Ready 상태에 있는 프로세스 중 하나를 대신 실행시키는 것이 효율적이다. Blocked 상태에서 Ready 상태로의 전이 Blokced 상태는 스케줄러에 의해서 선택될 수 없는 상태 입출력이 완료된 Blocked 프로세스는 Ready 상태가 되어 스케줄러를 기다린다. Ready와 Blokced의 차이점 Ready 상태 스케줄러에 의해 선택되어 지금 당장이라도 실행 가능한 상태 Blocked 상태는 스케줄러에 의해서 선택될 수 없는 상태 컨텍스트 스위칭(Context Switching)멀티 프로세스 운영체제가 여러 장점이 있지만 실행중인 프로세스를 변경하는건 시스템에 많은 부하를 가져다 준다.이유는 CPU 내에 존재하는 레지스터들은 현재 실행 중에 있는 프로세스 관련 데이터들로 채워지기 때문에 변경시 레지스터의 값들을 변경해야 하기 때문이다.즉 컨텍스트 스위칭이란 여러 프로세스를 실행하고 있는 상태에서 인터럽트 요청에 의해 기존의 프로세스의 상태 또는 레지스터 값(Context)을 저장하고 CPU가 다음 프로세스를 수행하도록 새로운 프로세스의 상태 또는 레지스터 값(Context)를 교체하는 작업이다 " }, { "title": "Circle Queue", "url": "/posts/CircleQueue/", "categories": "자료구조, Queue", "tags": "data_structure", "date": "2022-06-14 00:00:00 +0900", "snippet": "Circle Queue 선형 큐의 문제점을 개선한 자료구조 선형 큐와 원형 큐의 차이점 선형 큐는 rear이 배열의 마지막 자리가 되어도 front에서 지운 배열의 자리를 활용하지 못함 원형 큐는 rear이 꽉 차있을 때 enQueue를 한다면 (cQ-&gt;rear + 1) % cQ_SIZE 로 사이즈가 넘어간다면 가장 앞으로 온다 Circle Queue CodeCircleQueue.h#pragma once#define cQ_SIZE 4typedef char element;\t\t// 큐 원소(element)의 자료형을 char로 정의typedef struct { element queue[cQ_SIZE];\t// 1차원 배열 큐 선언 int front, rear;} QueueType;QueueType* createCQueue();int isCQueueEmpty(QueueType* cQ);int isCQueueFull(QueueType* cQ);void enCQueue(QueueType* cQ, element item);element deCQueue(QueueType* cQ);element peekCQ(QueueType* cQ);void printCQ(QueueType* cQ);CircleQueue.cpp#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include \"cQueueS.h\"QueueType* createCQueue() { QueueType* cQ; cQ = (QueueType*)malloc(sizeof(QueueType)); cQ-&gt;front = 0; // front 초깃값 설정 cQ-&gt;rear = 0; // rear 초깃값 설정 return cQ;}// 원형 큐가 공백 상태인지 검사하는 연산int isCQueueEmpty(QueueType* cQ) { if (cQ-&gt;front == cQ-&gt;rear) { printf(\" Circular Queue is empty! \"); return 1; } else return 0;}// 원형 큐가 포화 상태인지 검사하는 연산int isCQueueFull(QueueType* cQ) { if (((cQ-&gt;rear + 1) % cQ_SIZE) == cQ-&gt;front) { printf(\" Circular Queue is full! \"); return 1; } else return 0;}// 원형 큐의 rear에 원소를 삽입하는 연산void enCQueue(QueueType* cQ, element item) { if (isCQueueFull(cQ))\treturn; else { cQ-&gt;rear = (cQ-&gt;rear + 1) % cQ_SIZE; cQ-&gt;queue[cQ-&gt;rear] = item; }}// 원형 큐의 front에서 원소를 삭제하고 반환하는 연산element deCQueue(QueueType* cQ) { if (isCQueueEmpty(cQ)) return; else { cQ-&gt;front = (cQ-&gt;front + 1) % cQ_SIZE; return cQ-&gt;queue[cQ-&gt;front]; }}// 원형 큐의 가장 앞에 있는 원소를 검색하는 연산element peekCQ(QueueType* cQ) { if (isCQueueEmpty(cQ)) exit(1); else return cQ-&gt;queue[(cQ-&gt;front + 1) % cQ_SIZE];}// 원형 큐의 원소를 출력하는 연산void printCQ(QueueType* cQ) { int i, first, last; first = (cQ-&gt;front + 1) % cQ_SIZE; last = (cQ-&gt;rear + 1) % cQ_SIZE; printf(\" Circular Queue : [\"); i = first; while (i != last) { printf(\"%3c\", cQ-&gt;queue[i]); i = (i + 1) % cQ_SIZE; } printf(\" ] \");}" }, { "title": "유클리드 호제법", "url": "/posts/%EC%9C%A0%ED%81%B4%EB%A6%AC%EB%93%9C%ED%98%B8%EC%A0%9C%EB%B2%95/", "categories": "코딩테스트, 수학", "tags": "coding test", "date": "2022-06-13 00:00:00 +0900", "snippet": "유클리드 호제법 최대 공약수 임의의 두 자연수 a, b에 대해 최대공약수를 구하는 함수(a&gt;b) // 재귀함수 버전int gcd(int a, int b){\tif (b == 0)\t\treturn a;\telse\t\treturn gcd(b, a % b);}// 반복문 버전int gcd(int a,int b){while(1){ int r = a%b; if(r==0) return b; a = b; b = r; }} 최대 공배수 임의의 두 자연수 a, b에 대해 최소공배수를 구하는 함수(a&gt;b) int lcm(int a, b){ return a * b / gcd(a, b);}" }, { "title": "Mesh", "url": "/posts/Mesh/", "categories": "DirectX", "tags": "directx", "date": "2022-06-13 00:00:00 +0900", "snippet": "메시(Mesh) 3D 객체의 형태를 정의하는 정점(Vertex)들의 집합과 이 정점들을 연결하여 면(Face, 주로 삼각형)을 만드는 인덱스(Index) 정보를 포함하는 핵심 데이터 구조 기본적으로 GPU 메모리에 생성된 정점 버퍼(Vertex Buffer)와 인덱스 버퍼(Index Buffer)로 구성되며, 이를 ‘리소스’처럼 취급하여 렌더링에 사용 1. 메시 클래스 기본 구조 (C++ 헤더 예시)#pragma once#include \"CRes.h\" // 사용자 정의 리소스 기본 클래스 (가정)#include &lt;d3d11.h&gt; // DirectX 11 헤더#include &lt;wrl/client.h&gt; // ComPtr 사용을 위한 헤더#include &lt;vector&gt; // std::vector 사용 (선택 사항)// ComPtr 사용을 위한 네임스페이스using Microsoft::WRL::ComPtr;// 정점 구조체 (애플리케이션에 따라 다름)struct Vtx{ Vec3 vPos; // 위치 (예: DirectX::XMFLOAT3) Vec4 vColor; // 색상 (예: DirectX::XMFLOAT4) Vec2 vUV; // 텍스처 좌표 (예: DirectX::XMFLOAT2)};class CMesh : public CRes // CRes를 상속받는다고 가정{private: ComPtr&lt;ID3D11Buffer&gt; m_VB; // GPU상의 정점 버퍼 ComPtr&lt;ID3D11Buffer&gt; m_IB; // GPU상의 인덱스 버퍼 D3D11_BUFFER_DESC m_tVBDesc; // 정점 버퍼 생성 정보 D3D11_BUFFER_DESC m_tIBDesc; // 인덱스 버퍼 생성 정보 UINT m_iVtxCount; // 총 정점 개수 UINT m_iIdxCount; // 총 인덱스 개수 // (선택 사항) CPU 메모리에 원본 데이터를 유지할 경우 // void* m_pVtxSys; // CPU 측 정점 데이터 복사본 // void* m_pIdxSys; // CPU 측 인덱스 데이터 복사본 // 또는 std::vector 사용 std::vector&lt;Vtx&gt; m_vecVtxSys; std::vector&lt;UINT&gt; m_vecIdxSys;public: CMesh(); ~CMesh(); // 정점 및 인덱스 데이터로 GPU 버퍼를 생성하는 함수 int Create(const std::vector&lt;Vtx&gt;&amp; _vecVtx, const std::vector&lt;UINT&gt;&amp; _vecIdx); // 또는 void 포인터 사용 버전: // int Create(void* _pVtxData, UINT _iVtxCount, UINT _iVtxStride, void* _pIdxData, UINT _iIdxCount); // 렌더링 파이프라인에 이 메시의 버퍼를 설정하고 그리기 명령을 호출하는 함수 void Render(ID3D11DeviceContext* _pContext); // (CRes 상속 시) 파일로부터 로드하는 가상 함수 등 // virtual int Load(const std::wstring&amp; _strFilePath) override { return S_OK; }};2. 메시 데이터 정의 및 생성 (C++ 예시) 3D 모델을 만들기 위한 정점 데이터(위치, 색상, UV 등)와 인덱스 데이터를 정의하고, 이를 CMesh 객체를 통해 GPU 버퍼로 만듦// (어딘가에 전역 또는 멤버로 선언된 ID3D11Device* g_pd3dDevice 가정)// 사각형 메시 생성 예시void CreateRectangleMesh(ID3D11Device* pDevice, CMesh* pMesh){ std::vector&lt;Vtx&gt; vecVertices; std::vector&lt;UINT&gt; vecIndices; Vtx vertex; // 정점 데이터 정의 (0: 좌상, 1: 우상, 2: 우하, 3: 좌하) // 0 --- 1 // | \\ | // 3 --- 2 vertex.vPos = Vec3(-0.5f, 0.5f, 0.f); vertex.vColor = Vec4(1.f, 0.f, 0.f, 1.f); vertex.vUV = Vec2(0.f, 0.f); // 좌상 (빨강) vecVertices.push_back(vertex); vertex.vPos = Vec3(0.5f, 0.5f, 0.f); vertex.vColor = Vec4(0.f, 1.f, 0.f, 1.f); vertex.vUV = Vec2(1.f, 0.f); // 우상 (초록) vecVertices.push_back(vertex); vertex.vPos = Vec3(0.5f, -0.5f, 0.f); vertex.vColor = Vec4(0.f, 0.f, 1.f, 1.f); vertex.vUV = Vec2(1.f, 1.f); // 우하 (파랑) vecVertices.push_back(vertex); vertex.vPos = Vec3(-0.5f, -0.5f, 0.f); vertex.vColor = Vec4(1.f, 1.f, 0.f, 1.f); vertex.vUV = Vec2(0.f, 1.f); // 좌하 (노랑) vecVertices.push_back(vertex); // 인덱스 데이터 정의 (삼각형 두 개로 사각형 구성) // 삼각형 1: 0-1-2 vecIndices.push_back(0); vecIndices.push_back(1); vecIndices.push_back(2); // 삼각형 2: 0-2-3 vecIndices.push_back(0); vecIndices.push_back(2); vecIndices.push_back(3); // CMesh 객체의 Create 함수 호출 (pDevice는 ID3D11Device 포인터) if (FAILED(pMesh-&gt;Create(vecVertices, vecIndices))) // Create 함수 내에서 pDevice 사용 { // 에러 처리 MessageBox(nullptr, L\"메시 생성 실패!\", L\"에러\", MB_OK); } // 예시: 리소스 매니저에 추가 // CResMgr::GetInst()-&gt;AddRes&lt;CMesh&gt;(L\"RectMesh\", pMesh);}3. GPU 버퍼 생성 (CMesh::Create 함수 구현 예시) CMesh 클래스 내에서 정점 및 인덱스 데이터를 받아 GPU 버퍼를 생성하는 Create 함수의 구현 (실제 DEVICE는 ID3D11Device의 인스턴스여야 합니다. 여기서는 전역 또는 엔진 클래스 멤버로 접근한다고 가정) // CMesh.cppextern ID3D11Device* g_pd3dDevice; // 전역 또는 다른 방식으로 접근 가능한 디바이스 포인터int CMesh::Create(const std::vector&lt;Vtx&gt;&amp; _vecVtx, const std::vector&lt;UINT&gt;&amp; _vecIdx){ m_iVtxCount = static_cast&lt;UINT&gt;(_vecVtx.size()); m_iIdxCount = static_cast&lt;UINT&gt;(_vecIdx.size()); // (선택 사항) CPU 메모리에 데이터 복사본 유지 m_vecVtxSys = _vecVtx; m_vecIdxSys = _vecIdx; // 1. 정점 버퍼(Vertex Buffer) 생성 ZeroMemory(&amp;m_tVBDesc, sizeof(D3D11_BUFFER_DESC)); // 구조체 초기화 m_tVBDesc.ByteWidth = sizeof(Vtx) * m_iVtxCount; // 버퍼의 전체 크기 m_tVBDesc.Usage = D3D11_USAGE_DEFAULT; // GPU 읽기/쓰기, CPU 접근 불가 (정적 데이터) // (자주 변경 시 D3D11_USAGE_DYNAMIC, CPUAccessFlags = D3D11_CPU_ACCESS_WRITE) m_tVBDesc.BindFlags = D3D11_BIND_VERTEX_BUFFER; // 정점 버퍼로 바인딩됨을 명시 m_tVBDesc.CPUAccessFlags = 0; // D3D11_USAGE_DEFAULT일 경우 0 m_tVBDesc.MiscFlags = 0; m_tVBDesc.StructureByteStride = 0; D3D11_SUBRESOURCE_DATA tSubVtxData = {}; tSubVtxData.pSysMem = m_vecVtxSys.data(); // CPU 측 정점 데이터의 시작 주소 if (FAILED(g_pd3dDevice-&gt;CreateBuffer(&amp;m_tVBDesc, &amp;tSubVtxData, m_VB.GetAddressOf()))) { //Log(L\"정점 버퍼 생성 실패\"); return E_FAIL; } // 2. 인덱스 버퍼(Index Buffer) 생성 (인덱스가 있는 경우) if (m_iIdxCount &gt; 0) { ZeroMemory(&amp;m_tIBDesc, sizeof(D3D11_BUFFER_DESC)); m_tIBDesc.ByteWidth = sizeof(UINT) * m_iIdxCount; m_tIBDesc.Usage = D3D11_USAGE_DEFAULT; m_tIBDesc.BindFlags = D3D11_BIND_INDEX_BUFFER; // 인덱스 버퍼로 바인딩됨을 명시 m_tIBDesc.CPUAccessFlags = 0; m_tIBDesc.MiscFlags = 0; m_tIBDesc.StructureByteStride = 0; D3D11_SUBRESOURCE_DATA tSubIdxData = {}; tSubIdxData.pSysMem = m_vecIdxSys.data(); // CPU 측 인덱스 데이터의 시작 주소 if (FAILED(g_pd3dDevice-&gt;CreateBuffer(&amp;m_tIBDesc, &amp;tSubIdxData, m_IB.GetAddressOf()))) { //Log(L\"인덱스 버퍼 생성 실패\"); return E_FAIL; } } return S_OK;}4. 메시 렌더링 (CMesh::Render 함수 구현 예시) 생성된 메시를 화면에 그리기 위해서는 ID3D11DeviceContext를 사용하여 정점 버퍼와 인덱스 버퍼를 입력 조립기(IA) 단계에 설정하고, 드로우콜을 호출// CMesh.cppvoid CMesh::Render(ID3D11DeviceContext* _pContext){ if (!m_VB) // 정점 버퍼가 유효한지 확인 return; // 1. 입력 조립기(Input Assembler)에 정점 버퍼 설정 UINT iStride = sizeof(Vtx); // 단일 정점의 크기 (바이트) UINT iOffset = 0; // 버퍼 시작부터의 오프셋 (바이트) _pContext-&gt;IASetVertexBuffers(0, // 시작 슬롯 번호 1, // 설정할 버퍼 개수 m_VB.GetAddressOf(), // 정점 버퍼 포인터의 주소 &amp;iStride, // 스트라이드(정점 크기) 배열의 포인터 &amp;iOffset); // 오프셋 배열의 포인터 // 2. 입력 조립기에 인덱스 버퍼 설정 (인덱스가 있는 경우) if (m_IB &amp;&amp; m_iIdxCount &gt; 0) { _pContext-&gt;IASetIndexBuffer(m_IB.Get(), // 인덱스 버퍼 포인터 DXGI_FORMAT_R32_UINT, // 인덱스 포맷 (UINT는 32비트) 0); // 버퍼 시작부터의 오프셋 // 3. 인덱스 기반 드로우콜 호출 _pContext-&gt;DrawIndexed(m_iIdxCount, // 그릴 인덱스의 개수 0, // 시작 인덱스 위치 0); // 정점 버퍼에 더해질 기본 위치 오프셋 } else if (m_iVtxCount &gt; 0) // 인덱스 버퍼가 없으면 정점 버퍼만으로 그리기 { // 3. 비-인덱스 기반 드로우콜 호출 _pContext-&gt;Draw(m_iVtxCount, // 그릴 정점의 개수 0); // 시작 정점 위치 }}" }, { "title": "드로우 콜", "url": "/posts/%EB%93%9C%EB%A1%9C%EC%9A%B0%EC%BD%9C/", "categories": "DirectX", "tags": "directx", "date": "2022-06-12 00:00:00 +0900", "snippet": "드로우콜 (Draw Call)정의 및 역할 드로우콜은 CPU가 GPU에게 \"현재 파이프라인에 설정된 상태(셰이더, 버퍼, 텍스처, 각종 상태 객체 등)를 사용하여 실제로 지오메트리(정점 데이터)를 그려라고 지시하는 명령 그래픽스 렌더링 파이프라인을 실행시키는 주요 트리거 역할. 하나의 드로우콜은 일반적으로 하나의 메시(mesh) 또는 메시의 특정 부분을 그리는 데 해당 주요 함수 (DirectX 11 ID3D11DeviceContext 기준) Draw(VertexCount, StartVertexLocation): 인덱스 버퍼를 사용하지 않고, 현재 바인딩된 정점 버퍼에서 VertexCount개의 정점을 StartVertexLocation부터 순차적으로 사용하여 기본 도형을 그림 DrawIndexed(IndexCount, StartIndexLocation, BaseVertexLocation): 현재 바인딩된 인덱스 버퍼와 정점 버퍼를 함께 사용 인덱스 버퍼에서 IndexCount개의 인덱스를 StartIndexLocation부터 읽어, 해당 인덱스가 가리키는 정점들을 (필요시 BaseVertexLocation 오프셋을 더해) 참조하여 기본 도형을 그림. (대부분의 메시 렌더링에 사용) DrawInstanced(VertexCountPerInstance, InstanceCount, StartVertexLocation, StartInstanceLocation): Draw와 유사하지만, InstanceCount만큼 동일한 지오메트리를 여러 번 효율적으로 그림. 각 인스턴스마다 다른 데이터(예: 월드 행렬, 색상)를 적용할 수 있음(인스턴싱 기법). DrawIndexedInstanced(IndexCountPerInstance, InstanceCount, StartIndexLocation, BaseVertexLocation, StartInstanceLocation): DrawIndexed와 인스턴싱을 결합한 형태 (참고) Dispatch(ThreadGroupCountX, ThreadGroupCountY, ThreadGroupCountZ): 이는 그래픽스 드로우콜은 아니지만, 컴퓨트 셰이더를 실행시키는 명령으로, GPU에 계산 작업을 지시한다는 점에서 드로우콜과 유사한 역할을 함 드로우콜과 성능 각 드로우콜은 CPU에서 GPU로 상태를 설정하고 명령을 전달하는 과정에서 일정량의 오버헤드를 발생시킴 따라서 드로우콜의 수가 과도하게 많으면 CPU가 GPU에게 작업을 충분히 빨리 공급하지 못하는 CPU 병목(CPU-bound) 현상이 발생하여 전체적인 렌더링 성능이 저하될 수 있음 성능 최적화를 위해 드로우콜 수를 줄이는 기법들(예: 스태틱 배칭, 다이나믹 배칭, 인스턴싱, 텍스처 아틀라스, 머티리얼 병합 등)이 중요하게 사용됨드로우콜 이전의 주요 설정 작업 (State Setup) 드로우콜을 호출하기 전에, GPU가 무엇을 어떻게 그려야 할지 알 수 있도록 다음과 같은 파이프라인 상태들을 설정해야 함1. 입력 조립기 (IA) 상태 사용할 정점 버퍼, 인덱스 버퍼, 입력 레이아웃, 기본 도형 토폴로지(삼각형 리스트, 선 리스트 등).2. 셰이더 프로그램 현재 사용할 버텍스 셰이더, 픽셀 셰이더 (필요에 따라 지오메트리, 헐, 도메인 셰이더)3. 셰이더 리소스 상수 버퍼, 텍스처(SRV), 샘플러, UAV 등 셰이더가 참조할 리소스 바인딩.4. 래스터라이저 (RS) 상태 컬링 모드(앞면/뒷면), 채움 모드(솔리드/와이어프레임), 씨저링 등.5. 출력 병합기 (OM) 상태 렌더 타겟, 깊이/스텐실 버퍼, 블렌드 상태, 깊이/스텐실 테스트 상태." }, { "title": "컴퓨터 구조에 대한 두번째 이야기", "url": "/posts/%EC%BB%B4%ED%93%A8%ED%84%B0-%EA%B5%AC%EC%A1%B0%EC%97%90-%EB%8C%80%ED%95%9C-%EB%91%90%EB%B2%88-%EC%A7%B8-%EC%9D%B4%EC%95%BC%EA%B8%B0/", "categories": "윈도우즈시스템프로그래밍, 운영체제", "tags": "windows", "date": "2022-06-11 00:00:00 +0900", "snippet": "프로그래머 관점 컴퓨터 구조를 잘 아는 프로그래머도 컴퓨터 디자인에 참여 프로그래머의 디자인은 레지스터와 명령어 디자인레지스터 레지스터 디자인 레지스터를 몇비트로 구성할지 n비트 시스템에서의 명령어 길이도 n비트이고 레지스터도 n비트여야 하나의 명령어를 저장. 몇 개 정도로 레지스터를 구성할지 레지스터를 각각 무슨 용도로 사용할지 레지스터의 용도를 정하면 명령어가 단순해지고 속도가 빨라짐. 레지스터 구조명령어 명령어 구조 레지스터 구성형태에 따라 명령어 구조가 달라진다. 명령어를 비트값에 따라 디자인한다면 16비트로는 2의 16승인 65536개를 만드는 비효율적인 상황이 나옮. 명령어 예시 레지스터r1에 있는 값과 숫자 7를 더해서 레지스터r2에 저장하라 피연산자 레지스터 정보나 숫자만 올 수 있음 맨 앞의 비트는 레지스터나 숫자를 구분하는 비트 첫번째 피연산자 위치에는 레지스터 이름이 와야한다라는 제약사항이 있음 명령어의 제약사항 위에서 처럼 명령어를 디자인하는 과정에서 제약사항이 생긴다. arm이나 x86 계열의 어셈블리 프로그래밍에서도 첫번째 피연산자 위치에는 레지스터 이름이 와야한다라는 제약사항이 있다. 이러한 제약사항들은 CPU의 종합적 측면(성능,비용)이 고려되는 가운데서 생겨남 RISC vs CISC 명령어 구성에 제약사항이 항상 따르진 않음. CISC 장점 : 명령어 종류가 많고 다양한 조합이 가능하다 단점 : 명령어 수가 많고 크기가 일정치 않기 때문에 복잡해지고 복잡해진 구조는 성능 향상에 제한이 생김 16비트에서 사용 RISC CISC에서 명령어 수를 대폭 줄이고 명령어 길이를 일정하게 디자인한 구조 32비트, 64비트 , 임베디드에서 사용 초당 클럭수를 높이고, 명령어 길이와 처리가 일정하기 때문에 클럭당 처리할 수 있는 명령어의 개수가 늘어나면서 성능 향상이 됨 LOAD &amp; STORE 연산결과를 레지스터에만 저장할 수 있다는 제약사항이 있기 때문에 메인메모리의 주소값을 통한 사칙연산이 불가능하다 따라서 메인 메모리에 저장된 데이터를 레지스터로 옮기고, 덧셈을 진행해야 한다. 그러기 위한 명령어가 필요하다 LOAD 메인 메모리에 저장된 데이터를 레지스터로 이동시키기 위한 명령어 STORE 레지스터에 저장된 데이터를 메인 메모리로 이동시키기 위한 명령어 LOAD r1 0x20 0x20번지에 있는 값을 레지스터 r1에 저장 STORE r1 0x20 레지스터 r1에 있는 값을 메인 메모리 0x20번지에 저장 예시int a = 10; // 0x10 번지 할당int b = 20; // 0x20 번지 할당int c = 0; // 0x30 번지 할당c = a + b; 명령어 순서LOAD r1, 0x10 LOAD r2, 0x20 ADD r3, r1, r2STORE r3 , 0x30Direct 와 InDirect 하나의 명령어에 여러 정보를 담다보니 표현하는 데이터 크기에 제한이 따른다는 문제점이 있다. 그 이유는 할당된 비트 수 안에서 표현 가능한 범위의 메모리만 접근이 가능하기 때문 (Direct모드) 이러한 문제를 해결하기 위해 InDirect모드를 사용한다 Direct 모드 메모리의 주소값을 직접 표현 InDirect모드 명령어에서 지정하는 번지에 지정된 값을 주소값으로 참조 " }, { "title": "셰이더 버퍼 종류", "url": "/posts/%EC%85%B0%EC%9D%B4%EB%8D%94-%EB%B2%84%ED%8D%BC-%EC%A2%85%EB%A5%98/", "categories": "DirectX", "tags": "directx", "date": "2022-06-11 00:00:00 +0900", "snippet": "셰이더 버퍼 DirectX 11에서 셰이더에 데이터를 제공하거나 셰이더가 데이터를 조작하는 데 사용되는 주요 자원들1. 상수 버퍼정의 및 특징 CPU에서 셰이더(HLSL)로 상대적으로 작은 크기의 ‘상수’ 데이터를 전달하는 주된 방법 주로 변환 행렬(월드, 뷰, 투영), 조명 파라미터, 재질의 색상 및 속성 등 프레임 또는 드로우 콜(draw call)마다 변경될 수 있는 데이터를 위해 사용 HLSL에서는 cbuffer 키워드로 선언하며, C++의 구조체처럼 멤버 변수들을 가질 수 있음 이 멤버들은 CPU에서 설정한 값으로 채워짐 GPU에서 매우 빠르게 접근할 수 있도록 최적화되어 있음코드 C++ 설정 간략 ID3D11Buffer로 생성 (예: D3D11_USAGE_DYNAMIC, D3D11_BIND_CONSTANT_BUFFER). Map/Unmap (동적 버퍼) 또는 UpdateSubresource (기본 버퍼) 함수로 데이터 업데이트. VSSetConstantBuffers, PSSetConstantBuffers 등의 함수로 해당 셰이더 스테이지에 바인딩. // 전역 범위 또는 특정 셰이더 내에서 선언cbuffer PerObjectConstants : register(b0) // 'b0'은 바인딩 슬롯(레지스터) 번호{ matrix worldMatrix; matrix viewProjectionMatrix; float4 materialColor; float specularPower;};// Vertex Shader에서 사용 예시struct VS_INPUT{ float3 position : POSITION; float2 texCoord : TEXCOORD0;};struct VS_OUTPUT{ float4 position : SV_Position; float2 texCoord : TEXCOORD0;};VS_OUTPUT MyVertexShader(VS_INPUT input){ VS_OUTPUT output; // 월드 변환 float4 worldPos = mul(float4(input.position, 1.0f), worldMatrix); // 최종 클립 공간 위치 계산 output.position = mul(worldPos, viewProjectionMatrix); output.texCoord = input.texCoord; return output;}// Pixel Shader에서 사용 예시float4 MyPixelShader(VS_OUTPUT input) : SV_Target{ // 재질 색상 사용 float4 baseColor = materialColor; // ... 조명 계산 등 ... // specularPower 변수를 사용하여 반사광 계산 가능 return baseColor;}2. 텍스처 (Texture) - SRV 사용정의 및 특징 이미지 데이터(예: 디퓨즈 맵, 노멀 맵, 스페큘러 맵) 또는 일반적인 다차원 데이터를 저장하는 GPU 자원 1D, 2D, 3D, 큐브맵(CubeMap), 텍스처 배열 등 다양한 형태가 존재 SRV(Shader Resource View)를 통해 셰이더에서 읽기 전용으로 접근 SRV는 텍스처의 특정 부분(예: 밉맵 레벨, 포맷)을 지정하여 셰이더에 노출 SamplerState(샘플러 상태)와 함께 사용하여 텍스처 좌표에 따른 픽셀 값 필터링(예: 최근접, 선형, 이방성) 및 텍스처 래핑(예: 반복, 가장자리 고정) 방식을 제어코드 C++ 설정 간략: ID3D11Texture1D/2D/3D 등으로 텍스처 자원 생성. 생성된 텍스처 자원을 기반으로 ID3D11ShaderResourceView 생성. PSSetShaderResources (또는 VSSetShaderResources 등) 함수로 셰이더 스테이지에 SRV 바인딩. ID3D11SamplerState 생성 및 PSSetSamplers (또는 VSSetSamplers 등) 함수로 샘플러 바인딩. // 텍스처 리소스 선언 (SRV t0 레지스터에 바인딩)Texture2D diffuseTexture : register(t0);Texture2D normalMap : register(t1);// 샘플러 상태 선언 (s0 레지스터에 바인딩)SamplerState linearSampler : register(s0); // 예: 선형 필터링, 반복 래핑struct PS_INPUT // Vertex Shader로부터 전달받는 데이터{ float4 position : SV_Position; float2 texCoord : TEXCOORD0; // ... 기타 보간된 데이터 (예: 월드 노멀, 탄젠트 등) ...};// Pixel Shader에서 사용 예시float4 MyPixelShader(PS_INPUT input) : SV_Target{ // 디퓨즈 텍스처에서 색상 샘플링 float4 diffuseColor = diffuseTexture.Sample(linearSampler, input.texCoord); // 노멀맵에서 노멀 벡터 샘플링 (보통 추가적인 계산 필요) float3 normalFromMap = normalMap.Sample(linearSampler, input.texCoord).xyz * 2.0f - 1.0f; normalFromMap = normalize(normalFromMap); // 정규화 // ... 조명 계산 시 diffuseColor와 normalFromMap 사용 ... return diffuseColor;}3. 구조화된 버퍼 (Structured Buffer) - SRV 사용정의 및 특징 사용자 정의 구조체의 배열을 저장하는 버퍼 상수 버퍼(일반적으로 최대 64KB)보다 훨씬 큰 데이터를 저장할 수 있음 SRV(Shader Resource View)를 사용하여 셰이더에서 배열처럼 인덱스를 통해 각 구조체 요소에 읽기 전용으로 접근합니다. 텍스처와 달리 필터링 기능은 제공되지 않으며, 데이터를 직접 로드합니다.코드 C++ 설정 간략: ID3D11Buffer로 생성 (D3D11_BIND_SHADER_RESOURCE, D3D11_RESOURCE_MISC_BUFFER_STRUCTURED, StructureByteStride는 구조체 크기로 설정). 생성된 버퍼 자원을 기반으로 ID3D11ShaderResourceView 생성. PSSetShaderResources (또는 다른 셰이더 스테이지의 SetShaderResources 함수)로 SRV 바인딩. // C++과 HLSL 양쪽에서 일치해야 하는 사용자 정의 구조체struct LightData{ float3 lightPositionWorld; float falloffStart; float3 lightColor; float falloffEnd; float spotPower; // ... 기타 필요한 라이트 정보 ...};// 구조화된 버퍼 선언 (SRV t2 레지스터에 바인딩)StructuredBuffer&lt;LightData&gt; allSceneLights : register(t2);// Pixel Shader 또는 Compute Shader 등에서 사용 예시float4 CalculateLighting(float3 worldPos, float3 worldNormal, uint lightCount){ float4 finalColor = float4(0, 0, 0, 0); for (uint i = 0; i &lt; lightCount; ++i) { LightData currentLight = allSceneLights[i]; // 인덱스를 사용하여 라이트 데이터 접근 // ... currentLight 정보를 사용하여 조명 계산 ... // 예: float dist = distance(currentLight.lightPositionWorld, worldPos); // if(dist &lt; currentLight.falloffEnd) { ... } } return finalColor;}4. 바이트 주소 지정 가능 버퍼 (Byte Address Buffer / Raw Buffer) - SRV 사용정의 및 특징 버퍼를 원시 바이트(raw bytes) 스트림으로 취급 SRV(Shader Resource View)를 사용하여 셰이더에서 특정 바이트 오프셋으로부터 데이터를 직접 읽을 수 있음 매우 유연하여, 서로 다른 타입의 데이터가 섞여 있거나 표준적인 구조체로 표현하기 어려운 복잡한 데이터 구조를 다룰 때 유용 데이터 정렬(alignment) 및 타입 변환을 프로그래머가 HLSL 코드 내에서 직접 관리해야 함코드 C++ 설정 간략 ID3D11Buffer로 생성 (D3D11_BIND_SHADER_RESOURCE, D3D11_RESOURCE_MISC_BUFFER_ALLOW_RAW_VIEWS). ID3D11ShaderResourceView 생성 시 DXGI_FORMAT_R32_TYPELESS와 D3D11_BUFFEREX_SRV_FLAG_RAW 플래그 사용. 셰이더 스테이지에 SRV 바인딩. // 바이트 주소 지정 가능 버퍼 선언 (SRV t3 레지스터에 바인딩)ByteAddressBuffer rawBuffer : register(t3);// 셰이더 내에서 사용 예시float4 ProcessRawData(uint baseOffset){ // 지정된 오프셋에서 4개의 float (16바이트) 읽기 // Load4는 4개의 32비트 값을 읽어 uint4로 반환하므로, 필요시 asfloat 등으로 변환 uint4 packedData = rawBuffer.Load4(baseOffset); float4 data = asfloat(packedData); // 다음 4바이트(float 하나)를 읽기 (오프셋은 바이트 단위) float additionalValue = asfloat(rawBuffer.Load(baseOffset + 16)); // ... data와 additionalValue를 사용한 처리 ... return data + additionalValue;}5. 텍스처 버퍼 (Texture Buffer / TBuffer) - SRV 사용정의 및 특징 버퍼의 내용을 1차원 텍스처처럼 취급하여 접근할 수 있게 하는 특수한 형태의 버퍼 상수 버퍼보다 많은 양의 데이터를 저장 가능하며, 셰이더에서 배열처럼 인덱스를 통해 각 요소에 읽기 전용으로 접근 일반 텍스처와 달리 샘플러를 통한 필터링 기능은 제공되지 않음. Load() 함수 또는 배열 인덱싱을 통해 직접 텍셀(버퍼 요소) 데이터를 접근합니다. SRV(Shader Resource View)를 통해 셰이더에 바인딩됩니다.코드 C++ 설정 간략: ID3D11Buffer로 생성 (D3D11_BIND_SHADER_RESOURCE). ID3D11ShaderResourceView 생성 시 버퍼 요소의 특정 DXGI_FORMAT을 지정 (예: DXGI_FORMAT_R32G32B32A32_FLOAT). 셰이더 스테이지에 SRV 바인딩. // 텍스처 버퍼 선언 (SRV t4 레지스터에 바인딩)// C++에서 SRV 생성 시 요소 형식을 float4로 지정했다고 가정Buffer&lt;float4&gt; myTBuffer : register(t4);// 또는 최신 HLSL에서는 TextureBuffer&lt;float4&gt; myTBuffer : register(t4); 도 가능// 셰이더 내에서 사용 예시float4 GetValueFromTBuffer(int index){ // Load 함수를 사용하여 지정된 인덱스의 데이터 읽기 float4 data = myTBuffer.Load(index); // 또는 배열처럼 직접 접근 (최신 HLSL) // float4 data = myTBuffer[index]; return data;}6. UAV를 통한 버퍼/텍스처 (Read/Write Access via UAV)정의 및 특징 UAV(Unordered Access View)는 셰이더(주로 컴퓨트 셰이더 또는 픽셀 셰이더)가 버퍼나 텍스처에 대해 순서에 구애받지 않고(unordered) 임의의 위치에 읽기 및 쓰기 작업을 수행할 수 있게 하는 뷰 GPGPU(범용 GPU 프로그래밍) 작업에 핵심적입니다. 예: 물리 시뮬레이션, 파티클 시스템 업데이트, 실시간 이미지 처리, 고급 렌더링 기법(Order-Independent Transparency 등). 여러 셰이더 스레드가 동시에 동일한 메모리 위치에 접근하여 쓸 수 있으므로, 데이터 경쟁(race condition)을 피하기 위해 원자적 연산(atomic operations)이나 적절한 동기화(메모리 배리어 등)가 필요할 수 있음코드 C++ 설정 간략: ID3D11Buffer 또는 ID3D11TextureXD로 자원 생성 시 D3D11_BIND_UNORDERED_ACCESS 플래그 포함. 생성된 자원을 기반으로 ID3D11UnorderedAccessView 생성. 컴퓨트 셰이더에는 CSSetUnorderedAccessViews, 픽셀 셰이더에는 OMSetRenderTargetsAndUnorderedAccessViews 함수로 UAV 바인딩. // 파티클 데이터 구조체struct Particle{ float3 position; float3 velocity; float life;};// 읽기/쓰기 가능한 구조화된 버퍼 선언 (UAV u0 레지스터에 바인딩)RWStructuredBuffer&lt;Particle&gt; particleBuffer : register(u0);// 상수 버퍼 (예: 시간 값)cbuffer SimParams : register(b0){ float deltaTime;};// 컴퓨트 셰이더에서 사용 예시[numthreads(64, 1, 1)] // 스레드 그룹의 크기 정의void UpdateParticlesCS(uint3 dispatchThreadID : SV_DispatchThreadID){ uint index = dispatchThreadID.x; // 버퍼 크기를 벗어나지 않도록 체크 (선택적) // if (index &gt;= maxParticles) return; // 파티클 데이터 읽기 Particle p = particleBuffer[index]; // 파티클 상태 업데이트 p.position += p.velocity * deltaTime; p.life -= deltaTime; // 업데이트된 파티클 데이터 쓰기 if (p.life &gt; 0.0f) { particleBuffer[index] = p; } else { // 예: 파티클 비활성화 또는 재생성 로직 particleBuffer[index].life = 0.0f; // 간단히 비활성화 }}" }, { "title": "샘플러 상태", "url": "/posts/%EC%83%98%ED%94%8C%EB%9F%AC-%EC%8A%A4%ED%85%8C%EC%9D%B4%ED%8A%B8/", "categories": "DirectX", "tags": "directx", "date": "2022-06-11 00:00:00 +0900", "snippet": "SamplerState (샘플러 상태)정의 및 역할 SamplerState(샘플러 상태)는 텍스처를 샘플링(텍스처에서 특정 좌표의 픽셀/텍셀 값을 읽어오는 과정)할 때 GPU가 따라야 할 규칙들을 정의하는 객체 텍스처 자체의 데이터와는 별개로 존재하며, HLSL 셰이더에서 텍스처 샘플링 함수(예: Texture2D.Sample())를 호출할 때 텍스처 리소스(SRV)와 함께 이 샘플러 상태 객체를 인자로 전달 샘플러 상태는 다음과 같은 주요 샘플링 방식을 제어 필터링(Filtering): 텍스처 좌표가 정확히 텍셀 중앙에 위치하지 않거나, 텍스처가 화면 픽셀보다 크거나 작을 때 주변 텍셀들의 색상을 어떻게 혼합하여 최종 색상을 결정할지 정의합니다. (예: 최근접점 필터링, 선형 필터링, 이방성 필터링) 주소 지정 모드(Addressing Mode): 0.0 ~ 1.0 범위를 벗어나는 텍스처 좌표가 주어졌을 때 어떻게 처리할지 정의합니다. (예: 반복, 가장자리 고정, 거울 모드, 경계 색상 사용) 밉맵(Mipmap) 처리: 밉맵 레벨 간의 필터링 및 LOD(Level of Detail) 바이어스 등을 제어합니다. 주요 설정 옵션 (D3D11_SAMPLER_DESC 구조체 멤버)#include &lt;d3d11.h&gt; // DirectX 11 헤더 파일// #include &lt;wrl/client.h&gt; // ComPtr 사용 시 필요 (Microsoft::WRL::ComPtr)// 전역 또는 클래스 멤버 등으로 선언될 수 있는 디바이스 및 샘플러 상태 포인터// ID3D11Device* g_pd3dDevice = nullptr; // 이미 초기화되었다고 가정// ID3D11SamplerState* g_pLinearWrapSampler = nullptr;// 또는 ComPtr 사용:// Microsoft::WRL::ComPtr&lt;ID3D11Device&gt; g_pd3dDevice;// Microsoft::WRL::ComPtr&lt;ID3D11SamplerState&gt; g_pLinearWrapSampler;HRESULT CreateCustomSamplerState(ID3D11Device* pDevice, ID3D11SamplerState** ppSamplerState){ if (!pDevice || !ppSamplerState) { return E_INVALIDARG; } D3D11_SAMPLER_DESC samplerDesc = {}; // 샘플러 디스크립션 구조체 초기화 // 1. Filter: 텍스처 확대(Mag), 축소(Min), 밉맵(Mip) 필터링 방식을 조합하여 지정합니다. // 예시: 선형 필터링 (가장 일반적) samplerDesc.Filter = D3D11_FILTER_MIN_MAG_MIP_LINEAR; // 다른 예시: 이방성 필터링 (더 높은 품질, MaxAnisotropy 설정 필요) // samplerDesc.Filter = D3D11_FILTER_ANISOTROPIC; // 또 다른 예시: 비교 샘플러 (그림자 맵핑 등) // samplerDesc.Filter = D3D11_FILTER_COMPARISON_MIN_MAG_MIP_LINEAR; // 2. AddressU, AddressV, AddressW: 각 텍스처 좌표 축에 대한 주소 지정 모드를 설정합니다. // U: 텍스처의 가로 방향 (첫 번째 좌표) // V: 텍스처의 세로 방향 (두 번째 좌표) // W: 3D 텍스처의 깊이 방향 (세 번째 좌표) // 예시: 반복 (타일링 효과) samplerDesc.AddressU = D3D11_TEXTURE_ADDRESS_WRAP; samplerDesc.AddressV = D3D11_TEXTURE_ADDRESS_WRAP; samplerDesc.AddressW = D3D11_TEXTURE_ADDRESS_WRAP; // 1D/2D 텍스처에서는 무시될 수 있음 // 다른 예시: 가장자리 고정 // samplerDesc.AddressU = D3D11_TEXTURE_ADDRESS_CLAMP; // samplerDesc.AddressV = D3D11_TEXTURE_ADDRESS_CLAMP; // samplerDesc.AddressW = D3D11_TEXTURE_ADDRESS_CLAMP; // 또 다른 예시: 거울 모드 // samplerDesc.AddressU = D3D11_TEXTURE_ADDRESS_MIRROR; // samplerDesc.AddressV = D3D11_TEXTURE_ADDRESS_MIRROR; // samplerDesc.AddressW = D3D11_TEXTURE_ADDRESS_MIRROR; // 또 다른 예시: 경계 색상 사용 (BorderColor 설정 필요) // samplerDesc.AddressU = D3D11_TEXTURE_ADDRESS_BORDER; // samplerDesc.AddressV = D3D11_TEXTURE_ADDRESS_BORDER; // samplerDesc.AddressW = D3D11_TEXTURE_ADDRESS_BORDER; // 3. MipLODBias: 밉맵 레벨 선택에 적용할 부동 소수점 오프셋 값입니다. // 양수 값은 더 낮은 해상도(흐릿한) 밉맵을, 음수 값은 더 높은 해상도(선명한) 밉맵을 선택하게 합니다. samplerDesc.MipLODBias = 0.0f; // 기본값은 0 // 4. MaxAnisotropy: 이방성 필터링(D3D11_FILTER_ANISOTROPIC 또는 D3D11_FILTER_COMPARISON_ANISOTROPIC)을 // 사용할 경우 최대 이방성 수준을 지정합니다. (일반적으로 1 ~ 16 사이 값) // Filter가 이방성 필터가 아니면 이 값은 무시됩니다. samplerDesc.MaxAnisotropy = 1; // 이방성 필터링 사용 안 할 시 1 또는 0 // if (samplerDesc.Filter == D3D11_FILTER_ANISOTROPIC) // { // samplerDesc.MaxAnisotropy = 16; // 최대 품질 (GPU 지원 범위 확인 필요) // } // 5. ComparisonFunc: 비교 샘플러(Filter가 D3D11_FILTER_COMPARISON_* 계열일 때)를 위한 // 비교 함수를 지정합니다. (주로 그림자 맵핑의 PCF 기법에 사용) // Filter가 비교 필터가 아니면 이 값은 무시됩니다. samplerDesc.ComparisonFunc = D3D11_COMPARISON_NEVER; // 비교 샘플러 아닐 시 기본값 // if (samplerDesc.Filter == D3D11_FILTER_COMPARISON_MIN_MAG_MIP_LINEAR) // { // samplerDesc.ComparisonFunc = D3D11_COMPARISON_LESS_EQUAL; // 그림자 맵핑에 자주 사용 // } // 6. BorderColor: 주소 지정 모드가 D3D11_TEXTURE_ADDRESS_BORDER일 때 사용할 경계 색상(RGBA)입니다. // 값의 범위는 일반적으로 [0.0f, 1.0f] 입니다. samplerDesc.BorderColor[0] = 0.0f; // R samplerDesc.BorderColor[1] = 0.0f; // G samplerDesc.BorderColor[2] = 0.0f; // B samplerDesc.BorderColor[3] = 0.0f; // A (예: 투명 검정) // if (samplerDesc.AddressU == D3D11_TEXTURE_ADDRESS_BORDER) // { // samplerDesc.BorderColor[0] = 1.0f; // 예: 흰색 // samplerDesc.BorderColor[1] = 1.0f; // samplerDesc.BorderColor[2] = 1.0f; // samplerDesc.BorderColor[3] = 1.0f; // } // 7. MinLOD: 사용할 밉맵 레벨의 최소 한계(가장 상세한 밉맵 레벨)입니다. 0이 가장 높은 해상도. samplerDesc.MinLOD = 0; // 모든 밉맵 레벨 사용 가능하도록 허용 (최소) // 8. MaxLOD: 사용할 밉맵 레벨의 최대 한계(가장 낮은 해상도의 밉맵 레벨)입니다. // D3D11_FLOAT32_MAX는 모든 밉맵 레벨을 사용 가능하도록 합니다. samplerDesc.MaxLOD = D3D11_FLOAT32_MAX; // 모든 밉맵 레벨 사용 가능하도록 허용 (최대) // 특정 범위로 제한 예시: samplerDesc.MaxLOD = 5.0f; (0번부터 5번 밉맵 레벨까지만 사용) // ID3D11Device 인터페이스를 사용하여 샘플러 상태 객체 생성 HRESULT hr = pDevice-&gt;CreateSamplerState(&amp;samplerDesc, ppSamplerState); if (FAILED(hr)) { // 오류 처리 (예: MessageBox, 로그 출력) // MessageBox(nullptr, L\"Sampler State 생성 실패!\", L\"에러\", MB_OK); *ppSamplerState = nullptr; // 실패 시 포인터 초기화 } return hr;}// 사용 예시/*void InitMyGraphics(ID3D11Device* pDevice){ ID3D11SamplerState* pMySampler = nullptr; if (SUCCEEDED(CreateCustomSamplerState(pDevice, &amp;pMySampler))) { // 생성 성공! 이제 이 pMySampler를 사용하여 셰이더에 바인딩할 수 있습니다. // 예: g_pImmediateContext-&gt;PSSetSamplers(0, 1, &amp;pMySampler); // 사용이 끝나면 릴리즈해야 합니다 (ComPtr을 사용하지 않는 경우). // if (pMySampler) pMySampler-&gt;Release(); }}*/HLSL C++ 설정 간략 D3D11_SAMPLER_DESC 구조체의 멤버들을 원하는 값으로 채움 ID3D11Device::CreateSamplerState() 함수에 이 구조체의 주소를 전달하여 ID3D11SamplerState 객체를 생성 ID3D11DeviceContext의 PSSetSamplers() (픽셀 셰이더용), VSSetSamplers() (버텍스 셰이더용) 등의 함수를 사용하여 생성된 샘플러 객체를 특정 바인딩 슬롯에 설정 " }, { "title": "순열과 조합", "url": "/posts/%EC%88%9C%EC%97%B4%EA%B3%BC-%EC%A1%B0%ED%95%A9/", "categories": "코딩테스트, 수학", "tags": "coding test", "date": "2022-06-10 00:00:00 +0900", "snippet": "순열 순열 서로 다른 n개에서 r개를 뽑아서 정렬하는 경우의 수 #include&lt;iostream&gt;#include&lt;vector&gt;#define MAX 5using namespace std;char Arr[MAX];bool Check[MAX];vector&lt;char&gt; V;void Permutation(int n, int r) { if (n == r) { for (int i = 0; i &lt; V.size(); i++) { cout &lt;&lt; V[i] &lt;&lt; \" \"; } cout &lt;&lt; endl; return; } for (int i = 0; i &lt; MAX; i++) { if (Check[i] == true) continue; Check[i] = true; V.push_back(Arr[i]); Permutation(n + 1, r); V.pop_back(); Check[i] = false; }}int main(void){ Arr[0] = 'a'; Arr[1] = 'b'; Arr[2] = 'c'; Arr[3] = 'd'; Arr[4] = 'e'; Permutation(0, 3);}조합 조합 서로 다른 n개에서 순서 없이 r개를 뽑는 경우의 수 #include&lt;iostream&gt;#include&lt;vector&gt;#define MAX 5using namespace std;char Arr[MAX];bool Check[MAX];void combination(int idx, int n, int r){ if (n == r) { for (int i = 0; i &lt; MAX; i++) { if (Check[i] == true) { cout &lt;&lt; Arr[i] &lt;&lt; \" \"; } } cout &lt;&lt; endl; return; } for (int i = idx; i &lt; MAX; i++) { if (Check[i] == true) continue; Check[i] = true; combination(i,n+1,r); Check[i] = false; }}int main(void){ Arr[0] = 'a'; Arr[1] = 'b'; Arr[2] = 'c'; Arr[3] = 'd'; Arr[4] = 'e'; combination(0,0,2);}" }, { "title": "바인딩 슬롯", "url": "/posts/%EB%B0%94%EC%9D%B8%EB%94%A9-%EC%8A%AC%EB%A1%AF/", "categories": "DirectX", "tags": "directx", "date": "2022-06-10 00:00:00 +0900", "snippet": "바인딩 슬롯 (Binding Slots / 레지스터)정의 및 역할 바인딩 슬롯(또는 레지스터)은 CPU(C++ 코드)에서 설정한 GPU 리소스(예: 상수 버퍼, 텍스처, 샘플러, UAV)를 HLSL 셰이더 코드 내의 해당 변수와 연결하는 고유한 “연결 지점” 또는 “주소” 셰이더는 이 슬롯 번호를 통해 파이프라인에 바인딩된 특정 리소스에 접근 DirectX 11 그래픽스 및 컴퓨트 파이프라인의 각 셰이더 스테이지(Vertex Shader, Pixel Shader, Compute Shader 등)는 서로 독립적인 바인딩 슬롯 공간을 가짐. 예를 들어, Vertex Shader의 상수 버퍼 슬롯 0번(b0)은 Pixel Shader의 상수 버퍼 슬롯 0번(b0)과는 별개 중요성 바인딩 슬롯은 CPU에서 준비된 데이터와 GPU에서 실행될 셰이더 프로그램 간의 정확하고 효율적인 데이터 흐름을 보장하는 핵심 메커니즘HLSL에서의 사용법 HLSL 코드 내에서 리소스 변수를 선언할 때 register() 키워드를 사용하여 특정 타입의 슬롯과 번호를 명시적으로 할당 슬롯 번호(#)는 0부터 시작하며, 각 리소스 타입별로 사용 가능한 최대 슬롯 수가 정해져 있음 상수 버퍼 (Constant Buffers): register(b#) 최대 14개의 슬롯을 사용할 수 있음 D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT가 14 각 상수 버퍼는 최대 4096개의 상수(각 상수는 최대 4개의 32비트 값, 즉 float4 벡터)를 가질 수 있음. (4096 * 16 바이트 = 64KB)cbuffer MyConstantBuffer : register(b0){ matrix worldViewProj; float4 materialColor;};텍스처 SRV (Shader Resource Views for Textures): register(t#) 최대 128개의 슬롯을 사용할 수 있음Texture2D diffuseMap : register(t0);TextureCube skyBoxTexture : register(t5);버퍼 SRV (Shader Resource Views for Buffers): register(t#) (텍스처와 슬롯 공간 공유) 최대 128개의 슬롯을 사용할 수 있음StructuredBuffer&lt;MyData&gt; myStructuredData : register(t10);ByteAddressBuffer myRawData : register(t11);샘플러 (Samplers): register(s#) 최대 16개의 슬롯을 사용할 수 있음 (D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT).SamplerState linearSampler : register(s0);SamplerComparisonState shadowSampler : register(s1);UAV (Unordered Access Views): register(u#) 컴퓨트 셰이더 (Compute Shader)에서는 Direct3D 11.0에서는 최대 8개의 UAV 슬롯을 지원 D3D11_CS_TGSM_REGISTER_COUNT 또는 D3D11_SHADER_MAX_INTERFACES Direct3D 11.1 이상 기능 수준에서는 이 제한이 최대 64개로 확장될 수 있음 픽셀 셰이더 (Pixel Shader) 렌더 타겟과 동시에 바인딩될 때 제한이 있음 출력 병합기(Output Merger) 단계에서는 렌더 타겟과 UAV를 합쳐서 특정 개수(보통 8개)까지 바인딩할 수 있음 RWTexture2D&lt;float4&gt; outputImage : register(u0);RWStructuredBuffer&lt;Particle&gt; particleData : register(u1);C++에서의 설정 ID3D11DeviceContext의 다양한 SetShaderResources, SetConstantBuffers, SetSamplers, SetUnorderedAccessViews 계열 함수를 사용하여 C++ 코드에서 생성하고 준비한 리소스 뷰나 객체를 특정 슬롯 번호에 바인딩 이때 C++에서 지정하는 슬롯 번호는 HLSL 셰이더 코드의 register()에 명시된 슬롯 번호와 정확히 일치해야 해당 리소스가 올바르게 셰이더에 전달됨 context-&gt;VSSetConstantBuffers(0, 1, &amp;pConstantBuffer); // VS의 b0 슬롯에 상수 버퍼 바인딩context-&gt;PSSetShaderResources(0, 1, &amp;pTextureSRV); // PS의 t0 슬롯에 텍스처 SRV 바인딩context-&gt;CSSetUnorderedAccessViews(0, 1, &amp;pBufferUAV, nullptr); // CS의 u0 슬롯에 UAV 바인딩" }, { "title": "HLSL", "url": "/posts/HLSL/", "categories": "DirectX", "tags": "directx", "date": "2022-06-09 00:00:00 +0900", "snippet": "HLSL DirectX 그래픽스 파이프라인에서 실행되는 셰이더 프로그램을 작성하기 위해 Microsoft에서 개발한 C-유사 프로그래밍 언어 HLSL을 사용하면 개발자가 GPU의 프로그래머블 셰이더 스테이지(정점 셰이더, 픽셀 셰이더 등)를 직접 제어하여 원하는 시각적 효과를 구현할 수 있음 1. 시맨틱 (Semantic) 시맨틱은 HLSL 셰이더 코드 내의 변수나 구조체 멤버가 애플리케이션(C++) 코드의 데이터 또는 다른 셰이더 스테이지의 출력과 어떤 의미로 연결되는지를 나타내는 키워드 즉, 데이터의 출처와 역할을 명시하는 “꼬리표”와 같음 역할 C++에서 정의한 정점(Vertex) 구조체의 멤버 변수들을 HLSL Vertex Shader의 입력 구조체 멤버와 대응(매핑)시킴 서로 다른 셰이더 스테이지 간에 데이터를 전달할 때 해당 데이터의 의미를 명확히 함 예시(POSITION, COLOR, TEXCOORD0, NORMAL 등) 시스템 값 시맨틱(System-Value Semantics)은 특별한 의미를 가지며 파이프라인에서 특정 용도로 사용 SV_Position은 Vertex Shader의 최종 클립 공간 위치 출력 SV_Target은 Pixel Shader의 렌더 타겟 출력 **2. 입력 레이아웃 (Input Layout) **정의 입력 레이아웃은 CPU에서 GPU로 전달되는 정점 데이터가 Vertex Shader의 입력 시맨틱과 어떻게 정확히 대응되는지를 Direct3D에게 알려주는 객체(ID3D11InputLayout)생성 D3D11_INPUT_ELEMENT_DESC 구조체 배열을 사용하여 정의됨 각 D3D11_INPUT_ELEMENT_DESC는 정점 데이터의 한 요소(예: 위치, 색상)를 설명주요 멤버 SemanticName: HLSL 셰이더의 입력 시맨틱 이름 (예: “POSITION”). SemanticIndex: 동일한 시맨틱 이름이 여러 개 있을 경우 구분하기 위한 인덱스 (보통 0). Format: 해당 데이터의 형식 (예: DXGI_FORMAT_R32G32B32_FLOAT는 float 3개를 의미). InputSlot: 이 데이터를 가져올 정점 버퍼 슬롯 번호. AlignedByteOffset: 정점 구조체 내에서 이 데이터 요소의 시작 오프셋 (바이트 단위). InputSlotClass: 정점별 데이터(D3D11_INPUT_PER_VERTEX_DATA)인지 인스턴스별 데이터인지 지정.// D3D11_INPUT_ELEMENT_DESC 배열로 입력 레이아웃 정의D3D11_INPUT_ELEMENT_DESC layout[] ={ { \"POSITION\", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0 }, { \"COLOR\", 0, DXGI_FORMAT_R32G32B32A32_FLOAT, 0, 12, D3D11_INPUT_PER_VERTEX_DATA, 0 } // POSITION은 12바이트 (float3), COLOR는 그 뒤 12바이트 오프셋에서 시작 (float4)};// 이 layout 배열과 컴파일된 Vertex Shader 코드를 사용하여 ID3D11InputLayout 객체 생성// DEVICE-&gt;CreateInputLayout(layout, numElements, pVSBlob-&gt;GetBufferPointer(), pVSBlob-&gt;GetBufferSize(), &amp;g_pInputLayout);3. HLSL 셰이더 코드 구조 (예시)// Vertex Shader 입력 구조체struct VTX_IN{ float3 vPos : POSITION; // 애플리케이션에서 전달된 정점 위치 (시맨틱: POSITION) float4 vColor : COLOR; // 애플리케이션에서 전달된 정점 색상 (시맨틱: COLOR)};// Vertex Shader 출력 구조체 (Pixel Shader 입력으로 전달됨)struct VTX_OUT{ float4 vPosition : SV_Position; // 클립 공간 위치 (시스템 값 시맨틱) float4 vColor : COLOR; // Pixel Shader로 전달될 색상 (시맨틱: COLOR)};// 전역 변수 (예: 상수 버퍼에서 전달되는 변환 행렬)cbuffer TransformChangesEveryFrame : register(b0){ matrix g_matWorld; // matrix g_matView; // matrix g_matProj;}// Vertex Shader 메인 함수VTX_OUT VS_Test(VTX_IN _in){ VTX_OUT output = (VTX_OUT)0.0f; // 출력 구조체 초기화 // 모델 로컬 좌표를 월드 좌표로 변환 (예시) // 실제로는 월드, 뷰, 투영 변환을 모두 거쳐 SV_Position에 최종 좌표 할당 output.vPosition = mul(float4(_in.vPos, 1.0f), g_matWorld); // output.vPosition = mul(output.vPosition, g_matView); // output.vPosition = mul(output.vPosition, g_matProj); output.vColor = _in.vColor; // 입력 색상을 그대로 출력으로 전달 return output;}// Pixel Shader 메인 함수// VTX_OUT 구조체가 래스터라이저에 의해 보간되어 입력됨float4 PS_Test(VTX_OUT _in) : SV_Target // 최종 픽셀 색상 출력 (시스템 값 시맨틱){ return _in.vColor; // 보간된 색상을 그대로 출력} //프로젝트 속성//세이더 형식\t효과f/x//세이더 모델\t5.0//개체 파일 지우기HLSL 함수 삼각 함수 sin(x), cos(x), tan(x) : 기본삼각함수 asin(x), acos(x), atan(x) : x의 각 성분의 역삼각함수.범위 asin : [-π/2, π/2] acos : [-1, 1] atan : [-π/2, π/2] atan2(y,x) : atan(y/x)에 해당하는 함수로, atan(x)는 [-π/2, π/2]의 범위의 값을 가지지만, atan2(y,x)는 [-π, π]의 값을 리턴한다. atan2(y,x)는 x≠0 이면 항상 올바른 값을 계산핤 수 있으므로 더 선호한다. sinh(x), cosh(x), tanh(x) : 쌍곡 삼각함수 sincos(x,s,c) : sin(x)와 cos(x)를 동시에 s, c로 리턴한다. 여기서 s, c는 x와 동일한 차원의 타입이어야 한다. degrees(x) : 라디안 단위의 x값에 해당하는 각도값을 리턴한다. radians(x) : 각도 단위의 x값에 해당하는 라디안값을 리턴한다. 수학 함수 sqrt(x) : 제곱근 rsqrt(x) : 제곱근의 역수(1 / sqrt(x)) exp(x) : e^x. e를 바닥으로 하는 지수 ex를 돌려준다. exp2(x) : 2^x. 2를 바닥으로 하는 지수를 돌려준다. pow(x, y) : x^y ldexp(x, y) : x * 2^y log(x), log10(x), log2(x) : loge(x), log10(x), log2(x) 모든 로그함수의 인자값 x는 양수값으로 지정해야 한다. x가 음수이면 함수값이 정의되지 않고, x=0이면 -무한대를 리턴한다. 값 변환 함수 abs(x) : 절대값(성분마다) sign(x) : 부호에 따라 음수이면 -1, 0이면 0, 양수이면 1을 리턴 ceil(x) : 올림한 정수를 리턴(무조건 올림) floor(x) : 내림한 정수를 리턴 round(x) : 반올림한 정수를 리턴 리턴하는 정수값의 타입은 모드 float 타입이다. max(x,y), min(x,y) : 최대, 최소값 clamp(x, min, max) : x를 [min, max] 범위로 클램프한다. 즉, x가 범위안에 있으면 x를 그대로 리턴하지만, min보다 작으면 min을, max보다 크면 max를 리턴한다. saturate(x) : x를 [0, 1] 범위로 클램프(0~1을 넘어서는 값을 짤라 냄)한다. lerp(x,y,s) : 선형보간인 x + s(y - x) 를 리턴한다. x, y, s는 모두 동일한 타입으로 지정. 이 함수는 s가 0인 경우 x, 1인 경우 y를 돌려주도록 x와 y의 사이를 선형보간 한다. step(x,y) : x≤y 이면 1을 리턴하고, 그렇지 않으면 0을 리턴한다. smoothstep(min,max,x) : x가 [min, max] 사이의 값인 경우에 대해서 [0, 1] 사이에서 부드럽게 변하는 Hermite 보간법을 리턴한다. x가 min보다 작다면 0을 리턴하고, max보다 크다면 1을 리턴한다. asfloat(x) : 입력인자값을 float 타입으로 바꾼다. asint(x) : 입력인자값을 int 타입으로 바꾼다. asuint(x) : 입력인자값을 uint 타입으로 바꾼다. fmod(x,y) : x/y의 나머지를 실수로 리턴한다. frac(x) : x의 소수점 이하 부분을 리턴한다. frc(x) frexp(x,e) : 주어진 실수 x의 표현에서의 소수점 이하값인 가수부분과 지수부분을 동시에 리턴한다. 가수부분을 e로 리턴하고, 지수부분을 함수리턴값으로 리턴한다. x가 0일 경우, 함수는 가수와 지수의 양쪽 모두에 0을 돌려준다. modf(x,i) : x의 정수부분을 i로 리턴하고, 소수점 이하부분을 함수리턴값으로 리턴한다. 테스트 함수 all(x) : x의 모든 성분이 0 이외의 값인지 아닌지를 테스트한다. a11(x) : 인자값의 모든 원소들이 0이 아닌지를 검사한다. 모두 0이 아니면 bool타입의 true값을 리턴한다. any(x) : x의 원소중에 0이 아닌 원소가 하나라도 있으면 true값을 리턴한다. isfinite(x) : 인자값이 무한대가 아닌 유한한 값이면 true를 리턴한다. isinf(x) : 무한대 값(±INF)이면 true를 리턴한다. isnan(x) : NAN(Not a Number)이면 true를 리턴한다. 벡터 함수 cross(x,y) : 두 벡터의 외적을 계산한다. 두 인자값과 리턴값은 모두 float3 타입이다. dot(x,y) : 두 벡터의 내적을 계산한다. distance(x,y) : 두 벡터의 거리를 계산한다. len(x) : 벡터의 길이 length(x) : 벡터의 길이를 계산한다. 이들은 모두 하나의 float를 리턴한다. normalize(x) : 정규화된 벡터를 리턴한다. 즉, 리턴값은 x/length(x) 와 동일하다. determinant(m) : 행렬식을 리턴한다. 입력인자는 정방행렬이어야 한다. transpose(m) : m의 전치행렬을 리턴한다. mul(x,y) : 두 행렬의 곱을 계산한다. reflect(i, n) : 정반사광의 방향 벡터를 구하는 벡터반사 함수. 첫 번째 인자로 입사광의 방향벡터를 두 번째 인자로 반사면의 법선을 받는다. 기타 함수 tex1D(s, t) : 1D의 텍스처 참조. s는 샘플러 또는 sampler1D 개체, t는 스칼라. tex1D(s, t, ddx, ddy) : 미분을 지정한 1D의 텍스처 참조. s는 샘플러 또는 sampler1D 개체, t, ddx, ddy는 스칼라. tex1Dproj(s, t) : 1D의 투영 텍스처 참조. s는 샘플러 또느느 sampler1D 개체, t는 4D 벡터. t는 참조가 실행되지 직전의 성분으로 나눈셈 된다. tex1Dbias(s, t) : 1D 바이어스 텍스처 참조. t는 4D 벡터로 참조를 실행하기 전에, 밉레벨에 t.w의 바이어스를 걸칠 수 있다. tex2D(s, t) : 텍스쳐 샘플링에 사용하는 HLSL 함수. 첫 번째 인자에서 두 번째 인자 좌표에 있는 텍셀을 구하는 함수. s는 샘플러 또는 sampler2D 개체, t는 2D 텍스처 좌표. tex2D(s, t, ddx, ddy) : 2D의 투영 텍스처 참조. tex2Dbias(s, t) : 2D의 바이어스 텍스처 참조. tex3D(s, t) : 3D의 볼륨 텍스처 참조. s는 샘플러 또는 sampler3D 개체, t는 3D 텍스처 좌표. tex3D(s, t, ddx, ddy) : 미분을 지정한 3D의 볼륨 텍스처 참조. tex3Dproj(s, t) : 3D의 투영 볼륨 텍스처 참조. tex3Dbias(s, t) : 3D의 바이어스 텍스처 참조. texCUBE() : 입방체 텍스쳐를 샘플링하는 함수. 3D 큐브의 텍스처 참조. s는 샘플러 또는 samplerCUBE 개체, t는 3D 텍스처 좌표. texCUBE(s, t, ddx, ddy) : 미분을 지정한 3D의 큐브 텍스처 참조. texCUBEproj(s, t) : 3D 투영의 큐브 텍스처 참조. texCUBEbias(s, t) : 3D 바이어스 큐브 텍스처 참조. ddx(x), ddy(x) : 스크린공간의 x, y 좌표에 대한 x, y의 편미분을 리턴한다. fwidth(x) : abs( ddx(x) ) + abs( ddy(x) ) 를 리턴한다. clip(x) : x의 한 원소가 0보다 작으면 현재 픽셀을 버린다. x의 각 성분이 면으로부터의 거리를 나타내는 경우, 이 함수를 사용해, 클립면을 시뮬레이션 한다. 이 함수들을 픽셀셰이더에서만 사용할 수 있다. 고급기법에서 사용되는 함수 faceforward(n, i, ng) : 관찰자를 향하는 표면 노말(-n * sign(dot(i, ng)))을 리턴한다. reflect(i, n) : 반사벡터를 리턴한다. 입사 방향 i, 표면 법선 n로 했을 경우, v = i - 2 * dot(i, n) * n 에 의해 구할 수 있는 반사 벡터 v를 리턴한다. refract(i, n, R) : 굴절벡터를 리턴한다. 입사 방향 i, 표면 법선 n, 굴절 R 의 상대 인덱스가 주어졌을 경우 굴절 벡터 v를 리턴한다. i와 n사이의 입사각이 지정된 R보다 너무 크면 (0, 0, 0)을 리턴한다. lit(n · l, n · h, m) : 조명계수 벡터(앰비언트, 디퓨즈, 스펙큘러, 1)를 리턴한다. 앰비언트 = 1; 디퓨즈 = (n · l &lt; 0) ? 0 : n · l; 스펙큘러 = (n · l &lt; 0)   (n · h &lt; 0) ? 0 : (n · h * m); noise(x) : 연기나 화재효과에 사용되는 Perlin 노이즈값을 리턴한다. D3DCOLORtoUBYTE4(x) : 4D 벡터 x의 성분을 교체 및 스케일링 해, 일부 하드웨어에 있는 UBYTE4 지원의 부족을 보정한다. 데이터 형 sampler2D : 텍스처에서 텍셀을 구해올 때 사용하는 샘플러 데이터형출처 : http://www.silverwolf.co.kr/shader/79529" }, { "title": "Tree", "url": "/posts/Tree/", "categories": "자료구조, Tree", "tags": "data_structure", "date": "2022-06-08 00:00:00 +0900", "snippet": "Tree Tree 정점과 간선을 이용하여 사이클이 이루어지지 않게 구성된 자료구조 Tree의 특징 하나의 루트노드와 0개 이상의 하위 노드로 구성 데이터를 순차적으로 저장하지 않는 비선형 자료구조 계층관계로 만들어진 계층구조이며 모든 자식 노드는 하나의 부모노드만을 지님 비순환인 무방향 그래프 Tree 용어 노드 : 트리를 구성하는 원소(자료) 간선 : 노드를 연결하는 선 차수(Degree) : 한 노드가 가지는 서브 트리의 수, 즉 자식 노드의 수 노드의 크기 : 자신을 포함한 모든 자손 노드의 개수 노드의 깊이 : 루트에서 어떤 노드에 도달하기 위해 거쳐야 하는 간선의 수 노드의 레벨 : 트리의 특정 깊이를 가지는 노드의 집합 노드의 높이 : 루트 노드에서 가장 깊숙히 있는 노드의 깊이 Tree 노드 종류 루트(Root)노드 : 트리의 시작노드 단말 노드(리프 노드 ,Leaf) : 자식 노드가 없는 노드 형제 노드(Sibling) : 같은 부모 노드를 가진 자식 노드 내부 노드(Internal) : 단말 노드를 제외한 나머지 노드, 차수가 1 이상인 노드 Tree Code(템플릿)template&lt;typename T&gt;class Node {public: T _data; Node* Lchild;\t\t\t Node* Rchild;\t\t\tpublic: Node() : _data(0), Lchild(nullptr), Rchild(nullptr) {}; Node(T data,Node* l,Node* r) :_data(data), Lchild(l), Rchild(r) {}; ~Node();};template&lt;typename T&gt;void PreOrder(Node&lt;T&gt;* _Node)\t\t// 전위 순회{ if (nullptr != _Node) { cout &lt;&lt; _Node-&gt;_data &lt;&lt; \" \"; PreOrder(_Node-&gt;Lchild); PreOrder(_Node-&gt;Rchild); }}template&lt;typename T&gt;void InOrder(Node&lt;T&gt;* _Node)\t\t\t// 중위 순회{ if (nullptr != _Node) { InOrder(_Node-&gt;Lchild); cout &lt;&lt; _Node-&gt;_data &lt;&lt; \" \"; InOrder(_Node-&gt;Rchild); }}template&lt;typename T&gt;void PostOrder(Node&lt;T&gt;* _Node)\t\t// 후위 순회{ if (nullptr != _Node) { PostOrder(_Node-&gt;Lchild); PostOrder(_Node-&gt;Rchild); cout &lt;&lt; _Node-&gt;_data &lt;&lt; \" \"; }}" }, { "title": "Graph", "url": "/posts/Graph/", "categories": "자료구조, Graph", "tags": "data_structure", "date": "2022-06-08 00:00:00 +0900", "snippet": "Graph Graph 정점(vertex)와 간선(edge)들의 유한 집합 Grpah의 용어 정점(vertice) : 노드(node)라고도 하며 정점에는 데이터가 저장 간선(edge): 링크(link)라고도 하며 노드간의 관계를 나타냄 인접 정점(adjacent vertex) : 간선에 의해 연결된 정점 단순 경로(simple-path): 경로 중 반복되는 정점이 없는것, 같은 간선을 지나가지 않는 경로 차수(degree): 무방향 그래프에서 하나의 정점에 부속되어 있는 간선의 수 진출 차수(out-degree) : 방향그래프에서 사용되는 용어로, 한 노드에서 외부로 향하는 간선의 수 진입차수(in-degree) : 방향그래프에서 사용되는 용어로, 외부 노드에서 들어오는 간선의 수Grpah의 종류 무방향 그래프 : 두 정점을 연결하는 간선에 방향이 없는 그래프 방향 그래프 : 간선에 방향이 있는 그래프 완전 그래프 : 각 정점에서 다른 모든 정점을 연결하여 최댜로 많은 간선 수를 가진 그래프 부분 그래프 : 정점이나 간선을 일부만 제외하여 만든 부분 그래프 가중치 그래프 : 정점을 연결하는 간선에 가중치를 할당한 그래프 사이클 그래프 : 단순 경로의 시작 정점과 종료 정점이 동일한 경우(단순 경로 : 경로 중에서 반복되는 정점이 없는 경우) 비사이클 그래프 : 사이클이 없는 그래프 그래프의 구현방법 인접 리스트 인접 행렬(배열) 그래프의 탐색 DFS : 깊이 우선 탐색 임의의 노드에서 시작해서 다음 분기로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방법 BFS : 너비 우선 탐색 임의의 노드에서 시작해서 인접한 노드를 먼저 탐색하는 방법 Graph Code(인접 행렬)adjMatrix.h#pragma once#define MAX_VERTEX 30// 그래프를 인접 행렬로 표현하기 위한 구조체 정의typedef struct graphType { int n;\t\t\t\t\t\t\t\t\t// 그래프의 정점 개수 int adjMatrix[MAX_VERTEX][MAX_VERTEX]; // 그래프에 대한 30x30의 2차원 배열} graphType;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include \"adjMatrix.h\"// 공백 그래프를 생성하는 연산void createGraph(graphType* g) { int i, j; g-&gt;n = 0;\t\t\t\t\t\t\t\t// 정점 개수를 0으로 초기화 for (i = 0; i &lt; MAX_VERTEX; i++) { for (j = 0; j &lt; MAX_VERTEX; j++) g-&gt;adjMatrix[i][j] = 0;\t\t\t// 그래프 g에 대한 2차원 배열의 값을 0으로 초기화 }}// 그래프 g에 정점 v를 삽입하는 연산void insertVertex(graphType* g, int v) { if (((g-&gt;n) + 1) &gt; MAX_VERTEX) { printf(\"\\n 그래프 정점의 개수를 초과하였습니다!\"); return; } g-&gt;n++; // 그래프 정점의 개수 n을 하나 증가}// 그래프 g에 간선 (u, v)를 삽입하는 연산void insertEdge(graphType* g, int u, int v) { // 간선 (u, v)를 삽입하기 위해 정점 u와 v가 그래프에 존재하는지 확인 if (u &gt;= g-&gt;n || v &gt;= g-&gt;n) { printf(\"\\n 그래프에 없는 정점입니다!\"); return; } g-&gt;adjMatrix[u][v] = 1;// 삽입한 간선에 대한 2차원 배열의 원소 값을 1로 설정}// 그래프 g의 2차원 배열 값을 순서대로 출력하는 연산void print_adjMatrix(graphType* g) { int i, j; for (i = 0; i &lt; (g-&gt;n); i++) { printf(\"\\n\\t\\t\"); for (j = 0; j &lt; (g-&gt;n); j++) printf(\"%2d\", g-&gt;adjMatrix[i][j]); }}Graph Code(인접 리스트)adjList.h#pragma once#define MAX_VERTEX 30\t\t\t\t\t// 헤드 포인터 배열의 최대 크기// 인접 리스트의 노드 구조를 구조체로 정의typedef struct graphNode { int vertex;\t\t\t\t\t\t\t// 정점을 나타내는 데이터 필드 struct graphNode* link;\t\t\t// 다음 인접 정점을 연결하는 링크 필드} graphNode;// 그래프를 인접 리스트로 표현하기 위한 구조체 정의typedef struct graphType { int n;\t\t\t\t\t\t\t\t// 그래프의 정점 개수 graphNode* adjList_H[MAX_VERTEX];\t// 그래프 정점에 대한 헤드 포인터 배열} graphType;#include &lt;stdio.h&gt;#include \"adjList.h\"// 공백 그래프를 생성하는 연산void createGraph(graphType* g) { int v; g-&gt;n = 0;\t\t\t\t\t\t// 그래프의 정점 개수를 0으로 초기화 for (v = 0; v &lt; MAX_VERTEX; v++) g-&gt;adjList_H[v] = NULL;\t\t// 그래프의 정점에 대한 헤드 포인터 배열을 NULL로 초기화} // 그래프 g에 정점 v를 삽입하는 연산void insertVertex(graphType* g, int v) { if (((g-&gt;n) + 1) &gt; MAX_VERTEX) { printf(\"\\n 그래프 정점의 개수를 초과하였습니다!\"); return; } g-&gt;n++;\t\t\t\t\t\t\t\t// 그래프의 정점 개수 n을 하나 증가}// 그래프 g에 간선 (u, v)를 삽입하는 연산void insertEdge(graphType* g, int u, int v) { graphNode* node; // 간선 (u, v)를 삽입하기 위해 정점 u와 정점 v가 현재 그래프에 있는지 확인 if (u &gt;= g-&gt;n || v &gt;= g-&gt;n) { printf(\"\\n 그래프에 없는 정점입니다!\"); return; } node = (graphNode*)malloc(sizeof(graphNode)); node-&gt;vertex = v; node-&gt;link = g-&gt;adjList_H[u];\t// 삽입 간선에 대한 노드를 리스트의 첫 번째 노드로 연결 g-&gt;adjList_H[u] = node;}// 그래프 g의 각 정점에 대한 인접 리스트를 출력하는 연산void print_adjList(graphType* g) { int i; graphNode* p; for (i = 0; i &lt; g-&gt;n; i++) { printf(\"\\n\\t\\t정점 %c의 인접 리스트\", i + 65); p = g-&gt;adjList_H[i]; while (p) { printf(\" -&gt; %c\", p-&gt;vertex + 65); // 정점 0~3을 A~D로 출력 p = p-&gt;link; } }}" }, { "title": "ResourceView", "url": "/posts/ResourceView/", "categories": "DirectX", "tags": "directx", "date": "2022-06-08 00:00:00 +0900", "snippet": "DirectX 자원 뷰 (Resource View) 핵심 정리 DirectX에서 자원 뷰(Resource View)는 GPU 자원(예: 텍스처, 버퍼)을 렌더링 파이프라인의 특정 단계에 특정 용도로 연결(바인딩)하는 데 사용되는 객체 자원 뷰는 동일한 자원이라도 파이프라인의 어느 부분에 어떤 방식으로 접근할지를 정의하여, 자원의 다양한 활용을 가능하게 함 자원 뷰의 주요 종류1. 렌더 타겟 뷰 (Render Target View - RTV)역할 렌더링 파이프라인의 최종 색상 출력(픽셀 셰이더의 결과)을 받을 자원(주로 2D 텍스처)을 지정특징 렌더 타겟으로 사용될 자원의 특정 부분(예: 밉맵 레벨, 배열 슬라이스)이나 포맷을 지정 예를 들어, 화면에 그려질 최종 이미지나 중간 과정의 렌더링 결과를 저장하는 데 사용2. 깊이/스텐실 뷰 (Depth Stencil View - DSV)역할 깊이 정보와 스텐실 정보를 저장하고 테스트하는 데 사용될 자원(깊이/스텐실 버퍼)을 지정특징 RTV와 마찬가지로 렌더링 파이프라인의 출력(깊이/스텐실 값)을 받지만, 색상이 아닌 깊이 판정과 스텐실 판정을 위해 사용 3D 장면에서 물체의 앞뒤 관계를 결정(오클루전 컬링)하거나, 특정 영역에만 렌더링하는 등의 고급 효과에 필수적 3. 셰이더 자원 뷰 (Shader Resource View - SRV)역할 프로그래머블 셰이더(정점 셰이더, 픽셀 셰이더 등)가 자원으로부터 데이터를 읽을 수 있도록 함특징 텍스처를 샘플링하거나, 버퍼에서 데이터를 읽어오는 등 셰이더 연산에 필요한 입력 데이터를 제공함 이 뷰를 통해 접근하는 자원은 셰이더 내에서 일반적으로 수정(쓰기)할 수 없음 4. 순서 없는 접근 뷰 (Unordered Access View - UAV)역할 셰이더(주로 픽셀 셰이더 또는 계산 셰이더)가 자원으로부터 데이터를 읽는 동시에 쓸 수 있도록 함특징 출력 위치가 미리 정해져 있지 않아, 셰이더 내에서 자원의 임의의 위치에 데이터를 기록하는 스캐터(scatter) 연산이 가능 GPGPU(범용 GPU 프로그래밍) 작업, 고급 이미지 처리, 파티클 시뮬레이션 등 복잡한 데이터 조작에 사용 자원 뷰 생성 및 해제생성 자원 뷰는 ID3D11Device 인터페이스를 사용하여 생성됨 각 뷰 타입별로 별도의 생성 메서드가 제공 (예: CreateRenderTargetView, CreateShaderResourceView). 이들 생성 메서드는 일반적으로 다음과 같은 세 가지 매개변수를 받음 뷰를 적용할 자원을 가리키는 포인터 (예: ID3D11Texture2D, ID3D11Buffer). 뷰를 상세히 서술하는 구조체를 가리키는 포인터 (예: D3D11_RENDER_TARGET_VIEW_DESC*). 이 매개변수에 nullptr을 전달하면, 자원 생성 시 정의된 타입과 포맷을 기반으로 전체 자원을 포괄하는 기본 뷰가 생성 생성된 자원 뷰 객체를 받을 포인터의 주소 (예: ID3D11RenderTargetView**). 해제 자원 뷰는 COM(Component Object Model) 인터페이스이므로, 사용이 끝나면 참조 횟수를 관리하여 적절히 참조를 해제해야 함 ComPtr과 같은 스마트 포인터를 사용하면 이 과정이 자동으로 관리될 수 있음 " }, { "title": "Rendering_PipeLine", "url": "/posts/Rendering_PipeLine/", "categories": "DirectX", "tags": "directx", "date": "2022-06-07 00:00:00 +0900", "snippet": "DirectX 렌더링 파이프라인 요약 DirectX 렌더링 파이프라인은 3차원 장면 정보가 화면에 표시될 2차원 이미지로 변환되는 일련의 처리 단계입니다. 각 단계는 GPU 내에서 특정 작업을 수행 이러한 단계를 거쳐 3D 모델 데이터는 최종적으로 우리 눈에 보이는 2D 이미지로 렌더링 1. IA (Input Assembler) - 입력 조립기역할 렌더링 파이프라인의 시작점주요 작업 CPU로부터 정점(Vertex) 데이터와 인덱스(Index) 데이터를 읽어와 기본 도형(Primitive - 주로 삼각형)으로 조립하고, 이를 다음 단계로 전달2. Vertex Shader (VS) - 정점 셰이더역할 입력된 각 정점(Vertex)에 대해 개별적으로 실행되는 프로그램주요 작업 정점의 위치를 로컬 공간에서 월드 공간, 뷰 공간을 거쳐 최종적으로 NDC(Normalized Device Coordinates, 정규화된 장치 좌표계) 또는 투영 좌표계로 변환 정점의 색상, 텍스처 좌표 등 다른 속성들을 계산하거나 변환할 수도 있음3. Tessellation Stages (Hull Shader &amp; Domain Shader) - 테셀레이션 단계 (선택)역할 (DirectX 11에서 도입) 모델의 표면을 더 세밀하게 나누어 디테일을 동적으로 추가주요 작업 Hull Shader: 입력된 기본 도형(패치)을 어떻게 세분화할지 결정하고 제어점을 출력 Domain Shader: Hull Shader에서 생성된 정보를 바탕으로 실제 정점들을 생성하여 표면을 더 잘게 나눔 LOD(Level of Detail) 구현에 유용합니다.4. Geometry Shader (GS) - 기하 셰이더 (선택)역할 (DirectX 10에서 도입) 파이프라인 중간에서 기본 도형(Primitive) 전체를 입력으로 받아 새로운 기본 도형을 생성하거나 기존 도형을 수정, 또는 제거할 수 있음주요 작업 하나의 정점, 선, 삼각형을 입력받아 0개 이상의 기본 도형을 출력할 수 있음 파티클 생성, 실루엣 확장 등에 사용될 수 있지만, 과도하게 사용하면 성능에 부담을 줄 수 있음5. Rasterizer (RS) - 래스터라이저역할 벡터 기반의 기본 도형(주로 삼각형)을 화면에 표시될 픽셀 단위로 변환주요 작업 Culling (컬링): 화면에 보이지 않을 삼각형을 미리 제거. 주로 삼각형 정점의 감긴 순서(winding order)를 기준으로 앞면인지 뒷면인지 판별하여 뒷면 컬링(back-face culling)을 수행 뷰포트 변환 및 클리핑: NDC 좌표를 화면 좌표로 변환하고, 화면 영역을 벗어나는 부분을 잘라냄 픽셀 생성: 각 삼각형이 덮고 있는 픽셀들을 결정 속성 보간: 정점 셰이더에서 계산된 정점 속성(색상, 텍스처 좌표 등)을 각 픽셀에 맞게 보간. 이 보간된 값들이 픽셀 셰이더의 입력으로 됨 6. Pixel Shader (PS) - 픽셀 셰이더 (Fragment Shader라고도 함)역할 래스터라이저 단계에서 생성된 각 픽셀(후보)에 대해 실행되는 프로그램주요 작업 픽셀의 최종 색상을 계산. 텍스처 샘플링, 조명 계산, 그림자 적용 등 복잡한 연산이 수행 픽셀의 깊이 값(Z-value)을 계산할 수도 있음7. OM (Output Merger) - 출력 병합기역할 픽셀 셰이더에서 계산된 픽셀 값들을 최종적으로 화면에 표시될 렌더 타겟(보통 백 버퍼)에 기록하는 단계주요 작업 Depth Stencil Test (깊이/스텐실 검사):깊이 검사 (Z-Test): 현재 픽셀의 깊이 값과 깊이 버퍼(Depth Buffer)에 저장된 값을 비교하여, 현재 픽셀이 다른 픽셀에 가려지는지 판정 가려진 픽셀은 렌더 타겟에 기록되지 않습니다 (오클루전 처리). 스텐실 검사: 스텐실 버퍼를 사용하여 특정 영역에만 렌더링하는 등의 고급 효과를 구현 Blending (블렌딩):픽셀 셰이더에서 나온 픽셀 색상과 렌더 타겟에 이미 있는 픽셀 색상을 특정 혼합 공식에 따라 섞음. 투명/반투명 효과 등을 구현하는 데 사용 그림출처:https://docs.microsoft.com/ko-kr/windows/win32/direct3d11/overviews-direct3d-11-graphics-pipeline" }, { "title": "64비트기반프로그래밍", "url": "/posts/64%EB%B9%84%ED%8A%B8%EA%B8%B0%EB%B0%98%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/", "categories": "윈도우즈시스템프로그래밍, 운영체제", "tags": "windows", "date": "2022-06-05 00:00:00 +0900", "snippet": "64비트와 32비트 비트를 나누는 기준 한 번에 전송 및 수신할 수 있는 데이터의 크기 데이터 처리 능력(외부로부터 들어오는 데이터를 처리하는 크기) 프로그래머 입장에서의 비트 프로그래밍 할 때는 주소값의 범위가 넓으면 넓은 만큼 넓은 메모리 공간을 활용할수 있다. 32비트 컴퓨터에서 32비트를 처리하는데 한번에 전송하고 한번에 연산이 가능하지만, 32비트 컴퓨터에서 64비트를 처리하려면 주소값을 두번에 나눠서 ALU에 전송하고, 두번 이상에 걸쳐서 연산을 한다. 주소에 대한 내용 내부 메모리에 해당하는 램(RAM)에 주소가 정해져 있지 않고 운영체제에서 프로그램 실행을 위해 편의상 붙여놓은 가상의 주소를 사용(운영체제가 주소를 지정하는 주체) 주소값을 표현하기 위해 비트를 사용 주소의 표현 범위(비트)가 넓으면 넓을수록 좋은 이유는 그만큼 메모리 크기가 커짐. 프로그램 구현 관점에서의 WIN32 VS WIN64 LLP64 vs LP64 Windows에서는 LLP64 ,UNIX에서는 LP64모델을 사용하고 차이가 나는것은 long을 표현하는 부분 운영체제 모델 char short int long 포인터 Windows LLP64 1바이트 2바이트 4바이트 4바이트 8바이트 UNIX LP64 1바이트 2바이트 4바이트 8바이트 8바이트 64비트와 32비트 공존의 문제점 32비트와 64비트 사이에서 자료형의 크기가 달라 문제가 생긴다.int main(){ int arr[10]={0,}; int arrVal=(int)arr; //데이터 손실이 발생할 수 있는 위치 printf(\"pointer :%d\\n\",arrVal); return 0;} 32비트에서는 문제가 없었지만, 64비트에서는 포인터를 8비트로 표현하기 때문에 문제가 생길수 있다. 그러므로 64비트 시스템에서는 포인터가 지니고 있는 주소값을 4바이트 정수형으로 형변환하면 안된다. Windows 스타일 자료형 기본 자료형에 대한 마이크로소프트의 정의 WINDOWS자료형 의미 정의형태 BOOL Boolean variable typedef int BOOL DWORD 32-bit unsigned integer typedef unsigned long DWORD DWORD32 32-bit unsigned integer typedef unsigned int DWORD32 DWORD64 64-bit unsigned integer typedef unsigned __int64 DWORD64 INT 32-bit signed integer typedef int INT INT32 32-bit signed integer typedef signed int INT32 INT64 64-bit signed integer typedef signed __int64 INT64 LONG 32-bit signed integer typedef long LONG LONG32 32-bit signed integer typedef signed int LONG32 LONG64 64-bit signed integer typedef signed __int64 LONG64 UINT Unsigned INT typedef unsigned int UINT UINT32 Unsigned INT32 typedef unsigned int UINT32 UINT64 Unsigned INT64 typedef unsigned __int64 UINT64 ULONG Unsigned LONG typedef unsigned int ULONG ULONG32 Unsigned LONG32 typedef unsigned int ULONG32 ULONG64 Unsigned LONG64 typedef unsigned __int64 ULONG64 Polymorpihc 자료형 다형적이란 단어로 상황과 환경에 따라서 그 자료형이 의미하는 바가 유동적이라는 뜻으로 매크로를 이용하여 자료형을 비트에 따라 다르게 설정할 수 있다 Windows에서의 예시#if defined(_WIN64) //64비트일때 typedef __int64 LONG_PTR; typedef unsigned __int64 ULONG_PTR; typedef __int64 INT_PTR; typedef unsigned __int64 UINT_PTR;#else //32비트일때 typedef long LONG_PTR; typedef unsigned long ULONG_PTR; typedef int INT_PTR; typedef unsigned __int64 UINT_PTR;#endif 포인터가 아니지만 PTR를 붙인 이유는 포인터값 기반의 산술연산을 위해 정의된 자료형이기 때문. Polymorphic을 이용한 예시UINT_PTR CalDistance(UINT_PTR a , UINT_PTR b){ return a-b;}int _tmain(){ INT32 vall = 10; INT32 val2 = 20; _tprintf( _T(\"distance : %d \\n\"), CalDistance((UINT_PTR)&amp;vall,(UINT_PTR)&amp;val2) ) return 0;} 위의 예시처럼 Windows에서 제공하는 매크로로 실행환경에 따라(32비트,64비트)에 따라 대응할 수 있다." }, { "title": "IndexBuffer", "url": "/posts/IndexBuffer/", "categories": "DirectX", "tags": "directx", "date": "2022-06-04 00:00:00 +0900", "snippet": "DirectX 인덱스 버퍼 (Index Buffer) 3D 모델을 렌더링할 때, 특히 복잡한 모델은 수많은 삼각형으로 구성됨. 이때 인덱스 버퍼(Index Buffer)는 정점 버퍼(Vertex Buffer)와 함께 사용되어 렌더링 효율성을 크게 향상시키는 중요한 요소인덱스 버퍼가 필요한 이유정점 버퍼만 사용할 경우 첫 번째 삼각형: 3개의 정점 필요 두 번째 삼각형: 3개의 정점 필요 총 6개의 정점 데이터가 정점 버퍼에 저장 하지만 이 사각형은 실제로는 4개의 고유한 꼭짓점(정점)만 가짐. 두 삼각형이 공유하는 빗변의 양 끝점, 즉 2개의 정점 위치 데이터가 정점 버퍼에 중복으로 저장되는 것 이처럼 모델이 복잡해질수록 공유되는 정점은 더욱 많아지고, 이로 인해 상당한 메모리가 낭비되며, 중복된 정점 데이터에 대한 불필요한 처리(변환, 셰이딩 등)가 발생하여 성능 저하를 유발할 수 있음인덱스 버퍼의 역할 정점 버퍼에는 고유한 정점 데이터만 저장합니다. 인덱스 버퍼에는 이 고유한 정점들의 인덱스(번호)를 저장하여, 이 인덱스들을 특정 순서대로 참조함으로써 삼각형(또는 다른 기본 도형)을 정의 즉, 정점 데이터를 직접 나열하는 대신, 정점 버퍼의 몇 번째 정점을 사용하라는 식으로 간접적으로 정점을 참조장점 메모리 절약: 중복된 정점 데이터를 저장하지 않으므로 메모리 사용량이 줄어듬 성능 향상: GPU가 처리해야 할 고유 정점의 수가 줄어들고, 정점 캐시 효율이 높아져 렌더링 성능이 향상될 수 있음인덱스 버퍼 생성 및 사용 코드1.필요한 변수 선언// 인덱스 버퍼 객체를 가리킬 ComPtr 스마트 포인터ComPtr&lt;ID3D11Buffer&gt; g_pIB;2. 인덱스 데이터 정의 정점 버퍼에 있는 정점들을 어떤 순서로 연결하여 삼각형을 만들지를 정의 예를 들어, 4개의 정점(V0, V1, V2, V3)으로 사각형을 만든다고 가정하고, 인덱스는 UINT (부호 없는 정수) 타입을 사용// 사각형을 그리기 위한 인덱스 배열 (삼각형 2개, 총 6개의 인덱스)// 정점 순서: V0-V1-V2-V3 (예: 시계방향 또는 반시계방향으로 일관되게)// 삼각형 1: V0, V2, V3// 삼각형 2: V0, V1, V2// (인덱스 순서는 삼각형의 앞면/뒷면 판정에 영향을 주므로 중요합니다)UINT arrIDx[6] = { 0, 2, 3, // 첫 번째 삼각형 (V0, V2, V3) 0, 1, 2 }; // 두 번째 삼각형 (V0, V1, V2)3. 버퍼 설정 (D3D11_BUFFER_DESC) GPU에 생성할 인덱스 버퍼의 특성을 정의 정점 버퍼와 유사하지만, 몇 가지 설정이 다름D3D11_BUFFER_DESC tBufferDesc = {};// 버퍼의 총 크기 (바이트 단위)tBufferDesc.ByteWidth = sizeof(UINT) * 6; // 인덱스 타입 크기 * 인덱스 개수// 버퍼의 용도 및 CPU 접근 권한 설정// D3D11_USAGE_DEFAULT: GPU가 읽고 쓰는 가장 일반적인 리소스.// CPU에서는 직접적인 잦은 업데이트를 하지 않는 정적 데이터에 적합.// 인덱스 버퍼는 보통 한 번 생성 후 잘 변경되지 않으므로 DEFAULT가 적합합니다.tBufferDesc.Usage = D3D11_USAGE_DEFAULT;tBufferDesc.CPUAccessFlags = 0; // CPU에서 이 버퍼에 접근할 필요가 없음 (값 수정 X)// 바인딩 플래그: 버퍼가 파이프라인의 어느 단계에 바인딩될지 지정// D3D11_BIND_INDEX_BUFFER: 이 버퍼가 인덱스 버퍼로 사용됨을 명시.tBufferDesc.BindFlags = D3D11_BIND_INDEX_BUFFER;// 기타 플래그 (일반적인 인덱스 버퍼에는 0)tBufferDesc.MiscFlags = 0;tBufferDesc.StructureByteStride = 0;4. 초기 데이터 설정 (D3D11_SUBRESOURCE_DATA) 버퍼 생성 시 함께 채워 넣을 인덱스 데이터를 지정D3D11_SUBRESOURCE_DATA tSubDesc = {};tSubDesc.pSysMem = arrIDx; // CPU 메모리에 있는 인덱스 데이터 배열의 시작 주소5. 버퍼 생성 (CreateBuffer) 설정된 정보들을 바탕으로 Direct3D 디바이스의 CreateBuffer 함수를 호출하여 GPU 메모리에 인덱스 버퍼를 생성// DEVICE는 ID3D11Device* 타입의 디바이스 객체 포인터라고 가정HRESULT hr = DEVICE-&gt;CreateBuffer(&amp;tBufferDesc, &amp;tSubDesc, g_pIB.GetAddressOf());if (FAILED(hr)){ // 에러 처리 assert(nullptr);} 이제 g_pIB는 GPU에 생성된 인덱스 버퍼를 가리키게 됨6. 인덱스 버퍼 설정 (IASetIndexBuffer) 생성된 인덱스 버퍼를 렌더링 파이프라인의 입력 조립기(Input Assembler, IA) 단계에 설정하여 실제로 사용할 수 있도록 함 이 함수는 ID3D11DeviceContext의 멤버 // CONTEXT는 ID3D11DeviceContext* 타입의 디바이스 컨텍스트 객체 포인터라고 가정// 파이프라인에 인덱스 버퍼 설정CONTEXT-&gt;IASetIndexBuffer( g_pIB.Get(), // 사용할 인덱스 버퍼의 포인터 DXGI_FORMAT_R32_UINT, // 인덱스의 데이터 포맷 (32비트 부호 없는 정수) // (정점 수가 65536개 미만이면 DXGI_FORMAT_R16_UINT 사용 가능) 0 // 버퍼의 시작 부분에서부터의 오프셋 (일반적으로 0)); 이제 DrawIndexed() 계열의 그리기 함수를 호출하면, 설정된 정점 버퍼와 인덱스 버퍼를 사용하여 GPU가 도형을 렌더링을 함 인덱스 버퍼를 사용하면 Draw() 대신 DrawIndexed()를 사용" }, { "title": "SelectionSort", "url": "/posts/SelectionSort/", "categories": "자료구조, Sort", "tags": "data_structure", "date": "2022-06-03 00:00:00 +0900", "snippet": "선택정렬 전체 원소 중에서 기준 위치에 맞는 원소를 선택해 자리를 교환하는 방식 정렬되지 않는 원소중 가장 작은 원소를 찾은 다음 ,첫째 원소와 자리를 교환한다. 시간복잡도는(n²)선택정렬 Codevoid swap(int* a, int* b){ int tmp = *a; *a = *b; *b = tmp;}int main(){ srand((unsigned int)time(NULL)); int iArr[MAX]; for (int i = 0; i &lt; MAX; ++i) { iArr[i] = rand() % MAX; } // 선택 정렬 for (int i = 0; i &lt; MAX - 1; ++i) { int min = i; for (int j = i + 1; j &lt; MAX; ++j) { if (iArr[j] &lt; iArr[min]) { min = j; } } swap(&amp;iArr[i], &amp;iArr[min]); } for (int i = 0; i &lt; MAX; ++i) { cout &lt;&lt; iArr[i] &lt;&lt; endl; }}" }, { "title": "InsertSort", "url": "/posts/InsertSort/", "categories": "자료구조, Sort", "tags": "data_structure", "date": "2022-06-03 00:00:00 +0900", "snippet": "삽입정렬 정렬되어 있는 부분집합에 정렬할 새로운 원소의 위치를 찾아 삽입하는 방식 아직 정렬하지 않은 원소중 하나를 뽑고 정렬되어 있는 부분집합에서 크기를 비교하여 위치에 맞게 배정 시간복잡도는(n²)삽입정렬 Code#define MAX 10int main(){ srand((unsigned int)time(NULL)); int iArr[MAX]; for (int i = 0; i &lt; MAX; ++i) { iArr[i] = rand() % MAX; } // 삽입 정렬 for (int i = 1; i &lt; MAX; ++i) { int tmp = iArr[i]; int j = i; while ((j &gt; 0) &amp;&amp; (iArr[j - 1] &gt; tmp)) { iArr[j] = iArr[j - 1]; j = j - 1; } iArr[j] = tmp; } for (int i = 0; i &lt; MAX; ++i) { cout &lt;&lt; iArr[i] &lt;&lt; endl; }}" }, { "title": "VertexBuffer", "url": "/posts/VertexBuffer/", "categories": "DirectX", "tags": "directx", "date": "2022-06-03 00:00:00 +0900", "snippet": "DirectX 정점 버퍼 (VertexBuffer) 3D 그래픽스에서 정점 버퍼(Vertex Buffer)는 3D 모델을 구성하는 기본 단위인 정점(Vertex)들의 정보를 저장하는 GPU 메모리 영역정점기본정의 공간상의 한 위치(좌표)를 나타냄. 정점들을 연결하여 선이나 면(주로 삼각형) 같은 기본 도형(Primitive)을 만들고, 이 도형들이 모여 3D 모델(메시, Mesh)의 형태를 이룸물리적 특성 위치 값만 가지며, 크기는 개념적으로 무시부가 정보 DirectX에서 사용되는 정점은 단순히 위치(x, y, z) 정보뿐만 아니라, 다음과 같은 다양한 부가 데이터를 가질 수 있음 색상 (Color): 정점별 색상 정보 (예: Vec4(R, G, B, A)) 텍스처 좌표 (Texture Coordinates): 모델 표면에 이미지를 입히기 위한 UV 좌표 선 벡터 (Normal Vector): 빛 계산을 통한 명암 표현에 사용되는 표면의 방향 정보정점 좌표계: NDC (Normalized Device Coordinates) Vertex Shader를 거친 정점들이 최종적으로 변환되는 2차원 좌표계범위 일반적으로 화면의 가로, 세로, 깊이 방향으로 -1.0에서 +1.0 사이의 값을 가짐 화면 중앙이 (0,0), 왼쪽 하단이 (-1,-1), 오른쪽 상단이 (1,1)인 2D 평면 좌표계 깊이 값 Z도 이 범위 내에 들어옴역할 3D 공간(View Space)의 모든 좌표는 투영(Projection) 변환을 통해 이 NDC 공간으로 사영장점 화면 해상도에 독립적인 좌표계를 사용하므로, 다양한 해상도에 쉽게 대응가능. 좌표 계산 과정을 단순화정점 버퍼 생성 및 사용에 필요한 주요 변수// 1. 정점 버퍼 객체// ID3D11Buffer: GPU 메모리에 생성된 버퍼를 관리하는 COM 인터페이스.// 정점 데이터, 인덱스 데이터, 상수 데이터 등 다양한 종류의 데이터를 저장할 수 있음ComPtr&lt;ID3D11Buffer&gt; g_pVB; // Vertex Buffer를 가리킬 포인터// 2. 셰이더 관련 객체// ID3DBlob: 컴파일된 셰이더 코드나 에러 메시지 같은 임의의 바이너리 데이터를 담는 객체.ComPtr&lt;ID3DBlob&gt; g_pErrBlob; // 셰이더 컴파일 시 에러 메시지를 저장할 Blob// Vertex Shader 객체ComPtr&lt;ID3DBlob&gt; g_pVSBlob; // 컴파일된 Vertex Shader 코드를 저장할 BlobComPtr&lt;ID3D11VertexShader&gt; g_pVS; // 실제 Vertex Shader 객체를 가리킬 포인터정점 버퍼(Vertex Buffer) 생성 단계1. 정점 데이터 정의 먼저 GPU로 보낼 정점 데이터를 CPU 메모리에 정의 예를 들어, 삼각형을 구성하는 3개의 정점 데이터는 다음과 같이 정의// 사용자 정의 Vertex 구조체 (예시)struct Vertex{ Vec3 vPos; // 정점의 위치 (x, y, z) Vec4 vColor; // 정점의 색상 (R, G, B, A)};Vertex arrVtx[3] = {};// 각 정점의 위치(NDC 좌표 사용 예시)와 색상 설정arrVtx[0].vPos = Vec3(0.0f, 0.5f, 0.0f); // 삼각형의 위쪽 꼭짓점arrVtx[0].vColor = Vec4(1.f, 0.f, 0.f, 1.f); // 빨간색arrVtx[1].vPos = Vec3(0.5f, -0.5f, 0.0f); // 오른쪽 아래 꼭짓점arrVtx[1].vColor = Vec4(0.f, 1.f, 0.f, 1.f); // 녹색arrVtx[2].vPos = Vec3(-0.5f, -0.5f, 0.0f); // 왼쪽 아래 꼭짓점arrVtx[2].vColor = Vec4(0.f, 0.f, 1.f, 1.f); // 파란색2. 버퍼 설정 (D3D11_BUFFER_DESC) GPU에 생성할 버퍼의 특성을 정의D3D11_BUFFER_DESC tBufferDesc = {};// 버퍼의 총 크기 (바이트 단위)tBufferDesc.ByteWidth = sizeof(Vertex) * 3; // Vertex 구조체 크기 * 정점 개수// 버퍼의 용도 및 CPU 접근 권한 설정// D3D11_USAGE_DYNAMIC: CPU에서 쓰고 GPU에서 읽는 동적 버퍼. CPU에서 자주 업데이트할 경우 사용.// D3D11_CPU_ACCESS_WRITE: CPU에서 버퍼에 쓸 수 있도록 허용.tBufferDesc.Usage = D3D11_USAGE_DYNAMIC;tBufferDesc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;// (참고: 정적 버퍼의 경우 D3D11_USAGE_DEFAULT, CPUAccessFlags = 0 이 일반적)// 바인딩 플래그: 버퍼가 파이프라인의 어느 단계에 바인딩될지 지정// D3D11_BIND_VERTEX_BUFFER: 이 버퍼가 정점 버퍼로 사용됨을 명시.tBufferDesc.BindFlags = D3D11_BIND_VERTEX_BUFFER;// 기타 플래그 (일반적인 정점 버퍼에는 0)tBufferDesc.MiscFlags = 0;tBufferDesc.StructureByteStride = 0; // 구조화된 버퍼가 아닐 경우 03. 초기 데이터 설정 (D3D11_SUBRESOURCE_DATA) 버퍼를 생성할 때 함께 채워 넣을 초기 데이터를 지정D3D11_SUBRESOURCE_DATA tSubDesc = {};tSubDesc.pSysMem = arrVtx; // CPU 메모리에 있는 정점 데이터 배열의 시작 주소// tSubDesc.SysMemPitch = 0; (텍스처가 아니므로 0)// tSubDesc.SysMemSlicePitch = 0; (3D 텍스처가 아니므로 0)4. 버퍼 생성 (CreateBuffer) Direct3D 디바이스의 CreateBuffer 함수를 호출하여 GPU 메모리에 정점 버퍼를 생성// DEVICE는 ID3D11Device* 타입의 디바이스 객체 포인터라고 가정HRESULT hr = DEVICE-&gt;CreateBuffer(&amp;tBufferDesc, &amp;tSubDesc, g_pVB.GetAddressOf());if (FAILED(hr)){ // 에러 처리 assert(nullptr);} 이제 g_pVB는 GPU에 생성된 정점 버퍼를 가리키게 됨Vertex Shader 생성 단계 정점 버퍼의 데이터를 GPU에서 처리하여 변환(예: 월드 변환, 뷰 변환, 투영 변환)하는 역할을 하는 것이 Vertex Shader HLSL(High Level Shader Language)로 작성된 셰이더 코드를 컴파일하고 객체로 만들어야 함 1. Vertex Shader 파일 컴파일 (D3DCompileFromFile) HLSL로 작성된 셰이더 파일(예: .fx 또는 .hlsl 파일)을 컴파일UINT iFlag = 0;#ifdef _DEBUG // 디버그 모드에서는 셰이더 디버깅 정보 포함 iFlag = D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION; // 최적화 건너뛰기 옵션도 추가 가능#endif// 셰이더 파일 경로 (예시)wstring strShaderFilePath = CPathMgr::GetInst()-&gt;GetContentPath() + L\"shader\\\\test.fx\";// D3DCompileFromFile 함수를 사용하여 셰이더 파일 컴파일HRESULT hr = D3DCompileFromFile( strShaderFilePath.c_str(), // 셰이더 파일 경로 nullptr, // 매크로 정의 (없으면 nullptr) D3D_COMPILE_STANDARD_FILE_INCLUDE, // 표준 인클루드 처리기 사용 \"VS_Test\", // 컴파일할 셰이더 함수의 이름 (HLSL 코드 내 함수명) \"vs_5_0\", // 셰이더 모델 버전 (Vertex Shader Model 5.0) iFlag, // 컴파일 플래그 (디버그 등) 0, // 효과 컴파일 플래그 (일반 셰이더는 0) g_pVSBlob.GetAddressOf(), // 컴파일된 셰이더 코드를 받을 Blob 객체의 주소 g_pErrBlob.GetAddressOf() // 에러 발생 시 메시지를 받을 Blob 객체의 주소);// 컴파일 실패 시 에러 메시지 출력if (FAILED(hr)){ if (g_pErrBlob) // 에러 Blob이 유효한지 확인 { MessageBoxA(nullptr, (char*)g_pErrBlob-&gt;GetBufferPointer(), \"Vertex Shader Compile Failed!!\", MB_OK); } assert(nullptr); // 또는 다른 방식으로 에러 처리}2. Vertex Shader 객체 생성 (CreateVertexShader) 성공적으로 컴파일된 셰이더 코드(Blob)를 이용하여 실제 Vertex Shader 객체를 생성// DEVICE는 ID3D11Device* 타입의 디바이스 객체 포인터라고 가정hr = DEVICE-&gt;CreateVertexShader( g_pVSBlob-&gt;GetBufferPointer(), // 컴파일된 셰이더 코드 데이터의 시작 주소 g_pVSBlob-&gt;GetBufferSize(), // 컴파일된 셰이더 코드의 크기 nullptr, // 클래스 연결 정보 (일반적으로 nullptr) g_pVS.GetAddressOf() // 생성된 Vertex Shader 객체를 받을 포인터의 주소);if (FAILED(hr)){ // 에러 처리 assert(nullptr);} 이제 g_pVS는 렌더링 파이프라인에 설정하여 사용할 수 있는 Vertex Shader 객체를 가리키게 됩니다. 이 셰이더는 g_pVB에 담긴 정점들을 입력으로 받아 처리하게 됨" }, { "title": "BubbleSort", "url": "/posts/BubbleSort/", "categories": "자료구조, Sort", "tags": "data_structure", "date": "2022-06-02 00:00:00 +0900", "snippet": "버블정렬 인접한 원소를 두 개 비교하여 자리를 교환하는 방식을 반복하면서 정렬 가장 큰 원소가 마지막 자리에 정렬된다 시간복잡도는(n²)버블정렬 Codevoid swap(int* a, int* b){\tint tmp = *a;\t*a = *b;\t*b = tmp;}int main(){\tsrand((unsigned int)time(NULL));\tint iArr[MAX];\tfor (int i = 0; i &lt; MAX; ++i)\t{\t\tiArr[i] = rand() % MAX;\t}\t// 버블 정렬\tfor (int i = MAX - 1; i &gt; 0; --i)\t{\t\tfor (int j = 0; j &lt; i ; ++j)\t\t{\t\t\tif (iArr[j] &gt; iArr[j + 1])\t\t\t{\t\t\t\tswap(&amp;iArr[j], &amp;iArr[j + 1]);\t\t\t}\t\t}\t\t}for (int i = 0; i &lt; MAX; ++i){\tcout &lt;&lt; iArr[i] &lt;&lt; endl;}}" }, { "title": "SwapChain", "url": "/posts/SwapChain/", "categories": "DirectX", "tags": "directx", "date": "2022-06-01 00:00:00 +0900", "snippet": "DirectX 스왑 체인 (SwapChain) DirectX에서 스왑 체인(SwapChain)은 부드러운 화면 출력을 위한 핵심 기술* 기본적으로 두 개의 버퍼, 즉 프론트 버퍼(Front Buffer)와 백 버퍼(Back Buffer)를 사용 프론트 버퍼: 현재 모니터에 보여지고 있는 화면 백 버퍼: 다음 화면에 보여질 내용을 그리는 작업 공간 렌더링 과정 애플리케이션은 백 버퍼에 다음 프레임의 이미지를 그림 그림이 완성되면, Present() 함수를 호출 Present() 함수는 프론트 버퍼와 백 버퍼를 서로 교체(swap) 즉, 그림이 완성된 기존의 백 버퍼가 새로운 프론트 버퍼가 되어 화면에 표시되고, 기존의 프론트 버퍼는 새로운 백 버퍼가 되어 다음 그림을 그릴 준비 이러한 더블 버퍼링(Double Buffering) 방식을 통해, 화면에 그림이 그려지는 중간 과정을 사용자가 보지 않게 되어 화면 깜빡임(flickering) 없이 부드러운 애니메이션을 구현스왑 체인 설정 코드 (DXGI_SWAP_CHAIN_DESC)DXGI_SWAP_CHAIN_DESC desc = {}; // 스왑 체인 설정을 위한 구조체 초기화// 버퍼 설정desc.BufferCount = 1; // 일반적으로 1을 설정하면 DirectX가 프론트 버퍼와 백 버퍼를 자동으로 관리합니다. // (실제로는 백 버퍼의 개수를 의미하며, 프론트 버퍼는 항상 하나입니다)desc.BufferDesc.Width = (UINT)m_vRenderResolution.x; // 생성될 버퍼의 가로 해상도desc.BufferDesc.Height = (UINT)m_vRenderResolution.y; // 생성될 버퍼의 세로 해상도desc.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM; // 픽셀 포맷 (예: RGBA 각 채널당 8비트, 총 32비트)// 화면 주사율 (Refresh Rate) 설정// 모니터가 1초에 화면을 업데이트하는 횟수입니다. (예: 60/1 = 60Hz)desc.BufferDesc.RefreshRate.Denominator = 1; // 분모desc.BufferDesc.RefreshRate.Numerator = 60; // 분자// 기타 버퍼 설정desc.BufferDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED; // 스케일링 방식 (기본값)desc.BufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED; // 스캔라인 순서 (기본값)// 스왑 체인 동작 설정desc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT; // 버퍼가 렌더 타겟으로 사용됨을 명시desc.OutputWindow = m_hWnd; // 렌더링 결과를 출력할 윈도우 핸들desc.Windowed = true; // 창 모드 여부 (true: 창 모드, false: 전체 화면 모드)desc.SwapEffect = DXGI_SWAP_EFFECT_DISCARD; // 버퍼 교체 후 이전 프론트 버퍼의 내용을 버림 (가장 일반적)desc.Flags = 0; // 추가 옵션 (기본값 없음)// 멀티샘플링(MSAA) 설정 (일반적으로 기본값 사용)desc.SampleDesc.Count = 1; // 멀티샘플링 개수desc.SampleDesc.Quality = 0; // 멀티샘플링 품질desc.OutputWindow= m_hWnd; // 출력하려는 목적지 윈도우desc.Windowed = true; // 창모드거나 전체화면 (true면 창,false면 전체화면) BufferCount: 백 버퍼의 개수입니다. 1로 설정하면 프론트 버퍼 1개, 백 버퍼 1개로 구성된 기본적인 더블 버퍼링 환경이 만들어집니다. 더 많은 값을 설정하여 트리플 버퍼링 등을 구현할 수도 있음 BufferDesc.Format: 버퍼가 저장할 픽셀 데이터의 형식입니다. DXGI_FORMAT_R8G8B8A8_UNORM은 각 채널(Red, Green, Blue, Alpha)당 8비트를 사용하고, 0~1 사이의 값으로 정규화됨을 의미 BufferUsage : 버퍼의 주된 용도를 나타냅니다. DXGI_USAGE_RENDER_TARGET_OUTPUT은 이 버퍼가 렌더링 결과물이 저장될 대상임을 의미 SwapEffect : Present() 호출 후 백 버퍼의 내용 처리 방법을 지정 DXGI_SWAP_EFFECT_DISCARD: 가장 효율적인 옵션 중 하나로, 버퍼 교체 후 이전 프론트 버퍼(현재는 백 버퍼가 된)의 내용을 신경 쓰지 않고 버림 DXGI_SWAP_EFFECT_SEQUENTIAL: 버퍼 내용을 유지하며 순차적으로 사용 (플립 모델에서 주로 사용) DXGI_SWAP_EFFECT_FLIP_SEQUENTIAL / DXGI_SWAP_EFFECT_FLIP_DISCARD: 최신 DirectX에서 권장되는 플립 모델 효과입니다. 성능상 이점이 많음 스왑 체인 생성 과정 스왑 체인을 실제로 생성하려면 몇 가지 DXGI 인터페이스를 통해야 함 IDXGIDevice 가져오기: 현재 사용 중인 Direct3D 디바이스(m_pDevice)에서 QueryInterface를 통해 IDXGIDevice 인터페이스를 얻기, 이는 DXGI 기능을 사용하기 위한 디바이스 표현 IDXGIAdapter 가져오기: IDXGIDevice에서 GetParent를 호출하여 디바이스가 실행 중인 그래픽 어댑터(실제 그래픽 카드)를 나타내는 IDXGIAdapter 인터페이스를 얻기 IDXGIFactory 가져오기: IDXGIAdapter에서 다시 GetParent를 호출하여 DXGI 객체(스왑 체인, 어댑터 등)를 생성하는 데 사용되는 IDXGIFactory 인터페이스를 얻기 CreateSwapChain 호출: IDXGIFactory 인터페이스의 CreateSwapChain 함수를 호출하여 최종적으로 스왑 체인을 생성. 이때 Direct3D 디바이스, 앞에서 설정한 DXGI_SWAP_CHAIN_DESC 구조체, 그리고 생성된 스왑 체인을 받을 포인터를 인자로 전달 // 스왑 체인 생성을 위한 DXGI 인터페이스 포인터ComPtr&lt;IDXGIDevice&gt; pDXGIDevice = nullptr;ComPtr&lt;IDXGIAdapter&gt; pDXGIAdaptor = nullptr;ComPtr&lt;IDXGIFactory&gt; pDXGIFactory = nullptr;// 1. Direct3D 디바이스에서 IDXGIDevice 인터페이스 얻기m_pDevice-&gt;QueryInterface(__uuidof(IDXGIDevice), (void**)pDXGIDevice.GetAddressOf());// 2. IDXGIDevice에서 부모인 IDXGIAdapter 인터페이스 얻기pDXGIDevice-&gt;GetParent(__uuidof(IDXGIAdapter), (void**)pDXGIAdaptor.GetAddressOf());// 3. IDXGIAdapter에서 부모인 IDXGIFactory 인터페이스 얻기pDXGIAdaptor-&gt;GetParent(__uuidof(IDXGIFactory), (void**)pDXGIFactory.GetAddressOf());// 4. IDXGIFactory를 사용하여 스왑 체인 생성pDXGIFactory-&gt;CreateSwapChain( m_pDevice.Get(), // 스왑 체인을 사용할 Direct3D 디바이스 &amp;desc, // 위에서 설정한 스왑 체인 설정 구조체 주소 m_pSwapChain.GetAddressOf() // 생성된 스왑 체인 인터페이스를 받을 포인터의 주소);" }, { "title": "LinkedList", "url": "/posts/LinkedList/", "categories": "자료구조, LinkedList", "tags": "data_structure", "date": "2022-05-31 00:00:00 +0900", "snippet": "LinkedList LinkedList 선형 리스트중 하나로 노드가 데이터와 포인터를 가지고 한 줄로 연결되어 있는 방식으로 데이터를 저장하는 자료 구조 구조체(노드)와 포인터를 이용하여 각 구조체를 연결하여 사용 함수 init Head와 Tail을 초기화하고 Count를 하나 증가 push_back List가 비어있다면 추가한 노드가 Head이자 Tail List가 비어있지 않다면 TailNode뒤에 연결하고 연결한 노드를 TailNode로 설정 push_front List가 비어있다면 추가한 노드가 Head이자 Tail List가 비어있지 않다면 먼저 새로운 노드에 Head를 붙이고 그후 연결한 노드를 HeadNode로 설정 pop_back List가 비어있다면 assert List가 하나였다면 그 노드(Head이자Tail)를 메모리 해제(free) Head부터 TailNode의 이전노드까지 탐색하고 TailNode를 찾아내서 메모리 해제한후 이전노드의 다음노드를 가리키는 포인터에 nullptr pop_front List가 비어있다면 assert List가 하나였다면 그 노드(Head이자Tail)를 메모리 해제(free) 삭제하기 전에 삭제할 노드(맨앞)의 다음 노드를 Head로 바꾸고 맨앞 노드를 삭제 release 모든 노드 메모리 해제 show 모든 노드의 데이터 출력 LinkedList.h#pragma oncestruct INode {\tint iData;\t\t\t\t// int 데이터를 받는 변수\tINode* NextNode;\t\t// 다음 노드를 연결해줄 변수};struct IList{\tINode* HeadNode;\t\t// List의 첫노드를 가르키는 변수\tINode* TailNode;\t\t// List의 마지막노드를 가르키는 변수\tint CurCount;\t\t\t// 현재 데이터 갯수};void Init(IList* _List);void push_back(IList* _List,int _iData); // 가장 뒤에 노드를 추가하는 함수void push_front(IList* _List, int _iData); // 가장 앞에 노드를 추가하는 함수void pop_back(IList* _List); //가장 뒤의 노드를 삭제하는 함수void pop_front(IList* _List); //가장 앞의 노드를 삭제하는 함수void release(IList* _List); //메모리 해제void show(IList* _List);LinkedList.cppvoid Init(IList* _List){\t_List-&gt;CurCount = 0;\t_List-&gt;HeadNode = nullptr;\t_List-&gt;TailNode = nullptr;}void push_back(IList* _List, int _iData){\t// 연결할 노드 동적할당하고 초기화\tINode* NewNode =(INode*)malloc(sizeof(INode));\tNewNode-&gt;iData = _iData;\tNewNode-&gt;NextNode = nullptr;\tif (nullptr == _List-&gt;HeadNode)\t\t\t\t// 만약 List안이 비어있다면\t{\t\t_List-&gt;HeadNode = NewNode;\t\t\t\t\t\t_List-&gt;TailNode = NewNode;\t}\telse\t{\t\t//TailNode의 뒤에 Newnode를 연결\t\t_List-&gt;TailNode-&gt;NextNode = NewNode;\t\t//TailNode 갱신\t\t_List-&gt;TailNode = NewNode;\t}\t++_List-&gt;CurCount; // 데이터가 추가됐으므로 현재 데이터 개수 하나증가}void push_front(IList* _List, int _iData){\tINode* NewNode = (INode*)malloc(sizeof(INode));\tNewNode-&gt;iData = _iData;\tif (nullptr == _List-&gt;HeadNode)\t{\t\t_List-&gt;HeadNode = NewNode;\t\t_List-&gt;TailNode = NewNode;\t}\telse\t{\t\t// HeadNode에 NewNode를 먼저 연결할 경우 기존에 있었던 HeadNode-&gt;NextNode의 연결점이 사라지므로\t\t// 먼저 NewNode의 Nextnode에 기존에 있는 HeadNode-&gt;NextNode의 연결을 먼저해준다 \t\tNewNode-&gt;NextNode = _List-&gt;HeadNode;\t\t_List-&gt;HeadNode = NewNode;\t}\t++_List-&gt;CurCount;}void pop_back(IList* _List){\t// 만약 List가 비어있다면 _List-&gt;HeadNode가 nullptr이므로 에러발생\tassert(_List-&gt;HeadNode);\t//이전노드의 nextnode를 nullptr까지 만들어주어야하므로 이전노드를 구함.\t//삭제할 노드의 이전노드 카운팅\tint Prev = _List-&gt;CurCount - 1;\t\t// Prev가 0이면 데이터가 하나라는 뜻\tif (Prev==0)\t{\t\tfree(_List-&gt;HeadNode);\t\t_List-&gt;HeadNode = nullptr;\t\t_List-&gt;TailNode = nullptr;\t}\telse\t{\t\tINode* TmpNode = _List-&gt;HeadNode;\t\twhile (1)\t\t{\t\t\t//TailNode의 이전노드까지 이동\t\t\tif (TmpNode-&gt;NextNode == _List-&gt;TailNode)\t\t\t{\t\t\t\tbreak;\t\t\t}\t\t\tTmpNode = TmpNode-&gt;NextNode;\t\t}\t//기존 TailNode는 free하고 TailNode의 이전노드를 Tailnode로 만들면서 NextNode가 없어졌으므로 nullptr를 넣어준다.\t\tTmpNode-&gt;NextNode = nullptr;\t\tfree(_List-&gt;TailNode);\t\t_List-&gt;TailNode = TmpNode;\t}\t--_List-&gt;CurCount;}void pop_front(IList* _List){\tassert(_List-&gt;HeadNode); \t\tint Prev = _List-&gt;CurCount - 1;\tif (Prev == 0)\t{\t\tfree(_List-&gt;HeadNode);\t\t_List-&gt;HeadNode = nullptr;\t\t_List-&gt;TailNode = nullptr;\t}\telse\t{\t\t//맨앞의 삭제할 노드를 받는 Node\t\tINode* Node = _List-&gt;HeadNode;\t\t//삭제하기전에 미리 Head에 삭제할 노드의 다음 노드 연결\t\t_List-&gt;HeadNode = Node-&gt;NextNode;\t\t//삭제하기전에 다음주소를 nullptr\t\tNode-&gt;NextNode = nullptr;\t\t//삭제할노드를 받은 Node 삭제\t\tfree(Node);\t}\t--_List-&gt;CurCount;}void release(IList* _List){\tINode* Node = _List-&gt;HeadNode;\tfor (int i = 0; i &lt; _List-&gt;CurCount; ++i)\t{\t\tINode* NextNode = Node-&gt;NextNode;\t\tfree(Node);\t\tNode = NextNode;\t}}void show(IList* _List){\tINode* Node = _List-&gt;HeadNode;\tfor (int i = 0; i &lt; _List-&gt;CurCount; i++)\t{\t\tcout &lt;&lt; Node-&gt;iData &lt;&lt; endl;\t\tNode = Node-&gt;NextNode;\t}}" }, { "title": "Device", "url": "/posts/Device/", "categories": "DirectX", "tags": "directx", "date": "2022-05-30 00:00:00 +0900", "snippet": "DirectX 디바이스 (Device) DirectX를 사용하여 그래픽을 렌더링하려면, 하드웨어인 그래픽 카드(또는 어댑터)와 통신하고 제어할 수 있는 소프트웨어적인 매개체가 필요 이 핵심적인 소프트웨어 객체를 디바이스(Device)라고 부름 그래픽 카드 추상화: 디바이스는 복잡한 그래픽 하드웨어를 프로그래머가 좀 더 쉽게 다룰 수 있도록 추상화한 인터페이스 DirectX 사용의 필수 요소: DirectX 애플리케이션은 최소 하나 이상의 디바이스를 가져야 하며, 대부분의 경우 하나의 디바이스만 생성하여 사용 주요 인터페이스: ID3D11Device 와 ID3D11DeviceContext Direct3D 11에서는 디바이스의 역할이 두 가지 주요 인터페이스로 나뉨ID3D11Device역할 GPU 메모리 관리 및 리소스 생성 담당주요 기능 셰이더 프로그램 객체(Vertex Shader, Pixel Shader 등), 텍스처, 버퍼(정점 버퍼, 인덱스 버퍼, 상수 버퍼 등)와 같은 GPU 리소스(자원)를 생성 디스플레이 어댑터(그래픽 카드)의 다양한 기능(지원하는 포맷, 멀티샘플링 레벨 등)을 확인 상태 객체(래스터라이저 상태, 블렌드 상태 등) 및 질의(Query) 객체를 생성 ID3D11DeviceContext (주로 즉시 컨텍스트, Immediate Context)역할 GPU 렌더링 파이프라인 제어 및 렌더링 명령 실행 담당주요 기능 ID3D11Device가 생성하고 소유한 리소스를 사용하여 렌더링 파이프라인의 상태를 설정 (예: 어떤 셰이더를 사용할지, 어떤 버퍼를 입력으로 쓸지, 뷰포트는 어디로 설정할지 등) 실제 그리기(Draw) 명령을 생성하여 GPU에 전달 리소스 데이터를 업데이트하고 복사하는 등의 작업을 수행디바이스 생성 과정 (D3D11CreateDevice 함수)1. 준비 사항ComPtr&lt;ID3D11Device&gt; m_pDevice; // ID3D11Device 인터페이스를 받을 스마트 포인터ComPtr&lt;ID3D11DeviceContext&gt; m_pDeviceContext; // ID3D11DeviceContext 인터페이스를 받을 스마트 포인터UINT iFlag = 0; // 생성 플래그#ifdef _DEBUG // 디버그 빌드에서는 디버그 레이어를 활성화하여 오류 추적 용이 // (성능 저하가 있으므로 릴리스 빌드에서는 제외) iFlag |= D3D11_CREATE_DEVICE_DEBUG;#endif// 요청할 Direct3D 기능 수준 (Feature Level)// D3D_FEATURE_LEVEL_11_0 은 DirectX 11.0 기능을 사용하겠다는 의미D3D_FEATURE_LEVEL eFeatureLevel = D3D_FEATURE_LEVEL_11_0;2. D3D11CreateDevice 함수 호출HRESULT hr = D3D11CreateDevice( nullptr, // pAdapter: 사용할 그래픽 어댑터 포인터 (nullptr이면 기본 어댑터 사용) D3D_DRIVER_TYPE_HARDWARE, // DriverType: 하드웨어 드라이버 사용 (GPU 가속) // (D3D_DRIVER_TYPE_SOFTWARE는 CPU 사용) 0, // Software: 소프트웨어 래스터라이저 DLL 핸들 (하드웨어 사용 시 0) iFlag, // Flags: 생성 플래그 (예: D3D11_CREATE_DEVICE_DEBUG) &amp;eFeatureLevel, // pFeatureLevels: 요청할 기능 수준 배열 (여기서는 단일 값 주소 전달) 1, // FeatureLevels: 요청할 기능 수준 배열의 크기 (단일 값이므로 1) D3D11_SDK_VERSION, // SDKVersion: 항상 D3D11_SDK_VERSION 사용 m_pDevice.GetAddressOf(), // ppDevice: 생성된 ID3D11Device 인터페이스를 받을 포인터의 주소 &amp;eFeatureLevel, // pFeatureLevel_out: 실제로 지원되는 기능 수준을 받을 변수의 주소 (여기서는 입력과 동일 변수 사용) m_pDeviceContext.GetAddressOf()// ppImmediateContext: 생성된 ID3D11DeviceContext 인터페이스를 받을 포인터의 주소);// 생성 성공 여부 확인if (FAILED(hr)){ MessageBox(nullptr, L\"Direct3D Device 초기화 실패\", L\"초기화 에러\", MB_OK); // 적절한 에러 처리 (예: 프로그램 종료) return E_FAIL;} m_pDevice.GetAddressOf()와 m_pDeviceContext.GetAddressOf()는 ComPtr 스마트 포인터가 내부적으로 관리하는 인터페이스 포인터의 주소를 가져오는 함수. D3D11CreateDevice는 이 주소에 생성된 객체의 포인터를 기록 Feature Levels: pFeatureLevels 매개변수에 원하는 기능 수준들의 배열을 우선순위대로 전달 위 예제에서는 단일 값 D3D_FEATURE_LEVEL_11_0을 시도하도록 설정. D3D11CreateDevice는 이 중에서 하드웨어가 지원하는 가장 높은 기능 수준으로 디바이스를 생성하고, 그 결과를 9번째 인자인 pFeatureLevel_out에 반환 D3D11CreateDevice 함수 매개변수 상세HRESULT D3D11CreateDevice( [in, optional] IDXGIAdapter *pAdapter, // 특정 그래픽 어댑터 지정 (nullptr: 기본값) D3D_DRIVER_TYPE DriverType, // 드라이버 유형 (하드웨어, 소프트웨어, WARP 등) HMODULE Software, // 소프트웨어 드라이버 DLL 핸들 (DriverType이 소프트웨어일 때) UINT Flags, // 생성 플래그 (예: 디버그) [in, optional] const D3D_FEATURE_LEVEL *pFeatureLevels, // 지원을 시도할 기능 수준 배열 UINT FeatureLevels, // 위 배열의 요소 개수 UINT SDKVersion, // 항상 D3D11_SDK_VERSION [out, optional] ID3D11Device **ppDevice, // 생성된 디바이스 인터페이스 포인터 반환 [out, optional] D3D_FEATURE_LEVEL *pFeatureLevel, // 실제로 선택된 기능 수준 반환 [out, optional] ID3D11DeviceContext **ppImmediateContext // 생성된 즉시 컨텍스트 인터페이스 포인터 반환);" }, { "title": "유니코드", "url": "/posts/%EC%9C%A0%EB%8B%88%EC%BD%94%EB%93%9C/", "categories": "윈도우즈시스템프로그래밍, 운영체제", "tags": "windows", "date": "2022-05-29 00:00:00 +0900", "snippet": "아스키코드와 유니코드 아스키코드 미국에서 정의하고 있는 알파벳과 기호를 이용한 표준 아스키코드는 1Byte로 표현 유니코드 영어가 아닌 다른 국가에서 사용하는 문자를 표현하기 위한 표준 유니코드는 2Byte로 표현 문자셋(Character Set)의 종류와 특성 문자셋(Character Set) 문자들의 집합,약속된 문자의 표현방법을 의미 SBCS(Single Byte Character Set) 문자를 표현하는 데 있어서 1바이트만을 사용하는 방식 아스키코드가 대표적인 SBCS MBCS(Multi Byte Character Set) 다양한 바이트 수를 사용해서 문자를 표현하는 방식( 1Byte or 2Byte ) 아스키 코드에서 정의하고 있는 문자는 1Byte, 정의하지 않는 문자는 2Byte WBCS(Wide Byte Character Set) 모든 문자를 2바이트로 처리하는 문자셋 유니코드가 대표적인 WBCS MBCS 기반의 문자열예제1int main(){ char str[] = \"ABC한글\"; int size = sizeof(str); int len = strlen(str); printf(\"배열의 크기 : %d\\n \" size); pritnf(\"문자열 길이 : %d\\n \" len); return 0;}[실행결과]배열의 크기 : 8 ABC(3Byte) + 한글(4Byte) + NULL(1Byte) = 8Byte문자열 길이 : 7 ABC(3Byte) + 한글(4Byte) = 7Byte예제2int main(){ char str[] = \"한글입니다\"; int i; for(i=0; i&lt;5; i++) fputc(str[i],stdout); fputc(\"\\n\",stdout); for(i=0; i&lt;5; i++) fputc(str[i],stdout); return 0;}[실행결과]한글한글입니다 MBCS의 문제점 예제1에서 “ABC한글” 총 5글자 이지만 한글의 길이가 4로 인식되고 있다. 예제2에서 한글 길이는 5이지만 10번 호출해야 정상적인 출력이 이뤄진다. 이러한 MBCS의 문제점을 해결하기 위해 모든 문자열을 2Byte로 하는 WBCS기반으로 프로그래밍을 한다.WBCS 기반의 프로그래밍 char을 대신 wchar_t를 사용 char은 1바이트 메모리 공간만 할당하고, wchar_t는 2바이트 메모리 공간을 할당한다 문자열의 선언 ex) wchar_t str[] = “ABC” “ABC”는 MBCS 기반의 문자열이기 때문에 L”ABC”의 형태로 바꿔줘야 문제가 발생하지 않는다. wchar_t str[] = L”ABC” 가 맞는 표현 문자열 앞의 L은 문자열을 유니코드 기반(WBCS 기반)으로 표현하는 의미 (NULL도 2Byte) SBCS함수 WBCS함수 설명 strlen size_t wcslen(const wchar_t* string); 문자열 길이 strcpy wchar_t* wcscpy(wchar_t* dest, const wchar_t* src); 문자열 복사 strncpy wchar_t* wcsncpy(wchar_t* dest, const wchar_t* src , size_t cnt); cnt만큼 문자열 복사 strcat wchar_t* wcscat(wchar_t* dest, const wchar_t* src); 문자열 이어붙이기 strncat wchar_t* wcsncat(wchar_t* dest, const wchar_t* src , size_t cnt); cnt만큼 문자열 이어붙이기 strcmp int wcscmp(const wchar_t* s1 ,const wchar_t* s2); 문자열비교 strncmp int wcsncmp(const wchar_t* s1 ,const wchar_t* s2 , size_t cnt); cnt만큼 문자열 비교 SBCS함수 WBCS함수 설명 printf int wpritnf(const wchar_t* format [,arguments]…); 출력 scanf int wscanf(const wchar_t* format [,arguments]…); 입력 fgets wchar_t* fgetws(wchar_t* string, int n ,FILE* stream); 출력 fputs int fputws(const wchar_t* string, FILE* stream); 입력 wmain 프로그램 실행시 전달되는 문자열을 유니코드 기반으로 구성하기 위한 main 함수 MBCS와 WBCS의 동시 지원 #include Windows 기반 프로그래밍을 하는데 있어서 필요한 헤더파일 typedef 키워드를 통해 몇몇 기본 자료형을 Windows 스타일의 새로운 이름으로 정의 기본자료형 Windows스타일 char CHAR wchar_t WCHAR CHAR* LPSTR CONST CHAR* LPCSTR WCHAR* LPWSTR CONST WCHAR* LPCWSTR MBCS와 WBCS(유니코드)를 동시에 지원하기 위한 매크로 이러한 매크로를 통해 기반에 맞게 유니코드기반 혹은 MBCS기반의 문자열로 만들수 있다.#ifdef UNICODE typedef WCHAR TCAHR; typedef LPWSTR LPTSTR; typedef LPCWSTR LPCTSTR;#else typedef CHAR TCAHR; typedef LPSTR LPTSTR; typedef LPCSTR LPCTSTR;#endif" }, { "title": "Queue", "url": "/posts/Queue/", "categories": "자료구조, Queue", "tags": "data_structure", "date": "2022-05-27 00:00:00 +0900", "snippet": "Queue Queue은 선입선출(LIFO)의 형태로 먼저 들어가면 먼저 나오는 구조함수 front Queue에서 삭제가 일어나는 곳 rear Queue에서 삽입이 일어나는 곳 enqueue front가 가리키는 곳에 데이터를 삽입 dequeue rear이 가리키는 곳의 데이터를 삭제 empty 만약, 큐가 비어있다면 true를 반환, 아니면 false full 만약, 큐가 차있다면 true를 반환, 아니면 false #include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;queue&gt;#define MAX_QUEUE_SIZE 5using namespace std;typedef struct {int front;int rear;int data[MAX_QUEUE_SIZE];}QueueType;void Init_Queue(QueueType* q){q-&gt;rear = -1;q-&gt;front = -1;}bool Is_Full(QueueType* q){if (q-&gt;rear == MAX_QUEUE_SIZE - 1)\treturn true;else\treturn false;}bool Is_Empty(QueueType* q){if (q-&gt;front == q-&gt;rear)\treturn 1;else\treturn 0;}void EnQueue(QueueType* q, int data){if (Is_Full(q)){\tprintf(\"포화상태\\n\");\treturn;}q-&gt;data[++(q-&gt;rear)] = data;}int DeQueue(QueueType* q, int data){if (Is_Empty(q)){\tprintf(\"공백상태\\n\");\treturn -1;}int item = q-&gt;data[++(q-&gt;front)];return item;}" }, { "title": "Stack", "url": "/posts/Stack/", "categories": "자료구조, Stack", "tags": "data_structure", "date": "2022-05-26 00:00:00 +0900", "snippet": "Stack 자료를 쌓아서 올려놓은 형태의 자료구조 Stack은 후입선출(LIFO)의 형태로 먼저 들어가면 가장 나중에 나오는 구조함수 Top 스택의 입출력이 이루어지는 부분(가장 맨위) Push Top에 데이터를 집어넣음 Pop Top이 가리키고 있는 데이터를 꺼냄 empty 만약,스택이 비어있다면 true를 반환, 아니면 false full 만약, 스택안의 개수가 스택의 사이즈와 같다면 true를 반환, 아니면 false //#include &lt;stack&gt;//stack&lt;int&gt; stack; // 위와같은 stack 헤더파일로 사용가능함.#include&lt;stdio.h&gt;#define MAX_STACK_SIZE 100int stack[MAX_STACK_SIZE];int top=-1;int IsEmpty(){if(top&lt;0)\treturn true;else\treturn false;}int IsFull(){if(top&gt;=MAX_STACK_SIZE-1)\treturn true;else\treturn false;}void push(int value){if(IsFull()==true)\tprintf(\"스택이 가득 찼습니다.\");else\tstack[++top]=value; }int pop(){if(IsEmpty()==true)\tprintf(\"스택이 비었습니다.\");else \treturn stack[top--];}" }, { "title": "컴퓨터 구조에 대한 첫번 째 이야기", "url": "/posts/%EC%BB%B4%ED%93%A8%ED%84%B0-%EA%B5%AC%EC%A1%B0%EC%97%90-%EB%8C%80%ED%95%9C-%EC%B2%AB%EB%B2%88-%EC%A7%B8-%EC%9D%B4%EC%95%BC%EA%B8%B0/", "categories": "윈도우즈시스템프로그래밍, 운영체제", "tags": "windows", "date": "2022-05-25 00:00:00 +0900", "snippet": "컴퓨터 시스템의 주요 구성요소 컴퓨터 시스템을 구성하는 요소는 아래와 같다.컴퓨터 하드웨어의 구성 CPU 중앙처리장치로써, 기본적으로 연산을 담당한다. CPU의 내부에는 위 그림과 같이 ALU , 컨트롤유닛 , 버스인터페이스 , 레지스터가 있다. 메인메모리 램이라고도 부르는 메인메모리는 컴파일이 완료된 프로그램 코드가 올라가서 실행되는 영역이다 입출력 버스 입출력버스는 컴퓨터를 구성하는 구성요소 사이에서 데이터를 주고받기 위해 사용되는 경로다. 데이터의 종류와 역할에 따라 여러가지 버스가 있다. CPU에 대한 이해위의 그림과 같이 CPU 안에 여러가지 요소가 있다. ALU ALU는 CPU 내부에서 실제 연산을 담당하는 블록이다. ALU가 처리하는 기본적인 연산은 크게 두가지로 나뉜다 1.덧셈이나 뺄셈과 같은 산술연산 2.AND나 OR과 같은 논리연산 컨트롤유닛 CPU가 처리해야할 명령어들을 해석하고 해석된 결과에 따라 적절한 신호를 CPU의 다른블록에 전송한다. 레지스터 CPU안의 아주 작은 메모리 CPU 내부에 여러개가 존재하며 CPU의 종류에 따라 개수와 형태가 다양하다. 버스 인터페이스 컴퓨터의 여러부품들끼리 데이터를 동작하면서 주고받는데 그 매개체 역할을 해주는게 I/O 버스 CPU 내에 I/O 버스의 통신방식을 이해해서 매개체 역할을 하는 것이 버스 인터페이스 CPU 내부에 (레지스터에)저장돼 있는 데이터를 I/O버스에 송수신을 한다. 클럭 신호 메모리와 CPU의 속도 차이로 인해서 이를 맞춰주기 위해서이다. 클럭발생기에 의해 발생되는 클럭 신호는 CPU를 구성하는 요소 요소에 제공되며, 이 신호에 맞춰 CPU가 일을 한다. 만약 입/출력장치의 속도가 다르다고 할 때 입력보다 출력이 빨라 입력전에 있던 값을 출력하는 경우가 발생 프로그램 실행과정 단계 1 : 전처리기에 의한 치환작업 #include,#define과 같이 #으로 시작하는 지시자의 지시에 따라서 소스코드를 적절히 변경 단계 2 : 컴파일러에 의한 번역 컴파일러에 의해서 어셈블리 코드로 번역된다. 어셈블리 코드란 CPU가 디자인될 때 CPU에게 일을 시키기 위한 명령어도 같이 디자인되는데 이 명령어를 조합해서 만들어진 프로그램 코드를 의미한다. 단계 3 : 어셈블러에 의한 바이너리 코드 어셈블리코드를 바이너리코드(0과 1만으로 구성된 코드로)로 번역한다. 컴퓨터는 0과 1만으로 이해하기 떄문. 단계 4 : 링커에 의한 연결과 결합 프로그램 내에서 참조하는 함수나 라이브러리들을 하나로 묶는 작업 이 과정이 끝나면 실제로 실행 가능한 실행파일이 생성된다.(바이너리코드로 구성된 실행파일) 이렇게 만들어진 최종 실행파일은 컴퓨터에게 일을 시키기 위한 명령어가 들어가 있고메모리 공간에 올라가고 난 다음 CPU에 의해서 실행된다.이 밑에는 메모리 공간에 올라가고 나서의 과정이다. 단계 1 : Fetch 메모리상에 존재하는 명령어를 CPU로 가져오는 작업이다. 단계 2 : Decode 가져다 놓은 명령어를 CPU가 해석하는 단계이다 단계 3 : Execution 해석된 명령어의 명령대로 CPU가 실행되는 단계 하드웨어 구성의 재접근 명령어 실행을 위해서 제일 먼저 하는일이 Fetch인데 어떠한 이동 경로를 통해서 명령어의 Fetch가 진행되는가? 버스 시스템 명령어를 CPU안에 가져다 놓을 때 어디에 저장하는가? 명령어를 저장하기위한 레지스터 CPU 안에 가져다 놓은 명령어는 Decode 단계에서 해석되는데, 이는 CPU 안에 존재하는 누구에 의해서 진행되는가? 컨트롤 유닛 마지막 단계인 Execution은 누구에 의해서 진행되는가? 명령어를 통해서 요구하는것은 형태가 다양하지만 산술 및 논리연산으로써는 ALU 버스 시스템 데이터를 이동하는데에 있어서 사용되는 전송 경로를 가리켜 버스시스템이라고 한다. 데이터의 종류에 따라서 어드레스버스, 데이터버스, 컨트롤 버스가 있다. 버스의 종류 데이터 버스 데이터를 이동하기 위해 필요한 버스,데이터란 명령어나 피연산자를 의미 어드레스 버스 주소값을 이동하기위한 버스 컨트롤 버스 CPU와 메모리가 서로 특별한 사인을 주고받는 용도로 사용되는 버스 CPU는 메모리부터 데이터를 받거나 메모리에 데이터를 저장하기도 하는데 이 때 주소나 값을 저장하거나 송/수신할때의 신호를 위해 사용한다. " } ]
