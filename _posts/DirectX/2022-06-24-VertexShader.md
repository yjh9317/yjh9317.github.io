---
title: Vertex Shader
date: 2022-06-24
categories: [DirectX, DirectX]
tags: [directx]		# TAG는 반드시 소문자로 이루어져야함!
---

# **Vertext Shader**

### **정의**

* Vertex마다 호출되는 프로그램

* Input Assembler(입력 조립기) 단계에서 정점 데이터가 기본 도형(삼각형 등)으로 조립된 후, 각 정점은 Vertex Shader로 전달되어 처리가 가능

*  Vertex Shader는 모든 개별 정점에 대해 한 번씩 호출되는 함수

* GPU에서 병렬로 실행되므로 매우 빠른 처리가 가능

## **1. 주요 역할**

* 입력된 정점 데이터에 다양한 연산을 적용하여 특수 효과를 구현, 대표적인 역할은 다음과 같음

### **변환 (Transformations)**

*  정점의 위치를 다양한 좌표 공간으로 변환

### **조명 (Lighting)**

* 정점 단위의 조명 계산을 수행하여 명암을 표현할 수 있다 (Per-Vertex Lighting).

### **텍스처 좌표 생성 및 변환**

* 텍스처 매핑을 위한 UV 좌표를 생성하거나 애니메이션을 위해 변형

### **스키닝 (Skinning)**

* 캐릭터 애니메이션을 위해 정점을 뼈(bone)의 움직임에 따라 변형

### **변위 매핑 (Displacement Mapping) 준비**

* 정점의 위치를 높이 맵 등을 사용하여 실제로 이동시키는 고급 기법의 일부를 담당할 수 있다 (주로 Tessellation 단계와 연계).

<br>

## 2. **변환 (Transformations) 과정**

* Vertex Shader의 가장 기본적인 역할 중 하나는 3D 모델의 정점들을 여러 좌표 공간을 거쳐 최종적으로 화면에 표시될 수 있는 형태로 변환하는 것

* 이 변환 과정은 일반적으로 다음과 같은 순서로 진행

  * 로컬 공간 (Local Space) → 월드 공간 (World Space) → 뷰 공간 (View Space) → 투영 공간 (Projection Space / Clip Space)

### **1. 로컬 공간 (Local Space / 모델 공간, Model Space)**

#### **정의**

* 로컬 공간은 3D 모델링 소프트웨어에서 아티스트가 모델을 제작할 때 사용하는 객체 고유의 좌표계
* 각 객체는 자신만의 원점(0,0,0)과 축을 가지며, 이 객체의 정점들은 이 로컬 공간을 기준으로 정의됨.

#### **특징**

* 모델의 피벗(pivot) 또는 중심점이 보통 로컬 공간의 원점이 됨
* 예를 들어, 사람 캐릭터 모델은 발바닥 사이를 (0,0,0)으로 하여 디자인될 수 있고, 자동차 모델은 차체 중앙 하단을 원점으로 가질 수 있습니다.

#### **HLSL 입력**

* Vertex Shader의 입력으로 들어오는 정점 위치 데이터(POSITION 시맨틱)는 이 로컬 공간 좌표입니다.

### **2. 월드 공간 (World Space) 과 월드 변환 (World Transformation)**

#### **정의**

* 월드 공간은 게임이나 3D 장면 내의 모든 객체들이 함께 배치되는 공통된 전역 좌표계입니다. 
  * 이 공간에는 하나의 원점과 기준 축이 존재합니다.
* 월드 변환은 로컬 공간에 정의된 각 객체를 월드 공간의 특정 위치, 방향, 크기로 배치하는 과정

#### **월드 행렬 (World Matrix)**

* 이 변환은 각 객체마다 고유한 월드 행렬을 로컬 공간 정점 좌표에 곱함으로써 이루어짐
* 월드 행렬은 일반적으로 이동(Translation), 회전(Rotation), 크기 조절(Scaling) 변환 행렬들의 조합으로 구성됩니다 (TRS 행렬).
  * 월드 좌표 = 로컬 좌표 × 월드 행렬

#### **결과**

* 모든 개별 객체들이 하나의 동일한 월드 공간 좌표계 위에 존재하게 되어 서로의 상대적인 위치와 상태를 가늠할 수 있게 됩니다

### **3. 뷰 공간 (View Space / 카메라 공간, Camera Space) 과 뷰 변환 (View Transformation)**

#### **정의**

* 뷰 공간은 카메라의 시점에서 장면을 바라보는 좌표계
* 이 공간에서는 일반적으로 카메라가 원점(0,0,0)에 위치하고, 카메라가 바라보는 방향이 특정 축(예: Z축)과 일치하도록 설정
* 뷰 변환은 월드 공간의 정점들을 이 카메라 기준의 뷰 공간으로 옮기는 과정

#### **뷰 행렬 (View Matrix)**

* 이 변환은 월드 공간 정점 좌표에 뷰 행렬을 곱함으로써 수행됩니다.
  * 뷰 공간 좌표 = 월드 좌표 × 뷰 행렬

#### **뷰 행렬 구하는 방법**

* 카메라도 월드 공간에 존재하는 하나의 객체로 생각할 수 있다. 
  * 즉, 카메라 자체도 월드 공간에서의 위치와 방향(회전)을 나타내는 변환 행렬(카메라의 월드 행렬)을 가짐

* 장면 전체를 카메라의 시점으로 옮기기 위해서는, 다른 모든 객체들을 카메라의 위치와 방향에 대해 상대적으로 변환해야 합니다. 
  * 이는 **카메라의 월드 행렬의 역행렬(Inverse Matrix)**을 사용하는 것과 같습니다.

* `이동`: 만약 카메라가 월드 공간에서 (cx, cy, cz) 위치에 있다면, 다른 객체들은 카메라를 기준으로 (-cx, -cy, -cz)만큼 이동한 것처럼 보여야 합니다.

* `회전`: 카메라가 특정 방향으로 회전했다면, 다른 객체들은 카메라를 기준으로 반대 방향으로 회전한 것처럼 보여야 합니다. (정확히는, 월드 공간의 축들이 카메라의 로컬 축에 정렬되도록 변환됩니다.)

* 결론적으로 `뷰 행렬 = 카메라 월드 행렬의 역행렬` 입니다.

* DirectX에서는 주로 카메라의 위치(Eye Position), 바라보는 지점(Look-At Target), 그리고 상단 방향 벡터(Up Vector)를 사용하여 뷰 행렬을 생성하는 헬퍼 함수(예: XMMatrixLookAtLH 또는 XMMatrixLookAtRH)를 사용

### **4. 투영 공간 (Projection Space / 클립 공간, Clip Space) 과 투영 변환 (Projection Transformation)**

#### **정의**

* 투영 변환은 3차원 뷰 공간의 장면을 2차원 화면에 표시하기 위한 준비 단계로, 시야 볼륨(Viewing Volume 또는 Frustum) 내의 정점들을 **클립 공간(Clip Space)**이라는 특수한 4차원 동차 좌표계로 변환

* 이 단계에서 시야 볼륨 바깥의 지오메트리는 클리핑(잘라내기) 대상으로 표시됩니다.

#### **투영 행렬 (Projection Matrix)**

* 이 변환은 뷰 공간 정점 좌표에 투영 행렬을 곱함으로써 수행됩니다.
  * 클립 공간 좌표 = 뷰 공간 좌표 × 투영 행렬

#### **투영 방식 1.원근 투영 (Perspective Projection)**

* 가장 일반적으로 사용되는 방식으로, 사람의 눈이나 카메라 렌즈처럼 가까이 있는 물체는 크게, 멀리 있는 물체는 작게 보이게 하여 깊이감과 원근감을 제공
* 시야 볼륨은 절두체(Frustum, 잘린 피라미드 모양) 형태를 가집니다.
* 생성 시 `시야각(Field of View, FOV)`, `화면 종횡비(Aspect Ratio)`, `근접 클리핑 평면(Near Clip Plane)`, `원거리 클리핑 평면(Far Clip Plane)` 등의 매개변수가 필요.

#### **투영 방식 2.직교 투영 (Orthographic Projection)**

* 물체의 깊이(거리)에 관계없이 모든 물체가 동일한 크기로 보이게 합니다. 원근감이 없다.
* 시야 볼륨은 직육면체 형태를 가집니다.
* 2D 게임, UI 요소, 건축 도면 또는 특정 스타일의 3D 게임에서 사용됩니다.
* 생성 시 시야 볼륨의 가로, 세로 크기 및 근접/원거리 클리핑 평면 매개변수가 필요합니다.

#### **클립 공간 이후 (하드웨어 처리)**

* Vertex Shader의 최종 출력 위치(SV_Position 시맨틱에 할당된 값)는 이 클립 공간 좌표
* 이후 렌더링 파이프라인의 고정 기능 하드웨어는 클립 공간 좌표의 각 성분(x, y, z)을 동차 성분인 w로 나누는 **원근 나누기(Perspective Divide)**를 수행
  * NDC_x = Clip_x / Clip_w
  * NDC_y = Clip_y / Clip_w
  * NDC_z = Clip_z / Clip_w

* 이 결과로 정점들은 **정규화된 장치 좌표계 (Normalized Device Coordinates, NDC)**로 변환됨.
  * NDC 공간에서 X, Y 좌표는 보통 -1에서 +1 사이, Z 좌표는 0에서 +1 (Direct3D) 또는 -1에서 +1 (OpenGL) 사이의 값을 가집니다. 이 NDC 좌표가 최종적으로 화면 픽셀 좌표(스크린 공간)로 매핑

<br>

## **3. Vertex Shader의 최종 출력**

* Vertex Shader는 변환된 정점의 위치를 클립 공간 좌표로 SV_Position이라는 특별한 시스템 값 시맨틱을 가진 출력 변수에 할당해야 함

* 이외에도 텍스처 좌표, 정점 색상, 변환된 노멀 벡터 등 다른 계산된 값들을 다음 파이프라인 스테이지(주로 Rasterizer를 거쳐 Pixel Shader)로 전달하기 위해 출력 구조체에 담아 반환