---
title: operator=에서는 자기 대입에 대한 처리가 빠지지 않도록 하자
date: 2023-07-06
categories: [Effective C++,Effective C++]
tags: [effective c++]		# TAG는 반드시 소문자로 이루어져야함!
---

**항목 11: operator=에서는 자기 대입에 대한 처리가 빠지지 않도록 하자**
=============

* `자기 대입(self assignment)이란, 어떤 객체가 자기 자신에 대해 대입 연산자를 적용하는 것을 말한다.`

```c++
class Widget { ... };

Widget w;
...

w = w;  // 자기에 대한 대입
```

* 뭔가 이상한 코드이지만, 이 코드는 적법한(legal) 코드이다.

  * 즉, 사용자쪽에서도 이렇게 할 수도 있는 코드이다.

* 그리고 대입 연산은 눈에 띄지 않아 더욱 문제가 커진다.

<br>

**자기 대입이 생기는 이유**
-------------------

```c++
a[i] = a[j];    // 자기 대입일 수도 있는 코드
```

* 위 문장은 i와 j가 같은 값을 갖게 되면 자기대입문이 된다.

```c++
*px = *py;      // 자기 대입일 수도 있는 코드
```

* 위 문장도 px와 py가 같은 대상을 가리키게 되면 자기대입이 되고 만다.


* `언뜻 보기에 명확하지 않은 이러한 자기대입이 생기는 이유는 여러곳에서 하나의 객체를 참조하는 상태, 다시 말해 중복참조라고 불리는 것 때문이다.`

* 같은 타입으로 만들어진 객체 여러 개를 참조자 혹은 포인터로 물어 놓고 동작하는 코드를 작성할 때는 같은 객체가 사용될 가능성을 고려하는 것이 일반적으로 바람직한 자세이다.



* 사실, 같은 클래스 계통에서 만들어진 객체라 해도 굳이 같은 타입으로 선언할 필요는 없다.

  * 파생 클래스 타입의 객체를 참조하거나 가리키는 용도로 기본 클래스의 참조자나 포인터를 사용하면 되기 때문이다.

```c++
class Base { ... };                     //기본 클래스

class Derived : public Base { ... };    // 파생 클래스

void doSomething(const Base& rb,
                    Derived* pd);   // rb 와 *pd는 같은 객체일 수도 있다.
```

* 항목 13 및 14에 나온 조언을 따른다면 자원 관리 용도로 항상 객체를 만들어야 할 것이고, 이렇게 만든 자원 관리 객체들이 복사될 때 나름대로 잘 동작하도록 코딩할 것이다.

  * 바로 이때 조심해야 하는 것이 대입 연산자이다.

  * 이 연산자는 신경 쓰지 않아도 자기대입에 대해 안전하게 동작해야 한다.

  * 하지만 자원 관리를 완벽하게 코딩하기는 어려워 문제가 생길 수도 있다.

<br>


**operator= 연산자에서 자기 대입에 대해 주의할 점**
---------------

```c++
class Bitmap { ... };

class Widget {

private:
    Bitmap *pb; //힙에 할당한 객체를 가리키는 포인터
};

// 자기 참조 가능성이 있는 대입 연산자
Widget& Widget::operator=(const Widget& rhs)
{
    delete pb;                  // 현재 비트맵 사용 중지
    pb = new Bitmap(*rhs.pb);   // rhs의 비트맵 사용하도록 만듦

    return *this;
}
```

* 위에서 보는 operator=의 구현 코드는 문제가 없을거 같지만 자기 참조의 가능성이 있는 코드이다.

* operator= 내부에서 `*this(대입되는 대상)와 rhs가 같은 객체일 가능성이 있다는 것`이다.

  * 이 둘이 같은 객체이면, delete 연산자가 *this 객체의 비트맵에만 적용하는 것이 아니라 rhs의 객체까지 적용시켜버린다.

  * 그 결과 객체는 삭제된 포인터를 다시 대입하려는 코드가 발생해버린다.


<br>

**일치성 검사와 그에 대해 주의할 점**
----------

* 이러한 에러에 대한 전통적인 대책은 `일치성 검사(identity test)를 통해 자기 대입을 점검하는 것`이다.

```c++
Widget& Widget::operator=(const Widget& rhs)
{
    if (this == &rhs) return *this;  // 자기 대입인지에 대한 일치성 검사

    delete pb;                  
    pb = new Bitmap(*rhs.pb);   

    return *this;
}
```

* 이렇게 하면 되기는 하지만, 이전 버전의 operator=이 자기 대입에 안전하지 못할 뿐만 아니라 예외에도 안전하지 못하다.

* new Bitmap 표현식에서 예외가 터지게 되면, Widget 객체는 결국 삭제된 Bitmap을 가리키는 포인터를 대입해버리는 상황이 발생한다.

* 다행히도 operator=을 예외에 안전하게 구현하면 대개 자기대입에도 안전한 코드가 나오게 되어 있다.

<br>

**문장 순서로 예외와 자기대입 처리하기**
---------

* 일단 이번 항목에서는 `많은 경우에 문장 순서를 세심하게 바꾸는 것만으로 예외에 안전한(동시에 자기대입에 안전한) 코드가 만들어 진다`라는 법칙을 사용한다.

* 위 코드는 pb를 무턱대고 삭제하지 말고 이 포인터가 가리키는 객체를 복사한 직후에 삭제하면 깔끔하게 해결된다.

```c++
Widget& Widget::operator=(const Widget& rhs)
{
    Bitmap* pOrig = pb;         // 원래의 pb를 어딘가에 저장
    pb = new Bitmap(*rhs.pb)    // 다음, pb가 *pb의 사본을 가리키게 만듦
    delete pOrig;               // 저장해둔 원래의 pb를 삭제

    return *this;
}
```

* 위 코드는 new Bitmap 부분에서 예외가 발생하더라도 pb는 변경되지 않은 상태가 유지된다.

* 게다가 일치성 검사 같은 것이 없어도 자기대입 현상을 완벽하게 처리하고 있다.

  * `원본 비트맵을 복사해놓고, 복사해 놓은 사본을 포인터가 가리키게 만든 후, 원본을 삭제하는 순서로 실행하기 때문`

* 이 방법이 자기대입을 처리하는 가장 효율적인 방법은 아니지만, 동작에는 문제가 없다.


<br>


* 위 코드에서 효율을 신경쓰는 나머지 일치성 검사를 붙이려고 생각할 수 있다.

* 그런데 `자기대입이 발생하는 경우는 별로 없는데 일치성 검사 코드를 붙여 매 번 검사하는 것은 효율이 떨어진다.`

  * 일치성 검사 코드를 사용하면 그만큼 코드가 커지고, 처리 흐름에 분기를 만들어 실행 시간 속력이 줄어들 수 있다.<br> 또한 CPU 명령어 선행인출(instruction prefetch), 캐시 , 파이프라이닝 등의 효과도 마찬가지다.



<br>

**또 다른 예외 안정성과 자기대입 안전성을 동시에 가진 operator= 구현**
-----------

* `복사 후 맞바꾸기(copy and swap)`이라는 기법으로 항목 29에 자세히 설명하지만 이 기법은 operator= 적성에 매우 자주 쓰기 때문에 어떤식으로 구현하는지를 보여준다.

```c++
class Widget {
    ...
    void swap(Widget& rhs); // *this의 데이터 및 rhs의 데이터를 바꾼다.
    ...                     // 자세한 내용은 항목 29에서 설명
};

Widget& Widget::operator=(const Widget& rhs)
{
    Widget temp(rhs);   // rhs 데이터에 대한 사본 생성

    swap(temp);         // *this의 데이터를 사본과 교체

    return *this;
}
```

* 이 방법은 C++이 가진 두가지 특징을 활용하여 조금 다르게 구현할 수도 있다.

  * `클래스의 복사 대입 연산자는 인자를 값으로 취하도록 선언하는 것이 가능하다는 점`

  * `값에 의한 전달을 수행하면 전달된 대상의 사본이 생긴다는 점`

```c++
Widget& Widget::operator=(Widget rhs)   //값에 의한 전달로 인한 rhs의 사본
{
    swap(rhs);         // 사본과 *this의 데이터를 교체

    return *this;
}
```

<br>

> 이것만은 잊지 말자!
> * operator=을 구현할 때, 어떤 객체가 그 자신에 대입되는 경우를 제대로 처리하도록 만들자.<br>
> 원본 객체와 복사대상 객체의 주소를 비교해도 되고, 문장의 순서를 조정해도 되고, 복사 후 맞바꾸기 기법을 사용해도 된다.
> 
> * 두 개 이상의 객체에 대해 동작하는 함수가 있다면,이 함수에 넘겨지는 객체들이 사실 같은 객체인 경우에 정확하게 동작하는지 확인해야 한다.
{: .prompt-tip }
