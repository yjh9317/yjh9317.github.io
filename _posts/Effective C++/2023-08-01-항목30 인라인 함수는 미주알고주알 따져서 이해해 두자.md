---
title: 항목30 인라인 함수는 미주알고주알 따져서 이해해 두자
date: 2023-08-01
categories: [Effective C++,Effective C++]
tags: [effective c++]		# TAG는 반드시 소문자로 이루어져야함!
---


* 인라인 함수는 함수처럼 동작하면서 매크로보다 훨씬 안전하고 쓰기 좋고 함수 호출시 발생하는 오버헤드도 걱정할 필요가 없고 그리고 또 하나 이점이 있다.

* 대채적으로 컴파일러 최적화는 함수 호출이 없는 코드가 연속적으로 이어지는 구간에 적용되도록 설계되었기 때문에,`인라인 함수를 사용하면 컴파일러가 함수 본문에 대해 문맥별(context-specific) 최적화를 걸기가 용이해진다.`

  * 대부분의 컴파일러는 아웃라인 함수호출에 대해 이런 최적화를 적용하지 않는다.


-------------------

* 인라인 함수의 아이디어는 함수 호출문을 그 함수의 본문으로 바꿔치기하는 것이라, 목적 코드의 크기가 커진다.

* 가상 메모리를 쓰는 환경일지라도 인라인 함수로 커진 코드는 성능의 걸림돌이 되기 쉬워진다.

  * 페이징 횟수가 늘어나고, 명령어 캐시 적중률이 떨어질 가능성도 높아진다.


* 반대의 경우도 있는데 본문 길이가 매우 짧은 인라인 함수를 사용하면, 크기가 함수 호출문에 대해 만들어지는 코드보다 작아질 수 있다.

* 이럴 때는 `목적 코드 크기가 작아지며 명령어 캐시 적중률도 높아진다`

<br>

**inline**
=============

* inline은 컴파일러에 대해 명령이 아닌 `요청`을 한다.

* 이 요청은 `명시적으로 할 수도 있고 암시적으로도 될 수 있다.`

### 암시적
----------

* `클래스 정의 안에 함수를 바로 정의하면 컴파일러는 그 함수를 인라인 함수 후보로 넣는다`

```c++
class Person {
    public:
        int age() const {return theAge;}    // 암시적 인라인 요청

    private:
        int theAge;
};
```

* 이런 경우에는 암시적으로 인라인 함수로 선언된다.

  * 항목 46을 보면 프렌드 함수도 클래스 내부에서 정의 될 수 있다는 내용이 나온다.

<br>

### 명시적
--------

* `함수 정의 앞에 inline 키워드를 붙이면 인라인 함수로 선언한다`

```c++
// <algorithm>에 있는 std::max 템플릿 함수
template<typename T>
inline const T& std::max (const T& a, const T& b)   // 명시적 인라인 요청
{ return a < b ? b : a; }
```

* max가 템플릿이여서 인라인 함수와 템플릿은 대개 헤더 파일 안에 정의한다가 떠오를 것이다.

* 이 점을 오해해서 함수 템플릿은 반드시 인라인 함수이어야 한다고 생각하면 안된다.

<br>

**헤더파일 관련 내용**
----------

* `인라인 함수는 대체적으로 헤더 파일안에 있어야 한다.`

  * `왜냐하면 대부분의 빌드 환경에서 인라인을 컴파일 도중에 수행하기 때문이다.`

  * 인라인 함수 호출을 본문과 바꿔치려면 컴파일러가 어떤 형태인지 알고 있어야 한다.


* 템플릿 역시, 대체적으로 헤더 파일에 들어 있어야 한다.

* 템플릿이 사용되는 부분에서 해당 템플릿을 인스턴스로 만들려면 어떻게 생겼는지 컴파일러가 알아야 하기 때문이다.


* 하지만 템플릿 인스턴스화는 인라인과 완전히 별개다.

* 만들고 있는 함수 템플릿이 굳이 인라인될 이유가 없다면 inline을 선언할 필요가 없다.

<br>

**lnline은 컴파일러 선에서 무시할 수 있는 요청**
-------

* 대부분의 컴파일러 경우 inline 함수로 선언되어 있어도 `복잡한 함수(루프,재귀함수)는 인라인 확장의 대상에 넣지 않는데다 가상 함수라면 인라인하지 않는다.`

  * 경우에 따라서는 가상 함수라도 inline이 가능하다

* `인라인 함수가 실제로 인라인될지 안 될지는 개발자가 사용하는 빌드환경에 달렸다`

  * 그 중에서도 결정짓는 것은 컴파일러

  * 다행스러운 점은, 요청한 함수에 대한 인라인이 실패했을 경우, 메시지를 내주는 진단 수준 설정이 대부분의 컴파일러 기능에 들어 있다.(항목 53)
  
<br>

**조건이 맞아도 안되는 경우**
------------

* 완벽한 인라인 조건이어도, 컴파일러가 인라인 함수의 본문에 대해 코드를 만드는 경우가 있다.

### 예시
--------------

* 인라인 함수의 주소를 취하는 코드가 있으면, 컴파일러는 이 코드를 위한 아웃라인 함수 본문을 만들 수 밖에 없다.

* 있지도 않은 함수에 대해 어떻게 포인터를 가지고 올지, 게다가 인라인 함수로 선언된 함수를 함수 포인터를 통해 호출하는 경우도 대개 인라인되지 않는다.

* 즉, 확실한 인라인 함수여도, `어떻게 호출햐느냐`에 따라 인라인이 되기도 하고 안되기도 한다.

```c++
inline void f() { ... } // 컴파일러가 f의 호출을 반드시 인라인한다고 가정

void (*pf)() = f;       // pf는 f를 가리키는 함수 포인터

f();                    // 이 호출은 평범한 함수호출이라 인라인이 된다.

pf();                   // 이 호출은 함수포인터로 호출되어 인라인되지 않는다.
```

<BR>

**생성자와 소멸자의 inline**
------

* 생성자와 소멸자는 인라인하기 좋은 함수가 아니다.

```c++
class Base {

    private:
    std:: string bm1, bm2;
};

class Derived : public Base {

    public:
        Derived() {}        // Derived 의 생성자
                            // 진짜 비어있을까?

    private:
        std::string dm1, dm2, dm3;
};
```

* Derived의 생성자는 아무 코드가 없어 인라인하기 좋아보이지만 그렇지 않다.

------------

* C++는 객체가 생성되고 소멸될 때 일어나는 일들에 대해 여러가지 보장을 준비한다.

* 어떤 객체의 생성 과정에선 기본 클래스 부분과 객체의 데이터 멤버들이 자동으로 생성되고<br>
  소멸 과정에서 반대되는 순서로 저절로 이뤄지는 것도 마찬가지다.

* C++는 객체가 생성되는 도중에 예외를 던지더라도 생성이 완료된 부분만큼은 말끔히 소멸되도록 보장한다.

* 그런데 C++는 `무엇을` 해야 하는지는 정했지만, `어떻게` 할지는 정해져 있지 않다.

* 그래서 비어있는 Derived 생성자에서는 어떤 구현환경에서는 다음과 같은 코드로 만들어 질 것이라고 상상할 수 있다.

```c++
Derived::Derived() 
{
    Base::Base();

    //dm1 관련
    try {   dm1.std::string::string();  }
    catch (...)
    {
        Base::~Base();
        throw;
    }

    // 나머지 멤버 변수들에 대해서도 반복
    ...
}
```

* `컴파일러가 정확히 어떻게 예외 처리하는지 환경에 따라 다르지만 Derived의 텅 빈 생성자가 실제로는 데이터 멤버 처리와 기본 클래스 부분에 대해 생성자를 호출하기 때문에 인라인하기가 난감해진다.`

<br>

**라이브러리**
======

* 라이브러리를 설계하는 사람이라면 inline으로 선언할 때 영향에 대해 많은 고민을 해야 한다.

* 사용자의 눈에 뻔히 보이는 인라인 함수에 대해 라이브러리 차원에서 바이너리 업그레이드를 제공할 수 없기 때문이다.

* 어떤 라이브러리에 f라는 인라인 함수가 있고, 이 라이브러리를 쓰는 사용자가 f의 본문을 컴파일해서 응용 프로그램을 만들었다고 한다.

* 나중에 이 라이브러리 개발자가 f의 내부를 바꾼다고 하면, f를 썼던 사용자들은 각자의 소스를 다시 컴파일 해야 한다.

* 반대로 f가 인라인 함수가 아닌 보통 함수라면, f가 바뀔 때 사용자들은 링크만 하면 된다.

  * 게다가 f를 제공하는 라이브러리가 동적 링크 방식이라면, 개발 작업이 완벽히 투명하게 진행된다.


<br>

**결론**
========


> 이것만은 잊지 말자!
> * 함수 인라인은 작고,자주 호출된는 함수에 대해서만 하는 것으로 묶어두자.<br>
>   이렇게 디버깅 및 라이브러리의 바이너리 업그레이드가 용기해지고, 자칫 생길 수 <br>
>   있는 코드 부풀림 현상이 촤소화되며, 프로그램 속력이 빨라질 여지가 최고로 많아진다.
>
> * 함수 템플릿이 대개 헤더 파일에 들어간다는 일반적인 부분만 생각해서 이들을 <Br>
>   inline으로 선언하면 안된다.
{: .prompt-tip }
