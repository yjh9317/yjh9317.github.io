---
title: 항목8: 예외가 소멸자를 떠나지 못하도록 붙들어 놓자
date: 2023-07-01
categories: [Effective C++,Effective C++]
tags: [effective c++]		# TAG는 반드시 소문자로 이루어져야함!
---

**항목8 : 예외가 소멸자를 떠나지 못하도록 붙들어 놓자**
=====================

**예시**
-------

* 소멸자로부터 예외가 터져 나가는 경우를 C++ 언어에서 막진 않지만, 실제 상황을 보면 막을 수 밖에 없다.

```c++
class Widget{
public:
    ...
    ~Widget() { ... }   // 여기서 예외가 발생한다고 가정.
};

void doSomething()
{
    std::vector<Widget> v;
    ...
}
```

* vector타입의 v가 소멸될 때, 가지고 있는 Widget이 여러 개이고 첫 번째 Widget과 두 번쨰 Widget을 소멸시킬 때 예외가 발생한다고 가정한다.

* 두 예외가 발생한 조건이 어떤 조건이냐에 따라 프로그램 실행이 종료되든, 정의되지 않은 동작을 보일텐데 이 경우에는 정의되지 않는 동작을 보인다.

* 완전하지 못한 프로그램의 종료나 미정의 동작의 원인은 예외가 발생하도록 내버려둔 소멸자에게 있다.

<br>

**다른 예시**
---------

* 데이터베이스 연결을 나타내는 클래스를 쓰고 있다고 가정한다.

```c++
class DBConnection{
public:
    ...

    // DBConnection 객체를 반환하는 함ㅈ수
    static DBConnection create();   

    void close();   // 연결을 닫는다. 실패하면 예외 발생
};
```

* 사용자가 DBConnection 객체에 대해 직접 close를 호출해야 하는 설계이다.

* 사용자의 망각을 사전에 차단하는 좋은 방법은 DBConnection에 대한 자원 관리 클래스를 만들고 그 클래스의 소멸자에서 close를 호출하게 만드는 것이다.

```c++
// DBConnection을 관리하는 자원 클래스
class DBConn{
public:
    ...

    ~DBConn()           // 데이터베이스 연결이 항상 닫히도록 해주는 함수
    {
        db.close();
    }

private:
    DBConnection db;
};

// ==========
// 이런 프로그래밍으로 다음과 같은 코드가 가능해진다.

{
    // DBConn 객체가 DBConnection 객체를 관리
    DBConn dbc(DBConnection::create());

}   // 블록에서 DBConn 객체가 소멸되면서 close 함수 호출
```

* 근데 여기서 close함수를 호출했는데 예외가 발생한다고 가정하며 어떻게 될까?

* DBConn의 소멸자는 이 예외를 나가도록 내버려둔다는 것에서 문제가 생겨버린다.

<Br>

**소멸자에서 예외가 발생했을 때의 해결방법**
----------

* 이러한 문제를 해결하는 방법은 두가지가 있다.

* 첫 번째로, `close에서 예외가 발생하면 프로그램을 바로 끝내버린다. 대개 abort() 함수를 호출한다.`

```c++
DBCon::DBConn()
{
    try { db.close(); }
    catch (...) {
        // close 호출이 실패했다는 로그를 작성
        std::abort();
    }
}
```

* 객체 소멸이 진행되다가 에러가 발생한 후에 프로그램 실행을 계속할 수 없다면 괜찮은 선택이다.

* 정의되지 않는 동작까지 이를 수 있는 불상사를 막는다는 점에서 어느정도 장점이 있다.

<br>



* 두 번째로, `close를 호출한 곳에서 일어난 예외를 삼킨다.`


```c++
DBCon::DBConn()
{
    try { db.close(); }
    catch (...) {
        // close 호출이 실패했다는 로그를 작성
    }
}
```

* 대부분의 경우 예외를 삼키기는 좋지 않다.

  * 중요한 정보가 묻혀 무엇이 잘못됐는지를 알지 못한다.

* 하지만 때에 따라서는 불완전한 프로그램 종료 or 미정의 동작보다 예외 삼키기가 나을 수 있다.

  * 단 예외 삼키기를 선택한 것이 제대로 빛을 보려면, 발생한 예외를 그냥 무시한 뒤라도 프로그램이 신뢰성 있게 실행을 지속할 수 있어야 한다.

* 어느쪽을 택하든 둘 다 문제점이 있어 좋아보이진 않는다.

<br>

----------

* DBConn 인터페이스를 잘 설계해서, 발생할 소지가 있는 문제에 대해 대처할 기회를 사용자가 가지도록 하는 것은 어떨까?

* DBConn에서 close 함수를 직접 제공해 이 함수의 실행 중에 발생하는 예외를 사용자가 직접 처리하는 방식이다.

  * DBConnection이 닫혔는지의 여부를 유지했다가, 닫히지 않았으면 DBConn의 소멸자에서 닫을 수도 있다.

* 이렇게 하면 데이터베이스 연결이 누출되지는 않지만, 소멸자에서 호출하는 close마저 실패한다면 예외를 끝내거나 삼키는 방식으로 돌아올 수 밖에 없다.


```c++
class DBConn{
public:
    ...

    void close()        // 사용자 호출을 위해 만든 함수
    {
        db.close();
        closed = true;
    }

    ~DBConn()
    {
        if(!closed)
        {
            try{
                db.close();
            }
            catch(...)
            {
                // close 호출이 실패했다는 로그 작성
                ... 
            }
        }
    }

private:
    DBConnection db;
    bool closed;
};
```

* close 호출의 책임을 DBConn의 소멸자에서 DBConn의 사용자로 떠넘기는 아이디어는 무책임한 책임 전가처럼 보일 수 있지만 아니다.

* 어떤 동작이 예외를 일으키면서 실패할 가능성이 있고 또 그 예외를 처리해야 할 필요가 있다면, 그 예외는 `소멸자가 아닌 다른 함수에서 비롯된 것`이어야 한다는 것이 포인트이다.

  * 이유는 `예외를 일으키는 소멸자는 프로그램의 불완전 종료 혹은 미정의 동작의 위험을 내포하고 있기 때문이다.`

* 사용자가 호출할 수 있는 close 함수를 두긴 했지만, 부담을 떠넘기는 것이 아닌 사용자에게 예외를 처리할 수 있는 기회를 주는 것이다.

* close함수를 호출하고 그 부분이 잘못된다고 해도, DBConn이 예외를 삼키든 프로그램을 끝내든 사용자 쪽에서 불평할 자격이 없게 된다.
  * 어찌 되었든 문제 해결의 칼자루를 먼저 쥔 쪽은 사용자이고, 칼을 뽑지 않기로 결정한 쪽 역시 사용자 이기 때문.



<br>

> 이것만은 잊지 말자!
> * 소멸자에서는 예외가 빠져나가면 안된다.<br>
>   만약 소멸자 안에서 호출된 함수가 예외를 던질 가능성이 있다면, 어떤 예외이든지 소멸자에서 모두 받아낸 후에 삼켜 버리든지 프로그램을 끝내든지 해야 한다.
> * 어떤 클래스의 연산이 진행되다가 던진 예외에 대해 사용자가 반응해야 할 필요가 있다면,<br>
>   해당 연산을 제공하는 함수는 반드시 보통의 함수(즉, 소멸자가 아닌 함수)이어야 한다.
{: .prompt-tip }