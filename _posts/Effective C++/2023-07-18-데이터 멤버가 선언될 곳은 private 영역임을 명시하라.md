---
title: 데이터 멤버가 선언될 곳은 private 영역임을 명시하라
date: 2023-07-18
categories: [Effective C++,Effective C++]
tags: [effective c++]		# TAG는 반드시 소문자로 이루어져야함!
---

**항목22 : 데이터 멤버가 선언될 곳은 private 영역임을 명시하라**
===============

* 이번 항목에서 데이터 멤버가 public이면 안 되는지에 대한 이유를 알아보고, public 데이터 멤버에 대한 모든 이야기가 protected에도 똑같이 적용되는 모습을 확인한다.

<br>

public 데이터 멤버가 안되는 이유
=============


*  `문법적 일관성`때문이다.(항목18)

* 데이터 멤버가 public이 아니라면, 사용자 쪽에서 어떤 객체를 접근할 수 있는 유일한 수단은 멤버 함수이다.

* 어떤 클래스의 공개 인터페이스에 있는 것들이 전부 함수뿐이라면, 클래스의 멤버나 함수에 접근할 때 괄호를 사용해야할지 말아야할지 고민할 이유가 없어진다.

  * public에는 전부 함수로 되어있으니 그냥 괄호를 붙이고 쓰기만 하면 된다.

<br>

* 그리고 `함수를 사용하면 데이터 멤버의 접근성에 대해 훨씬 정교한 제어를 할 수 있다`

* 만일 어떤 데이터 멤버를 public으로 내놨다면 모두가 이 멤버에 대해 읽기 및 쓰기 권한을 갖게 되지만, 이 값을 읽고 쓰는 함수가 있으면 **접근 불가 · 읽기 전용 · 읽기 쓰기 접근 · 쓰기 전용 접근**을 직접 구현할 수 있다.

<br>

```c++
class AccessLevels{

public:
    int getReadOnly() const     { return readOnly; }

    int setReadWrtie(int value) { readWrite = value; } 
    int getReadWrite() const    { return readWrite; }

    int setWriteOnly(int value) { writeOnly = value; }

private:
    int noAccess;       // 이 int에 대해서는 접근 불가

    int readOnly;       // 이 int에 대해서는 읽기 전용 접근

    int readWrite;      // 이 int에 대해서는 읽기 쓰기 접근

    int writeOnly;      // 이 int에 대해서는 쓰기 전용 접근
};
```

* 그리고 가장 중요한 것은 `캡슐화`를 할 수 있다는 점이다.

<br>


### 캡슐화 예시
-----------------

* 자동화 장치를 사용해서 자동차가 지나가는 속도를 모니터링하는 프로그램을 만들고 있다고 가정한다

```c++
class SpeedDataCollection {

public:
    void addValue(int speed);       // 새 값을 추가

    double averageSoFar() const;    // 평균 속도를 반환
};
```

* **averageSoFar() 함수**가 어떻게 구현될지 생각해본다.

* 우선 수집한 속도 데이터 전체의 평균값을 담는 어떤 데이터 멤버를 클래스 안에 넣어두는 방안이 있다.

  * **averageSoFar() 함수**는 호출될 때마다 데이터 멤버의 값을 반환하기만 하면 된다.

* 또 다른 방법으로는 호출될 때마다 평균값을 계산하는 방법이 있다.

<br>

-----------

* 첫 번째 방법(현재 평균값 유지하기)을 사용한다면 , **SpeedDataCollection** 객체 하나하나가 커진다.

  * 평균값을 유지하기 위한 공간 할당이 추가되므로

* 하지만  이런 방법으로 구현한 **averageSoFar() 함수**는 효율면에서 좋을 수 있다.

  * 현재 평균값을 반환하기만 하면 되는 `인라인 함수`이기 때문이다 (항목30)


* 두 번째 방법을 사용한다면, 함수 자체의 속도는 느려지지만,**SpeedDataCollection** 객체의 하나하나의 크기는 첫 번째 방법보다 작아진다.

* 어느 방법이 좋은지는 환경에 따라 다르지만, 중요한 포인트는 `평균값 접근에 멤버 함수를 통하게 한다(평균값을 캡슐화한다)`라는 점이다.

  * 이렇게 함으로써, 내부 구현을 바꿀수 있게 되고, 사용자쪽에서는 해봐야 컴파일만 하면 끝난다(항목31을 참조하면 이러한 불편함까지 없앨 수 있다)

<br>

## 캡슐화의 장점

* `데이터 멤버를 함수 인터페이스 뒤에 감추게 되면 구현상의 융통성을 전부 누릴수 있게 된다.`

* 예를 들어 데이터 멤버를 읽고 쓸 때 다른 객체에 알림 메시지를 보낸다거나, 클래스의 불변속성 및 사전조건(prediction) · 사후조건(postcondition)을 검증한다든가, 스레딩 환경에서 동기화를 거는 일 등이 있다.

  * C++에서는 `프로퍼티(property)`라고 부른다


<br>


---------

* 그리고 사용자로부터 데이터 멤버를 숨기면(캡슐화), `클래스의 불변 속성을 항상 유지하는 데 절대로 소홀해질 수 없다`

* 불변속성을 보여줄 수 있는 통로가 멤버 함수밖에 없기 때문이다.

* 그뿐 아니라 `캡슐화는 현재의 구현을 나중에 바꾸기로 결정할 수 있는 권한을 예약하는 셈이다`

* 이러한 결정을 숨기지 않으면, 클래스의 소스코드를 갖고 있더라도 public으로 되어 있는 부분은 손을 대기가 힘들다.

* C++에서는 `public은 캡슐화되지 않았다를 뜻하며 실질적인 측면에서 캡슐화가 되지 않았다는 것은 바꿀수 없다라는 의미를 내포한다`

<br>

**protected의 경우**
-------

* protected 데이터 멤버의 경우도 앞과 비슷하다

* 문법적 일관성과 세밀한 접근 제어에 관한 이야기라면 public 데이터 멤버처럼 protected에 적용할 수 있다.

* 그러나 캡슐화는 protected가 public보다는 많이 가려져 있다고 생각이 들지만 실질적인 측면에서는 아니다.

<br>

### public 데이터 멤버를 제거한다고 가정하면
------------


* 어떤 클래스에 public 데이터 멤버가 있고 이것을 제거한다고 가정한다.

* 이 멤버와 연관있는 코드들이 얼마나 망가질까?

  * 엄청 많을테고 그렇기 때문에 public 데이터 멤버를 사용하려는 사용자가 사용하기 힘들어진다.

<br>

### protected 데이터 멤버를 제거한다고 가정하면
--------------

* protected 데이터 멤버를 제거한다고 가정한다.

* 이 멤버를 사용하는 파생 클래스 전부를 포함해서 엄청 많을 것이다.

<br>

**결론**
===================

* 결국 protected 멤버나 public 멤버나 오십 보 백보이다.

* `데이터 멤버가 바뀌면 이 멤버에 의존하는 다른 코드들이 헤아릴 수 없을 정도로 망가지는 것은 마찬가지이기 때문이다.`

* public이나 protected로 선언한 데이터 멤버를 사용자가 사용하기 시작하면 그 이후부터는 되돌릴 수가 없어진다.

  * 엄청난 양의 코드를 다시 써야할테고 테스트,문서,컴파일 등도 다시 해야 할 것이다.


* `캡슐화의 관점에서 쓸모있는 접근 수준은 private(캡슐화 제공)과 private이 아닌 나머지일 뿐이다.`


<br>


> 이것만은 잊지 말자!
> * 데이터 멤버는 private 멤버로 선언하자. 이를 통해 클래스 제작자는 문법적으로
> <br> 일관성 있는 데이터 접근 통로를 제공할 수 있고, 필요에 따라서는<br>
> 세밀한 접근 제어도 가능하며, 클래스의 불변속성을 강화할 수 있을 뿐 아니라,<Br>
> 내부 구현의 융통성도 발휘할 수 있다.
>
> * protected는 public보다 더 많이 '보호'받고 있는 것이 절대로 아니다.
{: .prompt-tip }
