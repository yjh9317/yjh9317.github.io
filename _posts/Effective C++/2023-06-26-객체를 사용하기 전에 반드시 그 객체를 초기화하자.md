---
title: 객체를 사용하기 전에 반드시 그 객체를 초기화하자
date: 2023-06-26
categories: [Effective C++,Effective C++]
tags: [effective c++]		# TAG는 반드시 소문자로 이루어져야함!
---

**항목4 : 객체를 사용하기 전에 반드시 그 객체를 초기화하자**
===========

* C++에서 객체의 값 초기화는 상황에 따라 다르게 적용된다.

```c++
class Point {
    int x,y;
};

...
Point p;
```

* 이렇게 작성하면, p의 데이터 멤버는 어떤 상황에서는 초기화가 보장되지만, 어떨 때는 보장되지 않는다.

* `초기화되지 않은 값을 읽도록 냅두면 정의되지 않은 동작이 그대로 작동해버린다.`

* 어떤 플랫폼의 경우는 초기화하지 않은 객체를 읽으면 프로그램이 멈춰버리지만, 대부분의 경우에는 무작위 비트 값을 읽고 객체의 내부가 이상한 값을 갖게 된다.

<br>

**객체 초기화 규칙에 대한 이야기**
========

* C++의 객체 초기화는 언제 초기화가 보장되는지, 언제는 보장되지 않는지에 대한 규칙은 준비되어 있지만 규칙 자체가 조금 복잡하다.

* 일반적으로 `C++의 C부분을 사용하며 초기화에 런타임 비용이 소모될 수 있는 상황이라면 값이 초기화된다는 보장이 없다.`

* 그렇지만 `C가 아닌 부분이 첨가되면, 사정이 달라진다.`

* 그래서 `배열(C++의 C부분)은 원소가 초기화된다는 보장은 없으나 vector(C++의 STL부분)은 초기화가 보장되는 이유`가 이런 법칙때문이다.

<br>

* 결국 `가장 좋은 방법은 모든 객체를 사용하기 전에 항상 초기화하는 것`이다.

* 기본 제공 타입으로 만들어진 비멤버 객체에 대해서 초기화를 아래와 같이 작성해본다.

```c++
int x = 0;                              // int 직접 초기화

const char* text = "A C-style string";  // 포인터 직접 초기화

double d;                               // 입력 스트림에서 읽는 것으로 초기화 수행
std::cin >> d;
```

* 이런 부분을 제외하고 나면 `C++의 초기화의 나머지 부분은 생성자로 귀결된다.`

* 생성자에서 지킬 규칙은 지극히 간단하다.

  * 바로 객체의 모든 것을 초기화하자!이다.

<br>

**주의할점**
----------

* 그런데 주의할 점은 `대입과 초기화를 헷갈리지 않는 점`이다.

* 주소록의 개인별 기재사항을 나타내는 클래스로 예시를 들어본다.

```c++
class PhoneNumber { ...  };

class ABEntry
{
public:
    ‌ABEntry(const std::string& name, const std::string& address,
            const std::list<PhoneNumber>& phones)
    ‌{
        // 모두 초기화가 아닌 대입이다.
        ‌‌theName = name; 
        ‌‌theAddress = address;
        ‌‌thePhones = phones;
        ‌‌numTimesConsulted = 0;
    ‌}

private:
    ‌std::string theName;
    std::‌string theAddress;
    std::‌list<PhoneNumber> thePhones;
    ‌int numTimesConsulted;
};
```

* 이렇게 하면 ABEntry 객체는 정상적으로 작동하지만 그리 좋은 방법은 아니다.

* C++ 규칙에 의하면 `어떤 객체든 그 객체의 데이터 멤버는 생성자의 본문이 '실행되기 전'에 초기화되어야 한다`라고 명시되어 있다.

* 현재 ABEntry의 생성자는 모두 초기화가 아닌 대입을 하고 있다.
  * 기본 제공 타입(예:int)라고 해서 대입되기 전에 초기화되리라는 보장은 없다.

<br>

----------------

* 위의 클래스를 더욱 효율적으로 만들기 위해 `멤버 초기화 리스트를 사용`한다

```c++
ABEntry::‌ABEntry(const std::string& name, const std::string& address,
        const std::list<PhoneNumber>& phones)
    ‌‌: theName(name), theAddress(address), thePhones(phones), numTimesConsulted(0) {}
     // 모두 초기화가 되고 있다.
```

* 대입만 사용한 버전인 경우는 theName, theAddress, thePhones에 대해 기본 생성자를 호출해서 초기화를 미리한 후에 생성자에서 새로운 값을 대입하는 형식이였다.
  * 따라서 먼저 호출된 기본 생성자에서 해 놓은 초기화는 아무 의미가 없어져 버렸다.

* 멤버 초기화 리스트에 들어간 인자는 `데이터 멤버에 대한 생성자의 인자로 사용`하기 때문에 위와 같은 문제를 피할 수 있다.

    * theName, theAddress, thePhonse 모두 복사생성자에 의해 초기화되고 있다.

<br>

--------------

* 위와 같은 대부분의 타입에 포함되지 않는 기본 제공 타입의 객체는 초기화와 대입에 걸리는 비용의 차이가 없지만, 멤버 초기화 리스트에 넣어주는 것이 좋다.

* 또 데이터 멤버를 기본 생성자로 초기화하고 싶을 때에는 멤버 초기화 리스트를 사용하는 것이 좋다.

* 매개 변수가 없어도 아래와 같이 멤버 초기화 리스트를 사용하는 것이 좋다.

```c++
// 매개 변수 없는 생성자 버전
ABEntry::‌ABEntry()
    ‌‌: theName(),
    theAddress(),
    thePhones(),
    numTimesConsulted(0)
    {}
```

<br>

------------------

* 위와 같이 하는 것이 오버라고 생각할 수도 있다.

* 어떤 데이터 멤버는 초기화 리스트에 들어가지 않았고 그 데이터 멤버의 타입이 사용자 정의 타입이면, 컴파일러가 자동으로 그들 멤버에 대해 기본 생성자를 호출하기 때문이다.

* 하지만 기본적으로 초기화 리스트에 올려놓는 습관을 들이면, 어쩌다가 리스트에서 빼먹었을 때 어떤 멤버가 초기화되지 않아 생기는 문제를 피할 수 있다.

<br>

--------

* 기본 제공 타입 멤버가 초기화 리스트를 넣는 일이 선택이 아닌 의무가 될 수도 있다.

* `상수거나, 참조자라면 반드시 초기화해야 한다.`

  * `상수나 참조자는 대입 자체가 불가능하기 때문이다.`

* 어떤 경우에는 초기화해야 하고 어떤 경우에는 초기화를 하지 않아도 되는 그런 규칙을 외우기 보다는 그냥 멤버 초기화 리스트를 항상 사용하는 것이 편할 것이다.

<br>

**객체를 구성하는 데이터의 초기화 순서**
====

* 이 순서는 어떤 컴파일러를 막론하고 항상 같다.

```yaml
1. 기본 클래스는 파생 클래스보다 먼저 초기화 된다.

2. 클래스 데이터 멤버는 그들이 선언된 순서대로 초기화 된다.
```
* 먼저 선언된 데이터 멤버보다 나중에 선언된 데이터 멤버가 멤버 초기화 리스트의 순서에서 더 빠르다고 하더라도 나중에 선언된 데이터 멤버보다 먼저 선언된 데이터 멤버가 더 빨리 초기화된다.

<br>


**정적(static) 객체**
------

* 이제 신경 써야할 것이 하나 남았는데 그것이 `비지역 정적 객체의 초기화 순서`다.

  * `비 지역 정적 객체의 초기화 순서는 개별 번역 단위에서 정해진다.`

<br>

* 정적 객체를 살펴보면 정적 객체는 `자신이 생성된 시점부터 프로그램이 끝날 때까지 살아 있는 객체를 일컫는다.`

  * 그래서 `스택 객체 및 힙 기반 객체는 정적 객체가 될 수 없다.`

* 정적 객체의 범주에 들어갈 수 있는 것들은

```yaml
1. 전역 객체
2. 네임 스페이스 유효범위에서 정의된 객체
3. 클래스 안에서 static으로 선언된 객체
4. 함수 안에서 static으로 선언된 객체
5. 파일 유효범위에서 static으로 정의된 객체
```

* 위와 같이 총 다섯 종류가 있다.

* 이들 중 `함수 안에 있는 정적 객체는 지역 정적 객체(local static object)`라 하고 나머지는 `비지역 정적 객체(non-local static object)`라 한다.

* 이 객체들은 프로그램이 끝날 때 즉, main() 함수의 실행이 끝날 때 정적 객체의 소멸자가 호출된다.


<br>

**번역 단위**
----------

* 위에서 정적 객체의 초기화 순서를 이야기 하면서 번역 단위란 말이 나왔는데 번역 단위는 `컴파일을 통해 하나의 목적 파일(object file)을 만드는 바탕이 되는 소스 코드`를 일컫는다.

  * 여기서 `번역은 소스의 언어를 기계어로 옮긴다는 의미`이다.

* 기본적으로 소스 파일 하나가 되는데, 그 파일이 #include하는 파일들까지 합쳐 하나의 번역 단위가 된다.

<br>

* 그래서 지금 문제는 이렇게 정리된다.

* 별도로 컴파일된 소스 파일이 두 개 이상 있으며 각 소스 파일에 비지역 정적 객체(전역 객체, 네임스페이스에 있는 객체, 클래스 혹은 파일에 있는 정적 객체)가 한 개 이상 들어 있는 경우이다.

* 실제적인 문제는 `한쪽 번역 단위에 있는 비정적 객체의 초기화가 진행되면서 다른 쪽 번역 단위에 있는 비지역 정적 객체가 사용되는데 이 객체가 초기화되어 있지 않을지도 모른다는 점`이다.

  * 별개의 번역 단위에서 정의된 비지역 정적 객체들의 초기화 순서는 정해져 있지 않기 때문

<br>

**예시**
-------

* 파일 클래스로 예시를 든다.
  * 이 클래스는 주변의 모든 파일을 단일 파일 시스템처럼 보이게끔 하는 클래스로, 이런 단일 파일 시스템을 나타내는 특수한 객체가 전역 혹은 네임스페이스 유효범위에 들어 있어야 할 것이다.

```c++
class FileSystem{                   // 라이브러리에 포함된 클래스
public:
    ...
    std::size_t numDisks() const;   // 많은 멤버 함수들 중 하나
    ...
};

extern FileSystem tfs               // 사용자가 쓰게 될 객체
                                    // "tfs" = "the file system"
```

* 이제 파일 시스템 내의 디렉토리를 나타내는 클래스를 사용자가 만들었다고 가정한다.
  * 이 클래스는 tfs를 사용하는게 자연스럽다.

```c++
class Directory{        // 라이브러리의 사용자가 만든 클래스
public:
    Directory(params);
    ...
};

Directory::Directory(params)
{
    ...
    stdd::size_t disks = tfs.numDisks(); // tfs 객체를 여기서 사용함.
    ...
}
```

* 그 다음 이 사용자가 Directory 클래스를 사용해서 임시 파일을 담는 디렉토리 객체를 생성하기로 했다.

```c++
Directory tempDir( params ); // 임시 파일을 담는 디렉토리
```

* 이 때 tfs가 tempDir보다 먼저 초기화되지 않으면, tempDir의 생성자는 tfs가 초기화되지도 않았는데 접근해버린다.

  * tfs와 tempDir은 다른 소스 파일에서 만들어지고 시기도 다르다.즉, 다른 번역 단위 안에서 정의된 비지역 정적 객체이다.

<br>

**문제에 대한 방법**
------

* `이러한 문제를 해결하는 방법은 없다.`

  * `서로 다른 번역 단위에 정의된 비지역 정적 객체들 사이의 상대적인 초기화 순서는 정해져 있지 않기 때문이다.`

* 하지만 다행스러운 사실은 설계에 약간의 변화만 주면 이 문제를 사전봉쇄할 수 있다는 것이다.

* 방법은 `비지역 정적 객체를 하나씩 맡는 함수를 준비하고 이 안에 각 객체를 넣는 것`이다.

* 함수 속에서도 이들은 정적 객체로 선언하고, 그 함수에서는 이들에 대한 참조자를 반환하게 만든다.

* 사용자 쪽에서는 비지역 정적 객체를 직접 참조하지 않고 함수호출로 대신한다.

* 정리하면 `비지역 정적 객체가 지역 정적 객체로 바뀐 것이다.`

  * 디자인 패턴의 싱글톤 패턴의 전형적인 구현 양식이다.

<br>

**지역 정적 객체와 비지역 정적 객체**
--------

* 지역 정적 객체는 함수 호출 중에 그 객체의 정의에 최초로 닿았을 때 초기화되도록 만들어져 있다.
  * C++이 보장함

* 따라서 비지역 정적 객체를 직접 접근하지 않고 지역 정적 객체에 대한 참조자를 반환하는 쪽으로 바꾸었다면, 얻어낸 참조자는 반드시 초기화된 객체를 참조하도록 맞춰야 한다.

* 그리고 비지역 정적 객체 대신 준비한 지역 객체 참조자 반환 함수를 호출할 일이 없다면 해당 객체의 생성/소멸 비용도 생기지 않게 막아야 한다.

<br>

```c++
class FileSystem { ... };

FileSystem& tfs()           //tfs 객체를 이 함수로 대신 사용
{
    static FileSystem fs;   // 지역 정적 객체 정의 및 초기화
    return fs;              // 객체에 대한 참조자 반환
}

class Directory { ... };

Directory::Directory(params)
{
    ...
    stdd::size_t disks = tfs.numDisks();
    ...
}

Directory& tempDir()    // 참조자로 바뀐것 제외하고 이전과 동일
{
    static Directory td;
    return td;
}
```

* 이 기법을 도입하면서 출현한 `참조자 반환 함수`는 어느 경우든 복잡하게 구현될 일이 없다.
  * 하지만 멀티스레드가 관련된다면 문제가 생길 여지가 많다.

* 첫 줄에서 지역 정적 객체를 정의/초기화하고, 두 번째 줄에서 그 객체의 참조자를 반환하면 끝이다.


<br>

**정리**
========

* 객체가 초기화되기 전에 그 객체를 사용할 일이 생기지 않으려면 3가지를 기억해야 한다.


> 이것만은 잊지 말자!
> * 멤버가 아닌 기본제공 타입 객체는 직접 초기화
>
> * 객체의 모든 부분에 대한 초기화에는 멤버 초기화 리스트를 사용<br>
    기본적으로 멤버를 나열할 땐 데이터 멤버가 선언된 순서와 맞춰서 나열
>
> * 여러 번역 단위에 정의된 비지역 정적 객체들의 초기화 순서 문제는 피해서 설계.
    비지역 정적 객체를 지역 정적 객체로 바꿔야 한다
{: .prompt-tip }
