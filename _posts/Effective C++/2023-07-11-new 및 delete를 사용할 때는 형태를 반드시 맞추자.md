---
title: 항목16 - new 및 delete를 사용할 때는 형태를 반드시 맞추자
date: 2023-07-11
categories: [Effective C++,Effective C++]
tags: [effective c++]		# TAG는 반드시 소문자로 이루어져야함!
---

**항목16 : new 및 delete를 사용할 때는 형태를 반드시 맞추자**
=========

```c++
std::string *stringArray = new std::string[100];

...

delete stringArray;
```

* 위 코드에서 큰 문제는 없어보이지만, 위 코드처럼 작성하면 프로그램이 `미정의 동작`에 빠질 수 있다.

* 100개의 string 객체들 가운데 99개는 정상적인 소멸 과정을 거치지 못할 가능성이 크다.

  * 위 코드로는 소멸자가 99번 불릴 일이 없기 때문이다.

<br>

---------

* new 연산자를 사용해서 표현식을 꾸미게 되면(즉, new로 어떤 객체를 동적 할당하면),
  이로 인해 `두 가지의 내부 동작`이 진행된다

  * `메모리가 할당된다`

  * `그 다음, 할당된 메모리에 대해 한 개 이상의 생성자가 호출된다.`

* delete 표현식을 사용할 경우(즉, delete 연산자를 사용할 때는) 또 다른 `두 가지의 내부 동작`이 진행된다.

  * `기존에 할당된 메모리에 대해 한개 이상의 소멸자가 호출된다.`

  * `그 이후, 메모리가 해제된다.`

* 여기서 delete 연산자가 적용되는 객체가 몇개가 될까?

  * 질문의 답은 `소멸자가 호출되는 횟수`이다.

<br>

------------

* 처음의 코드에서 삭제되는 포인터는 객체 하나를 가리키는지, 아니면 객체의 배열을 가리킬까?

  * 이것이 핵심인데, 왜냐하면 `단일 객체의 메모리 배치구조(layout)는 객체 배열에 대한 메모리 배치구조와 다르기 때문이다.`

* 특히, `배열에 만들어지는 힙 메모리`에는 배열원소의 개수가 정해지는데 이 떄문에 delete 연산자는 소멸자가 몇 번 호출될지를 쉽게 알 수 있다.

* 반면에 `단일 객체용 힙 메모리`는 이런 정보가 없다.

<br>

----------------

* 어떤 포인터에 대해 delete를 적용할 때, delete 연산자로 하여금 `배열 크기 정보가 있다`는 것을 알려 주는 방법은 개발자에게 있다.

* 바로 `대괄호 쌍([])`을 `delete 뒤에 붙여 주는 것`이다.

* 그제야 delete가 `포인터가 배열을 가리키고 있다`라고 가정한다.

```c++
std::string* stringPtr1 = new std::string;

std::string* stringPtr2 = new std::string[100];

...

delete stringPtr1;      // 객체 한 개를 삭제

delete[] stringPtr2;   // 객체의 배열을 삭제
```

<br>

**stringPtr1의 delete에 []를 붙이면**
--------

* delete는 앞쪽의 메모리 몇 바이트를 읽고 이 것을 배열의 크기라고 해석한다.

* 배열의 크기에 해당하는 횟수만큼 소멸자를 호출하는데 메모리가 null에서 delete하면서 에러가 발생한다

<br>

**stringPtr2의 delete[]에서 []를 없애면**
--------

* 소멸자 호출 횟수가 적어서 메모리 누출이 발생한다.

<Br>

**결론**
--------------

* `new 표현식에 []를 썼으면 delete 표현식에도 []를 사용하고 new 표현식에 []가 없으면 delete 표현식에도 []를 없애면 된다.`

<br>

**주의할 점**
-----------

* 동적 할당된 메모리에 대한 포인터를 멤버 변수로 갖고 있는 클래스를 작성 중이라면,생성자가 여러 개일 경우 더욱 중요하다

  * 왜냐하면 `포인터 멤버를 초기화하는 부분인 생성자에서 new 형태를 똑같이 맞출 수 밖에 없기 떄문이다`

<br>

--------

* 이 규칙은 typedef에서도 알아두면 좋다.

* typedef로 정의된 어떤 타입의 객체(배열)를 메모리에 생성하려고 new를 썼을 때 나중에 어떤 형태의 delete를 적어 줘야 하는지에 대한 언급은 해당 작성자가 책임져야 한다.

```c++
typedef std::string AddressLines[4];    // 주소는 4줄이고 각각 string

std::string *pal = new AddressLines;    // new AddressLines는 string*를
                                        // 반환한다.
```

* delete 역시 배열 형태가 되어야 제대로 작동한다

```c++
delete pal;         // 미정의 동작
delete [] pal;      // 정상 작동
```

* 배열 타입을 typedef 타입으로 만들지 않는 것이 복잡해지지 않는다.
  * 대신 C++ 라이브러리에 있는 string이나 vector같은 클래스 템플릿으로 작성하는 것이 훨씬 간편하고 안전하다

  * 위 예제의 AddressLines는 vector\<string>으로 표현된다.


> 이것만은 잊지 말자!
> * new 표현식에 []를 썼으면, 대응되는 delete 표현식에도 []를 써야한다.<Br>
>   new 표현식에 []를 안 썼으면, 대응되는 delete 표현식에도 []를 안 써야한다.
{: .prompt-tip }
