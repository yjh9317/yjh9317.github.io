---
title: 멤버 함수보다는 비멤버 비프렌드 함수와 더 가까워지자
date: 2023-07-19
categories: [Effective C++,Effective C++]
tags: [effective c++]		# TAG는 반드시 소문자로 이루어져야함!
---

**항목23 : 멤버 함수보다는 비멤버 비프렌드 함수와 더 가까워지자**
=================

* 웹브라우저를 나타내는 클래스가 하나 있다고 가정한다

```c++
class WebBrowser {

public:
    // 다운로드한 파일들을 임시 저장한 캐시를 비우는 함수
    void clearCache();
    // 방문한 URL의 기록을 없애는 함수
    void clearHistory();
    // 시스템이 갖고 있는 쿠키를 전부 제거하는 함수
    void removeCookies();
};
```

* 사용자 중에는 이 세 함수를 한 번에 하고 싶은 사람도 있어 세 함수를 모아서 불러주는 함수도 준비한다

```c++
class WebBrowser{

public:
    ...
    void clearEverything(); // 위 3 함수를 전부 호출
};
```

* 이 기능은 비멤버로 제공해도 된다.

* 웹브라우저 객체의 멤버 함수를 순서대로 호출만 하면 된다

```c++
void clearBrowser(WebBrowser& wb)
{
    wb.clearCache();
    wb.clearHistory();
    wb.removeCookies();
}
```

* `그러면 멤버 함수인 clearEverything() 함수와 비멤버 함수인 clearBrowser() 함수 둘 중 어느 것이 괜찮을까?`

<br>

**비멤버 함수 vs 멤버 함수**
----------------

* 객체 지향 법칙에 관련된 이야기를 찾아보면 데이터와 그 데이터를 기반으로 동작하는 함수는 한 데 묶여 있어야 하며, 멤버 함수가 더 낫다고 한다

* 하지만 이 이야기는 객체 지향 방법이 무엇인가에 대해 제대로 이해하지 못해서 나오는 제안이다.

* `객체 지향 법칙은 할 수 있는 만큼 캡슐화하라고 이야기하고 있다.`

* 그러나 `멤버 버전인 clearEverything() 함수가 비멤버 버전인 clearBrowser() 함수보다 캡슐화 정도에서 형편없다`

* 이것 말고도 `비멤버 함수를 사용하면` WebBrowser 관련 기능을 구성하는데 있어 `패키징 유연성(packaging flexibility)이 높아지는 장점`이 있고, 이로 인해 추가적인 이점으로는 `컴파일 의존도도 낮추고 WebBrowser의 확장성도 높일 수 있다`


<br>

**비멤버 함수가 멤버 함수보다 더 나은 이유**
-----------

* 이야기는 캡슐화부터 시작되는데 어떤 것을 캡슐화하면, 외부에서 이것을 볼 수 없게 된다

* 밖에서 볼 수 있는 것들이 줄어들면, 그것들을 바꿀 때 필요한 비용이 작아진다
  * 변경 자체가 영향을 줄 수 있는 범위가 '변경된 것을 볼 수 있는 것들'로 한정되기 때문

* 캡슐화되는 것들이 많아지면, 그것들을 변경할 수 있는 여유도 많아진다

* 즉, `이미 있는 코드를 바꾸더라도 제한된 사용자들밖에 영향을 주지 않는 융통성을 확보할 수 있다는 뜻이다`

<br>

----------

* 어떤 객체의 모습을 그 객체의 데이터로 설명할 수 있다고 생각한다.

* 이 데이터를 직접 볼 수 있는(접근할 수 있는) 코드가 적으면 적을수록 그 데이터는 많이 캡슐화된 것이고, 그 객체가 가진 데이터의 특징을 바꿀 수 있는 자유도가 그만큼 높은 것이다

  * 데이터의 특징이라면 데이터 멤버의 개수, 타입 등등

* 어떤 데이터를 접근하는 함수가 많으면 그 데이터의 캡슐화 정도는 낮다는 이야기이다.

<br>

----------

* 항목22를 보면 데이터 멤버는 private 멤버이어야 한다는 이야기를 서술했다.

  * private 멤버가 아니면 데이터를 접근할 수 있는 함수의 개수를 프로그래머의 손으로 어떻게 제한할 수 없기 때문

* private 멤버로 되어 있는 경우, 여기에 접근할 수 있는 함수의 개수는 예측이 쉽다.

  * **클래스 멤버의 함수의 개수** + **프렌드 함수의 개수**

  * private 멤버는 멤버 함수 및 프렌드 함수만 접근할 수 있음

<br>

----------

* 똑같은 기능을 제공하는데 `멤버 함수(클래스의 private 데이터 멤버뿐만 아니라 private 멤버로 되어 있는 다른 함수)`를 쓸 지,<br>
  아니면 `비멤버 비프렌드 함수(어느 것도 접근할 수 없는)`를 쓸지에 대해 다시 생각해본다.

* 캡슐화를 생각하면 후자일 것이다.

* 왜냐하면 `비멤버 비프렌드 함수는 어떤 클래스의 private 멤버 부분을 접근할 수 있는 함수의 개수를 늘리지 않기 때문이다`


<br>


**주의해야 할 부분**
===========

### 첫번 째, 이 이야기는 비멤버 비프렌드(non-friend) 함수에만 적용된다
------------------

* 프렌드 함수는 private 멤버에 대한 접근 권한이 해당 클래스의 멤버 함수가 가진 권한과 똑같기 때문에 캡슐화에 대한 영향 역시 같다

* 캡슐화라는 관점에서 보았을 때, 위의 선택은 멤버 함수와 비멤버 함수사이의 선택이 아니라 <br>`멤버 함수와 비멤버 '비프렌드' 함수 사이의 선택`이다.

  * 물론 캡슐화만의 관점이 아니다.
  * 항목24를 보면 암시적 타입 변환의 관점에서 멤버 함수 및 비멤버 함수 중 하나를 고르는 이야기가 나온다

<br>

### 두 번째, 캡슐화에 대해서 "함수는 어떤 클래스의 비멤버가 되어야 한다"는 주장은 "그 함수는 다른 클래스의 멤버가 될 수 없다"라는 의미가 아니다
----------------

* clearBrowser같은 함수가 WebBrowser 클래스의 멤버(혹은 프렌드)가 아니기만 하면 된다.

  * WebBrowser가 가진 private 멤버의 캡슐화에 영향을 주지 않는다는 점이 더 중요하기 때문

* C++로는 더 자연스럽게 구현할 수 있다.

* `clearBrowser를 비멤버 함수로 두되, WebBrowserStuff와 같은 네임스페이스안에 두는 것이다.`

```c++
namespace WebBrowserStuff{

    class WebBrowser { ... };

    void clearBrowser(WebBrowser& wb);

    ...
}
```

* 사실 이 코드는 자연스러움보다 몇걸음 더 나아간 방법이다.

* 왜냐하면 네임스페이스는 클래스와 달리 여러 개의 소스 파일에 나뉘어 흩어질 수 있기 때문이다.


<br>

---------

* WebBrowser처럼 응용도가 높은 클래스는 이런 종류의 편의 함수가 꽤 많이 생길 수 있다.

  * 즐겨찾기(bookmark)에 관련된 함수라든지, 인쇄에 관련된 함수라든지, 쿠키 관리용 함수 등등도 가능하다

* 일반적인 경우에, 왠만한 사용자라면 편의 함수중 몇 개만 알거나 관심을 둔다

* 이것들을 나누어 놓는 쉽고 깔끔한 방법은, 즐겨찾기 관련 편의 함수를 하나의 헤더파일에 몰아서 선언하고, <br> 쿠키 관련 편의 함수는 다른 헤더파일에 몰아서 선언하고,<br> 인쇄 관련 편의 함수는 제 3의 헤더에 몰아서 선언하는 것이다.
  * `즉, 기능을 분류하여 헤더파일에 나누어서 선언하는 것`

```c++
// "webbrowser.h" 헤더 -> WebBrowser 클래스 자체에 대한 헤더
// 그리고 WebBrowser에 관련된 '핵심' 기능들이 선언되어 있음
namespace WebBrowserStuff{

    class WebBrowser { ... };

    ...                 // '핵심' 관련 기능
                        // 거의 모든 사용자가 써야 하는 비멤버 함수들이 여기에 들어간다
}


// "webborwserbookmarks.h" 헤더
namespace WebBroswerStuff{

    ...                  // 즐겨찾기 관련 편의 함수들이 여기에 들어간다
}


// "webborwsercookies.h" 헤더
namespace WebBroswerStuff{

    ...                  // 쿠키 관련 편의 함수들이 여기에 들어간다    
}
```

* 표준 C++ 라이브러리가 이러한 구조로 구성되어 있다

* std 네임스페이스에 속한 모든 것들이 \<C++StandardLibrary\> 헤더 같은 것들이 모조리 들어가 한통으로 섞여 있지 않고, 몇 개의 기능과 관련된 함수들이 수십개의 헤더(\<vector\>, \<algorithm\>,\<memory\>등)에 흩어져 선언되어 있다.

* vector기능만 필요한 사람은 \<memory\>를 #include할 필요가 없으며, list를 사용하지 않는 사용자는 \<list\>를 #include할 필요가 없다

* 이렇게 하면 `사용자가 실제로 사용하는 구성요소에 대해서만 컴파일 의존성을 고려할 수 있게  된다`

  * 항목31에서 컴파일 의존성을 줄이는 다른 방법들을 기술

* 반면 클래스 멤버 함수로 오게되면 이야기가 달라진다.

* 이런식으로 기능을 쪼개는것 자체가 불가능해진다.

* 하나의 클래스는 그 전체가 통으로 정의되어야 하고 여러 조각으로 나눌 수가 없기 때문이다.

<br>

--------

* `편의 함수 전체를 여러 개의 헤더파일에(그러나 하나의 네임스페이스에) 나누어 놓으면 편의 함수 집합의 확장도 손쉬워진다.`

* 해당 네임스페이스에 비멤버 비프렌드 함수를 원하는 만큼 추가해 주기만 하면 그게 확장이다.

* 예를 들어, WebBrowser를 잘 쓰고 있는 사용자가 어쩌다 다운로드 이미지에 관련된 편의 함수를 만들어야 하겠다고 작정했다면,<br>헤더 파일 하나를 새로 선언 후 WebBrowserSutff 네임스페이스를 그 안에 관련 함수의 선언문만 끼워 넣으면 끝이라는 소리다.

* 이렇게 새로 추가된 함수는 기존의 다른 편의 함수들처럼 지금 바로 사용할 수 있고<br>WebBrowserStuff의 구성요소로 바로 합쳐진다.

<br>

* 이런 부분은 클래스로는 제공이 불가능한 기능이다.

  * 클래스 정의 자체를 사용자가 확장할 수 없기 때문

* 새로운 클래스를 파생시킬 수 있지만 파생 클래스는 기본 클래스 안에 캡슐화된(다시 말해 private) 멤버에 대한 접근권한이 없기 때문에 애매하다

* 게다가 항목7에서도 말했다싶이, 모든 클래스가 기본 클래스로 쓸 용도로 설계된 것은 또한 아니다

<br>


# 결론


> 이것만은 잊지 말자!
> * 멤버 함수보다는 비멤버 비프렌드 함수를 자주 쓰도록 하자.<br>
>   캡슐화 정도가 높아지고, 패키징 유연성도 커지며, 기능적인 확장성도 늘어난다.
{: .prompt-tip }
