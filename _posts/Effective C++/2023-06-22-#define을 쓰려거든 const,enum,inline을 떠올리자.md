---
title: #define을 쓰려거든 const,enum,inline을 떠올리자
date: 2023-06-22
categories: [Effective C++,Effective C++]
tags: [effective c++]		# TAG는 반드시 소문자로 이루어져야함!
---

**항목2 : #define을 쓰려거든 const,enum,inline을 떠올리자**
=======================

* 제목에서 말하고 싶은 것은 `선행 처리자보다 컴파일러를 더 가까이 하자`이다.

<br>

**예시**
--------

```c++
#define ASPECT_RATIO 1.653
```

* 위와 같은 예시에서 우리에게는 `ASPECT_RATIO`가 `기호식 이름(symbolic name)`으로 보이지만 컴파일러에게는 보이지 않는다.

    * `소스 코드가 어떻든 컴파일러에게 넘어가기 전에 선행처리자가 밀어버리고 숫자 상수로 바꿔버리기 때문`

    * 그 결과로, ASPECT_RATIO라는 이름은 컴파일러가 쓰는 기호 테이블에 들어가지 않는다.

<br>

------------------

* 그래서 숫자 상수로 대체된 코드에서 컴파일 에러가 발생한다면 꽤 곤란해 질 수 있다.

    * 소스 코드엔 ASPECT_RATIO가 있지만 에러메세지에는 1.653이 있기 때문

    * 1.653이라는 상수가 어디서 왔는지도 찾아야 해서 시간이 허비될 수 있다.

    * 기호 테이블에 들어가지 않기 때문에 `기호식 디버거(symbolic debugger)`에도 이 문제가 나타날 수 있다.

<br>

----------------

* 이 문제의 해결법은 `매크로 대신 상수를 사용`하는 것이다.

```c++
// 대문자로 표기하는 이름은 보통 매크로에 사용하기에 이름 표기도 변경
const double AspectRatio = 1.653; 
```

* AspectRatio는 상수 타입의 데이터이기 때문에 컴파일러의 눈에도 보이며 기호 테이블에도 들어간다.

* 그리고 상수가 부동소수점 실수 타입일 경우에는 컴파일을 거친 최종 코드가 #define을 썼을 때보다 작게 나올 수 있다.

    * 그 이유는 매크로를 쓰면 코드에 ASPECT_RATIO가 등장할 때마다 선행 처리자(define)에 의해 상수(1.653)으로 바꾸면서 사본이 등장 횟수만큼 들어가지만, 상수 타입의 AspectRatio는 여러번 쓰이더라도 사본은 딱 한 개만 생기기 때문

<br>

---------------------

* #define을 상수로 교체할 때는 두 가지 유의할 점이 있다.

* 첫 째는 `상수 포인터(constant pointer)를 정의하는 경우`이다.

    * 상수 정의는 대게 헤더 파일에 넣는 것이 상례이므로(다른 소스 파일이 이것을 인클루드해서 사용함) 포인터는 꼭 const로 선언해 줘야 하고, 포인터가 가리키는 대상까지 const로 선언하는 것이 보통이다.

    * 이를테면 어떤 헤더 파일 안에 char* 기반의 문자열 상수를 정의한다면 다음과 같이 const를 두번 사용해야 한다.

    ```c++
    const char* const authorName = "Scott Meyers";
    // const의 의미와 사용법에 대한 자세한 사항은 항목3에 기재
    ```

* char* 기반의 문자열 보다는 string 객체가 정의하기에 더 좋다.

    ```c++
    const std::string authorName("Scott Meyers");
    ```

<br>

* 두 번째는 클래스 멤버로 상수를 정의하는 경우,즉 `클래스 상수를 정의하는 경우`이다.

    * 어떤 상수의 유효범위를 클래스로 한정하고자 할 땐 그 상수를 멤버로 만들어야 하는데, 그 상수의 `사본 개수를 한 개만 갖고 싶게 하려면 정적(static) 멤버로 만들어야 한다.`


```c++
class GamePlayer{
private:
    static const int NumTurns = 5;  // 상수 선언
    int scores[NumTunrs];           // 상수를 사용하는 부분
};
```

* 위에 있는 NumTurns는 정의가 아닌 `선언`이다.

* C++에서 사용하려는 것에 대해 정의를 하지만, `정적 멤버로 만들어지는 정수류(각종 정수 타입, char, bool 등) 타입의 클래스 내부 상수는 예외`이다.

  * 이들에 대해 주소를 취하지 않는 한, 정의 없이 선언만 해도 아무 문제가 없게 되어 있다.

  * 단, 클래스 상수의 주소를 구한다든지, 주소를 구하지 않는데도 컴파일러가 잘못 만들어진 관계때문에 주소를 요구하는 경우에는 별도의 정의를 제공해야 한다.

  ```c++
  // NumTurns의 정의
  const int GamePlayer::NumTurns;    
  ```

<br>

* 이 떄 클래스 상수의 정의는 헤더 파일에 두지 않고 구현 파일에 둔다.

  * 정의에는 상수의 초기값이 있으면 안되는데, `클래스 상수의 초기값은 해당 상수가 선언된 시점에 바로 주어지기 때문이다.`(즉, NumTunrs는 선언될 당시에 바로 초기화된다는 것이다.)

<br>

> 매크로는 일단 정의되면 컴파일이 끝날 때까지(중간에 #undef되지만 않으면) 유효하다
> 정리하면, #define은 클래스 상수를 정의하는 데 쓸 수 없을 뿐만 아니라 어떤 형태의 캡슐화 혜텍도 받을 수 없다.
> 즉, private 성격의 #define 같은 것이 없다는 이야기
{: .prompt-tip }


<br>

---------------------------

* 오래된 컴파일러는 위의 문법을 받아들이지 않는 경우가 종종 있다.

    * 이유는 정적 클래스 멤버가 선언된 시점에 초기값을 주는 것이 맞지 않다고 판단하기 때문

    * 게다가 클래스 내부 초기화를 허용하는 경우가 정수 타입의 상수에 대해서만 국한되어 있기 때문

* 위의 문법이 먹히지 않는 컴파일러라면, 초기값을 상수 '정의' 시점에 주도록 신경써야 한다.

```c++
// 
classs CostEstimate{
private:
    static const double FudgeFactor;    // 정적 클래스 상수의 선언
                                        // 헤더 파일에 둔다.
    ...                                        
};

const double
    CostEstimate::FudgetFactor = 1.35;
```
<br>

--------

* 웬만한 경우라면 충분하지만, 한 가지 예외가 있다면 해당 클래스를 컴파일하는 도중에 클래스 상수의 값이 필요할 때인데, 이를테면 GamePlayer::scores 등의 배열 멤버를 선언할 때가 대표적인 예이다.(컴파일러는 컴파일 과정에서 배열의 크기을 알아야 함)

* 그렇기 때문에 정수 타입의 정적 클래스 상수에 대한 클래스 내 초기화를 금지하는 구식 컴파일러에 대한 괜찮은 방법을 추천한다면, `나열자 둔갑술(enum hack)`이라는 기법을 생각할 수 있다.

  * 이 기법의 원리는 `나열자(enumerator) 타입의 값은 int가 놓일 곳에도 쓸 수 있다는 점`이다.


```c++
class GamePlayer{
private:
    enum {NumTurns = 5};    // 나열자 둔갑술
                            // NumTurns를 5에 대한 기호식 이름으로 만듦

    int scores[NumTurns];   // 배열의 크기 해결
};
```

* 이 나열자 둔갑술를 알아두면 좋은점은 다음과 같다.

* 첫 번째로 `동작 방식이 const보다는 #define에 가깝다.`

  * const의 주소를 취할순 있지만, enum의 주소를 취할 수 없다.

* 두 번째로 `템플릿 메타프로그래밍의 핵심 기법`이기도 하다.

<br>

--------------------

* #define의 다른 오용 사례는 매크로 함수이다.

* 함수처럼 보이지만 함수 호출 오버헤드를 일으키지 않는 매크로를 구현하는 것이다.

```c++
// a와 b 중에 큰 것을 f에 넘겨 호출
#define CALL_WITH_MAX(a,b) f((a)>(b) ? (a) : (b))
```

* 이런 매크로를 작성할 때는 반드시 괄호를 씌워주는 센스를 잊지 말아야 한다.

* 하지만 괄호 처리를 한다고 해도 문제는 발생한다.

```c++
int a = 5, b = 0;

// a가 두 번 증가(비교하면서 한번, 결과값으로 한번)
CALL_WITH_MAX(++a,b);       

// a가 한 번 증가
CALL_WITH_MAX(++a,b+10);    
```

<br>

---------------

* C++에서는 함수 호출을 없애 준다는 명목하에 발생하는 문제점을 해결할 수 있다.

* 기존 매크로의 효율을 그대로 유지하면서 정규 함수의 모든 동작방식 및 타입 안정성까지 완벽히 취하는 방법인 `인라인 함수에 대한 템플릿`을 준비하는 것이다.

```c++
// T가 정확히 무엇인지 모르기 때문에 매개변수로 상수 객체에 대한 참조자를 쓴다.
template<typename T>
inline void callWithMax(const T& a, const T& b)
{
    f(a > b ? a : b);
}
```

* 이 함수는 템플릿이기 때문에  family of functions를 만들어낸다.

* 동일한 타입의 객체 두 개를 인자로 받고 둘 중 큰 것을 f에 넘겨서 호출하는 구조이다.


<br>

-----------


> 이것만은 잊지 말자!
> * 단순한 상수를 슬 때는 #define보다 const 객체 혹은 enum을 우선 생각하자.
> * 함수처럼 쓰이는 매크로를 만들려면, #define 매크로보다 인라인 함수를 우선 생각하자.
{: .prompt-tip }