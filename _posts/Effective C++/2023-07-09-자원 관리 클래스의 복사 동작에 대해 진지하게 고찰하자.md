---
title: 항목14 - 자원 관리 클래스의 복사 동작에 대해 진지하게 고찰하자
date: 2023-07-09
categories: [Effective C++,Effective C++]
tags: [effective c++]		# TAG는 반드시 소문자로 이루어져야함!
---

**항목14: 자원 관리 클래스의 복사 동작에 대해 진지하게 고찰하자**
==============

* 항목 13에서 봤듯이 힙에서 생성한 자원은 shared_ptr같은 스마트포인터를 이용하여 처리했지만, 힙에서 생기지 않는 자원은 스마트 포인터로 처리하기엔 알맞지 않다.

* 항상 그런것은 아니지만, 자원 관리 클래스를 스스로 만들어야 할 필요가 느끼는 경우가 이러한 경우다.

<br>

---------

* 예시로, Mutex 타입의 뮤텍스 객체를 조작하는 C API를 사용한다고 가정한다.


```c++
void lock(Mutex* pm);   // pm이 가리키는 뮤텍스에 잠금

void unlock(Mutex* pm); // pm이 가리키는 해당 뮤텍스에 잠금을 푼다
```

* 뮤텍스 잠금 관리 클래스를 만들어 이전에 걸어놓은 뮤텍스 잠금을 잊지 않고 풀어줄려고 하려 한다.

  * 이런 용도의 클래스는 기본적으로 RAII 법칙을 따라 구성한다.

  * 즉, 생성 시에 자원을 획득하고, 소멸 시에 그 자원을 해제하는 것이다.


```c++
class Lock
{
public:
    ‌explicit Lock(Mutex* pm)
    ‌‌: mutexPtr(pm)
    ‌{ 
        ‌‌lock(mutexPtr); //자원 획득
    ‌} 

    ‌~Lock()
    ‌{
        ‌‌unlock(mutexPtr); //자원 해제
    ‌}

private:
    ‌Mutex* mutexPtr;
};
```

* 사용자는 Lock을 사용할 때 RAII 방식에 맞춰 사용하면 된다.


```c++
Mutex m;

...

{                   // 임계 영역을 위한 블럭

    Lock m1(&m);    //  뮤텍스 잠금

    ...             // 임계 영역에서 할 연산 수행

}                   // 뮤텍스 잠금풀림
```

* 위 코드는 잘 작동될 거 같지만, Lock 객체가 복사된다면 어떻게 될까?


```c++
Lock m1(&m);   
Lock m2(m1); //복사 생성자
```

* 위 예시로 말하고자 싶은 것은 `RAII 객체가 복사될 때 어떤 동작이 이루어져야 할까?`이다.


<br>

**RAII 객체 복사할 때 동작**
-----------

**첫 번째**
------------

* `복사를 금지한다.`

  * 복사를 막는 방법은 항목 6을 참고로 하면 되는데, 결론은 `복사 연산(함수)를 private 멤버로 만드는 것이다.`

```c++
class Lock : private Uncopyable {
public:
    ...
};
```

<br>

**두 번째**
--------------

* `관리하고 있는 자원에 대해 참조 카운팅을 수행한다`

  * `자원을 사용하고 있는 마지막 객체가 소멸될 때까지 그 자원을 없애지 않는게 바람직한 경우도 있다.`

    * 이러한 경우는 `해당 자원을 참조하는 객체의 개수에 대한 카운트를 증가시키는 식으로 RAII 객체의 복사 동작을 만들어야 한다.`

    * 이러한 방식을 사용할 때는 shared_ptr를 사용한다

<br>

----------

* 자신의 RAII 클래스에 참조 카운팅 방식의 복사 동작을 넣고 싶을 때 tr1::shared_ptr을 데이터 멤버로 넣는다고 해결되지 않는다.

  * Lock이 참조 카운팅 방식으로 돌아가게 하기 위해, mutexPtr의 타입을 shared_ptr\<Mutex>로 바꾸는 것은 좋지 않다.

  * 참조 카운팅이 0이 될 때 가리키고 있는 대상을 삭제해버리기 때문에 원하는 바와 다소 어긋난다.


<br>


--------


* 다행스러운 점은 shared_ptr이 `삭제자(delete)` 지정을 허용한다는 사실이다.

  * `삭제자란, tr1::shared_ptr이 유지하는 참조 카운트가 0이 될 때 호출되는 함수 혹은 객체를 의미`

```c++
class Lock
{
public:
    ‌explicit Lock(Mutex* pm)     
        ‌‌: mutexPtr(pm, unlock)  // shared_ptr을 초기화하기 위해 가리킬 포인터로 
        ‌{                       // Mutex객체의 포인터를 사용하고 삭제자로 unlock 함수를 사용
            ‌‌lock(mutexPtr.get());   // get은 항목15에서 기술
        ‌} 

private:
    ‌tr1::shared_ptr<Mutex> mutexPtr;    // 원시 포인터 대신 shared_ptr 사용
};
```
* 위 코드에서 눈여겨볼 점은 Lock 클래스가 이제는 소멸자를 선언하지 않는다는 점이다.

  * 이유는 클래스의 소멸자는 비정적 데이터 멤버의 소멸자를 자동으로 호출하기 때문에 mutexPtr의 참조 카운팅이 0이 되면 자동으로 호출하기 때문이다.


<br>

**세 번째**
----------

* `관리하고 있는 자원을 진짜로 복사한다.`

  * 자원 관리 객체를 복사하면 그 객체가 둘러싸고 있는 자원까지 복사되어야 한다. 즉 `깊은 복사(deep copy)`를 수행해야 한다.

  * 표준 string 타입을 보면 문자열을 구성하는 원소들을 힙 메모리에 저장해 놓고, 이 메모리에 대한 포인터를 데이터 멤버로 갖고 있다.

  * string 타입으로 생성한 객체는 결국 힙 메모리를 포인터로 물고 있는 형태가 되는데 이때 이 객체를 복사하면 사본은 포인터 및 그 포인터가 가르키는 (새로운) 힙 메모리를 갖게 된다.



<br>

**네 번째**
--------

* `관리하고 있는 자원의 소유권을 옮긴다`

  * `어떤 특정한 자원에 대해 자원을 실제로 참조하는 RAII 객체는 딱 하나만 존재하게 만들고 싶어 RAII 객체가 복사될 때, 자원의 소유권을 사본으로 완전 옮기는 경우이다.`

  * 이런 스타일의 복사는 항목 13의 auto_ptr 복사 동작이다.

<br>


> 이것만은 잊지 말자!
> * RAII 객체의 복사는  그 객체가 관리하는 자원의 복사 문제를 안고 가기 때문에, 그 자원을 어떻게 복사하느냐에 따라 RAII 객체의 복사 동작이 결정된다.
> 
> * RAII 클래스에 구현하는 일반적인 복사 동작은 복사를 금지하거나 참조 카운팅을 해 주는 선에서 마무리한다.<br>
> 그 이외의 방법도 가능하다
{: .prompt-tip }