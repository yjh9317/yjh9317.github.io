---
title: 항목7: 다형성을 가진 기본 클래스에서는 소멸자를 반드시 가상 소멸자로 선언하자
date: 2023-06-30
categories: [Effective C++,Effective C++]
tags: [effective c++]		# TAG는 반드시 소문자로 이루어져야함!
---

**항목7 : 다형성을 가진 기본 클래스에서는 소멸자를 반드시 가상 소멸자로 선언하자**
==========

**예시**
-------


* 시간을 기록하는 기본 클래스를 만들고 적절한 용도에 따라 파생 클래스를 설계하는 걸로 예시를 든다.

```c++
class TimeKeeper
{
public:
    ‌TimeKeeper();
    ‌~TimeKeeper();
};

class AtomicClock : public TimeKeeper { }; // TimeKeeper의 파생 클래스
class WaterClock : public TimeKeeper { }; // TimeKeeper의 파생 클래스
class WristWatch : public TimeKeeper { }; // TimeKeeper의 파생 클래스
```

* 이 클래스를 사용하고 싶은 사용자들은 시간 정보에 접근하고 싶어하는데, `어떤 시간기록 객체에 대한 포인터를 손에 넣는 용도로 팩토리 함수를 만들어 사용한다고 한다.`

```c++
// 파생 클래스를 동적으로 할당된 객체의 포인터로 반환
TimeKeeper* getTimeKeeper();
```

* 동적 할당으로 받은 메모리는 힙에 있으므로, 메모리 및 기타 자원의 누출을 막기 위해 해당 객체를 적절히 삭제해야 한다.

```c++
// TimeKeeper 계통 클래스를 동적 할당으로 객체 생성
TimeKeeper* ptk = getTimeKeeper(); 

...

delete ptk;     // 삭제
```

<br>

**문제**
------------------------

* 그런데 이렇게 사용한다면 다음과 같은 문제가 생긴다.
 
```yaml
1. getTimeKeeper() 함수`가 반환하는 포인터가 `파생 클래스 객체에 대한 포인터라는 점

2. 이 포인터가 가리키는 객체가 삭제될 때는 기본 클래스 포인터를 통해 삭제된다는 점

3. 기본 클래스에 들어 있는 소멸자가 비가상 소멸자(non-virtual destructor)라는 점
```

* C++ 규정에 의하면, `기본 클래스 포인터를 통해 파생 클래스 객체가 삭제될 때 그 기본 클래스에 비가상 소멸자가 들어 있으면 프로그램 동작은 미정의 사항이라고 되어 있다.`

<br>

**해결**
------------


* 이 문제를 해결하기 위해서는, `기본 클래스에서 가상 소멸자를 사용하는 것이다.`

  * 그러면 파생 클래스 객체를 기본 클래스 포인터로 삭제할 때 원하는 대로 동작한다.

```c++
class TimeKeeper
{
public:
    ‌TimeKeeper();
    ‌virtual ~TimeKeeper(); //virtual 소멸자 사용
};
```

* 소멸자말고도 기본 클래스에 가상 함수들도 파생 클래스에 맞게 구현하기 위해서 다형성(virtual)을 사용해야 한다.

<br>


**vptr(가상 함수 테이블)**
-------------------

* `가상 소멸자를 갖고 있지 않은 클래스는 상속으로 사용할 클래스가 아니라고 생각하는 것`이라고 보면 된다.

* 입장을 바꿔 `기본 클래스로 의도치 않은 클래스에 대해 소멸자를 가상으로 선언 하는 것 역시 좋지 않은 행동이다.`

```c++
class Point     // 2D 공간의 한 점
{
public:
    ‌Point(int xCoord, int yCoord);
    ‌~Point();

private:
‌int x, y;
};
```

* int가 32비트를 차지한다고 가정하면, 이 Point 객체는 64비트 레지스터에 맞게 들어간다.

* 그리고 C등 다른 언어로 작성된 함수에 넘길 일이 생겨도 64비트 크기의 자료로 넘어갈 것이다.

* 그런데 `Point 클래스의 소멸자가 가상 소멸자로 만들어진 순간, 사정이 변한다`

<br>

--------------

* 가상 함수를 C++에서 구현하려면 클래스에 별도의 자료구조가 하나 들어가야 한다.

* 이 자료구조는 `vptr(가상 함수 테이블)`이라고 불리는 것으로, `프로그램 실행 중에 주어진 객체에 대해 어떤 가상 함수를 호출해야 하는지를 결정하는데 사용하는 정보가 담겨 있지만, 실제로는 포인터의 형태를 취한다.`


* `vptr`은 `가상 함수의 주소, 즉 포인터의 배열`을 가리키고 있으며 `가상 함수 테이블 포인터의 배열`은 `vtbl(가상 함수 테이블)`이라고도 불린다.

  * `가상 함수를 하나라도 갖고 있다면 반드시 그와 관련된 vtbl을 가지게 된다.`

* `어떤 객체에 대해 어떤 가상 함수가 호출되려고 하면, 호출되는 실제 함수는 그 객체의 vptr이 가리키는 vtbl에 따라 결정된다.`

<br>

-----------------

* 결론은 Point 클래스에 가상 함수가 들어가면 Point 타입 객체의 크기가 커진다.

* 32비트면 vptr의 크기가 32비트이고, 64비트면 vptr의 크기가 64비트이다.
  * vptr도 결국 포인터이므로 포인터의 크기만큼 커지는 것

* 그리고 C등 다른 언어로 선언된 동일한 자료구조와도 호환성이 없어진다.
  * 다른 언어로 Point클래스와 동일하게 만들어도 vptr은 만들 수 없기 때문이다.

* 결국 다른 언어면, vptr 부분을 보충해야 하는데 구현 환경에 따라 세부 사항이 달라지는 문제기 때문에 이식성에 대한 기대는 접는 것이 좋다.


<br>

**정리**
----------------

* 소멸자를 전부 virtual로 선언하는 일은 virtual로 절대 선언하지 않는 것 만큼이나 좋지 않다.

* `가상 소멸자를 선언하는 것은 가상 함수가 하나라도 있을 때만 선언하는 것이 좋다.`

* 가상 함수가 전혀 없어도 비가상 소멸자때문에 문제가 생기는 경우도 있다.

<br>

**비가상 소멸자때문에 생기는 문제**
---------

* string 타입은 가상 함수를 갖고 있지 않지만, string을 기본 클래스로 만들어 문제가 생기는 경우가 있다.

```c++
// string은 가상 소멸자가 없다!
class SpecialString : public : std::string { };
```

* 이 SpecialString의 포인터를 string 포인터로 어떻게 변환한 후, 그 string 포인터에 delete를 적용하면 그 순간 미정의 동작이 되어버린다

```c++
SpecialString* pss = new SpecialString("Impending Doom");
std::string* ps;

...

ps = pss; // SpecialString* -> std::string*

...

​​​​​​​​​​//string의 소멸자만 호출되고 SpecialString의 소멸자는 호출되지 않아 
// SpecialString쪽이 삭제되지 않는다!
delete ps; 
​
```

* 이 현상은 가상 소멸자가 없는 클래스면 어디서든 전부 적용된다.

  * STL타입 vector,list,set,unordered_map등이 여기에 해당된다.

<br>

**순수 가상 소멸자**
--------

* 경우에 따라서 `순수 가상 소멸자`를 두면 편리하게 사용할 수 있다.

  * 순수 가상 함수 클래스는 `추상 클래스`로 만들어진다.

* 어떤 클래스가 추상 클래스면 좋겠지만, 마땅히 넣을 만한 순수 가상 함수가 없을 때도 있다.

  * 추상 클래스는 기본 클래스로 쓰일 목적으로 만들어지고 기본 클래스로 쓰이려는 클래스는 가상 소멸자를 가져야 한다.

* 즉, `추상 클래스로 만들고 싶은 클래스에 순수 가상 소멸자를 선언하면 된다!`

```c++
class AWOV
{
public:
    ‌virtual ~AWOV() = 0; //순수 가상 소멸자 선언
};
```

* AWOV 클래스는 순수 가상 함수를 갖고 있으므로 추상 클래스이고, 동시에 순수 가상 함수가 가상 소멸자이므로, 소멸자로 인한 호출 문제도 고민할 필요가 없다.

* 그런데 주의할 점은, `순수 가상 소멸자의 정의를 두지 않으면 안된다는 것이다.`

```c++
AWOV::~AWOV() {}
```

* 소멸자가 동작하는 순서는 이렇다.

```yaml
1. 가장 말단에 있는 파생 클래스의 소멸자가 먼저 호출된다.

2. 기본 클래스쪽으로 거쳐 올라가면서 각 기본 클래스의 소멸자가 하나씩 호출된다.

3. 컴파일러는 ~AWOV의 호출 코드를 만들기 위해 파생 클래스의 소멸자를 사용한다.
```

<br>


------------

* 기본 클래스의 손에 가상 소멸자를 쥐어 주자는 규칙은 `다형성`을 가진 기본 클래스, 그러니까 `기본 클래스 인터페이스를 통해 파생 클래스 타입의 조작을 허용하도록 설계된 기본 클래스에만 적용된다.`


> 이것만은 잊지 말자!
> * 다형성을 가진 기본 클래스에는 반드시 가상 소멸자를 선언해야 한다.<br>
>    즉,어떤 클래스가 가상 함수를 하나라도 갖고 있다면, 이 클래스의 소멸자도 >    가상 소멸자이어야 한다.
> * 기본 클래스로 설계되지 않았거나 다형성을 갖도록 설계되지 않은 클래스에는 가상 소멸자로 선언하지 말아야 한다.
{: .prompt-tip }