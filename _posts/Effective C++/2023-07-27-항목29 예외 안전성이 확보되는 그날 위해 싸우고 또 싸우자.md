---
title: 항목29 예외 안전성이 확보되는 그날 위해 싸우고 또 싸우자
date: 2023-07-27
categories: [Effective C++,Effective C++]
tags: [effective c++]		# TAG는 반드시 소문자로 이루어져야함!
---

**항목29 예외 안전성이 확보되는 그날 위해 싸우고 또 싸우자**
===========

* 예외 안전성을 확보하는 작업은 매우 힘들다.

### 예시

* 배경그림을 가진 GUI 메뉴를 구현한 클래스가 있다고 가정한다

* 이 클래스는 스레딩 환경에서 동작하고 병행성 제어를 위해 뮤텍스(mutex)를 갖고 있다.

```c++
class PrettyMenu{
    public:
        void changeBackground(std::istream& imgSrc);    // 배경 그림을
                                                        // 바꾸는 멤버 함수

    private:
        Mutex mutex;        // 이 객체를 위한 뮤텍스

        Image *bgImage;     // 현재의 배경 그림
        int imageChanges;   // 배경그림이 바뀐 횟수
};

// PrettyMenu의 changeBackground 함수
void PrettyMenu::changeBackground(std::istream& imgSrc)
{
    lock(&mutex);           // 뮤텍스를 획득

    delete bgImage;             // 이전 배경그림을 삭제
    ++imageChanges;             // 그림 변경 횟수 증가
    bgImage = new Image(imgSrc) // 새 배경그림

    unlock(&mutex);
}
```

* 예외 안전성 측면에서는 이 함수 이상으로 나쁠수 없다

* 일반적으로 예외 안전성을 확보하려면 두 가지의 요구사항을 맞춰야 하는데, 이 함수는 어느 요구사항도 맞지 않는다.

<br>

### 예외 안정성을 가진 함수
---------

* `자원이 새도록 만들지 않아야 한다`

  * 위 코드는 new Image(imgSrc) 표현식에서 예외를 던지면 unlock 함수가 실행되지 않게 되어 뮤텍스가 계속 잡힌 상태로 남는다.

* `자료구조가 더럽혀지는 것을 허용치 않는다`

  * new Image(imgSrc)가 예외를 던지면 bgImage가 가리키는 객체는 이미 삭제된 후이다
    <br>새 그림이 제대로 깔리지도 않았는데 imageChanges 변수는 이미 증가되었다


<br>

### 자원이 새는거에 대한 대처
----------

* 객체를 써서 자원 관리를 전담케 하는 방법은 항목 13에 있고, 항목 13 을 이용하여 뮤텍스를 적절한 시점에 해제하는 방법을 구현한 Lock 클래스가 항목 14에 있다.

```c++
void PrettyMenu::changeBackground(std::istream& imgSrc)
{
    Lock ml(&mutex);           // 항목 14에 있는 Lock 클래스
                               // 뮤텍스를 대신 획득하고 없어질 시점에 해제하는 객체

    delete bgImage;             
    ++imageChanges;             
    bgImage = new Image(imgSrc) 
}
```

<br>

# 자료구조 오염 문제에 대한 대처


* 여기서는 선택을 해야 하는데 그전에 고를 수 있는 것이 무엇인지를 파악하기 위해 용어 공부가 필요하다.

<br>

## 세 가지 보장(guarantee)


* `예외 안전성을 갖춘 함수는 아래의 세 가지 보장(guarantee) 중 하나를 제공한다.`

<br>

### 기본적인 보장(basic guarantee)
--------------

* `함수 동작 중에 예외가 발생하면, 실행 중인 프로그램에 관련된 모든 것들을 유효한 상태로 유지하겠다는 보장`

* 어떤 객체나 자료구조도 더렵히지 않으며, 모든 객체의 상태는 내부적으로 일관성을 유지하고 있다.
  * 즉, 모든 클래스는 불변속성을 만족한다.

* 하지만 프로그램의 상태가 정확히 어떠한지는 예측이 안될 수도 있다.

* 예를 들어, changeBackground 함수가 동작하다 예외가 발생했을 때 PrettyMenu 객체는 바로 이전의 배경 그림을 그대로 그릴 수도 있고, 아니면 청므부터 마련해둔 기본 배경그림을 사용할 수도 있다.

  * 이부분은 전적으로 함수를 만든 사람에 달려있어 사용자는 예측할 수 없다.

<br>

### 강력한 보장(strong guarantee)
-------------

* `함수 동작 중에 예외가 발생하면, 프로그램의 상태를 절대로 변경하지 않겠다는 보장`

* 이런 함수를 호출하는 것은 `원자적인(atomic) 동작`이라고 할 수 있다.

* 호출이 성공하면(예외가 발생하지 않으면) 마무리까지 완벽하게 성공하고,<Br>
  호출이 실패하면 함수 호출이 없었던 것처럼 프로그램의 상태가 되돌아간다



---------

* `쓰기 편한가`의 측면에서는 강력한 보장을 제공하는 함수가 기본 보장을 제공하는 함수보다 더쉽다.

* 예측할 수 있는 프로그램의 상태가 두 개밖에 안되기 때문이다.
  * 하나는, `성공적으로 실행을 마친 후의 상태`
  * 다른 하나는 `함수가 호출될 때의 상태`

* 이와 대조적으로 함수가 기본 보장을 제공할 경우에는 에외 발생시에 프로그램이 있을 수 있는 상태가 그냥 유효하기만 하면 어떤 상태도 될 수 있다.

<br>

### 예외불가 보장(nothrow guarantee)
----------

* `예외를 절대로 던지지 않겠다는 보장(약속한 동작은 언제나 끝까지 완수하는 함수)`

* 기본제공 타입에 대한 모든 연산은 예외를 던지지 않게 되어 있다.

  * 즉, 예외불가 보장이 제공

  * 예외에 안전한 코드를 만들기 위한 가장 기본적이며 핵심적인 요소

--------

* 어떤 예외도 던지지 않게끔 예외 지정이 된 함수는 예외불가 보장을 제공한다고 생각할 수 있지만 잘못된 생각이다.

```c++
int doSomething() throw();      // 비어 있는 예외 지정
```

* 위의 함수 선언이 전하는 메시지는 doSomething함수가 절대로 예외를 던지지 않겠다는 뜻이 아닌 <br>
  doSomething에서 지정되지 않은 예외가 발생했을 경우에 실행되는 처리자인 `unexpected 함수`가 호출되어야 한다는 뜻이다.

* 위 함수는 어떤 예외 안전성 보장도 제공하지 않을 수 있다.

  * 함수 선언문에 이식성,효율성,예외 안전성 보장등 그 어떠한것도 알려주지 않기 때문

  * 함수는 선언이 아닌 `구현`에서 어떤 특성을 갖는지를 결정짓는다

<br>

### 세 가지 보장 중 선택
---------

* 예외 안전성을 갖춘 함수는 위 세 가지 보장 중 하나를 반드시 제공해야 한다.

* 그래서 `선택`해야 하는것은 `어떤 보장을 제공할 것인가`이다.


* 위 세 가지 보장 중 하나를 고르자면 실용성이 있는 강력한 보장이 괜찮아 보인다.

* 예외 안전성의 관점에서 보면 예외불가 보장이 좋아보이지만, 예외를 던지는 함수를 호출하지 않고 C++의 C 부분으로부터 벗어나오기는 힘들다.

  * 동적 할당 메모리를 사용하는 STL컨테이너에서도, 메모리를 확보하지 못하면 bad__alloc 예외를 던지도록 구현되어 있다.

* 현실적으로는 대부분의 함수에 있어 `기본적인 보장` 혹은 `강력한 보장` 중 하나를 고르게 된다.

<br>

## 강력한 보장 제공


* changeBackground 함수로 돌아와 강력한 예외 안전성 보장을 제공하기 위해선 다음과 같이 변경한다.

```c++
class PrettyMenu {
  ...
  std::tr1::shared_ptr<Image> bgImage;
  ...
};

void PrettyMenu::changeBackground(std::istream& imgSrc)
{
  Lock ml(&mutex);

  bgImage.reset(new Image(imgSrc));   // bgImage의 내부 포인터를
                                      // new Image 표현식의 실행결과로 바꿔치기

  ++imageChanges;
}
```

* 첫 번째로, `bgImage 데이터 멤버의 타입을 자원관리용 포인터(스마트 포인터)로 바꾼다`

  * 자원은 스마트 포인터에서 관리되고 new Image가 성공해야만 이전 Image를 삭제한다.

* 두 번째로, `함수 내의 문장을 재배치하여 배경그림이 바뀌기 전 imageChanges를 증가시키지 않도록 한다`

* 두 가지만 바꾸면 거의 충분하다.

  * 위 예시에서는 매개변수 imgSrc가 istream 타입으로, 생성자에서 예외가 발생할 수 있다.

<br>

## 복사후 맞바꾸기(copy-and-swap)

* 예외에 속수무책인 함수를 강력한 예외 안전성 보장을 제공하는 함수로 만들기 위한 일반적인 설계 전략이다.

* 복사후 맞바꾸기(copy-and-swap)는 `어떤 객체를 수정하고 싶으면 그 객체의 사본을 만들어 놓고 그 사본을 수정하라`는 뜻이다.

* 이러면 수정 동작 중에 실행되는 연산에서 예외가 발생해도 원본 객체는 유지하게 된다

* `동작이 성공적으로 완료되면 수정된 객체를 원본 객체와 맞바꾼는데, 이 작업을 예외를 던지지 않는 연산 내부에서 수행한다.`

<br>

### 예시
--------

* 원본 객체의 모든 데이터를 별도의 구현(implementation) 객체에 넣고, 그 구현 객체를 가리키는 포인터를 원본 객체가 물게 한다.

  * `pimpl 관용구`라고도 하며 항목 31에서 자세히 다룬다.

```c++
struct PMImpl {   

  shared_ptr<Image> bgImage;  
  int imageChanges;
};

class PrettyMenu {
  ...

  private:
    Mutex mutex;
    shared_ptr<PMImpl> pImpl;
};

void PrettyMenu::changeBackground(std::istream& imgSrc)
{
  using std::swap;

  Lock ml(&mutex);

  shared_ptr<PMImpl> pNew(new PMImpl(*pImpl));  // 객체의 데이터 부분 복사

  pNew->bgImage.reset(new Image(imgSrc));       // 사본 수정

  swap(pImpl, pNew);                            // 스왑
}
```

* 복사후 맞바꾸기(copy-and-swap)는 `객체의 상태를 전부 바꾸거나 혹은 안 바꾸거나 하는 방식으로 유지하려는 경우에 좋다`

<br>

----------------

* 그러나 함수 전체가 강력한 예외 안정성을 갖도록 보장하지 않는 다는 것이 일반적이다.

```c++
void someFunc()
{
  ...     // 이 함수의 현재 상태에 대해 사본을 만들어 놓는다.

  f1();
  f2();

  ...     // 변경된 상태를 바꾼다.
}
```
* someFunc안에 다른 함수 f1()과 f2()에서 예외 안정성을 보장하지 못한다면 someFunc 역시 예외 안전성을 보장하기 힘들다.

* 만약 f1() 함수와 f2() 함수 둘 다 강력한 예외 안전성을 보장한다고 해도 f1,f2 함수가 실행되면 프로그램 상태가 f1,f2 함수에 의해 변해 있어 someFunc 함수를 호출할 때의 상태와 달라져서 별로 나아지는 것이 없다.

* 강력한 예외 안전성을 보장하려다 이러한 문제에 발목잡힐 수도 있다.

<br>

**결론**
========

> 이것만은 잊지 말자!
> * 예외 안전성을 갖춘 함수는 실행 중 예외가 발생되더라도 자원을 누출시키지 않고 
>   <br>자료구조를 더럽히지 않는다. 이런 함수들이 제공할 수 있는 예외 안전성 
>   <br>보장은 기본적인 보장, 강력한 보장, 예외 금지 보장이 있다.
> 
> * 강력한 예외 안전성 보장은 '복사-후-맞바꾸기' 방법을 써서 구현할 수 있지만
>   <br>모든 함수에 대해 강력한 보장이 실용적이진 않다
> 
> * 어떤 함수가 제공하는 예외 안전성 보장의 강도는 그 함수가 내부적으로
>   <br>호출하는 함수들이 제공하는 가장 약한 보장을 넘지 않는다.
{: .prompt-tip }
