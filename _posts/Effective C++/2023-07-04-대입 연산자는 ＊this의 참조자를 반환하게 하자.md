---
title: 대입 연산자는 *this의 참조자를 반환하게 하자
date: 2023-07-04
categories: [Effective C++,Effective C++]
tags: [effective c++]		# TAG는 반드시 소문자로 이루어져야함!
---

**항목10 : 대입 연산자는 \*this의 참조자를 반환하게 하자**
==============
* C++의 대입 연산은 여러 개가 사슬처럼 엮일 수 있는 재미있는 성질을 갖고 있다.

```c++
int x,y,z;

x = y = z = 15;
```

* 대입 연산이 가진 또 하나의 재미있는 특성은 `우측 연관(right-associative) 연산`이라는 점이다.

```c++
x = (y = (z = 15));
```

* 위 코드를 풀어보면, 15가 z에 대입되고, 그 대입 연산의 결과가 y에 대입되고, y에 대한 대입 연산의 결과가 x에 대입된다.

* 이렇게 대입 연산이 사슬처럼 엮이려면 대입 연산자가 좌변 인자에 대한 참조자를 반환하도록 구현되어 있다.

  * 이런 구현은 일종의 관례(convention)이다.


```c++
class Widget{
public:
    // 반환 타입은 현재 클래스에 대한 참조자
    Widget& operator=(const Widget& rhs)
    {
        ...
        return *this;   //좌변 객체(의 참조자)를 반환
    }
};
```

<br>

----------


* "좌변 객체의 참조자를 반환하게 만들자" 라는 규약은 `단순 대입형 연산자 말고도 모든 형태의 대입 연산자에서 지켜져야 한다.`

```c++
class Widget{
public:
    // +=말고도 -=, *= 등에도 동일하게 적용한다.
    Widget& operator+=(const Widget& rhs)
    {
        ...
        return *this;
    }

    // 대입 연산자의 매개변수 타입이 일반적이지 않은 경우에도 동일한 규약 적용
    Widget& operator=(int rhs) 
    {
        ...
        return *this;
    }
};
```

* 따르지 않고 코드를 작성하더라도 컴파일이 안된다거나 하는 건 아니지만 `이 관례는 모든 기본제공 타입들이 따르고 있을 뿐만 아니라 표준 라이브러리에 속한 모든 타입에서도 따르고 있다는 점은 무시할 수 없다.`


<br>

> 이것만은 잊지 말자!
> * 대입연산자는 *this의 참조자를 반환하도록 만들어라
{: .prompt-tip }