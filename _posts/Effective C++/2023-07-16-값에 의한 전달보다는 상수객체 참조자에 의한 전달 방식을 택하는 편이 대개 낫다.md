---
title: 값에 의한 전달보다는 상수객체 참조자에 의한 전달 방식을 택하는 편이 대개 낫다
date: 2023-07-16
categories: [Effective C++,Effective C++]
tags: [effective c++]		# TAG는 반드시 소문자로 이루어져야함!
---

**항목20 : 값에 의한 전달보다는 상수객체 참조자에 의한 전달 방식을 택하는 편이 대개 낫다**
===========

* 기본적으로 C++는 함수로부터 객체를 전달받거나 함수에 객채를 전달할 때 `값에 의한 전달(pass-by-value)` 방식을 사용한다.

* 특별히 다른 방식을 지정하지 않는 한, `함수 매개변수는 실제 인자의 사본을 통해 초기화되며, 어떤 함수를 호출한 쪽은 그 함수가 반환한 값의 사본을 돌려받는다.`

* 이 사본을 만들어내는 원천이 바로 복사생성자인데, 이 점 때문에 `값에 의한 전달이 고비용의 연산이 되기도 한다.`


**예시**
---------

```c++
class Person{

public:
    Perosn();           // 매개변수는 간결함을 위해 생략
    virtual ~Person();  // 가상 소멸자인 이유는 항목 7에서 확인

private:
    std::string name;
    std::string address;
};

class Student : public Person {
public:
    Student();           
    virtual ~Student();

private:
    std::string schoolName;
    std::string schoolAddress;
};
```

* 이제 아래 코드에 있는 **validateStudent()** 라는 함수를 호출하고 있는데, 이 함수는 Student 인자를 전달받고(값으로), 이 인자가 유효화됐는가를 알려주는 값을 반환한다.

```c++
bool validateStudent(Student s);         // Student를 값으로 전달받는 함수

Student plato;

bool platoIsOK = validateStudent(plato); // 함수 호출
```

* 이 함수가 호출되면 어떤 일이 일어날까?


<br>

**validateStudnet 함수 호출**
---------------

* plato로부터 매개변수 s를 초기화시키기 위해 Student의 복사 생성자가 호출될 것이다.

* 게다가 s는 **validateStudent() 함수**가 복귀할 때 소멸된다.

* 정리하면, 이 함수의 `매개변수 전달 비용은 Student의 복사 생성자 호출 한 번, 그리고 Student의 소멸자 호출 한 번`이다.


<br>

**값에 의한 전달에서의 복사 생성자**
==========

* 과정

  1. Student 객체에는 String 객체 2개가 멤버로 들어있기 때문에, Student 객체가 생성될 때마다 멤버 변수인 String 객체 2개도 같이 생성되어야 한다.

  2. 게다가 Student 객체는 Person 객체로부터 파생되었기 때문에, Person 객체도 먼저 생성되어야 한다.

  3. Person 객체에도 String 객체 2개가 들어 있어 Person 객체가 매번 생성될 때 String 생성자가 두번 더 불린다.

* 결과

  * 결국 Student 객체 하나를 값으로 전달했을 뿐인데
    <br>Student 복사 생성자 호출 1번,  Person 복사 생성자 호출 1번, String 복사 생성자 호출 4번이 일어난다.

  * Student 객체의 사본이 소멸될 때도 호출된 생성자들 각각이 소멸자 호출과 대응되어 소멸자도 총 6번이 호출된다.

  * 객체를 값으로 전달했을 뿐인데 생성자 6번, 소멸자 6번이 호출되어버렸다



* 이러한 상황을 해결하기 위해 사용하는 방법이 `상수객체에 대한 참조자(reference-to-const)`로 전달하게 만드는 것이다.


<br>

**상수객체에 대한 참조자(reference-to-const)**
========

```c++
bool validateStudent(const Student& s);
```

* 이렇게 코드를 바꾸면 `새로 만들어지는 객체가 없어 생성자와 소멸자가 전혀 호출되지 않는다.`

* 여기서 새겨둬야 할 부분은 매개변수 선언문에 있는 `const`이다.

  * 원래는 validateStudent는 Student 매개변수를 값으로 받도록 되어 있기 때문에 사본이였지만,
  <br> 참조로 인한 전달은 원본을 수정할 수 있기 때문에 const로 불변성을 지니게 하여 변할 걱정이 없게 만들었다.

<Br>

**복사손실 문제(slicing problem)**
=====

* 참조에 의한 전달 방식으로 매개변수를 넘기면 `복사손실 문제(slicing problem)`가 없어지는 장점도 있다.

* 파생 클래스 객체가 기본 클래스 객체로서 전달되는 경우가 드물지 않게 있는데, `이 객체가 값으로 전달되면 기본 클래스의 복사 생성자가 호출되고 파생 클래스 객체의 부분들이 떨어지고 만다`

  * 결국 기본 클래스 생성자로 만들어진 파생 클래스가 되어버린다.

<br>

**예시**
-----------

```c++
class Window{

public:
    std::string name() const;       // 윈도우 이름 반환
    virtual void display() const;   // 윈도우 테두리 및 내부를 그린다.
};

class WindowWithScrollBars: public Window {

public:

    virtual void display() const;
};
```

* 이 클래스를 가지고 어떤 윈도우의 이름을 출력하고 그 윈도우를 화면에 표시하는 함수를 만든다.

* 우선 틀리게 구현한 버전을 가지고 이야기를 시작한다.

```c++
void printNameAndDisplay(Window w)  // 매개변수에 복사손실 발생
{
    std::cout << w.name();
    w.display();
}
```

* 이 함수에 WindowWithScrollBars 객체를 넘긴다면 어떤 일이 일어날까?

```c++
WindowWithScrollBars wwsb;

printNameAndDisplay(wwsb);
```

* 문제점

  * 매개변수 w가 생성되긴 하지만, Window 객체로 만들어지면서 WindowWithScrollBars의 부분은 생성되지 않는다.

  * 가상 함수인 display 함수는 Window::display가 호출되고 WindowWithScrollBars::display는 호출되지 않는다.

* 이러한 복사손실 문제에서 벗어나려면, w를 상수객체에 대한 참조자로 전달하도록 만들면 된다.

```c++
void printNameAndDisplay(const Window& w)
{
    std::cout << w.name();
    w.display();
}
```

* 이제 w는 어떤 종류의 윈도우가 사용되더라도 윈도우의 성질 그대로 갖게 된다.

<br>

**그 뒤 내용**
========

* C++ 컴파일러의 동작 원리에 관심이 있는 사람이라면, 참조자는 보통 포인터를 써서 구현된다는 사실을 알 것이다.

  * 즉, 참조자를 전달하는 것은 포인터를 전달하는 것과 일맥상통한다는 이야기다.

* 이렇게 따져보면 전달하는 객체의 타입이 기본제공 타입(int 등)일 경우 참조자보단 값에 의한 전달이 더 효율적일 때가 많다.

* 그래서 `값에 의한 전달 및 상수객체의 참조에 의한 전달 중 하나를 선택할 때, 기본제공 타입에 대해서는 값에 의한 전달을 선택해도 엉터리가 아니라는 뜻이다.`


<br>

**STL의 반복자와 함수 객체**
-----------

* 이 점은 `STL의 반복자와 함수 객체`에도 마찬가지이다.

* 반복자와 함수 객체를 구현할 때는 반드시 `1.복사 효율을 높일 것`과 `2.복사손실 문제에 노출되지 않도록 만드는 것`이 필수이다.


<br>

**다시 기본 제공 타입에 대한 이야기**
---------

* 기본 제공 타입은 작다

* 타입 크기가 작으면 사용자 정의 타입이라도 값에 의한 전달을 해야 한다고 생각이 들 수도 있다.

* 그런데 크기가 작다는 해석은 그 객체의 복사 생성자 호출이 저비용이란 뜻으로 해석하라는 단서가 아니다.

* `멤버 변수에 포인터 객체가 있다면 그 포인터 객체가 가리키는 대상까지도 복사하는 작업이 따라다녀 비용이 비쌀 수도 있다.`

<br>

**객체 크기가 작고 복사 생성자도 비싸지 않다면**
---------

* 만약 객체 크기가 작고 복사 생성자도 비싸지 않다고 가정해본다.

* 여기서는 `수행 성능 문제`가 발목을 잡을 수 있다.

* 컴파일러 중에는 기본제공 타입과 사용자 정의 타입을 아예 다르게 취급하는 것들이 있다.

  * 기본제공 타입과 사용자 정의 타입의 하부 표현구조가 똑같아도 말이다.

* 이를테면 `기본제공 타입 double은 레지스터에 넣지만, double 하나만 갖고 있는 사용자 정의 타입은 레지스터에 넣지 않을 수도 있다`

* 이런 개발 환경에서 일한다면 참조에 의한 전달을 쓰는편이 좋다.

  * 포인터로 구현되는 참조이기에 레지스터에 들어가기 때문이다.

<br>

**사용자 정의 타입을 값에 의한 전달로 만들면 안되는 이유가 하나 더 있다**
-----------

* 크기가 작다고해서 사용자 정의 타입을 무조건 값으로 전달할 수 없는 이유는 `사용자 정의 타입의 크기는 언제든 변화에 노출되어 있다는 것이다.`

* 지금은 크기가 작아도 나중엔 커질 수 있고 C++ 구현 환경으로 바꿀 때조차 사정이 변할 수도 있다.

<br>

**결론**
=======

* 일반적으로 값에 의한 전달이 저비용이라고 가정해도 괜찮은 유일한 타입은 `기본제공 타입, STL 반복자, 함수 객체 타입`이렇게 세 가지 뿐이다.

* `이 외의 타입에는 상수객체 참조자에 의한 전달을 선택하는 것이 대체로 좋다`

<br>


> 이것만은 잊지 말자!
> * '값에 의한 전달'보다는 '상수 객체 참조자에 의한 전달'을 선호하자<br>
>   대체적으로 효율적일 뿐만 아니라 복사손실 문제까지 막아준다
>
> * 이번 항목에서 다룬 법칙은 기본제공 타입 및 STL 반복자, 그리고 함수 객체 
>   타입에는 맞지 않는다.
>   <br> 이들에 대해서는 '값에 의한 전달'이 더 적절하다.
{: .prompt-tip }
