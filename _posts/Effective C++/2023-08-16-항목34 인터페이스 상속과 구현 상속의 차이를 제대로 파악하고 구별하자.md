---
title: 항목34 인터페이스 상속과 구현 상속의 차이를 제대로 파악하고 구별하자
date: 2023-08-16
categories: [Effective C++,Effective C++]
tags: [effective c++]		# TAG는 반드시 소문자로 이루어져야함!
---

* public 상속이란 개념은 그다지 복잡하지 않지만, 자세히 들여다 보면 두 가지로 나뉜다.

* 하나는 `함수의 인터페이스 상속`, 다른 하나는 `함수의 구현 상속`이다.

  * 인터페이스 상속 및 구현 상속의 차이는 함수 선언 및 함수 정의의 차이와 같다


<br>

**인터페이스**
-----------

* 설계자는 인터페이스를 상속하고 싶을 수도 있고, 상속받으면서 오버라이드를 하고싶을 수도 있고 막고 싶은 경우도 있다.

```c++
class Shape {
    
    public:
        virtual void draw() const = 0;
        virtual void error(const string& msg);
        int objectID() const;
};

class Rectangle : public Shape { ... };
class Ellips : public Shape { ... };
```

* Shape는 추상 클래스이므로, 인스턴스를 만들지 못하고 Shape 클래스의 파생 클래스를 인스턴스 해야한다.

* 그런데 이 Shape로부터 public 상속으로 파생되는 클래스들에게 영향력이 엄청나다.

* 이유는 `멤버 함수 인터페이스는 항상 상속되게 되어 있기 때문이다.`

  * 항목32에서 말했듯이, public 상속의 의미는 is-a이므로 기본 클래스에 해당하는 것들은 모두 파생 클래스에도 해당되어야 한다.

<br>

----------------


* Shape의 멤버 함수는 `순수 가상 함수인 draw`와 `가상 함수인 error `와 `비가상 함수인 objectID`가 있는데 셋 다 의미하는 것이 다르다


### 순수 가상 함수 draw

* 순수 가상 함수의 가장 큰 특징은<br>
  `첫째, 순수 가상 함수를 물려받은 클래스는 해당 순수 가상 함수를 선언해야 한다`와<br>
  `둘째, 순수 가상 함수는 전형적으로 추상 클래스안에서 정의를 갖지않는다`이다.

* 이 두가지를 하나로 모으면 다음과 같은 결론이 나온다.

  * `순수 가상 함수를 선언하는 목적은 파생 클래스에게 함수의 인터페이스만을 물려주는 것이다.`


* 하지만 사실 순수 가상 함수에도 정의를 제공할 수 있다.

  * 단, 구현이 붙은 순수 가상 함수를 호출하려면 반드시 클래스 이름을 한정자로 붙여줘야만 한다.



```c++
Shape* ps = new Shape;

Shape* ps1 = new Rectangle;
ps1->draw();                // Rectange::draw

Shape* ps2 = new Ellipse;
ps2->draw();                // Ellipse::draw

ps1->Shape::draw();         // Shape::draw
ps2->Shape::draw();         // Shape::draw
```

### 단순 가상 함수 error

* 순수 가상 함수와 같이 함수의 인터페이스를 상속하게 한다는 점은 같지만,<br>
  파생 클래스쪽에서 오버라이드할 수 있는 함수 구현부도 제공한다는 점이 다르다

* `단순 가상 함수를 선언하는 목적은 파생 클래스로 하여금 함수의 인터페이스뿐만 아니라 그 함수의 기본 구현도 물려받게 하자 이다.`


### 비가상 함수인 ObjectID

* 멤버 함수가 비가상 함수라는 뜻은 파생 클래스에서 다른 행동이 일어나지 않는다는 뜻이다.

* 즉, `비가상 멤버 함수를 선언하는 목적은 파생 클래스가 함수 인터페이스와 더불어 그 함수의 필수적인 구현(mandatory implementation)을 물려받게 하자 이다`


<br>

**함수 설계에서의 실수**
---------------

* 순수 가상 함수, 단순 가상 함수, 비가상 함수의 차이점으로 파생 클래스가 물려받았으면 하는 것들을 정밀하게 지정할 수 있다.

* 그리고 멤버 함수를 선언할 때, 클래스 설계를 많이 하지 않는 사람들의 가장 큰 실수 두 가지가 있다.

* 첫 번째는, `모든 멤버 함수를 비가상 함수로 선언하기`이다.

  * 파생 클래스를 만들어도 기본 클래스의 동작이 특별해지지 않고, 특히 비가상 소멸자가 문이다

  * 가상 함수의 비용 때문에 신경쓰는 사람은 80-20 법칙을 생각해야 한다.

  * 80-20 법칙이란, 전체 실행 시간 80%가 전체 코드의 20%밖에 안된다는 뜻으로,<br>가상 함수의 비용을 따지기 보단 진짜 큰 차이가 나는 20% 코드에 집중하는 것이 좋다는 뜻이다.,


* 두 번째는, `모든 멤버 함수를 가상 함수로 선언하기`이다.
  * 함수 중에서도 파생 클래스에서 재정의가 안 되어야 하는 함수도 있을 것이다.<br>
    그런 함수는 비가상 함수로 만들어 불변동작으로 만들어야 한다.

<br>

**결론**
=======

> 이것만은 잊지 말자!
> * 인터페이스 상속은 구현 상속과 다르다. public 상속에서, 파생 클래스는 항상<br>
>   기본 클래스의 인터페이스를 모두 물려받는다.
>
> * 순수 가상 함수는 인터페이스 상속만을 허용한다.
>
> * 단순(비순수) 가상 함수는 인터페이스와 상속과 더불어 기본 구현의 상속도 가능하도록 
>   지정한다.
>
> * 비가상 함수는 인터페이스 상속과 더불어 필수 구현의 상속도 가하도록 지정한다.
{: .prompt-tip }

