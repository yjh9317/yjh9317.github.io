---
title: 쓰레드의 생성과 소멸
date: 2023-03-27
categories: [윈도우즈시스템프로그래밍, 운영체제]
tags: [windows]		# TAG는 반드시 소문자로 이루어져야함!
---

쓰레드 동기화
==============

* 여기서 동기화란 일치함을 의미하는게 아닌 순서에 있어서 질서가 지켜지고 있음을 의미한다.

* 두가지 관점에서의 쓰레드 동기화

    * 실행순서의 동기화

    * 메모리 접근에 대한 동기화


<br><br>

## 실행순서 동기화
--------------------

* 만일 A 쓰레드가 계산한 결과를 B 쓰레드가 받아 출력하는 경우, 반드시 A 쓰레드가 먼저 실행을 완료해야 한다.

* ```쓰레드의 실행 순서를 정의하고 이 순서에 반드시 따르도록 하는 것이 쓰레드 동기화이다```

<br><br>

## 메모리 접근 동기화
--------------------

* 한 순간에 하나의 쓰레드만 접근해야 하는 메모리 영역이 존재한다.
  * ex) 데이터와 힙

* ``` 메모리 접근에 잇어서 동시 접근을 막는 것 또한 쓰레드의 동기화에 해당한다```


<br><br>


## 쓰레드 동기화에 있어 두가지 방법
-------------

* 유저 모드 동기화와 커널 모드 동기화가 있다.

<br>

### 유저모드

* 동기화가 진행되는 동안 커널 코드가 실행되지 않는 동기화 기법

  * 커널모드로의 전환이 없기 때문에 성능에 이점이 있지만, 기능이 제한됨

<br>

### 커널 모드 동기화

* 커널에서 제공하는 동기화 기능을 활요하는 기법

* 커널 모드로 변경이 필요하여 성능이 저하되지만, 유저 모드에서 사용하지 못하는 기능을 제공받는다.

<br><br>


임계 영역 접근 동기화
=================

* 메모리 접근의 동기화는 임계 영역의 접근을 동기화하겠다는 뜻으로 해석할 수 있다.

## 임계 영역에 대한 이해
--------------------

* 임계영역이란

    * ```배타적 접근(한 순간에 하나의 쓰레드만 접근)이 요구되는 공유 리소스(전역변수와 같은)에 접근하는 코드블록```을 의미한다.

* 임계 영역의 해결책은 임계 영역의 동시 접근을 막는 것이다.

    * 동기화 기법을 통해 한 순간에 하나의 쓰레드만 접근이 가능토록 하게 한다.

<br>

## Windows에서 제공하는 동기화 기법
-------------

* 유저 모드 동기화

  1. 크리티컬 섹션 기반의 동기화

  2. 인터락 함수 기반의 동기화

* 커널 모드 동기화
  
  1. 뮤텍스 기반의 동기화

  2. 세마포어 기반의 동기화

  3. 이름 있는 뮤텍스 기반의 프로세스 동기화

  4. 이벤트 기반의 동기화

<br>

* 위의 5가지는 임계 영역 접근 동기화에서 사용하기 적절한 기법이다.

* 이벤트는 실행순서 동기화에서 사용하는 것이 적절한 기법이다.(다음장에서 설명)

* 아래에서 임계 영역 접근 동기화에 대한 설명을 작성할 것이다.

<br><br>

유저 모드의 동기화
====================

* 유저 모드는 커널 모드로의 전환도 불필요하고, 커널 모드 동기화에 비해 단순하므로 이 기법으로도 해결 가능하다면 커널 모드 동기화를 사용할 필요는 없다.

<br>

## 크리티컬 섹션 기반의 동기화
------------

* 화장실(혹은 벽 어딘가) 앞에 걸어놓은 화장실 열쇠를 예시로 들어 설명한다.

* 임계 영역을 화장실이라고 했을 때, 이 화장실에 들어가기 위해 화장실 앞에 걸려 있는 열쇠(혹은 벽 어딘가에 걸려있는 열쇠)를 가져가야 한다.

* 열쇠가 걸려있다면 이 열쇠로 문을 열고 들어가면 되고, 일을 다 보고 난 후에 다시 열쇠를 화장실 앞에 걸어 놓는다.

* 이것이 바로 크리티컬 섹션의 동기화 방식

    * ```열쇠를 얻은 자만이 화장실(임계 영역)에 들어갈 수 있다```.

<br>

```c++
// critical section object는 CRITICAL_SECTION의 변수를 의미
CRITICAL_SECTION gCriticalSection;           // critical section object. 열쇠를 의미.
InitializeCriticalSection(gCriticalSection); // 사용하기 위한 초기화 함수

// 임계 영역 진입을 위한 크리티컬 섹션 오브젝트. 즉 열쇠 획득.
// 여러 쓰레드 중, 빠른 하나만 열쇠를 얻고 나머지는 Blocked 상태
EnterCriticalSection(&gCriticalSection);     

//            ...임계영역...

// 크리티컬 섹션 오브젝트 반환. 즉 열쇠 반환.
LeaveCriticalSection(&gCriticalSection);

// ... 중략 ...

// 열쇠 소멸
DeleteCriticalSection(&gCriticalSection);
```

<br><br>

## 인터락 함수 기반의 동기화
------------
* 전역으로 선언된 변수 하나의 접근 방식을 동기화 하는 것이라면,이러한 용도로 특화된 인터락 함수를 사용하는 것도 나쁘지 않다.

* 인터락 함수는 ```함수 내부적으로 하나의 쓰레드에 의해서만 실행되도록 동기화되어 있다```.


```c++
// 값을 하나 증가시킬 32 비트 변수의 주소값 전달
LONG InterlockedIncrement(
    LONG volatile* Addend
);

// 값을 하나 감소시킬 32 비트 변수의 주소값 전달
LONG InterlockedDecrement(
    LONG volatile* Addend
);

// 위 함수들을 사용하면 동기화 상태에서 접근하는 것과 동일한 안정성을 보장받는다.
void IncreaseCount(void)
{
    InterlockedIncrement(&gTotalCount); // ~= ++gTotalCount. 원자적 접근(Atomic Access)을 보장한다
}
```
* 한 순간에 하나의 쓰레드만 접근하기 때문에 둘 이상의 쓰레드 접근에 의한 문제는 결코 발생하지 않음

* 크리티컬 섹션 동기화 기법도 내부적으론 인터락 함수 기반으로 구현되어 있다.

* 인터락 함수들은 유저 모드 기반이기 때문에 속도가 상당히 빠르다.

* 마이크로소프트는 MSDN에 보다 다양한 인터락 함수들을 제공한다.

<br><br>

## volatile
---------------
* 위 두 함수 선언에 포함된 키워드 volatile은 크게 두가지 의미를 지낸다.

```1. 최적화를 수행하지 말 것```

* 컴파일러는 자동적으로 최적화를 실행한다.

```c++

// 함수 원형
int func()
{
    int a = 10;
    a = 20;
    a = 30;
    cout << a;
}

// 컴파일러가 최적화한 함수
int func()
{
    int a = 30;
    cout << a;
}
```

* 이러한 최적화때문에 문제가 발생할 수 있기 때문에 volaitle 키워드를 사용하여 최적화를 멈출 수 있다.


```2. 메모리에 직접 연산할 것```

* 메모리가 아닌 Cash 메모리에 저장하여 문제가 생길 수 있다.

<br><br>

커널 모드 동기화
====================

* 유저 모드에 비해 느리지만 Windows 커널 레벨에서 제공해주는 동기화 기법이기 때문에 유저 모드 동기화에서 제공해 주지 못하는 기능을 제공받을 수 있다.

## 뮤텍스 기반의 동기화
---------------

* 크리티컬 섹션 동기화에서 열쇠는 크리티컬 섹션 오브젝트이고, 이는 CRITICAL_SECTION이라는 자료형의 변수였다면, 뮤텍스 기반 동기화 기법에서 열쇠는 뮤텍스 오브젝트이다.

<br>

```c++
HANDLE CreateMutex(
    LPSECURITY_ATTRIBUTES lpMutexAttributes, // 보안 속성을 지정
    BOOL bInitialOwner,                      // 소유자 지정
    LPCTSTR lpName                           // 뮤텍스 이름 지정
);
// If the below function fails, the return value is NULL.

BOOL ReleaseMutex(
    HANDLE hMutex   // 반환할 뮤텍스의 핸들
);
// If the below function fails, the return value is zero
```

* 뮤텍스는 크리티컬 섹션 오브젝트와 달리 초기화 함수의 호출이 필요 없다.
  * 위 함수가 호출되면서 초기화가 이뤄지기 때문

<br>

* 뮤텍스 또한 커널오브젝트이므로 상태를 지니는데 Signaled와 Non-signaled상태가 있다.

    * 커널 오브젝트는 Non_Signaled인 상태에서 특정 상황에 Signaled 상태가 된다.

<br>

* 뮤텍스는 누군가에 의해 획득이 가능할 때 Signaled상태에 놓이는데, 이 특성을 이용해 동기화를 한다.

<br>

### 과정
------------

1. 쓰레드는 임계영역에 들어가기 위해 뮤텍스를 획득해야 하므로 뮤텍스 핸들 인자를 전달하며 WaitForSingleObject 함수를 호출한다.

    * 뮤텍스가 획득 가능한 상태라면 Signaled 상태고, 뮤텍스를 획득하면서 임계 영역에 진입한다.

2. WaitForSingleObject()함수는 인자로 전달된 핸들의 커널오브젝트가 Signaled 상태가 되어 반환하는 경우, 해당 커널 오브젝트를 Non-Signaled로 변경하므로, 다른 쓰레드들은 임계영역에 대한 진입이 제한된다.

3. 임계 영역에서 일을 마친 쓰레드가 임계 영역을 마치면서 ReleaseMutex함수를 호출한다.
   * 이 함수가 호출되면 뮤텍스는 Signaled가 되어 다른 쓰레드들의 진입을 허용한다.

<p align="center"><img src="./../../assets/img/뮤텍스 기반 임계 영역 보호 원리.png" width=500 height =350></p>


<br><br>

## 세마포어 기반의 동기화
---------------
* 세마포어는 뮤텍스와 상당히 비슷하지만 차이가 있다.

* 그 차이는 세마포어에는 카운트 기능이 존재하고, 뮤텍스에는 존재하지 않는다.

    * 카운터 기능이란 임계 영역에 접근 가능한 쓰레드 개수를 조절하는 기능을 의미한다.

<br>

```c++
HANDLE CreateSemaphore(
    LPSECURITY_ATTRIBUTES lpSemaphoreAttribures,  // 보안 속성
    LONG lInitialCount, // 임계 영역에 접근 가능한 쓰레드 개수(열쇠 개수)
    LONG lMaximumCount, // 세마포어가 가질 수 있는 카운트의 최대 크기 지정
                        // lInitialCount와 같다면 mutex와 동일한 기능을 하고, 작을수는 없다
    LPCTSTR lpName      // 세마포어에 이름을 붙이기 위해 사용
);
// If the below function fails, the return value is NULL.


BOOL ReleaseSemapohre(
    HANDLE hSemaphore,      // 반환할 세마포어의 핸들
    LONG lReleaseCount,     /* 증가시킬 값의 크기 (2라면 세마포어 카운터는 2증가)
                               만일 최대 카운터값을 넘기면 FALSE를 반환 */
    LPLONG lpPreviousCount  // 변경되기 전 세마포어 카운트 값을 저장할 변수
);
// If the below function fails, the return value is zero
```

<br>

* 카운트가 0일 경우 Non-Signaled, 1 이상인 경우 Signaled 상태가 된다

* 세마포어의 핸들을 인자로 전달하면서 WaitForSingleObject 함수를 호출할 경우, 그 값이 하나씩 감소하면서 함수를 반환한다.

* 과정은 뮤텍스와 비슷하지만 차이점이 있다면 세마포어의 카운터가 0이 되기 전까지 WaitForSingleObject 함수를 호출할 수 있다는 점이다.

  * 만약 0인 경우 블로킹 상태가 된다.

* 임계영역에 빠져나온 쓰레드는 ReleaseMutex함수가 아닌 ReleaseSemaphore 함수를 호출해야 한다.

<p align="center"><img src="./../../assets/img/세마포어 기반 카운트 및 임계 영역 보호 원리.png" width=500 height =350></p>


<br><br>

## 이름 있는 뮤텍스 기반의 프로세스 동기화
---------------

* 위의 함수들에 생성하는 오브젝트에 이름을 붙일수 있도록 디자인되어 있음을 알 수 있다.

  * 뮤텍스에 이름을 붙이면 이름 있는 뮤텍스, 세마포어에 이름을 붙이면 이름있는 세마포어가 된다.

<br>

* 지금까지는 하나의 프로세스 내에 둘 이상의 쓰레드 동기화를 목적으로 뮤텍스가 사용되었다.

* 뮤텍스는 커널, 즉 운영체제 소유이기 때문에 다음과 같은 형태의 동기화도 가능하다.

<br>

<p align="center"><img src="./../../assets/img/이름있는 뮤텍스 활용의 예.png" width=500 height =250></p>

<br>

* 위 그림은 서로 다른 프로세스 영역에 존재하는 쓰레드가 뮤텍스를 이용해서 동기화 하는 상황이다.

* 뮤텍스는 커널 오브젝트이므로, 프로세스 A의 요청에 의해 생성되었다고 할지라도 커널에 있기 때문에 다른 프로세스에 대한 접근도 가능하다.

* ```다만, 핸들 테이블에 커널 오브젝트와 이를 지칭하는 핸들값에 대한 정보를 담고 있어, 다른 프로세스에서 접근이 불가능하다```.

* ```이러한 접근 불가능한 상황을 해결하기 위해 뮤텍스에 이름을 붙여주기로 결정한다.```

<br>

* 동기화가 가능하려면, 프로세스 B의 쓰레드도 뮤텍스에 접근이 가능해야 한다.

  * 프로세스 A 쓰레드의 핸들테이블에 적힌 뮤텍스의 핸들값을 넘겨준다고 해도 프로세스 A의 핸들테이블에서만 유효한 값이다.
    * 아래 그림에서 핸들값은 204를 의미

  * 프로세스 B의 핸들테이블에서 204는 의미가 없다.

<br>

* 프로세스 A의 핸들테이블에 등록된 뮤텍스의 핸들 정보를 프로세스 B의 핸들테이블에서도 사용가능하기 위해서는 이에 대한 정보를 전달해야 한다.
  * 하지만 다른 프로세스이기 때문에 핸들이 아닌 이름으로 전달해야 한다.

* CreateMutex나 CreateSemaphore의 매개변수로 뮤텍스의 이름을 지정할 수 있다.

* OpenMutex()함수를 통해 이름있는 뮤텍스를 지정한다.

<br>

<p align="center"><img src="./../../assets/img/이름있는 뮤텍스가 필요한 이유.png" width=500 height =250></p>

<br>

```c++
HANDLE OpenMutex(
    DWORD dwDesiredAccess,  // 이름있는 뮤텍스로의 접근 권한을 지정
    BOOL bInheritHandle,    // 핸들의 상속 유무를 결정하기 위한 전달 인자
    LPCTSTR lpName,         /* 얻고자 하는 핸들 정보의 커널 오브젝트 이름을 전달
                            이름과 일치하는 뮤텍스가 있다면, 이 뮤텍스의 핸들을 반환 핸들 테이블에 정보도 추가된다.*/
);
// If the below function fails, the return value is NULL.
```

<br><br>

뮤텍스 소유와 WAIT_ABANDONED
========================

### 예시전에 알아야 할 내용
------------------

* WaitForSingleObject() 함수 호출 후 반환값으로 WAIT_ABANDONED가 반환될 때가 있다.

* 뮤텍스는 획득한 쓰레드가 직접 반환하는것이 원칙이고, 세마포어와 그 이외 동기화 오브젝트는 다른 쓰레드가 반환해줘도 문제가 되지 않는다.



### 예시
---------------

* 두 개의 쓰레드 A,B와 동기화 오브젝트인 뮤텍스 C가 존재한다.

* 쓰레드 A가 뮤텍스 C를 획득하고 쓰레드 B는 쓰레드 A가 뮤텍스를 반환하기를 기다린다.
  
* 그런데 예상치 못한 일로 쓰레드 A가 종료되어 뮤텍스가 반환되지 않고 사라진다.

* 때문에 쓰레드 B는 없어져 버린 뮤텍스 대신 WAIT_ABANDONED값을 반환하게 된다.

    * WAIT_ABANDONED의 반환 자체는 오류가 아니다.


## 즉
---------
* WAIT_ABANDONED는 운영체제가 뮤텍스 반환이 정상적으로 이루어지지 않았을 때 대신 반환하는 값이다.