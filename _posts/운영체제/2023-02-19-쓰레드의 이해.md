---
title: 쓰레드의 이해
date: 2023-02-19
categories: [윈도우즈시스템프로그래밍, 운영체제]
tags: [windows]		# TAG는 반드시 소문자로 이루어져야함!
---

멀티 프로세스 기반 프로그램
===========================================
* 둘 이상의 서로 다른 프로그램을 실행을 위해서 둘 이상의 프로세스를 생성하는 것

* 또는 하나의 프로그램이 두가지 이상의 일을 동시에 처리하기 위해서도 둘 이상의 프로세스를 생성해야 하기도 한다.

    * 하나의 프로그램 내에서 여러 개의 실행 흐름을 찾을 수 있다.

<br><br><br>

멀티 프로세스 운영 기반 프로그램의 문제점과 새로운 제안
===========================================

* 두 가지 이상의 일을 동시에 처리하기 위해서, 혹은 둘 이상의 실행 흐름이 필요해서 추가적으로 프로세스를 추가하는 것은 부담스럽다.

  *  많은 수의 프로세스 생성은 빈번한 컨텍스트 스위칭으로 이어져 성능에 영향을 미치기 때문이다.

<br><br>

1 - 컨텍스트 스위칭에 소요되는 시간을 줄이기 위해 해야할 것
-------------------------------

* 저장하고 복원하는 컨텍스트 정보의 개수를 줄여주면 된다.

    * 컨텍스트 정보란 프로세스의 상태 정보와 관련이 있으므로 결국 프로세스 상태 정보를 줄여야 한다.

<br><br>

2 - 컨텍스트 스위칭이 필요한 이유
--------------

* 프로세스들이 서로 완전히 독립되기 때문

  * 다른 프로세스를 실행하기 위해 CPU와 메모리까지 다른 프로세스가 사용할 수 있도록 자리를 비켜야 함


<br><br><br>

쓰레드
=======================

* 별개의 프로그램을 동시 실행하기 위해서는 독립된 프로세스 구조가 필요하다.

* 하지만 하나의 프로그램 내에서 둘 이상의 실행 흐름을 두기 위해서,모든 것을 독립시키는 구조로 갈 필요는 없다.

    * 그래서 등장한 것이 쓰레드

<br><br>

쓰레드와 프로세스의 차이점
-------------- 
* 프로세스는 독립된 두 개의 프로그램을 위해서 사용된다.

* 쓰레드는 하나의 프로그램 내에서 둘 이상의 프로그램을 만들어 내기 위해 디자인됐다.

* 프로세스와 달리 쓰레드간에는 공유하는 상태 정보들이 있다.

    * 이것이 쓰레드의 컨텍스트 스위칭을 빠르게 하는 요인이 된다.

<br>

* 정리

    * 쓰레드는 하나의 프로그램 내에서 여러 개의 실행 흐름을 두기 위한 모델

    * 쓰레드는 프로세스처럼 독립적인 구조가 아닌, 쓰레드들 사이에는 공유하는 요소들이 있다.

    * 쓰레드는 공유하는 요소가 있는 관계로,컨텍스트 스위칭에 걸리는 시간이 프로세스보다 짧다.


<br><br><br>


메모리 구조 관점에서 본 프로세스와 쓰레드
===============================

* 프로세스와 쓰레드의 차이점을 이해하는 가장 좋은 방법은 메모리 구조 관점에서 비교하는 것

* 프로세스 생성 후 메모리 구조

<p align="center"><img src="./../../assets/img/프로세스 생성후 
메모리 구조.png" width=350 height =350></p>

* 자식 프로세스들은 생성되고 나서 모든 것이 부모 프로세스와 독립적이다.

  * 부모 프로세스는 자신이 가지고 있는 핸들 테이블을 상속하는 등 부모역할을 하지만, 어디까지나 생성되는 과정에서 발생하는 일

  * 메모리 구조상 생성이후에는 아무런 관계가 없다.

    * 이러한 메모리 구조를 지녔기 때문에 프로세스간의 통신을 위해선 IPC라는 매커니즘이 필요

<br><br><br>

* 쓰레드 생성후 메모리 구조

<p align="center"><img src="./../../assets/img/쓰레드 생성후 메모리 구조.png" width=500 height =300></p>


* 생성된 쓰레드들은 스택영역을 제외한 나머지 부분을 공유하고 있다.

* 쓰레드의 특성

    * 쓰레드마다 스택을 독립적으로 할당해 준다.

        * 스택은 함수 호출시 전달되는 인자, 되돌아갈 주소값 및 함수 내에서 선언하는 변수등을 저장하는 메모리 공간

        * 이 메모리 공간이 독립적이라는 뜻은 추가적인 실행 흐름을 만들 수 있다는 의미가 된다.

        * 즉, 실행 흐름의 추가를 위한 최소 조건이 독립된 스택의 제공


    * 코드 영역을 공유한다.

        * 프로세스는 다른 프로세스의 코드 영역에 있는 함수를 호출할 수 없지만, 쓰레드는 코드 영역을 공유하므로 함수를 호출할 수 있다.<br><br>

         <p align="center"><img src="./../../assets/img/프로세스 내의 쓰레드.png" width=300 height =400></p>

          1. 프로세스이므로 첫 시작인 main 함수가 있다.
          2. 이 영역에 또 다른 실행의 하는 쓰레드의 main 함수가 있다.
          3. 이 쓰레드 main 함수는 코드 영역에 존재하는 모든 함수를 호출할 수 있다.

          쓰레드가 있는 프로그램은 시작과 동시에 총 3개의 흐름이 형성하는가?  X
          자식 프로세스를 생성하는 부모 프로세스처럼, 쓰레드 생성을 위해 마련된 함수를 호출을 통해서 쓰레드를 생성한다.
        <br><br>



    
    * 데이터 영역과 힙을 공유한다.

        * 힙과 데이터 영역을 공유하므로 힙과 데이터 영역에 메모리 공간을 할당해서 서로 통신하는 것이 가능하다.

            * IPC와 같은 복잡한 통신기법이 필요없다.

        * 즉, 전역변수와 malloc 함수를 통해서 동적 할당된 메모리 공간은 공유가 가능하다.

        * 그러나, 데이터 영역과 힙 영역의 공유가 장점만 있는 것은 아니다.

            * 메모리 영역을 공유하는 만큼 문제가 발생할 수도 있다.

<br><br><br>

Windows에서의 프로세스와 쓰레드
=======================

* 프로세스와 쓰레드의 관계
  
    * Windows입장에서 프로세스는 단순히 쓰레드를 담는 상자에 지나지 않는다.
        * 때문에 실제 프로그램의 흐름을 형성하는 것은 쓰레드이다.
        
    * 프로세스의 상태 정보들은 어떻게 이해해야 하는가?

      * 사실 windows 운영체제에 있어서 프로세스는 상태(Running, Ready, Blocked)를 지니지 않는다.

      * 상태를 지니는 것은 프로세스가 아니라 쓰레드이다.

      * 스케줄러가 실행의 단위로 선택하는 것도 프로세스가 아닌 쓰레드이다.

        * Windows에 있어서 실행의 중심에 있는 것은 프로세스가 아닌 쓰레드

      * 같은 프로세스 내부의 쓰레드끼리의 컨텍스트 스위칭은 기존에 알던 프로세스의 컨텍스트 스위칭보다 속도가 빠르다.

      * 하지만, 서로 다른 프로세스의 내부에 있는 쓰레드끼리 컨텍스트 스위칭을 한다면 기존에 알던 프로세스 컨텍스트 스위칭과 같다. 속해있는 프로세스 영역이 다르면 공유하는 영역이 없기 때문이다.

<br><br>

* 그림

<br>

<p align="center"><img src="./../../assets/img/Windows에서의 스케줄링 방식.png" width=500 height =300></p>

<br>

* 프로세스 B안에 두개의 쓰레드가 존재하는데, 이 둘은 하나의 프로세스 내에 존재하므로 별개의 쓰레드가 아니다.

    * 이 둘 사이에서 발생하는 컨텍스트 스위칭은 프로세스의 컨텍스트 스위칭보다 속도가 훨씬 빠르다.

      * 같은 프로세스 내에 있으므로 스택을 제외한 나머지 영역을 공유하기 때문

<br>

* 프로세스 A의 쓰레드가 실행 도중 프로세스의 B의 쓰레드로 실행을 옮기는 과정은 프로세스의 컨텍스트 스위칭가 다를 바가 없다.


<br><br>

* 쓰레드를 생성하지 않는 프로세스의 실행 방식
    
    * 생성과 동시에 기본적으로 main함수를 호출해 줄 쓰레드를 생성하는데, 이러한 쓰레드를 main 쓰레드라고 한다.

    * 일반적으로 프로그래머에 의해 직접적으로 생성되는 쓰레드와 구분짓는다.
 

<br><br><br>

쓰레드 구현 모델에 따른 구분
===========================

* 쓰레드의 구현 원리

<br>

1 - 커널 레벨(Kernel Level) 쓰레드와 유저 레벨(User Level) 쓰레드
--------------------------
* 쓰레드를 생성해 주는 대상은 커널일 수 있다.

* 이러한 경우 운영체제가 제공하는 시스템 함수 호출을 통해 쓰레드 생성을 요구해야 한다.

* 그러면 운영체제는 해당 쓰레드를 생성 및 관리하면서 새로운 흐름을 형성하도록 도와준다.

* 이렇듯 프로그래머 요청에 따라 쓰레드를 생성 및 스케줄링 하는 주체가 커널인 경우, 이를 가리켜 커널 레벨 쓰레드라 한다.

  * 커널 레벨에서 쓰레드가 지원된다는 뜻이다.

<br><br><br><br>

2 - 커널 레벨(Kernel Level) 쓰레드
------------------------

* 하나의 프로세스에 할당되는 메모리 공간이 4G(기가)바이트라고 가정한다면
  * 일부는 프로그램 코드를 올리고, 일부는 실행중에 변수 선언이나 메모리 동적할당 용도로 쓴다. 

  * 이렇게 프로그램이 동작하기 위해 사용되는 메모리 공간을 유저 영역이라 한다.

  * 즉 코드영역, 데이터 영역, 스택,힙 영역을 가리켜 유저 영역이라고 한다.

<br><br>

* 그러면 커널 영역은? 

  * 하나의 프로세스에 할당되는 메모리 공간 중 유저 영역을 제외한 나머지 영역을 의미한다.


  * 운영체제가 실행되기 위해 운영체제 역시 메모리에 올라가야하고, 일반 프로그램처럼 실행중에 변수 선언과 메모리 동적 할당도 필요하다. 
  
  * 이렇게 운영체제라는 하나의 소프트웨어를 실행시키기 위해서 필요한 메모리 공간을 커널 영역이라 한다.


  * 과거 32비트 Windows 운영체제에서는 총 4G바이트 메모리 영역(물론 가상메모리 크기) 중 2G바이트를 유저영역, 나머지 2G바이트를 커널 영역으로 활용하였다


  * 오늘날 64비트 운영체제에서는 총 16T(테라)바이트의 메모리를 프로세스에게 할당하고, 유저영역과 커널영역은 각각 8T바이트씩 할당하고 있다.


  * 아래 그림에서, 쓰레드에게 일을 시키기 위한 프로그램 코드는 프로그래머가 개발하므로 쓰레드 A B C의 실행 코드는 유저영역에 존재한다


  * 그러나 스케줄러와 스케줄링에 필요한 쓰레드 정보는 커널 영역에 존재한다. 
  
  * 이것이 바로 커널 레벨 쓰레드의 유형이다.
  
  * 오늘날 대부분의 운영체제(Windows, Linux)는 커널 레벨 쓰레드를 기반으로 쓰레드 모델을 지원한다.

<br>

* 커널 레벨 쓰레드 모델

<br>

<p align="center"><img src="./../../assets/img/커널 레벨 쓰레드 모델.png" width=500 height =380></p>

<br><br><br><br>



3 - 유저 레벨(User Level) 쓰레드 모델
--------------------------
* 멀티 프로세스 운영체제라고 해서 커널이 기본적으로 쓰레드를 지원하는 것은 아니다.

  * 과거 UNIX에서는 비록 멀티프로세스 운영체제이긴 하나 쓰레드를 지원하지 않았다. 

* 이렇듯 커널에서 쓰레드 기능을 지원하지 않았을 때 생각해 볼 수 있는 것이 유저 레벨 쓰레드이다.

* 혹은 커널이 제공하는 쓰레드 모델이 마음에 들지 않을 겅우에도 커널에 의존적이지 않은 형태로 쓰레드의 기능을 제공하는 라이브러리를 활용할 수 있는데, 이러한 방식을 제공되는 쓰레드가 유저 레벨 쓰레드이다.

* 커널에서 제공되는 기능이 아니므로 당연히 실행 시 유저 영역에서 실행된다.

* 유저레벨 쓰레드와 커널 레벨 쓰레드는 기능의 제공 주체가 누구냐에 달려있다.

  * 유저 레벨 쓰레드 모델을 적용할 경우, 운영체제는 쓰레드의 존재를 알지도 확인하지도 못한다.

* 아래 그림은 쓰레드를 지원하지 않는 운영체제에서 유저 레벨 쓰레드 모델을 적용한 상황이다.

* 쓰레드를 지원하지 않기 때문에 스케줄러가 스케줄링 하는 대상은 프로세스이다.

* 그리고 쓰레드를 스케줄링 하는 스케줄러는 유저 영역에서 실행된다.

<br>

* 커널 레벨 쓰레드 모델

<br>

<p align="center"><img src="./../../assets/img/유저 레벨 쓰레드 모델.png" width=500 height =400></p>

<br><br><br><br>


* 중간 정리 내용

<br>
    
    메모리는 활용 대상에 따라서 유저 영역과 커널 영역으로 나뉜다.
    유저 영역은 사용자가 구현한 프로그램 동작 시 사용하게 되는 메모리 영역이고, 커널 영역은 운영체제 동작 시 사용하게 되는 메모리 영역이다.

    그리고 커널이 쓰레드를 지원할 경우 쓰레드 관리가 커널 영역에서 이뤄지기 때문에 커널 레벨 쓰레드 모델이라 하고, 커널이 지원하지 않을 경우에 라이브러리를 통해서 제공받아야 하는데 이러한 경우에는 유저 영역에서 쓰레드의 관리가 이뤄지기 때문에 유저 레벨 쓰레드 모델이라 한다.

<br>


커널 모드와 유저 모드
==========================

* Windows는 동작할 때 커널 모드와 유저 모드 중 한가지 모드로 동작한다.

* 커널 모드는 유저 영역에 비해서 상대적으로 중요하다.

    * 유저 영역에서 메모리 참조 오류가 발생한다면 실행중인 프로그램에만 영향을 끼치지만<br>
      커널 영역은 커널의 코드가 실행되는 영역이므로 시세틈 전체에 문제를 일으킬 수도 있다.

<br><br>

* 그런데 우리가 구현하거나 사용하는 프로그램은 유저 영역에서 실행되므로 커널 영역에서 문제를 일으킬 일은 없어 보인다.

    * 그러나 C언어의 특성상 메모리 참조가 용이하기 떄문에 C언어로 구현하면 이에 대한 보장을 할 수 없다.

    * 따라서 안전성 제공 측면에서 다른 방법이 필요하다.

<br><br>

* 이에 등장한 것이 커널 모드와 유저 모드이다.

  * 일반적인 프로그램은 기본적으로 유저 모드에서 동작한다
  
  * 그러다가, Windows커널이 실행되어야 하는 경우에는 커널모드로 전환이 일어난다.

  * 커널 영역에서 실행이 이뤄져야 할 경우에는 커널 모드로 전환이 일어나는 것이다.

<br><br><br>


* 여러 개의 프로세스들이 실행 중에 있다. 정해진 타임 슬라이스가 지나서 스케줄러가 동작하려고 한다. 이 때 커널 모드로의 전환이 일어나겠는가?
  
  * 당연히 일어난다, 스케줄러는 커널의 일부에 해당하기 때문이다

  * 이러한 스케줄러가 동작하려면 커널의 모드로의 전환이 필수다

<br><br>

* 그렇다면, 커널 모드와 유저 모드의 차이점은 무엇인가?
 
  * 프로세스가 유저모드에서 동작할 때에는 커널 영역으로의 접근이 금지된다.


  * 즉 뜻하지 않게 유저 모드에서 실행중인 프로그램이 커널 영역에 접근을 시도하면 시스템에서 오류가 발생했음을 알리고 접근을 봉쇄한다.

  * 반면 커널 모드에서 동작할 때에는 모든 영역의 접근이 허용된다.

  * 하지만 모드의 전환(커널 모드 유저 모드)는 시스템에 부담을 주는 일이므로 상황에 따른 적절한 반영이 요구된다.

<br><br>

* 커널 모드와 유저 모드를 제공하는 대상은 Windows 운영체제가 아닌 프로세서(Processor)이다.
  
  * 즉, 메모리 보호 기능이 CPU에 달려있다. 
  
    * 이는 메모리 관리 부분에서 설명하겠다.
 
<br><br>

1 - 커널 레벨 쓰레드와 유저 레벨 쓰레드의 장점 및 단점
----------------------------


* 커널 레벨 쓰레드의 장점 및 단점

  * 장점 : 커널에서 직접 제공해 주기 때문에 안전성과 다양한 기능성이 제공된다
  
  * 단점 : 커널에서 제공해 주는 기능이기 때문에 유저 모드에서 커널 모드로의 전환이 빈번하게 일어난다. 따라서 이는 성능의 저하로 이어지게 된다.

<br><br>

* 유저 레벨 쓰레드의 장점 및 단점

  * 장점 : 커널은 쓰레드의 존재조차 모른다. 오로지 유저 모드로 동작하기 때문에 유저 모드에서 커널 모드로의 전환이 필요없다. 때문에 성능이 좋다.

  * 단점 : 하나의 프로세스 내에 총 3개의 쓰레드 A B C가 있다고 했을 때  A 쓰레드가 시스템 함수를 호출했는데 커널에 의해 블로킹되었다. 이럴 경우 B,C도 실행되지 않는다.<br>
  운영체제는 프로세스의 존재만 알지 쓰레드의 존재를 모른다. 때문에 A 쓰레드가 속해있는 프로세스 전부가 블로킹되는 문제를 안고 있다.<br>이 문제를 해결하기 위한 방법이 있지만 결국 프로그래밍이 어려워지고 커널 레벨 쓰레드에 비해 결과 예측이 어렵다.


<br><br>

* 분명 속도의 향상이라는 유저레벨 쓰레드의 장점이 있다.

  * 때문에 Windows 개발자들과 달리 Linux 개발자들은 라이브러리를 통한 유저 레벨 쓰레드를 활용하기도 한다.
 