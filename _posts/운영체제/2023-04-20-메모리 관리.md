---
title: 메모리 관리
date: 2023-04-17
categories: [윈도우즈시스템프로그래밍, 운영체제]
tags: [windows]		# TAG는 반드시 소문자로 이루어져야함!
---

가상 메모리(Virtual Memory) 컨트롤
=================
* CPU 관점에서 보는 메모리는 물리 메모리

* CPU와 프로그래머가 바라보는 메모리는 같은 메모리로, 32bit면 4GB의 메모리

* 4GB라는 가상 메모리가 있고 실제 메모리는 별도로 존재해면서 가상 메모리와 매핑되는 구조를 가지고 있다.

<br>

## 가상 메모리의 Commit, Free와 물리메모리의 관계
-----------------

* 가상 메모리는 페이지 단위로 나눠진다
  * `페이지의 개수는 가상 메모리의 크기/ 페이지 하나당의 크기`

* 페이지는 윈도우상에서 가상 메모리로, 실제로 컨트롤하는 객체는 운영체제이다.
  
* 윈도우즈는 가상 메모리(페이지)를 관리할 때 특성 정보를 부여한다.

<br><br>

## 특성 정보
--------------

<p align="center"><img src="./../../assets/img/윈도우즈%20시스템%20프로그래밍/메모리%20관리/FreeCommit.png" width=600 height =300></p>

* Commit 상태
  * 이 가상메모리는 물리적인 메모리가 할당되었음을 의미
  * 대표적인 예는 malloc() 함수로,호출하면 이 페이지를 물리 메모리와 맵핑시키겠다는 의미이다.
  * free함수를 사용해서 반환하면 그 페이지는 Free 상태가 되면서 물리 메모리와의 연결을 끊는다

* Free 상태
  * 초기 상태로, 이 가상메모리는 물리 메모리와 연결되지 않은 비어있는 메모리.


* Reserve 상태

  * 메모리를 Commit과 Free로만 관리하니 메모리 효율이 비효율적이라 나온것이 Reserve 상태이다
  * Windows에서만 사용한다.

<br><br>

## Reserve 상태의 필요성
---------------------

* 예시로 평소에는 100정도의 메모리를 사용하는 프로그램이 어떤 경우에 10000의 메모리를 요구하는 매일 실행되는 프로그램이 있다고 가정한다.

* 그러면 그 메모리를 평소정도인 100이 아닌, 10000도 포함할 수 있게 할당해야 해서 10000을 배열의 크기로 잡을 것이다.

* 그 어떠한 경우를 위해 10000의 메모리 크기를 부여하는것은 매우 비효율적이다.

<br><br>

<p align="center"><img src="./../../assets/img/윈도우즈%20시스템%20프로그래밍/메모리%20관리/예제.png" width=600 height =400></p>

* 위 그림에서 COMMIT 상태의 페이지 5개가 있는데 페이지0,1만 사용한다면 페이지 2,3,4는 할당받은 상태로 아무것도 하지 않아 다른 메모리에서 사용할 수가 없다.

* 그러면서 물리 메모리와의 연결도 돼 있기 때문에 더 문제이다.

* 페이지1,2만 잡아놓고 나중에 추가적으로 받으면 되는 것이라고 생각할 수도 있겠지만, 앞에 처럼 만들면 가상메모리상에서의 연결된 메모리 구성이 아니게 된다.

* 이런 상태를 막기위해 Reserve상태를 사용한다.



<br><br>

<p align="center"><img src="./../../assets/img/윈도우즈%20시스템%20프로그래밍/메모리%20관리/RESERVE%20상태에%20대한%20이해.png" width=600 height =300></p>


* Reserve는 "예약"이라는 뜻으로,다른 곳에서 Reserve 공간을 할당하려할 때 할당을 허용하지 않는다.

* 그러면서 RESERVE상태는 COMMIT 상태가 아니면 물리적인 메모리와의 맵핑도 되지 않는다.

* 쉽게 말하면 나중에 사용할 수도 있으니 접근 X

<br><br>

## 메모리 할당의 시작점과 단위 확인
-------------------

* 평소에는 Free상태로 있다가 Commit 또는 Reserve로 바꿀수 있는데 페이지 중간부터 상태를 바꿀 수가 없다.

* OS는 페이지 단위로 관리하기 때문에 메모리를 할당하기 위해선 기준인 최소단위가 있다.

* 최소 단위는 Allocation Granularity Boundary 기준.
  * 메모리 할당의 시작점을 의미한다.

  * 페이지 크기의 몇 배수: 지나친 단편화를 막기 위해.
    * 홀수 번지마다 할당 가능하다면 A B A B 이런 식은 불가능하다.
    * 하지만 A A B B 는 가능하다.메모리 관리측면에서 편해지고 단편화가 해결된다

<br>

* 할당할 메모리의 크기
  * 최소 1페이지 이상
    * 페이지 중간에 할당하는 것을 막기 위해 설정

<br>

* GetSystemInfo(&si) // SYSTEM_INFO

  - pageSize = si.dwPageSize  // 페이지 사이즈

  - allocGranularity = si.dwAllocationGranularity // 메모리 할당 시작점을 어떻게 잡을지

  * dwPageSize는 4K일 경우 dwAllocationGranularity 64K

  * 페이지 사이즈가 4KB이면 Allocation Granularity Boundary는 64KB.

  * 그럼 우리는 64KB 번지를 시작으로 4KB 만큼 메모리 할당 요청 가능.

  * 그 다음은 128KB 번지를 시작으로 4KB만큼 메모리 할당 요청 가능.


<br>

```c++
// malloc()과 유사하다.
// malloc()은 힙 메모리,VirtualAlloc는 가상 메모리(가상 메모리도 힙메모리)
// malloc()은 COMMIT/FREE 상태만 가능하지만 아래 함수는 RESERVE 상태도 가능하다..
LPVOID VirtualAlloc(
    LPVOID lpAddress,       // 할당의 시작 주소.
    SIZE_T dwSize,          // 할당의 크기
    DWORD flAllocationType, // MEM_RESERVE(거의 쓸일 X) or MEM_COMMIT
    DWORD flProtect         // PAGE_NOACCESS or PAGE_READWRITE
);  // 반환: 할당이 이뤄진 메모리의 시작번지
```

```c++
// VirtualFree()는 COMMIT 상태를 FREE 상태로 끌어내리기도 하지만,
// RESERVE 상태를 FREE 상태로 끌어내리기도 함.(잘 안씀)
// 또한 COMMIT 상태를 RESERVE상태로 끌어내리기도 한다.
// 결국 아래 함수는 할당 받은 가상 메모리 공간을 반환하는데 의의가 큼.
BOOL VirtualFree(
    LPVOID lpAddress,
    SIZE_T dwSize,
    DWORD dwFreeType // MEM_DECOMMIT(COMMIT->RESERVE) or MEM_RELEASE
);
```

<br><Br>

힙 컨트롤
======================

## 디폴트힙

<p align="center"><img src="./../../assets/img/윈도우즈%20시스템%20프로그래밍/메모리%20관리/Windows 디폴트 힙.png" width=600 height =300></p>

* 규칙적이지도 않고, 그 크기도 결정되어 있지 않은 경우에는 List 자료구조로 구현한다.

* List 자료구조는 지울 때 메모리를 반환할 때 일일이 방문해서 전부 지워줘야 한다.

  * 그렇기 때문에 에러 발생 확률이 높다.

* 위의 예에선 하나의 Heap안에 홍길동과 최대수를 위한 데이터가 같이 존재하기 때문에 최대수의 데이터만 지우려면 일일이 최대수의 데이터를 방문하고 지워주는데 이 때 에러가 발생할 확률이 높아진다.

* 힙을 만들면 Windows가 기본적으로 제공해주는 Heap을 디폴트 힙이라 한다.

  * 초기 크기가 정해져 있고 늘어날 수도 있다.

* Windows는 디폴트 힙이외에 힙을 더 만들 수 있게 해주는데 그것이 힙 컨트롤이다.


<br><br>

## 컨트롤 힙

<p align="center"><img src="./../../assets/img/윈도우즈%20시스템%20프로그래밍/메모리%20관리/Windows%20시스템에서%20힙%20메모리.png" width=600 height =300></p>

* 위에 홍길동을 위한 힙 A와 최대수를 위한 힙 B이 있다.

* 최대수의 데이터를 지우려면 한번의 함수 호출로 힙B를 삭제시켜버리면 된다.
  * Dynamic Heap이라는 기법이 제공함

<br>

* 가상 메모리 컨트롤은 예약이 주요 관점으로, 메모리를 효율적으로 사용하기 위해서

* Dynamic Heap은 메모리 효율성보다는 데이터를 분리(관리)하겠다는 측면이 강하다.

* Virtual Memory는 스택,힙,데이터, 그 외의 메모리 공간이 있는데 그 외의 메모리 공간에 힙 메모리 공간에 추가로 할당할 수 있다.
  * 이 행동을 힙으로 볼지, 가상 메모리 일부를 다른 용도로 사용하는지는 관점에 따라 다름

* 그런데 힙 메모리는 할당 및 결정이 Runtime 때 이뤄진다.

* 가상 메모리의 힙 할당도 Runtime 때 받기 때문에 힙으로도 볼 수 있다.

<br><Br>

## Dynamic Heap의 이점
-----------------------

<p align="center"><img src="./../../assets/img/윈도우즈%20시스템%20프로그래밍/메모리%20관리/메모리%20단편화와%20힙.png" width=500 height =500></p>

* 메모리 단편화 해소

  * 프로그램의 로컬리티가 낮아지는 문제점 발생할 수 있음

  * 동적 힙을 사용하면, 관련된 데이터들만 빈틈없이 연속적으로 배치할 수 있음.


* 동기화 문제에서 자유

  * 쓰레드 별로 힙을 생성할 수 있는데, 동시에 같은 메모리를 할당할 수 있으므로 다른 쓰레드의 접근을 막는다.

  * 그림의 왼쪽처럼 별도의 힙을 구성한다면, 쓰레드별로 힙을 생성해서 동기화 문제를 막을 수 있음

<br><Br>

##  Dynamic Heap 생성 및 할당
---------------------------

* 힙의 생성 및 소멸

  * HeapCreate(): 힙의 생성
    * 디폴트 힙이 아닌 외부의 메모리 공간에서 힙 생성할 때 사용하는 함수

  * HeapDestroy(): 힙의 소멸. 위 그림에서 힙B처럼 모든 메모리가 한꺼번에 날아간다.

<br> 

* 생성된 힙 내의 메모리 할당 및 해제

  * HeapAlloc(): 힙 내에 메모리 할당. HeapCreate()시에 반환되는 힙 핸들을 이용.

  * HeapFree(): 힙 내에 메모리 반환

    * malloc()/free()는 디폴트 힙에 할당하고 반환

<br><br>

MMF(Memory Mapped File)
======================

## 1번 그림

<p align="center"><img src="./../../assets/img/윈도우즈%20시스템%20프로그래밍/메모리%20관리/MMF%20이해.png" width=600 height =300></p>

<br>

## 2번 그림

<p align="center"><img src="./../../assets/img/윈도우즈%20시스템%20프로그래밍/메모리%20관리/MMF의%20데이터%20저장%20관계.png" width=600 height =400></p>

<br>

* File의 일부 메모리를 프로세스의 가상메모리에 연결시킨다. (1번)
* 연결 후, 프로세스의 가상 메모리에 데이터를 저장하면 그 파일에 반영된다 (2번)
  * 이 때 위치(오프셋)도 적용됨, 그림에서 보면 색깔 부분으로 구분되어 있음.

<br>

MMF의 개념
---------------

* 파일에 저장되어 있는 기능을 정렬하려면, 전부 메인메모리에 올려 정렬하고 다시 파일에 저장해야  한다.

* MMF를 사용하면 메모리가 파일에 Mapping 돼 있으니까 메인 메모리에서 정렬하면 알아서 적용된다.

<br><br>

MMF의 장점
-------------

<p align="center"><img src="./../../assets/img/윈도우즈%20시스템%20프로그래밍/메모리%20관리/MMF의%20성능%20향상.png" width=600 height =500></p>

* 데이터를 메모리에 Write하기 때문에 가장 최신 데이터도 메모리에 있다.

* 그래서 read할 때 File이 아닌 메모리에서 Read하면 된다.

* 일단 메모리에 Write,Read하기 때문에 File에 저장하는건 주기적 or 특정 이벤트 발생했을 때만 해도 된다.

  * 즉, 빈번한 I/O가 발생하는 곳은 가장 최근 데이터를 유지하고, 데이터를 저장할 수 있는 상황이 보장된다면 주기적,상황적으로 저장해도 된다.

* 결국 File에 있는 Data를 메모리가 Cash역할을 해주고 있는 것.

<br><br>

MMF 구현과정
-------------------

* 1단계: 파일의 생성

  * HANDLE hFile = CreateFile(...);

<br>

* 2단계: 파일 연결 오브젝트 생성

  * HANDLE hMapFIle = CreateFileMapping(hFile, ...);

    * 파일 만들고 바로 메모리와 매핑시키는게 아니다.

    * 매핑을 시킬 수 있도록 파일 정보를 담은 오브젝트를 만들어야 한다.

    * 파일 매핑을 위한 연결 오브젝트라고도 함.

    * 이 오브젝트를 통해서 OS에게 "이 파일의 이부분을 매핑 시켜주세요."라고 요청.

<br>

* 3단계: 가상 메모리에 파일 연결

  * TCHAR* pWrite = (TCHAR*)MapViewOfFile(hMapFile, ...);

    * 실질적으로 파일과 메모리의 어디서부터 어디까지를 매핑 진행 요청.

    * 이제 pWrite 부터 원하는 위치까지 포인터 연산을 통해서 접근하면 된다.

    * ptr to char이기 때문에 1byte 마다 접근 가능.

    * ptr ro int로 바뀌면 4byte 단위 마다 접근 가능.