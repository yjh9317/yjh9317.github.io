---
title: 1장 C++의 동시성
date: 2024-09-01
categories: [Concurrency,Concurrency]
tags: [concurrency]		# TAG는 반드시 소문자로 이루어져야함!
---

# **1.1 동시성이란 무엇인가?**

* 가장 기본적인 수준에서 동시성은 `둘 이상의 개별적인 활동이 동시에 발생하는 것을 의미`
* 컴퓨터 시스템에서의 동시성은 단일 시스템이 여러 독립적인 활동을 순차적이 아닌 병렬적으로 수행하는 것을 말함

## **컴퓨터 시스템에서의 동시성**

* 과거 대부분의 컴퓨터는 단일 프로세서(싱글 코어)를 가지고 있었고, 작업 전환(task switching)을 통해 여러 작업이 동시에 실행되는 것처럼 보이게 했다.

  * 이는 실제 병렬 처리가 아닌 환상에 가까움

*  반면, 다중 프로세서 또는 멀티코어 프로세서를 가진 컴퓨터는 진정한 하드웨어 동시성(hardware concurrency)을 통해 여러 작업을 실제로 병렬 실행할 수 있다.


## **동시성에 대한 접근 방식**

### **다중 프로세스 (Multiple Processes)**

* 각 프로세스가 자체 스레드에서 실행되며, 운영체제에 의해 보호받는 독립된 주소 공간을 가짐.
* 프로세스 간 통신(IPC)은 복잡하거나 느릴 수 있지만, 데이터 격리로 인해 안전한 동시 코드 작성이 용이할 수 있음

### **다중 스레드 (Multiple Threads)**
* 단일 프로세스 내에서 여러 스레드가 실행.
* 스레드들은 주소 공간을 공유하므로 데이터 공유가 용이하지만, 공유 데이터 접근 시 일관성 유지를 위한 프로그래머의 세심한 주의가 필요함.

<br>

# **1.2 왜 동시성을 사용하는가?**

* 동시성을 사용하는 주된 이유는 `관심사 분리(separation of concerns)`와 `성능 향상(performance)`

## **관심사 분리를 위한 동시성 사용**

* 서로 다른 기능 영역을 별도의 스레드로 분리하여 코드를 더 이해하기 쉽고 테스트하기 용이하게 만들 수 있음.
*  예를 들어, DVD 플레이어 애플리케이션에서 사용자 인터페이스 처리와 DVD 재생 처리를 별도의 스레드로 분리하면 각 스레드의 로직이 단순해지고 응답성이 향상됨

## **성능을 위한 동시성 사용**

* 멀티코어 프로세서의 가용성이 높아짐에 따라, 소프트웨어가 이러한 추가적인 컴퓨팅 성능을 활용하기 위해서는 여러 작업을 동시에 실행하도록 설계되어야 함

### **작업 병렬성 (Task Parallelism)**

* 단일 작업을 여러 부분으로 나누어 병렬로 실행하여 전체 실행 시간을 줄임.

### **데이터 병렬성 (Data Parallelism)**

* 여러 스레드가 동일한 작업을 데이터의 다른 부분에 대해 수행함

### **동시성을 사용하지 말아야 할 때**

* 동시성으로 얻는 이점보다 비용이 클 때는 사용하지 않는 것이 좋음.  
* 멀티스레드 코드는 이해하고 유지 관리하기 더 복잡하며, 버그 발생 가능성도 높음.
* 또한, 스레드 시작에는 오버헤드가 따르며, 너무 많은 스레드는 시스템 리소스를 고갈시키거나 작업 전환 비용을 증가시켜 오히려 성능을 저하시킬 수 있음

<Br>

# **1.3 C++에서의 동시성과 멀티스레딩** 

### **C++ 멀티스레딩의 역사**

* 1998년 C++ 표준은 스레드의 존재를 인지하지 않았음.
* 컴파일러 공급업체들은 플랫폼별 확장을 통해 멀티스레딩을 지원해왔음.
* MFC, Boost, ACE와 같은 C++ 라이브러리들은 플랫폼별 API를 캡슐화하여 객체 지향적인 멀티스레딩 기능을 제공했음

### **새로운 표준(C++11)에서의 동시성 지원**

* C++11 표준은 새로운 스레드 인지 메모리 모델과 함께 스레드 관리, 공유 데이터 보호, 스레드 간 연산 동기화, 저수준 원자적 연산(atomic operations)을 위한 클래스들을 표준 라이브러리에 포함시킴.
* Boost 스레드 라이브러리가 새 라이브러리의 주된 모델이 됨

### **C++ 스레드 라이브러리의 효율성**

*  C++ 표준 위원회는 표준 라이브러리, 특히 스레드 라이브러리 설계 시 효율성을 중요하게 고려.
*  저수준 API를 직접 사용하는 것보다 이점이 거의 없도록 설계되었으며, 대부분의 주요 플랫폼에서 효율적인 구현이 가능하도록 함.
*  또한, 궁극적인 성능을 위해 저수준 원자적 연산 라이브러리를 제공

### **플랫폼별 기능**

* C++ 스레드 라이브러리는 포괄적인 기능을 제공하지만, 특정 플랫폼에서는 표준 라이브러리가 제공하는 것 이상의 기능을 제공할 수 있음.
* 이를 위해 `native_handle()` 멤버 함수를 통해 기본 구현을 플랫폼별 API로 직접 조작할 수 있도록 지원할 수 있음

<br>

# **1.4 시작하기**

* C++에서 멀티스레드 프로그램을 작성하는 것은 일반적인 C++ 프로그램 작성과 크게 다르지 않지만, 일부 함수가 동시에 실행될 수 있으므로 공유 데이터에 대한 동시 접근이 안전하도록 보장해야 함.

```c++
#include <iostream>
#include <thread>           

void hello()                       
{
  std::cout<<"Hello Concurrent World\n";
}

int main()
{
  std::thread t(hello);   
  t.join();                      
}
```

* `<thread>` 헤더를 포함
* 새 스레드에서 실행될 함수(초기 함수, initial function)를 정의 
* `std::thread` 객체를 생성하여 새 스레드를 시작하고, 이 객체의 생성자에 실행할 함수를 전달. 
* 메인 스레드는 새 스레드가 완료될 때까지 `join()` 멤버 함수를 호출하여 기다려야 함. 그렇지 않으면 주 프로그램이 먼저 종료되어 새 스레드가 실행될 기회를 갖지 못할 수 있음

