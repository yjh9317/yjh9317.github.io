---
title: 재정의 함수들을 override로 선언하라
date: 2024-02-20
categories: [Modern Effective C++,Modern Effective C++]
tags: [modern effective c++]		# TAG는 반드시 소문자로 이루어져야함!
---

* C++의 객체 지향 프로그래밍에는 클래스,상속,가상함수를 중심으로 돌아간다.

* 그 중에 있는 가상 함수는 잘못 사용하기가 매우 쉽다.


# 가상함수

### 가상함수의 필수조건

* 가상함수의 재정의가 일어나려면 다음과 같은 여러 필수조건을 만족해야 한다.

  * 부모 클래스 함수가 반드시 가상 함수여야 한다.

  * 부모 클래스의 함수와 자식 클래스의 함수가 같은 이름이어야 한다.(소멸자 예외)
  
  * 부모 클래스의 함수와 자식 클래스의 함수의 매개변수 형식이 반드시 동일해야 한다.

  * 부모 클래스의 함수와 자식 클래스의 함수의 const성이 동일해야 한다.

  * 부모 클래스의 함수와 자식 클래스의 함수의 반환 타입과 예외 명세가 반드시 호환되어야 한다.

* 위는 C++98에서도 적용되는 규칙들이고, 이후 C++11에서 다음과 같은 조건 하나가 추가되었다.

  * 멤버 함수들의 참조 한정사가 동일해야 한다.

### 참조 한정사

* 참조 한정사는 C++11의 기능으로, 이 기능으로 멤버 함수를 왼값 or 오른값에만 사용할 수 있게 제한할 수 있다.

* 가상 함수가 아닌 멤버 함수에도 가능하다.

```c++
// 선언
class Widget {

public:
    void doWork() &;    // *this가 왼값일 때만 호출

    void doWork() &&;   // *this가 오른값일 때만 호출
};

// 적용

Widget makeWidget();    // 팩토리 함수(오른값 반환)

Widget w;               // 보통 객체 (왼값 반환)

...

w.dowork();             // 왼값 전용 함수를 호출

makeWidget().dowork();  // 오른값 전용 함수를 호출
```

* 주의해야할 점은 부모 클래스의 가상 함수에 참조 한정사가 있다면, 재정의하는 자식 클래스의 가상 함수에도 같은 참조 한정사가 있어야 한다.


<br>

### 참조 한정사 사용 예시

* 멤버 함수 참조 한정사를 붙여야 하는 상황이 흔치 않지만,다음과 같은 경우에 사용한다

* 만약 Widget 클래스에 vector 멤버가 있고 그것에 직접 접근할 수 있는 멤버 함수를 클라이언트에게 제공한다고 한다.

```c++
// 클래스
class Widget{
public:
  using DataType = std::vector<double>;

  DataType& data() { return values; }

private:
  DataType values;
};

// 사용

Widget w;

auto vals1 = w.data(); // w.values를 vals1에 복사
```

* data의 반환 형식은 왼값 참조이며 왼값 참조는 정의상 왼값으로 취급되므로, vals1은 복사 생성된다.

* 다음으로, Widget을 생성하는 팩토리 함수가 있고 이 팩토리 함수를 통해 변수를 초기화한다고 한다.

```c++
// 팩토리 함수
Widget makeWidget();

// 팩토리 함수로 초기화
auto vals2 = makeWidget().data(); // Widget 안에 있는 values를 vals2에 복사
```

* 이 Widget::data 도 왼값 참조를 돌려주며 복사 생성되지만, Widget은 makeWidget이 돌려준 임시객체이다.

* 그 임시 객체 안의 vector를 복사보다 이동이 바람직하지만, data가 왼값 참조를 돌려주기 때문에 C++의 규칙들을 준수하는 컴파일러는 반드시 복사 연산을 위한 코드를 작성해야 한다.

* 정말로 필요한 것은 data가 오른값 Widget에 대해 호출될 경우에는 반드시 오른값을 돌려주게 하는 것이다.

* 참조 한정사 버전으로 오버로딩하면 그런 일이 가능하다.

```c++
class Widget{
public:
  using DataType = std::vector<double>;

  DataType& data() & { return values; }   // 왼값 참조 한정사
  DataType&& data() && { return values; } // 오른값 참조 한정사

private:
  DataType values;
};
```

* 왼값 참조 한정사는 왼값 참조를 돌려주고, 오른값 참조 한정사는 오른값 참조 한정사를 돌려준다.

```c++
auto vals1 = w.data();            // 왼값 참조로, 복사 생성

auto vals2 = makeWidget().data(); // 오른값 참조로, 이동 생성
```

* 하지만 멤버 함수에 참조 한정사가 붙어 있다면, 그 함수의 모든 오버로딩 함수들도 참조 한정사를 지정해야 한다.

* 이는 참조 한정되지 않은 오버로딩이 왼값 객체와 오른값 객체 모두에 대해 호출될 수 있기 때문이다.

* 그런 오버로딩은 참조 한정된 오버로딩들과 경쟁하며, 따라서 그 함수에 대해 모든 호출이 중의적인 호출로 변한다.

<br>

# **결론**

> 이것만은 잊지 말자!
> * 멤버 함수 참조 한정사를 이용하면 멤버 함수가 호출되는 객체(*this)의 왼값 버전과
>   오른값 버전을 다른 방식으로 처리할 수 있다.
> {: .prompt-tip }