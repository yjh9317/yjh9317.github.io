---
title: 특수 멤버 함수들의 자동 작성 조건을 숙지하라
date: 2024-04-03
categories: [Modern Effective C++,Modern Effective C++]
tags: [modern effective c++]		# TAG는 반드시 소문자로 이루어져야함!
---

* C++에서의 특수 멤버 함수들은 `스스로 작성하는 멤버 함수`를 의미한다.

* C++98에서는 `기본 생성자,소멸자,복사 생성자, 복사 대입 연산자`가 있는데, 이 함수들은 명시적으로 선언되어 있지 않지만 사용될 때 작성된다.

* 작성된 특수 멤버 함수들은 `암묵적으로 public이자 inline`이며 `가상 소멸자를 상속받는 클래스를 제외하고는 non-virtual`이다.

<br>

# C++11 특수 멤버 함수 작성에 관한 규칙

* C++11에서 들어와서는 특수 멤버 함수 그룹에 `이동 생성자`와 `이동 대입 연산자`가 추가되었다.

```c++
class Widget {
public:
    Widget(Widget&& rhs);

    Widget& operator=(Widget&& rhs);
};
```

* 이들에 대해서는 복사 관련 생성자와 규칙이 비슷하다.

## 이동 연산의 주의점

* 이동 연산들은 필요할 때만 작성되며, non-static 멤버에 관해서만 이동을 수행한다

* 그런데 항상 이동 연산이 실제로 일어난다는 보장은 없다. 사실 멤버별 이동은 `멤버별 이동 요청`에 가깝다.

* 이유는 `이동이 활성화되지 않은 형식은 그 형식이 제공하는 복사 연산들을 통해서 이동되기 때문이다.`

* 결국 이동 연산을 지원하지 않는다면 복사 연산이 수행된다가 핵심이다.

<br>

## 이동 연산 작성되는 조건

* 이동 연산은 복사 연산들의 것과 조금 다르다

### 복사 연산 조건

* `복사 연산은 서로 독립적이라 하나를 선언한다고 다른 하나의 작성이 방지되지는 않는다`

* 즉, 복사 연산을 선언하고 복사 대입 연산자를 명시적으로 선언하지 않은 상태에서 복사 대입 연산자를 사용하면 컴파일러가 자동으로 작성한다.

### 이동 연산 조건

* 하지만 `이동 연산은 독립적이지 않아 둘 중 하나를 선언하면 컴파일러는 다른 하나를 작성하지 않는다`

* 이유는 `이동 생성자가 적합하지 않은 클래스라면 이동 대입 연산자 역시 적합하지 않을 가능성이 높기 때문이다`

### 복사 연산과 이동 연산 관계

* `복사 연산을 하나라도 명시적으로 선언한 클래스에 대해서는 이동 연산들이 작성되지 않는다`

* 이유는 `복사 연산을 선언했다는 것은 일반적인 객체 복사 방식(멤버별 복사)이 그 클래스에 대해 적합하지 않고, 그렇다면 이동 연산 역시 적합하지 않을 가능성이 높기 때문이다`

<br>

* 반대 방향도 마찬가지로, `이동 연산을 하나라도 명시적으로 선언하면 컴파일러는 복사 연산들을 비활성화한다`

<br>

## 3의 법칙

* 3의 법칙이란 `복사 생성자, 복사 대입 연산자, 소멸자 중 하나라도 선언했다면 나머지 둘도 전부 선언해야 한다`라는 의미이다.

* 복사 대입 연산자를 프로그래머가 직접 지정해야 하는 경우는 그 클래스가 어떤 형태로든 자원 관리를 수행하기 때문에 생긴다

* 근데 그러한 클래스는 거의 항상 (1) 복사 연산이 수행하는 자원 관리를 다른 복사 연산에도 수행해야 하며, (2) 클래스 소멸자 역시 자원 관리에 참여한다.


<br>

## 이동 연산 작성 조건 정리

* 클래스에 대한 이동 연산들은 다음 세 조건이 모두 만족되고 필요할 때만 자동으로 작성된다.

```yaml
1. 클래스에 그 어떤 복사 연산도 선언되어 있지 않다
2. 클래스에 그 어떤 이동 연산도 선언되어 있지 않다.
3. 클래스에 소멸자가 선언되어 있지 않다.
```

<br>

## default

* 만일 클래스 중에 소멸자나 복사 연산 중 하나를 선언하면 복사 연산들이 자동으로 작성된다는 점에 의존하는 것이 있다면, 그런 의존성이 사라지도록 클래스를 업그레이드 하는 것이 바람직하다.

* C++11에서는 기본 행동을 사용하겠다는 의사를 `=default`를 이용해 명시적으로 표현할 수 있다.

```c++
class Widget{
public:  
    ~Widget();

    Widget(const Widget&) = default;

    Widget& operator=(const Widget&) = default;
};
```

* 이러한 접근 방식은 다형적 기반 클래스, 즉 파생 클래스 객체를 조작하는 데 사용하는 인터페이스를 정의하는 클래스에 유용한 경우가 많다.

  * 대체적으로 가상 소멸자가 있다.

* 소멸자를 가상으로 만드는 것 이외에는 변경할 것이 없는 기본 구현이 적합한 경우에 default를 사용하면 좋다.

### default의 다른 용도

* 독자가 소멸자를 직접 선언하면 이동 연산들의 자동 작성이 금지된다.

* 만일 그러한 `사용자 선언 소멸자를 두면서도 이동을 지원하고 싶다면, 이동 연산에 =default를 지정하면 된다`

* 이동 연산들을 직접 선언하면 복사 연산들이 비활성되지만, 복사 연산 역시 지원하고 싶다면 =default를 지정하면 된다

```c++
class Base{
public:
    virtual ~Base() =default;

    Base(Base&&) = default;
    Base& operator&(Base&&) = default;

    Base(const Base&) =default;
    Base& operator=(const Base&) = default;
};
```

<br>

# 특수 멤버 함수들을 관장하는 C++11 규칙들 정리

```yaml
1. 기본 생성자 :
- C++98의 규칙과 같다.
- 클래스에 사용자 선언 생성자가 없는 경우 자동으로 작성한다.

2. 소멸자 :
- C++98 규칙들과 본질적으로 같다.
- 유일한 차이는 소멸자가 기본적으로 noexcept라는 점이다.
- C++98에서처럼, 기본적으로 작성되는 소멸자는 기반 클래스 소멸자가 
  virtual일 때만 virtual로 작성한다.

3. 복사 생성자 :
- 런타임에서는 C++98과 동일하다.
- 즉, non-static 자료 멤버들을 멤버별로 복사 생성한다.
- 클래스에 사용자 선언 복사 생성자가 없을 때에만 자동으로 작성된다.
- 클래스에 이동 연산이 하나라도 선언되어 있다면 삭제된다.
- 사용자 선언 복사 대입 연산자나 소멸자가 있는 클래스에서 
  복사 생성자의 자동 작성 기능은 비권장이다.

4. 복사 대입 연산자 : 
- 런타임에서는 C++98과 동일하다.
- 즉, non-static 자료 멤버들을 멤버별로 복사 대입한다.
- 클래스에 사용자 선언 복사 대입 연산자가 없을 때에만 자동으로 작성된다.
- 클래스에 이동 연산이 하나라도 선언되어 있다면 삭제된다.
- 사용자 선언 복사 대입 연산자나 소멸자가 있는 클래스에서 
  복사 생성자의 자동 작성 기능은 비권장이다.

5. 이동 생성자와 이동 대입 연산자 :
- 각각 non-static 자료 멤버의 멤버별 이동을 수행한다.
- 클래스에 사용자 선언 복사 연산들과 이동 연산, 소멸자가 없을때에 
  자동으로 작성한다
```

<br>

# 멤버 함수 템플릿과 특수 멤버 함수 자동 작성 관계

* `멤버 함수 템플릿이 존재한다고 해도 특수 멤버 함수의 자동 작성이 비활성화된다는 규칙은 없다`

```c++
class Widget{

    template<typename T>
    Widget(const T& rhs);

    template<typename T>
    Widget& operator=(const T& rhs);
};
```
* 이 템플릿들이 복사 생성자나 복사 대입 연산자들의 서명과 일치하는 함수들로 인스턴스화될 가능성이 있지만, 컴파일러는 여전히 복사 연산들과 이동 연산들을 작성한다.

<br>

# 결론


> 이것만은 잊지 말자!
> * 컴파일러가 스스로 작성할 수 있는 멤버 함수들, 즉 기본 생성자와 소멸자,
>   복사 연산들, 이동 연산들을 가리켜 특수 멤버 함수라고 부른다.
>
> * 이동 연산들은 이동 연산들이나 복사 연산들, 소멸자가 명시적으로 선언되어
>   있지 않는 클래스에만 자동으로 작성된다.
>
> * 복사 생성자는 복사 생성자가 명시적으로 작성되지 않은 클래스에 대해서만
>   자동으로 작성되며, 이동 연산이 있다면 삭제된다.
>   복사 대입 연산자는 복사 대입 연산자가 명시적으로 작성되지 않은 클래스에
>   대해서만 자동으로 작성되며, 이동 연산이 있다면 삭제된다.
>   소멸자가 명시적으로 선언되 클래스에서 복사 연산들이 자동으로 작성되는
>   기능은 비권장이다.
>
> * 멤버 함수 템플릿 때문에 특수 멤버 함수의 자동 작성이 금지 되는 경우는
>   전혀 없다.
> {: .prompt-tip }

