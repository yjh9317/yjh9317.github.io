---
title: 예외를 방출하지 않을 함수는 noexcept로 선언하라
date: 2024-03-21
categories: [Modern Effective C++,Modern Effective C++]
tags: [modern effective c++]		# TAG는 반드시 소문자로 이루어져야함!
---

# **C++98 예외명세**

* 프로그래머는 함수에서 발생할 수 있는 예외 형식들을 요약하고, 그래서 함수의 구현이 수정되면 예외 명세도 바꿔야 할 가능성이 생겼다.

* 그런데 예외 명세가 변하면 호출자가 원래의 예외 명세에 의존할 수 있어 클라이언트 코드가 깨질 수 있다.

* 대체로 컴파일러는 함수 구현, 예외명세, 클라이언트 코드 사이 일관성 유지에 아무런 도움을 주지 않아 C++98에서는 예외 명세가 득보다 실이 컸다.

<br>

# **C++11 예외명세**

* C++11에서는 함수가 예외를 하나라도 방출하는지의 여부에 의미가 있다고 생각하여 함수 선언시 함수가 예외를 방출하지 않을 것임을 명시할 때는 `noexcept` 키워드를 사용하면 된다.

* `함수를 noexcept로 선언할 것인지의 여부는 인터페이스 설계상의 문제`이다.

* 함수의 예외 방출 행동은 클라이언트에게 아주 중요한 사항이다.

* `함수의 호출자는 함수의 noexcept 여부를 조회할 수 있고, 그 조회 결과는 호출 코드의 예외 안정성이나 효율성에 영향을 미친다.`

* 그런만큼 함수의 noexcept 여부는 멤버 함수의 const 여부만큼이나 중요한 정보이다.

<br>

# **noexcept 장점**

* 예외를 만들지 않을 함수에 noexcept를 적용하는 것에 또 다른 장점이 있는데 그것은 `컴파일러가 더 나은 목적 코드(object code)를 산출할 수 있다는 것이다`

* 함수 f를 호출했을 때 호출자가 예외를 받게 되는 일이 절대 없게 하고 싶다고 한다.

```c++
int f(int x) throw();   // f는 예외를 방출하지 않음 C++98 방식

int f(int x) noexcept();   // f는 예외를 방출하지 않음 C++11 방식
```

* 실행시점에서 어떤 예외가 f 바깥으로 나오면 f의 예외 명세가 위반된다.

### C++98

* C++98에서는 예외 명세가 위반되면 호출 스택이 f를 호출한 지점에 도달할 때까지 풀리며, 그 지점에서 몇가지 동작이 취해진 후 프로그램이 종료된다.

### C++11

* C++11에서는 실행시점 행동이 약간 다르다. 

* C++11에서 프로그램이 실행 종료되기 전에 호출 스택이 풀릴 수도 있고, 풀리지 않을 수도 있다.

* `호출 스택이 풀리는 것과 풀릴 수도 있는 것의 차이는 컴파일러 코드 작성에 놀랄 만큼 큰 영향을 미친다`

* noexcept 함수에서 컴파일러의 최적화기는 예외가 함수 바깥으로 전파될 수 있다고 해도 실행시점 스택을 풀기 가능 상태로 유지할 필요가 없다.

* 또한 예외가 noexcept 함수를 벗어난다고 해도 noexcept 함수 안의 객체들을 반드시 생성의 반대 순서로 파괴해야 하는 것도 아니다.

* 그러나 `예외 명세가 throw()인 함수에는 그러한 최적화 유연성이 없으며, 예외 명세가 아예 없는 함수 역시 마찬가지로 그런 유연성이 없다.`

```c++
반환형식 함수이름(매개변수목록) noexcept;   // 최적화 여지가 가장 크다

반환형식 함수이름(매개변수목록) throw();    // 최적화 여지가 더 작다

반환형식 함수이름(매개변수목록);            // 최적화 여지가 더 작다
```

* 예외를 산출하지 않을 함수는 noexcept로 선언하는 것이 좋은 이유는 이 예만으로 충분하지만, 다른 이유가 있는 함수들도 있다.

<br>

# 이동 연산

* C++98에서는 기존 메모리에 있는 객체를 파괴하고 일일이 복사했지만 C++11에서는 더 큰 메모리 조각을 새로 할당하고, 기존 메모리 요소를 새 조각으로 옮긴다.

*  이 접근방식 덕분에 push_back은 강한 예외 안전성을 보장할 수 있었다. 

* 즉, 요소들을 복사하는 도중에 예외가 던져져도 요소들이 파괴되지 않아 vector의 상태는 변하지 않는다.

* 이러한 점에서 push_back의 예외 안전성 보장이 위반될 수 있다.

### push_back에서 예외 발생

* 기존 메모리에서 n개의 요소를 이동한 후 (n+1)번째 요소를 이동하는 도중에 예외가 발생하면 push_back 연산이 완료되지 못하고 실패한다.

* 그런데 vector는 이미 수정된 상태여서 요소들이 다른곳으로 이동했는데, 그것들을 원래대로 복원하는 것이 불가능할 수 있다.

* 각 객체를 원래의 메모리로 다시 이동하는 연산 자체에서도 예외가 발생할 수 있기 때문이다

<br>

# 가능하면 이동하되 필요하면 복사한다

* 기존 코드 행동이 push_back이 보장하는 예외 안전성에 의존할 수도 있다는 점에서, 심각한 문제이기 때문에 `이동 연산들이 예외를 방출하지 않음이 확실하지 않은 한 C++11 컴파일러는 push_back 안의 복사 연산들을 소리없이 이동 연산들로 대체하지 않는다.`


* 그리고 `push_back뿐만 아니라, 표준 라이브러리의 여러 함수는 이러한 가능하면 이동하되 필요하면 복사한다` 전략을 활용한다.

* 그래서 `이동 연산이 예외를 방출하지 않음을 함수가 어떻게 알아낼 수 있는지는 주어진 연산이 noexcept로 선언되어 있는지를 확인하면 된다.`

<br>

# swap

* noexcept가 특히나 바람직한 다른 예로 swap 함수가 있다.

* swap은 여러 STL 알고리즘 구현에서 핵심 구성요소이며, 복사 대입 연산자들에서도 흔히 사용된다.
  
  * 여러 곳에서 사용되기 때문에 noexcept를 통해서 최적화할 가치가 크다.

* 표준 라이브러리에 있는 swap들의 noexcept 여부는 사용자 정의 swap들의 noexcept 여부에 어느정도 의존한다.

```c++
template<class T, size_t N>
void swap(T (&a)[n], T(&b)[n]) noexcept(noexcept(swap(*a,*b)));

template<class T1, class T2>
struct pair {
    // ...
    void swap(pair& p) noexcept(noexcept(swap(first,p.first))) &&
                        noexcept(noexcept(swap(second,p.second)));
};
```

* 이 함수들은 조건부 noexcept이여서, 이들이 noexcept 인지에 대한 것은 `noexcept 절 안의 표현식들이 noexcept인지에 의존한다.`

* 더 높은 수준의 자료구조들의 교환이 일반적으로 noexcept인지의 여부가 오직 더 낮은 수준의 구성요소들의 교환이 noexcept인지의 여부에 의존한다는 사실은, swap 함수를 작성할 때 가능한 한 항상 noexcept를 지정하는 것이 바람직하다는 뜻이다.


<br>

# 정확성

* noexcept가 제공하는 최적화 기회도 중요하지만, 더 중요한 것은 정확성이다.

* `함수의 구현이 예외를 방출하지 않는다는 성질을 확실히 할때만 noexcept로 선언해야 한다.`

* 만일 함수를 noexcept로 선언하고 나중에 마음을 바꾼다면, 흡족할 수습 방안이 없어 클라이언트 코드가 깨질 위험이 있다.

<br>

# 예외 중립적 함수

* 중요한 것은 `대부분의 함수가 예외에 중립적이다`

* 예외 중립적 함수는 스스로 예외를 던지지 않지만, 예외를 던지는 다른 함수들을 호출할 수 있다.

* `다른 함수가 예외를 던지면 예외 중립적 함수는 그 예외를 그대로 통과시킬 수 있어서 예외 중립적 함수는 결코 noexcept가 될 수 없다.`

<br>

# 기본적인 noexcept 함수

* `모든 메모리 해제 함수와 모든 소멸자는 암묵적으로 noexcept 함수이다.`

* 소멸자가 암묵적으로 noexcept로 선언되지 않는 경우는, 예외 방출 가능성을 명시적으로 밝힌 (`noexcept(false)`로 선언된) 소멸자를 가진 형식의 자료 멤버가 클래스에 있을 때 뿐이다.

  * 표준 라이브러리에는 하나도 없다.

<br>

# **결론**

> 이것만은 잊지 말자!
> * noexcept는 함수의 인터페이스 일부이다. 이는 호출자가 noexcept 여부에
>   의존할 수 있음을 뜻한다.
>
> * noexcept 함수는 비noexcept 함수보다 최적화의 여지가 크다.
>
> * noexcept는 이동 연산들과 swap,메모리 해제 함수들, 그리고 소멸자들에
>   특히나 유용하다
>
> * 대부분의 함수는 noexcept가 아닌 예외에 중립적이다.
> 
> {: .prompt-tip }
