---
title: 1-6 ~ 1-7 함수 템플릿에 대한 추가적인 질문 && 요약
date: 2024-08-03
categories: [Template,Template]
tags: [template]		# TAG는 반드시 소문자로 이루어져야함!
---

# 1-6 함수 템플릿에 대한 추가적인 질문

## 값으로 전달할까, 참조로 전달할까?

* 왜 인자를 참조 대신 값으로 전달하는지 궁금할 수 있다.

* 일반적으로 기본 타입이나 `std::string_view`와 같은 저렴한 간단한 타입을 제외한 타입에 대해서는  불필요한 복사가 발생하지 않아서 참조로 전달하는 것이 권장된다.

### 값 전달이 참조 전달보다 나은 경우

* 몇 가지 이유로 인해 일반적으로 값으로 전달하는 것이 더 나은 경우가 많다.

  * 문법이 간단함

  * 컴파일러가 더 잘 최적화함

  * `Move semantics`이 복사를 저렴하게 만든다.

  * 때로는 복사나 이동이 전혀 발생하지 않을 수 있다.

### 특정 측면(specific aspects)

* 게다가 템플릿에서는 특정한 측면들이 작용한다.

  * 템플릿은 간단한 타입과 복잡한 타입 모두에 사용될 수 있어, 복잡한 타입에 맞춘 접근 방식을 선택하는 것이 간단한 타입에는 역효과를 낼 수 있다.

  * 호출자로서 `std::ref()`와 `std::cref()`를 사용하여 여전히 참조로 인자를 전달할 수 있습니다.

  * 문자열 리터럴이나 원시 배열을 전달하는 것은 항상 문제가 될 수 있지만, 이를 참조로 전달하는 것이 종종 더 큰 문제가 될 수 있다.

* 이러한 모든 내용은 뒤에 7장에서 기술할 예정이다.

* 참조를 사용해야만 기능이 가능한 경우가 아니면 일반적으로 인자를 값으로 전달한다.

<br>

## 왜 inline을 사용하지 않는가?

* 함수 템플릿은 inline으로 선언할 필요가 없다

* `non-inline 일반 함수와 달리, 헤더 파일에 non-inline 함수 템플릿을 정의하고 이 헤더 파일을 여러 번역 단위에 포함할 수 있기 때문이다.`


### inline 규칙 예외

* `이 규칙의 유일한 예외는 특정 타입에 대한 템플릿의 전체 특수화`다.

* 이 경우 결과 코드가 더 이상 제너릭하지 않는다(모든 템플릿 매개변수가 정의됨)

### 컴파일러와 inline 

* 엄밀한 언어 정의 관점에서 inline은 프로그램 내에서 함수 정의가 여러 번 나타날 수 있음을 의미한다.

* 그러나 이는 컴파일러에게 해당 함수 호출을 "인라인 확장"해야 한다는 힌트를 제공하기도 합니다. 

* 이렇게 하면 특정 경우에 더 효율적인 코드를 생성할 수 있지만, 많은 다른 경우에는 코드를 덜 효율적으로 만들 수도 있다.

* 현재 컴파일러는 보통 inline 키워드에 의해 암시된 힌트 없이도 이를 더 잘 결정한다.

* 그러나 컴파일러는 여전히 이 결정에서 inline의 존재를 고려한다.

## 왜 constexpr을 사용하지 않는가?

* C++11부터는 constexpr을 사용하여 일부 값을 컴파일 타임에 계산할 수 있는 기능을 제공할 수 있고 템플릿의 경우 이 기능이 유용하다.

* 예를 들어, 최대값 함수(maximum function)를 컴파일 타임에 사용할 수 있도록 하려면 다음과 같이 선언해야 한다.

```c++
template<typename T1, typename T2>
constexpr auto max(T1 a, T2 b)
{
    return b < a ? a : b;
}
```
* 이렇게 하면 컴파일 타임 컨텍스트(예: 원시 배열의 크기를 선언할 때)에서 최대값 함수 템플릿을 사용할 수 있다:

```c++
int a[::max(sizeof(char),1000u)];
```

* 또는 `std::array`의 크기에서 사용할 수 있다

```c++
std::array<std::string, ::max(sizeof(char),1000u)> arr;
```
* 이때 템플릿 내에서 부호가 있는 값과 부호가 없는 값을 비교하는 것에 대한 경고를 피하기 위해 1000을 unsigned int로 전달한다.


125페이지의 8.2절에서 constexpr을 사용하는 다른 예제를 논의할 것입니다. 그러나 기본 개념에 집중하기 위해, 다른 템플릿 기능을 논의할 때는 constexpr을 생략할 것입니다.

<br>

# 1-7 요약

* 함수 템플릿은 다른 템플릿 인자에 대해 함수의 집합을 정의합니다.

* 함수 파라미터에 인자를 전달할 때, 함수 템플릿은 해당 파라미터 타입에 대해 인스턴스화할 템플릿 파라미터를 유추합니다.

* 앞의 템플릿 파라미터를 명시적으로 지정할 수 있습니다.

* 템플릿 파라미터에 대해 기본 인자를 정의할 수 있습니다. 이러한 기본 인자는 이전 템플릿 파라미터를 참조할 수 있으며, 기본 인자가 없는 파라미터가 뒤따를 수 있습니다.

* 함수 템플릿을 오버로딩할 수 있습니다.

* 다른 함수 템플릿과 함수 템플릿을 오버로딩할 때는, 어떤 호출에서도 하나만 일치하도록 해야 합니다.

* 함수 템플릿을 오버로딩할 때, 명시적으로 템플릿 파라미터를 지정하는 것으로 변경을 제한하십시오.

* 함수 템플릿을 호출하기 전에 컴파일러가 모든 오버로딩된 버전을 볼 수 있도록 해야 합니다.


<br><br>

# 따로 찾아본거


## non-line 함수

### non-inline 일반 함수

* 일반적으로 비inline 함수는 함수의 정의를 한 번만 해야 합니다.

* 즉, 함수 정의는 한 번만 컴파일러에 의해 볼 수 있어야 하며, 여러 번역 단위(translation unit)에서 동일한 함수 정의가 포함되면 링커 단계에서 중복 정의 오류가 발생할 수 있습니다.

* 이를 피하기 위해 보통 비inline 함수의 정의는 소스 파일(.cpp 파일)에 포함되고, 그 함수의 선언만이 헤더 파일에 포함됩니다. 

* 이렇게 하면, 각 번역 단위는 해당 함수의 선언을 알지만, 함수의 정의는 한 번만 포함되게 됩니다

### non-inline 함수 템플릿

* 함수 템플릿의 경우, 함수가 특정 타입으로 인스턴스화될 때마다 새로운 함수가 생성됩니다.
  
* 이 때문에 함수 템플릿의 정의는 헤더 파일에 포함되어도 문제가 없습니다.
  
* 다르게 말하면, 동일한 함수 템플릿이 여러 번역 단위에서 동일한 방식으로 인스턴스화되더라도, 이 인스턴스들은 각각 독립적으로 생성되므로 링커에서 중복 정의 오류가 발생하지 않습니다.

* 따라서 함수 템플릿은 일반 비inline 함수와는 달리, 비inline 함수 템플릿의 정의를 헤더 파일에 포함시킨 후 여러 번역 단위에서 그 헤더 파일을 포함해도 문제가 없습니다.

<br>

## non-line 함수의 정의를 한 번만 하는 이유

*  주로 링커의 중복 정의 오류를 피하기 위해서

*  함수의 정의가 여러 소스 파일에 걸쳐 중복되면, 각 파일에 대해 생성된 오브젝트 파일들에는 동일한 함수의 정의가 포함되기 때문

* 링크 단계에서 링커가 이 함수 정의들을 결합하려고 할 때, 동일한 함수의 정의가 여러 번 존재하는 것을 발견하게 됩니다. 이로 인해 링커는 어떤 정의를 사용할지 결정하지 못하고, "중복 정의" 오류를 발생시



