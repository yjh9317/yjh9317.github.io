---
title: 7.1 값에 의한 전달 또는 참조에 의한 전달
date: 2024-08-16
categories: [Template,Template]
tags: [template]		# TAG는 반드시 소문자로 이루어져야함!
---

# 값에 의한 전달 또는 참조에 의한 전달

* 초기부터 C++는 값에 의한 호출과 참조에 의한 호출을 제공했으며, 어느 것을 선택해야 할지 결정하는 것은 항상 쉽지 않다.
* 일반적으로 참조에 의한 호출은 비트리비얼(trivial하지 않은) 객체에 대해 더 저렴하지만 더 복잡하다.
*  C++11은 이동(move semantics)를 추가하여 참조에 의한 전달 방식이 다양해졌다

   * `X const& (상수 lvalue 참조)`: 전달된 객체를 수정 없이 참조
   * `X& (비상수 lvalue 참조)`: 전달된 객체를 수정할 수 있는 참조
   * `X&& (rvalue 참조):` 이동 시맨틱을 사용하여 전달된 객체를 참조하며, 이를 수정하거나 값을 훔칠 수 있다.

* 알려진 구체적인 타입에 대해 매개변수를 어떻게 선언할지 결정하는 것은 이미 복잡하다.
* 템플릿에서는 타입이 알려지지 않으므로 어떤 전달 메커니즘이 적절한지 결정하기가 더욱 어렵다.

* 그럼에도 불구하고, 1.6.1절에서 특별한 이유가 없는 한 함수 템플릿의 매개변수를 값에 의한 전달로 전달할 것을 권장했다.
* 특별한 이유는 다음과 같다

  * 복사가 불가능한 경우.
  * 매개변수가 데이터를 반환하는 데 사용되는 경우.
  * 템플릿이 원래 인수의 모든 속성을 유지하면서 매개변수를 다른 곳으로 전달하는 경우.
  * 성능 향상이 상당한 경우.
  
* 이 챕터에서는 템플릿에서 매개변수를 선언하는 다양한 접근 방식을 논의하며, 값에 의한 전달을 일반적으로 권장하는 이유와 그렇게 하지 말아야 할 이유에 대한 근거를 제공한다.
* 또한 문자열 리터럴 및 기타 raw 배열을 다룰 때 발생하는 까다로운 문제에 대해서도 논의한다.

<br>

# 값에 의한 전달

* 매개변수를 값에 의한 전달로 전달할 때, 각 인수는 원칙적으로 복사되어야 한다.

* 따라서 각 매개변수는 전달된 인수의 복사본이 된다.

* 클래스의 경우, 복사본으로 생성된 객체는 일반적으로 복사 생성자로 초기화가 된다.

* 복사 생성자를 호출하는 것은 비용이 많이 들 수 있다.

* 그러나 매개변수를 값에 의한 전달로 전달할 때도 비용이 많이 드는 복사를 피하는 다양한 방법이 있다.
  
* 실제로 컴파일러는 객체 복사 작업을 최적화하여 복사 작업을 제거할 수 있으며, 이동 시맨틱을 사용하여 복잡한 객체의 복사도 저렴해질 수 있다.

### 예시

* 예를 들어, 인수가 값에 의한 전달로 전달되는 간단한 함수 템플릿을 살펴보겠다.

```c++
template<typename T>
void printV (T arg) { ... }
```

* 이 함수 템플릿을 정수에 대해 호출하면, 결과 코드는 다음과 같다

```c++
void printV (int arg) { ... }
```

* 매개변수 `arg`는 객체, 리터럴 또는 함수에서 반환된 값이든 상관없이 전달된 모든 인수의 복사본이 된다.

* std::string을 정의하고 해당 함수 템플릿을 호출하면 템플릿 매개변수 `T`는 `std::string`으로 인스턴스화되어 다음과 같이 된다.

```c++
std::string s = "hi";
printV(s);

// string 버전의 템플릿
void printV (std::string arg) { ... }
```

* 이번에는 문자열을 전달할 때 `arg`는 `s의 복사본`이 된다.
* 이번 복사는 문자열 클래스의 복사 생성자에 의해 생성되는데, 이는 잠재적으로 비용이 많이 드는 작업이다.
* 원칙적으로 이 복사 작업은 전체 또는 깊은 복사를 생성하므로, 복사본은 내부적으로 값을 저장하기 위한 자체 메모리를 할당한다.

### 복사 생성자 호출하지 않는 경우

* 그러나 잠재적인 복사 생성자가 항상 호출되는 것은 아니다.

```c++
std::string returnString();
std::string s = "hi";
printV(s);                      // 복사 생성자 호출
printV(std::string("hi"));      // 복사 작업은 보통 최적화됨 (아니면 이동 생성자 호출)
printV(returnString());         // 복사 작업은 보통 최적화됨 (아니면 이동 생성자 호출)
printV(std::move(s));           // 이동 생성자 호출
```

* 첫 번째 호출에서는 lvalue를 전달하므로 복사 생성자가 사용된다.
* 그러나 두 번째와 세 번째 호출에서, 즉 즉석에서 생성된 임시 객체나 다른 함수에서 반환된 prvalue에 대해 함수 템플릿을 직접 호출할 때, 컴파일러는 일반적으로 복사 생성자를 전혀 호출하지 않도록 인수 전달을 최적화한다.
  * C++17부터는 이 최적화가 요구된다.

* C++17 이전에는 복사를 최적화하지 않는 컴파일러는 최소한 이동 시맨틱을 사용해야 했으며, 이는 일반적으로 복사를 저렴하게 만든다.

* 마지막 호출에서 `std::move(s)`를 사용하여 `xvalue(기존의 비상수 객체)`를 전달할 때, 더 이상 s의 값을 필요로 하지 않음을 신호하여 이동 생성자를 호출하도록 강제한다.

* 따라서 매개변수가 값에 의한 전달로 전달되는 `printV()`의 구현을 호출할 때, 일반적으로 lvalue를 전달할 때만 비용이 많이 든다

* 불행히도, 이는 꽤 일반적인 경우다.
  * 객체를 일찍 생성하여 나중에(일부 수정 후) 다른 함수에 전달하는 것이 꽤 일반적이기 때문

<br>

## 값에 의한 전달은 디케이(decay)


* 값에 의한 전달로 매개변수를 전달할 때 언급해야 할 또 다른 특성이 있다
* 인수를 매개변수에 전달할 때 타입이 `디케이`된다.
  * raw 배열은 포인터로 변환
  * const 및 volatile과 같은 한정자가 제거

```c++
template<typename T>
void printV (T arg) {
    ...
}

std::string const c = "hi";
printV(c);      // `c`는 디케이되어 `arg`의 타입은 `std::string`이 됨

printV("hi");   // 포인터로 디케이되어 `arg`의 타입은 `char const*`가 됨

int arr[4];
printV(arr);    // 포인터로 디케이되어 `arg`의 타입은 `int*`가 됨
```

* 문자열 리터럴 "hi"를 전달할 때, 그 타입 `char const[3]`는 `char const*`로 디케이되므로, 이는 T의 추론된 타입이 된다.

* 따라서 템플릿은 다음과 같이 인스턴스화된다

```c++
void printV (char const* arg) { ... }
```

* 이 동작은 C에서 유래되었으며, 장단점이 있다.

* 종종 전달된 문자열 리터럴의 처리를 단순화하지만, 단점은 printV() 내부에서 단일 요소에 대한 포인터를 전달한 것인지 raw 배열을 전달한 것인지 구별할 수 없다는 것이다.

* 이러한 이유로, 7.4절에서 문자열 리터럴 및 기타 raw 배열을 처리하는 방법에 대해 논의한다