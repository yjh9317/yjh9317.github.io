---
title: 5.2 초기화 (Zero Initialization)
date: 2024-08-14
categories: [Template,Template]
tags: [template]		# TAG는 반드시 소문자로 이루어져야함!
---

# 5.2 초기화 (Zero Initialization)


## 기본 타입의 초기화

* 기본 타입들(예: int, double, 또는 포인터 타입)에는 유용한 기본값으로 초기화하는 기본 생성자가 존재하지 않는다.

* 따라서 초기화되지 않은 지역 변수는 정의되지 않은 값을 가지게 된다.

```c++
void foo() {
  int x;   // x는 정의되지 않은 값을 가짐
  int* ptr; // ptr은 아무 곳이나 가리킬 수 있음 (null을 가리키지 않음)
}
```

## 템플릿 클래스에 있는 변수의 초기화

* 이제, 템플릿을 작성하면서 템플릿 타입의 변수를 기본값으로 초기화하고자 할 때, 단순 정의만으로는 기본 타입에 대해 이러한 초기화를 수행할 수 없다.

```c++
template<typename T>
void foo() {
  T x;
}
// 만약 T가 기본 타입이라면 x는 정의되지 않은 값을 가짐
```

### 값 초기화

* 위 문제를 해결하기 위해, 기본 타입에 대해 명시적으로 0으로 초기화하는 기본 생성자를 호출할 수 있다
  * 또는 bool에 대해서는 false, 포인터에 대해서는 nullptr

* 이 방법으로 기본 타입에 대해서도 적절한 초기화를 보장할 수 있다

```c++
template<typename T>
void foo() {
  T x{}; // 만약 T가 기본 타입이라면 x는 0 또는 false가 됨
};
```

* 이러한 초기화 방법을 `값 초기화(value initialization)`라고 하며, 이는 제공된 생성자를 호출하거나 객체를 0으로 초기화하는 것을 의미한다.

* 이 방식은 생성자가 명시적으로 정의된 경우에도 작동한다.

<br>

### 예전 값 초기화

* C++11 이전에는 올바른 초기화를 보장하기 위한 구문이 다음과 같았다.

```c++
T x = T(); // 만약 T가 기본 타입이라면 x는 0 또는 false가 됨
```

* C++17 이전에는 복사 초기화에 선택된 생성자가 명시적이지 않은 경우에만 이 방식이 작동했다.

* C++17에서는 `필수 복사 생략(mandatory copy elision)`이 도입되어 이러한 제한이 없어졌고, 어떤 구문이든 사용할 수 있게 되었다.

* 그러나 중괄호 초기화는 기본 생성자가 없는 경우 초기화 목록 생성자를 사용할 수 있습니다.

<br>

### 클래스 템플릿 파라미터의 값 초기화


* 클래스 템플릿의 멤버가 파라미터화된 타입일 때도, 기본 타입에 대해 멤버가 초기화되도록 보장하려면, 기본 생성자를 정의하고 중괄호 초기화를 사용할 수 있다.

```c++
template<typename T>
class MyClass {
private:
  T x;

public:
  MyClass() : x{} {}  // 기본 타입에도 x가 초기화되도록 보장
};

// 이 생성자는 C++11 이전에도 잘 작동한다.
// MyClass() : x() {}
```

* C++11 이후에는 비정적 멤버에 대해 기본 초기화를 제공할 수 있어서 다음과 같은 구문도 가능하다.

```c++
template<typename T>
class MyClass {
private:
  T x{};  // 명시적으로 초기화하지 않으면 x는 0으로 초기화됨
};
```

* 하지만, 기본 인수(default arguments)에는 이 구문을 사용할 수 없다.

```c++
// 오류 버전
template<typename T>
void foo(T p{}) { ... }

// 기본 인수에 사용하려면 아래와 같이 사용해야 한다.
template<typename T>
void foo(T p = T{}) { ... }  // C++11 이전에는 T()를 사용해야 함
```