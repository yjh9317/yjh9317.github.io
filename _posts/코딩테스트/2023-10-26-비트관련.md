---
title: 비트 관련
date: 2023-10-26
categories: [코딩테스트,코딩테스트]
tags: [coding test]		# TAG는 반드시 소문자로 이루어져야함!
---

**비트중 1의 개수**
==============

```c++
short CountBits(unsigned int x)
{
	short num_bits = 0;

    // x가 0이 되기 전까지 최하위 비트와 비교하면서
    // 1이면 추가하고 (x & 1);
    // 끝나면 최하위 비트 삭제 (x >>= 1)
	while (x)
	{
		num_bits += x & 1;
		x >>= 1;
	}
	return num_bits;
}
```

<br>

**매우 큰 수에 대한 패리티 구하기**
=============

* `패리티` : 정보 전달 과정에서 오류가 생겼는지 검사하는 값으로 전체 비트의 개수를 2로 나눈 나머지 값

* 두 가지 방법이 있는데 하나는 다수의 비트를 한번에 처리하는 방법이고 다른 하나는 연산 결과를 룩업테이블(lookup table)에 캐시 형태로 저장하는 방법이다.

### 캐시 형태로 저장하기

* 64비트의 패리티 값은 너무 크기 때문에 모두 저장할 수 없다 (2의 64승)

* 따라서 16비트 4개로 나눈 후, 각 숫자의 패리티 값을 구하고 나온 4개의 패리티값의 패리티를 구하면 된다.

    * 2의 16승은 65536으로 배열에 저장할 수 있고 64가 16으로 나눠 떨어져서 10비트씩 나누는 것보다 코드가 간단함

```c++
short parity(unsigned long long x)
{
    const int kMaxSize = 16;
    const int kBitMask = 0xFFFF; // 1111 1111 1111 1111

    //  16비트 하나씩 비교,
    return  kPreComputedParity[x >> (3 * kMaskSize)] ^
            kPreComputedParity[(x >> (2 * kMaskSize)) & kBitMask] ^
            kPreComputedParity[(x >> kMaskSize) & kBitSize)] ^
            kPreComputedParity[x & kBitMask];
}
```
* 시간 복잡도는 해시 테이블의 키값에 따라 달라진다.
* 해시 테이블에 사용될 키값의 비트 수가 L이고 전체 비트 수가 n이라면 시간 복잡도는 O(n/L)이 된다.

<br>

### 다수의 비트를 한번에 처리

* 8비트 숫자를 사용해서 설명하려고 한다. 8비트가 1101 0111이라고 가정한다.

* 11010111을 4비트로 나눠 (1101), (0111)로 만들고 둘이 XOR한 연산한 값이 11010111의 패리티 값과 같다.

* 1101은 다시 (11)(01), 0111은 (01)(11)으로 XOR을 하면 (10) , (10)이 나오고 둘이 다시 XOR하면 (00)으로 패리티 값이 0이 나온다
* 결국 11010111의 패리티는 (00)의 XOR값인 0이다.

```c++
short Parity(unsigned long long x)
{
    x ^= x >> 32;
    x ^= x >> 16;
    x ^= x >> 8;
    x ^= x >> 4;
    x ^= x >> 2;
    x ^= x >> 1;
    return x & 0x1;
}
```
* 단어 크기가 n일 때 시간 복잡도는 O(log n)이 된다

<br>

**비트 연산 관련**
==============

### 비트 세팅

```c++
// 이렇게 하면 1비트가 10개로 줄세워진 값을 얻을 수 있다.
int bit = (1 << 10) - 1;
```

### 비트 변경

```c++
// p번째 비트를 변경 1이면 0, 0이면 1
bit |= (1 << p);
```

### 해당 자리수가 1인지 확인

```c++
// 만약 p번째 비트자리수가 1이라면 true, 아니면 false
if( bit & (1 << p )) { ... }
```

### 비트 삭제

```c++
// p번째 비트를 0으로 만듦
bit &= ~(1 << p);
```

### 비트 토글 (1이면 0, 0이면 1)

```c++
// p번째 비트를 Toggle
bit ^= (1 << p);
```

### 비트 집합

```c++
int added =         (a | b);    // a와 b의 합집합
int intersection =  (a & b);    // a와 b의 교집합
int removed =       (a & ~b);   // a와 b를 뺀 차집합
int toggled =       (a ^ b);    // a와 b중 하나만 포함된 원소들의 집합
```

### 집합의 크기 구하기

```c++
int bitCount(int x)
{
    if ( x == 0 ) return 0;

    return x % 2 + bitCount(x / 2);
}
```

### 최하위 비트 자리수 구하기

```c++
// bit가 1000 1000이라면
// -bit는 2의 보수때문에 ~bit에 +1를 더한 값인 0111 1000이 된다.

// 1000 1000
// 0111 1000 결과는 다음과 같이 되고 4번째 bit가 최하위 비트가 된다.
int resultBit = ( bit & -bit );
```

### 최하위 비트 지우기

```c++
// - 1을 통해 최하위 비트를 끄고 그 밑 비트를 전부 킨 다음
// AND 연산을 통해 최하위 비트 1을 0으로 만든다.

// bit가 10 1000이라면 bit - 1은 10 0111이기 때문에 AND 연산을 하면
// 10 0000이 되어버린다.
bit &= (bit - 1);
```