---
title: 비트 관련
date: 2023-10-26
categories: [코딩테스트,코딩테스트]
tags: [coding test]		# TAG는 반드시 소문자로 이루어져야함!
---

**비트중 1의 개수**
==============

```c++
short CountBits(unsigned int x)
{
	short num_bits = 0;

    // x가 0이 되기 전까지 최하위 비트와 비교하면서
    // 1이면 추가하고 (x & 1);
    // 끝나면 최하위 비트 삭제 (x >>= 1)
	while (x)
	{
		num_bits += x & 1;
		x >>= 1;
	}
	return num_bits;
}
```

<br>

**가장 낮은 비트 지우기**
==========

```c++
x & (x - 1)

// x가 00101100 일 때, x -1은 00101011 이다
// x & x-1 은 00101000이 되어 가장 낮은 3번째 자리수인 1을 지울 수 있다.
```


<br>

**매우 큰 수에 대한 패리티 구하기**
=============

* `패리티` : 정보 전달 과정에서 오류가 생겼는지 검사하는 값으로 전체 비트의 개수를 2로 나눈 나머지 값

* 두 가지 방법이 있는데 하나는 다수의 비트를 한번에 처리하는 방법이고 다른 하나는 연산 결과를 룩업테이블(lookup table)에 캐시 형태로 저장하는 방법이다.

### 캐시 형태로 저장하기

* 64비트의 패리티 값은 너무 크기 때문에 모두 저장할 수 없다 (2의 64승)

* 따라서 16비트 4개로 나눈 후, 각 숫자의 패리티 값을 구하고 나온 4개의 패리티값의 패리티를 구하면 된다.

    * 2의 16승은 65536으로 배열에 저장할 수 있고 64가 16으로 나눠 떨어져서 10비트씩 나누는 것보다 코드가 간단함

```c++
short parity(unsigned long long x)
{
    const int kMaxSize = 16;
    const int kBitMask = 0xFFFF; // 1111 1111 1111 1111

    //  16비트 하나씩 비교,
    return  kPreComputedParity[x >> (3 * kMaskSize)] ^
            kPreComputedParity[(x >> (2 * kMaskSize)) & kBitMask] ^
            kPreComputedParity[(x >> kMaskSize) & kBitSize)] ^
            kPreComputedParity[x & kBitMask];
}
```
* 시간 복잡도는 해시 테이블의 키값에 따라 달라진다.
* 해시 테이블에 사용될 키값의 비트 수가 L이고 전체 비트 수가 n이라면 시간 복잡도는 O(n/L)이 된다.

<br>

### 다수의 비트를 한번에 처리

* 8비트 숫자를 사용해서 설명하려고 한다. 8비트가 1101 0111이라고 가정한다.

* 11010111을 4비트로 나눠 (1101), (0111)로 만들고 둘이 XOR한 연산한 값이 11010111의 패리티 값과 같다.

* 1101은 다시 (11)(01), 0111은 (01)(11)으로 XOR을 하면 (10) , (10)이 나오고 둘이 다시 XOR하면 (00)으로 패리티 값이 0이 나온다
* 결국 11010111의 패리티는 (00)의 XOR값인 0이다.

```c++
short Parity(unsigned long long x)
{
    x ^= x >> 32;
    x ^= x >> 16;
    x ^= x >> 8;
    x ^= x >> 4;
    x ^= x >> 2;
    x ^= x >> 1;
    return x & 0x1;
}
```
* 단어 크기가 n일 때 시간 복잡도는 O(log n)이 된다