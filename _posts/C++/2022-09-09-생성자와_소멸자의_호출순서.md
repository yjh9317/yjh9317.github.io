---
title: 생성자와 소멸자 호출순서
date: 2022-09-09
categories: [C++,C++]
tags: [C++]		# TAG는 반드시 소문자로 이루어져야함!
---

자식 클래스와 부모 클래스의 생성자
==================
* 자식 클래스 객체가 생성되면 자식과 부모 클래스의 생성자와 소멸자가 전부 호출된다.

<br><br>

생성자 호출 및 실행 순서
================
* 여기서 말하는 호출은 함수가 호출되는 그 시점을 의미
* 실행은 멤버 변수 초기화를 실행한다는 의미

<br>

* 순서
  1. 자식 클래스의 객체가 생성될 때 자식 클래스의 생성자가 호출된다.<br><br>
  2. 자식 클래스의 이니셜라이저 안에 묵시적으로 실행되는 부모 클래스의 생성자가 호출된다.
      * 만약 자식 생성자 이니셜라이저에 명시적으로 멤버 변수 뒤에 부모 클래스 생성자를 호출해도 부모 클래스 생성자가 먼저 실행된다.<br><br>
  3. 부모 클래스의 생성자가 호출되면 부모 클래스의 생성자 안에 있는 코드를 모두 실행하고 난 후에 자식 클래스 생성자로 돌아간다.<br><br>
  4. 그 다음 자식 클래스 생성자의 코드가 전부 실행된다.

<br>

* 결론
  * 생성자의 호출 순서는 자식 -> 부모
  * 생성자의 실행 순서는 부모 -> 자식


<br><br>

소멸자 호출 및 실행 순서
=========================
* 소멸자는 생성자와 달리 부모 클래스로 올라가지 않고 자식 클래스에서 호출이 되고 나면 실행까지 마치고 나서 부모 클래스의 소멸자로 넘어간다.

* 순서
  1. 자식 클래스의 객체가 소멸될 때 자식 클래스의 소멸자가 호출된다.<br><br>
  2. 자식 클래스의 소멸자가 호출되면 실행까지 마치고 그 다음에 부모 클래스의 소멸자로 넘어간다.<br><br>
  3. 부모 클래스의 소멸자도 호출되면 그 뒤에 바로 실행한다.

<br>

* 결론
  * 소멸자의 호출 순서는 자식 -> 부모
  * 소멸자의 실행 순서는 자식 -> 부모


<br><br>

예시
==========================

```c++
class A {
public:
    A() { cout << "생성자 A" << endl; }
    ~A() { cout << "소멸자 A" << endl; }
};

class B : public A{
public:
    B() { cout << "생성자 B" << endl; }
    ~B() { cout << "소멸자 B" << endl; }
};

class C : public B{
public:
    C() { cout << "생성자 C" << endl; }
    ~C() { cout << "소멸자 C" << endl; }
};

int main()
{
    C c;   
}

/*
실행 결과

생성자 A
생성자 B
생성자 C
소멸자 C
소멸자 B
소멸자 A
*/
```