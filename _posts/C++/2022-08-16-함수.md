---
title: 함수
date: 2022-08-16
categories: [C++,C++]
tags: [C++]		# TAG는 반드시 소문자로 이루어져야함!
---


함수
================
* 특별한 목적의 작업을 수행하기 위해 독립적으로 설계된 코드의 집합

<br>

* 함수를 사용하기 위해선 사용하려는 위치보다 앞에서 선언을 해야한다.<br>
* 특정 파일안에서만 사용할 함수는 선언과 구현 모두 소스파일안에서 작성하지만,<br>
함수를 다른 모듈이나 파일에서도 사용하려면 선언은 헤더파일,구현은 소스파일에 작성한다.<br>

<br>

선언과 구현
======================

* 함수 선언
  
        void myFunction(int i, char c);


위와 같이 함수를 선언만하고 구체적인 동작은 구현하지 않은 채 이 함수를 호출한 문장이 담긴 코드를 컴파일하면<br>
실제로 코드에 존재하지 않는 함수를 호출하기 때문에 링크과정에서 에러가난다.<br>


* 함수 구현

        // 두 매개변수를 출력
        void myFunction(int i, char c)
        {
            std::cout << i << std::endl;
            std::cout << c << std::endl;
        }


<br>

함수의 형태
=================================

        반환타입 함수명(매개변수)
        {
            // 호출 시 작동될 코드

            // 반환타입이 void가 아니라면 return으로 반환타입에 맞는 값을 반환해야한다.
            // 반환타입이 void였다면 return;을 이용하여 함수를 즉시 끝낼 수 있다.
        }

<br><br>

함수 리턴 타입 추론
====================
C++14부터는 함수의 리턴 타입을 컴파일러가 알아서 지정할 수 있다.<br>
이 기능을 적용하려면 리턴타입자리에 auto키워드를 적는다.

        auto addNum(int num1,int num2)
        {
            return num1 + num2;
        }

그러면 컴파일러는 return문값의 타입에 따라 리턴 타입을 추론한다.<br>
함수 안에 return문이 여러 개 있을 수 있는데, 모두 타입이 같아야 한다.<br>

<br><br>

현재 함수 이름
==============================
함수마다 내부적으로 _func_라는 로컬변수가 정의돼 있다.<br>
이 변수는 현재 함수 이름을 값으로 갖고 있고 주로 로그를 남기는데 활용한다.

        auto addNum(int num1,int num2)
        {
            std::cout << "Entering function " << _func_ << std::endl; 
            return num1 + num2;
        }


<br><br>

함수의 인자 전달 방식
================================
* Call By Balue
  * 함수의 인자가 포인터나 레퍼런스를 사용하지 않았을 때의 방식
  * 함수를 호출한 시점에서 전달한 인자의 값을 복사하여 함수 내부의 입력 인자의 초기값을 설정한다.
  * 함수를 호출한 시점의 인자값과 함수 내부의 인자값은 같지만, 메모리는 독립적으로 서로 다르다.

<br>

        // 함수 내부
        void swap(int first, int second)
        {
            int temp = first;
            first = second;
            second = temp;
        }

        int a = 3 , b = 4;
        swap(a,b);    // 함수를 호출한 시점


* 함수의 인자가 포인터나 레퍼런스가 아니므로 Call By Balue의 방식이다.
* a, b의 값이 first, second에 복사가 되지만 값만 복사하여 전달한 것이어서 a,b와 first,second는 서로 다른 개체이므로 a,b가 바뀌지 않는다.

<br><br><br><br>

* Call By Reference
  * 함수의 인자가 포인터나 레퍼런스로 전달되었을 때의 방식
  * 함수를 호출한 시점의 인자를 함수 내부의 입력 인자가 참조하여 사용하는 방식
  * 함수를 호출한 시점의 인자와 함수 내부의 입력 인자가 같은 개체가 된다.

<br>
        
        // 함수 내부
        void swap(int* first, int* second)
        {
            int temp = *first;
            *first = *second;
            *second = temp;
        }

        int a = 3 , b = 4;
        int *pa = &a;
        int *pb = &b;
        swap(pa,pb);    // 함수를 호출한 시점


* 함수의 인자가 포인터나 레퍼런스이므로 Call By Reference의 방식이다.
* a,b의 주소를 가지고 있는 pa,pb의 값이 first,second에 주소값이 그대로 복사되어 들어간다
  <br>(엄밀히 말하면 주소값을 복사하는 방식)
* 함수 내부에서 a와 b의 주소값을 가지고 있는 first와 second를 역참조(*)하여 값을 바꾸고 나면 a와 b의 값이 서로 바뀌게 된다.