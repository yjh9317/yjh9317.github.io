---
title: 에러 처리하기 - 2
date: 2023-02-07
categories: [C++,C++]
tags: [C++]		# TAG는 반드시 소문자로 이루어져야함!
---

익셉션 클래스 직접 정의하기
====================================
* 익셉션 클래스를 직접 정의하면 두 가지의 장점이 있다.
  
  * 익셉션 클래스를 직접 정의하면 runtime_error처럼 광범위한 이름 대신 발생한 에러에 최대한 가까운 이름으로<br> 표현할 수 있다.
  * 원하는 정보를 익셉션에 얼마든지 추가할 수 있다. 표준 라이브러리에서 제공하는 익셉션은 에러 스트링만 넣을 수 있다.

<br>

* 익셉션을 직접 정의할 때는 반드시 표준 exception 클래스를 직접 or 간접적으로 상속하는 것이 좋다.
  
  * 단, 이 원칙을 따르지 않는 서드파티 라이브러리가 있을 때는 X

<br><br><br><br>

* 파일 에러 클래스


<br>

    class FileError : public exception
    {
        public:
            FileError(string_view fileName) : mFileName(fileName) {}

        virtual const char* what() const noexcept override {
            return mMessage.c_str();
        }

        string_view getFileName() const noexcept { return mFileName; }

        protected:
            void setMessage(string_view message) { mMessage = message; }

        private:
            string mFileName;
            string mMessage;
    };

<br>

* exception 클래스를 상속하려면 what() 메서드를 오버라이드해야 한다.
    * 이 스트링은 익셉션 객체가 소멸되기 전까지 사용할 수 있다.

    * 이 스트링을 mMessage에 저장하고 파생 클래스에선 setMessage 메서드를 이용하여 다른 값으로 설정할 수 있다.

<br><br><br><br>

* 파일 열기 에러 클래스

<br>

    class FileOpenError : public FileError
    {
        public:
            FileOpenError(string_view fileName) : FileError(fileName)
            {
                setMessage("Unable to open"s + fileName.data());
            }
    };

<br>

* FileError 클래스를 상속한다.

* FileOpenError 익셉션은 파일 열기 에러를 표현하는 값을 mMessage에 저장

<br><br><br><br>

* 파일 읽기 에러 클래스

<br>

    class FileReadError : public FileError
    {
        public:
            FileReadError(string_view fileName, size_t lineNumber)
                : FileError(fileName) , mLineNumber(lineNumber)
            {
                ostringstream ostr;
                ostr << "Error reading " << fileName << " at line " << lineNumber; // 에러 줄 번호
                setMessage(ostr.str());
            }

            size_t getLineNumber() const noexcept { return mLineNumber; }
        
        private:
            size_t mLineNumber;
    }

<br>

* FileError 클래스를 상속한다.

* FileReadError 클래스는 파일이 열리지 않는 예외 상황을 위한 클래스

<br><br>

* 이렇게 작성한 FileError 클래스의 다형성을 이용하여 익셉션을 처리하는 catch 구문을 다음과 같이 작성할 수 있다.

<br>

    try {
        ...
    } catch (const FileError& e){
        ...
    }

<br>

* 익셉션이 발생하면 그 익셉션 객체를 이동 생성자나 복제 생성자로 이동하거나 복제하게 된다.

    * 익셉션 객체는 최소 한번 이상 이동하거나 복제된다.

    * 익셉션 객체를 레퍼런스로 받지 않으면 여러번 복제될 수 있다.
  
* 그래서 익셉션으로 사용할 클래스를 정의할 때는 객체를 복제하거나 이동할 수 있도록 만들어야한다.


<br><br><br>


중첩된 익셉션
================
* 익셉션을 처리하는 도중 다른 에러가 발생해 새로운 익셉션이 전달되면 현재 처리하고 있던 익셉션 정보는 사라진다.
  
* 먼저 잡은 익셉션을 새로 발생한 익셉션의 문맥 안에 포함시킬 수 있다.

<br><br><br>

* 예시

<br>

    // 클래스
    class MyException : public std::exception
    {
        public:
            MyException(string_view message) : mMessage(message) {}
            virtual const char* what() const noexcept override{
                return mMeesage.c_str();
            }

        private:
            string mMessage;            
    }

    =================

    // 함수
    void doSomething()
    {
        try{
            throw runtime_error("Throwing a runtime_error exception");
        } catch(const runtime_error& e){
            cout << __func__ << " caught a runtime error" << endl;
            cout << __func__ << " throwing MyException" << endl;
            throw_with_nested(
                MyException("MyException with nested runtime_error"));  // 새로운 익셉션을 throw
        }
    }

    ==================
    
    // main()

    int main()
    {
        try{
            doSomething();
        } catch(const MyException& e){
            cout << __func__ << " caught MyException: " << e.what() << endl;
            const auto* pNetsed = dynamic_cast<const nested_exception*>(&e);    // 이전 익셉션 접근

            if(pNested){
                try{
                    pNested->rethrow_nested();
                } catch(const runtime_error& e){
                    // 중첩된 익셉션 처리
                    cout << "Nested exception : << e.what() << endl;
                }
            }
        }
        return 0;
    }

<br>

* 어떤 익셉션을 처리하는 catch 문에서 새로운 익셉션을 던지려면 std::throw_with_netsed()를 이용한다.

* 나중에 발생한 익셉션을 처리하는 catch 문에서 먼저 발생했던 익셉션에 접근할 때는 dynamic_cast를 이용한다.

  * MyException을 처리하는 catch 핸들러로 dynamic_cast()를 이용하여 현재 익셉션에 중첩된 익셉션에 접근
  
  * 중첩된 익셉션이 없다면 널 포인트를 리턴
  
  * 중첩된 익셉션이 있다면 nested_exception의 rethrow_nested() 메서드를 호출해 다시 익셉션을 던져 다른 try/catch문에서 처리한다.

<br>

* rethrow_if_nested()라는 헬퍼 함수를 이용하여 중첩된 익셉션을 확인할 수도 있다

<br>

    // 아래와 위 모두 같은 동작
    const auto* pNetsed = dynamic_cast<const nested_exception*>(&e);
    if(pNested){
    try{
        pNested->rethrow_nested();
    } catch(const runtime_error& e)

    =====================

    try{
        rethrow_if_nested(e);
    } catch(const runtime_error& e);


<br>
<br><br><br>

