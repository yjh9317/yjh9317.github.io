---
title: 레퍼런스
date: 2022-08-22
categories: [C++,C++]
tags: [C++]		# TAG는 반드시 소문자로 이루어져야함!
---

레퍼런스
===============

* 일종의 변수에 대한 별칭(alias)
* 변수의 주소를 가져오거나 변수에 대한 역참조 연산을 수행하는 작업을 자동으로 처리하는 특수한 포인터

<br>

레퍼런스 변수
================
* 레퍼런스 변수는 반드시 생성하자마자 초기화 해야한다

* 초기화

        // xRef는 x에 또 다른 이름으로 xRef를 사용하는것은 x를 사용하는것과 같다
        int x = 3;
        int& xRef = x;
        xRef = 10;      // x = 10; 과 같음

* 초기화 하지 않을 경우

        int& xRef; // 컴파일 에러


<br><br>

* 정수 리터럴처럼 이름없는 값에 대해서는 레퍼런스를 생성하지 못한다(non-const 레퍼런스)<br>
  * 단, const 값에 대해서는 레퍼런스 생성가능.

<br>

        int& unnamedRef1 = 5; // 컴파일 에러
        const int& unnamedRef2 = 5; // 정상 작동


<br><br>

* 임시객체에 대한 non-const 레퍼런스는 만들수없다<br>
  * 단,const 레퍼런스는 만들 수 있다.

<br>

        std::string getString() { return "Hello World!"; }

        std::string& string1 = getString();     // 컴파일 에러
        const std::string& string2 = getString(); // 정상 작동


<br><br>

레퍼런스 대상 변경하기
===============================
* 레퍼런스는 한 번 생성되고 나면 가리키는 대상을 바꿀 수 없다.

<br><br>

* 한 번 선언된 레퍼런스에 다른 변수를 대입하면 레퍼런스가 가리키는 대상이 바뀌는 것이 아닌, 레퍼런스가 원래 가리키던 변수의 값이 새로 대입한 변수의 값으로 바뀌게 된다.

<br>

        int x = 3, y = 4;
        int& xRef = x;
        xRef = y; // xRef가 y를 가리키는 것이 아니라 x의 값이 4로 바뀐다.

<br>

* y의 주소를 대입한다고 해도 대상을 바꿀 순 없다.<br>
  * y의 주소는 포인터지만 xRef는 포인터에 대한 레퍼런스가 아닌 int에 대한 레퍼런스이기 때문이다.

<br>

        xRef = &y // 컴파일 에러

<br><br>

* 레퍼런스에 레퍼런스를 대입하는 방식으로도 레퍼런스 대상을 바꿀 수 없다<br>

        int x = 3; , z = 5;
        int& xRef = x;
        int& zRef = z;
        zRef = xRef;    // 레퍼런스가 아닌 값이 대입된다.
        // z의 값이 x의 값이 대입되어 3이 된다.

<br><br>

포인터에 대한 레퍼런스와 레퍼런스에 대한 포인터
=========================
* 레퍼런스는 포인터를 포함해 모든 타입에 대해 만들 수 있다.


        int* intP;
        int*& ptrRef = intP;
        ptrRef = new int;
        *ptrRef = 5;

* ptrRef는 intP에 대한 레퍼런스이다.<br>
* intP는 int에 대한 포인터이다.<br>
* ptrRef를 수정하면 intP가 바뀐다.<br>

<br><br>

* 레퍼런스가 가져온 주소는 레퍼런스가 가리키는 변수의 주소와 같다


        int x = 3;
        int& xRef = x;
        int* xPtr = &xRef;  // 레퍼런스의 주소는 값의 주소와 같다.
        *xPtr = 100;



* x에 대한 레퍼런스의 주소를 가져와서 xPtr이 x를 가리키도록 설정<br>
* 조심해야할 점은 xPtr과 xRef는 타입이 다르다<br>


        if(xPtr == xRef)    // 오류

        xPtr는 int에 대한 포인터 타입이고, xRef는 int에 대한 레퍼런스 타입

        if(xPtr == &xRef)   // 정상 작동
        if(xPtr == &x)      // 정상 작동

<br>

* 그리고 레퍼런스에 대한 레퍼런스를 선언할 수 없다

        int&&   // 선언 X
        int&*   // 선언 X


<br><br>

레퍼런스 데이터 멤버
==========================
* 클래스의 데이터 멤버 또한 레퍼런스 타입으로 정의할 수 있다.
* 레퍼런스는 반드시 초기화를 해야 하므로 반드시 생성자 이니셜라이저에서 초기화해야한다.

        class MyClass
        {
            public:
                MyClass(int& Ref) : mRef(ref) {}
            private:
                int& mRef;
        }

<br><br>

레퍼런스 매개변수
====================
* 매개변수는 값 전달 방식에 따르기 때문에 함수는 인수의 복사본들 받는다.<br>
* 하지만 매개변수를 레퍼런스 타입으로 선언하면 인수를 레퍼런스 전달 방식으로 처리한다.<br>


        // 매개 변수가 레퍼런스 타입이므로 서로의 값이 바뀐다.
        void swap(int& first, int& second)
        {
            int temp = first;
            first = second;
            second = temp;
        }

        int x = 5 ,int y =6;
        swap(x,y);

<br>

* 레퍼런스 전달 방식은 함수안에서 인수로 전달한 값을 수정하면 원본 변수에 반영이 되기도 하지만,인수에 대한 복제본을 만들지 않아 다른 장점도 있다.
  * 효율성 : 크기가 큰 객체나 struct,class는 복제 오버헤드가 크다.<br>
      레퍼런스 전달 방식은 레퍼런스만 함수에 전달한다.
  * 정확성 : 값 전달 방식을 지원하지 않는 객체가 있다. 지원하더라도 깊은 복사가 적용되지 않을 수도 있다.

<br><br>

포인터를 레퍼런스로 전달하기
================================

* 매개변수가 레퍼런스 타입인 함수나 메서드에 포인터를 전달하면 난감해진다.<br>
* 이 때는 포인터를 역참조해서 전달하면 포인터를 레퍼런스로 '변환'할 수 있다.<br>
* 포인터가 가리키는 값을 가져와서 레퍼런스 매개변수를 초기화하기 때문이다.<br>

        int x = 5, y = 6;
        int *xp = &x, *yp = &y;
        swap(*xp, *yp);

<br><br>

레퍼런스 리턴값
=========================
* 함수의 리턴값을 레퍼런스로 전달하면 레퍼런스 전달 방식으로 처리한다.<br>
* 함수의 인자와 마찬가지로 객체 전체를 리턴하지 않고 객체에 대한 레퍼런스만 리턴하면 복제 연산을 줄일 수 있다.

<br>

* 주의
  * 함수안의 지역변수는 레퍼런스로 리턴하면 안된다
    * 함수가 끝나면 지역변수는 스택에서 사라지는데 레퍼런스로 참조하고 있기 때문에 오류가 발생할 수 있다.

<br><br>

rvalue 레퍼런스(우측값  레퍼런스)
==========================
* lvalue는 변수처럼 이름과 주소를 가지면서 대입문의 왼쪽에 나온다.<br>
* rvalue는 lvalue가 아닌 나머지를 말한다.(상숫값,임시 객체)<br>
* rvalue 레퍼런스는 임시 객체에 대해 적용할 함수를 컴파일러가 선택하기 위한 용도로 사용한다.

<br>

        // 좌측값 레퍼런스 매개변수
        void handleMessage(string& messssage)
        {
                cout<< "handleMessage with lvalue reference: " << message << endl;
        }

        // 우측값 레퍼런스 매개변수
        void handleMessage(string&& messssage)
        {
                cout<< "handleMessage with rvalue reference: " << message << endl;
        }

        string a = "Hello";
        string b = "World";
        handleMessage(a);               // handleMessage(string& messssage) 호출
        handleMessage(a+b);             // handleMessage(string&& messssage) 호출

<br><br>

레퍼런스와 포인터의 선택 기준
=====================================
레퍼런스로 할 수 있는 일은 모두 포인터로 처리할 수 있으니 레퍼런스가 필요없다고 느껴질 수도 있다.

        void swap(int* first, int* second)
        {
                int temp=*first;
                *first = *second;
                *second = temp;
        }

이렇게 하면 코드가 복잡해지지만 레퍼런스를 사용한다면 코드가 깔끔해지고 레퍼런스의 값은 널이 될 수없고 레퍼런스를 명시적으로 역참조 할 수 없기 때문에 포인터보다 안전하다.<br>
(단 포인터가 하나도 없을 경우에만 레퍼런스가 더 안전하다고 말할 수 있다.)

<br>

* 하지만 반드시 포인터를 사용해야하는 경우도 있다.<br><br>
  1. 대표적인 예로 가리키는 위치를 변경해야 할 때가 있다.<br> 
     * 레퍼런스는 한번 초기화하면 변경할 수 없기 때문에 동적 할당 메모리의 주소는 레퍼런스가 아닌 포인터로 저장해야한다.<br><br>
  2. 주솟값이 nullptr이 될 수도 있는 optional 타입은 반드시 포인터를 사용해야한다.<br><br>
  3. 컨테이너에 다형성 타입을 저장할 때도 포인터를 사용해야 한다.

<br>

결국 매개변수나 리턴값을 포인터나 레퍼런스중 어느것이 적합한지를 따질려면 메모리의 소유권이 어디있는지를 따져보는 것이다.<br>
소유권을 이전할 필요가 있다면 항상 스마트 포인터를 사용하는것이 좋지만,<br>
메모리 소유권이 변수를 받는 코드에 없어서 메모리를 해제할 일이 없다면 레퍼런스로 전달한다.
